// TML Types, Structs, and Enums example

module examples.types

import std.math.sqrt

// Struct definition
public type Point {
    x: F64,
    y: F64,
}

// Enum with data
public type Shape {
    Circle(F64),              // radius
    Rectangle(F64, F64),      // width, height
    Triangle(Point, Point, Point),
}

// Simple enum
type Direction {
    North,
    South,
    East,
    West,
}

// Generic enum (like Rust's Result)
type Outcome[T, E] {
    Ok(T),
    Err(E),
}

// Generic enum (like Rust's Option)
type Maybe[T] {
    Just(T),
    Nothing,
}

// Extend Point with methods
extend Point {
    /// Create a new point
    public func new(x: F64, y: F64) -> This {
        return This { x: x, y: y }
    }

    /// Origin point (0, 0)
    public func origin() -> This {
        return This.new(0.0, 0.0)
    }

    /// Calculate distance to another point
    public func distance(this, other: Point) -> F64 {
        let dx: F64 = this.x - other.x
        let dy: F64 = this.y - other.y
        return sqrt(dx**2 + dy**2)
    }

    /// Manhattan distance
    public func manhattan_distance(this, other: Point) -> F64 {
        let dx: F64 = this.x - other.x
        let dy: F64 = this.y - other.y
        return dx + dy
    }
}

// Behavior (trait) definition
public behavior Drawable {
    func draw(this) -> String;
    func area(this) -> F64;
}

// Implement Drawable for Shape
extend Shape with Drawable {
    func draw(this) -> String {
        when this {
            Circle(r) -> "Circle with radius " + r.to_string(),
            Rectangle(w, h) -> "Rectangle " + w.to_string() + "x" + h.to_string(),
            Triangle(p1, p2, p3) -> "Triangle",
        }
    }

    func area(this) -> F64 {
        when this {
            Circle(r) -> 3.14159 * r**2,
            Rectangle(w, h) -> w * h,
            Triangle(p1, p2, p3) -> calculate_triangle_area(p1, p2, p3),
        }
    }
}

func calculate_triangle_area(p1: Point, p2: Point, p3: Point) -> F64 {
    // Using cross product formula
    let a: F64 = p1.x * (p2.y - p3.y)
    let b: F64 = p2.x * (p3.y - p1.y)
    let c: F64 = p3.x * (p1.y - p2.y)
    return (a + b + c) / 2.0
}

/// Generic function working with Maybe
func unwrap_or[T](maybe: Maybe[T], default: T) -> T {
    when maybe {
        Just(value) -> value,
        Nothing -> default,
    }
}

/// Generic function working with Outcome
func unwrap_or_else[T, E](result: Outcome[T, E], default: T) -> T {
    when result {
        Ok(value) -> value,
        Err(_) -> default,
    }
}

// Type alias
type UserId = U64
type UserName = String
type Callback = func(I32) -> Bool

@test
func test_point_distance() {
    let p1: Point = Point.new(0.0, 0.0)
    let p2: Point = Point.new(3.0, 4.0)
    assert_eq(p1.distance(p2), 5.0, "Distance calculation")
}

@test
func test_shape_area() {
    let circle: Shape = Circle(5.0)
    let rect: Shape = Rectangle(10.0, 20.0)

    assert_eq(circle.area(), 78.53975, "Circle area")
    assert_eq(rect.area(), 200.0, "Rectangle area")
}
