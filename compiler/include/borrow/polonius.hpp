//! # Polonius Borrow Checker
//!
//! This module implements the Polonius borrow checking algorithm as an
//! alternative to the default NLL (Non-Lexical Lifetimes) checker.
//!
//! Polonius uses a Datalog-style constraint solver to determine which loans
//! are active at each program point. It is strictly more permissive than NLL,
//! accepting programs where borrows are conditionally taken across branches.
//!
//! ## Key Concepts
//!
//! - **Origin**: Where a reference came from. Each reference variable has an
//!   associated `OriginId`. Origins flow through assignments and reborrows.
//!
//! - **Loan**: A specific borrow operation (`ref x` or `mut ref x`). Loans are
//!   created at borrow sites and invalidated by mutations/moves of the borrowed
//!   place.
//!
//! - **Point**: A program point in the control flow graph. Each statement gets
//!   a unique `PointId` used for tracking loan propagation.
//!
//! - **Subset constraint**: `origin1 ⊆ origin2` means origin1's loans flow
//!   into origin2. Generated by reborrows and function calls.
//!
//! ## Algorithm
//!
//! 1. Generate input facts from AST traversal (loans, invalidations, CFG edges,
//!    subset constraints, liveness)
//! 2. Optionally run location-insensitive pre-check (fast path for simple code)
//! 3. Run fixed-point solver: propagate loans through CFG edges and subset
//!    constraints, filtered by origin liveness
//! 4. Detect errors: loan invalidated while still reachable through a live origin
//!
//! ## Usage
//!
//! ```cpp
//! polonius::PoloniusChecker checker(type_env);
//! auto result = checker.check_module(module);
//! // Returns Result<bool, std::vector<BorrowError>> — same as NLL checker
//! ```

#ifndef TML_BORROW_POLONIUS_HPP
#define TML_BORROW_POLONIUS_HPP

#include "borrow/checker.hpp"

#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace tml::borrow::polonius {

// ============================================================================
// Core Types (10.1)
// ============================================================================

/// Unique identifier for an origin (region variable).
/// Each reference in the program has an associated origin.
using OriginId = uint32_t;

/// Unique identifier for a loan (borrow operation).
using LoanId = uint32_t;

/// Unique identifier for a program point in the CFG.
using PointId = uint32_t;

constexpr OriginId INVALID_ORIGIN = UINT32_MAX;
constexpr LoanId INVALID_LOAN = UINT32_MAX;
constexpr PointId INVALID_POINT = UINT32_MAX;

/// Represents "where a reference came from."
///
/// Every reference-typed variable in the program gets an `OriginId`.
/// Origins flow through assignments, reborrows, and function calls.
struct Origin {
    OriginId id = INVALID_ORIGIN;
    std::string debug_name; ///< For error messages (e.g., "ref_x", "'a")
    PlaceId ref_place = 0;  ///< The place holding this reference
};

/// Represents a specific borrow operation.
///
/// Created when `ref x` or `mut ref x` appears in the source code.
/// Tracks what was borrowed, the kind, and the source location.
struct Loan {
    LoanId id = INVALID_LOAN;
    PlaceId borrowed_place = 0; ///< Base place being borrowed
    Place full_place;           ///< Place with projections (e.g., x.field)
    BorrowKind kind = BorrowKind::Shared;
    SourceSpan span; ///< Source location of the borrow
};

/// Position within a statement for finer-grained program points.
enum class PointPosition {
    Start, ///< Before the statement executes
    Mid,   ///< After evaluation but before side effects complete
};

/// A program point in the control flow graph.
///
/// Each statement in the function generates one or more points. Points
/// are connected by CFG edges to form the control flow graph.
struct Point {
    PointId id = INVALID_POINT;
    size_t stmt_index = 0; ///< Matches Location.statement_index
    PointPosition position = PointPosition::Start;
    SourceSpan span;
};

// ============================================================================
// Relations (10.2) — Input Facts
// ============================================================================

/// A borrow creates a loan at this point, associated with an origin.
///
/// Generated when `ref x` or `mut ref x` is evaluated.
struct LoanIssuedAt {
    OriginId origin;
    LoanId loan;
    PointId point;
};

/// An action at this point would invalidate this loan.
///
/// Generated when the borrowed place is assigned to, moved, or dropped.
struct LoanInvalidatedAt {
    PointId point;
    LoanId loan;
};

/// Control flow edge from one point to another.
///
/// Generated from the AST control flow structure:
/// - Linear code: point_i → point_i+1
/// - if/else: fork + merge edges
/// - loop: back edges
/// - when: fork to each arm + merge
struct CfgEdge {
    PointId from;
    PointId to;
};

/// Origin subset constraint: sub's loans flow into sup.
///
/// `sub ⊆ sup` means any loan in `sub` is also in `sup`.
/// Generated by reborrows (`let r2 = ref *r1` → sub=r2, sup=r1)
/// and function calls with reference parameters/returns.
struct SubsetConstraint {
    OriginId sub; ///< The "smaller" origin (e.g., reborrow)
    OriginId sup; ///< The "larger" origin (e.g., original borrow)
    PointId at_point;
};

/// An origin is live at this program point.
///
/// An origin is live if the reference variable holding it might still
/// be used at or after this point. Computed by backward liveness analysis.
struct OriginLiveAt {
    OriginId origin;
    PointId point;
};

// ============================================================================
// FactTable — Collects all Polonius facts
// ============================================================================

/// Collects all input and computed Polonius facts for a function.
///
/// Input facts are generated by `PoloniusFacts` during AST traversal.
/// Computed facts are produced by `PoloniusSolver` during fixed-point iteration.
class FactTable {
public:
    // --- Input facts ---
    std::vector<LoanIssuedAt> loan_issued_at;
    std::vector<LoanInvalidatedAt> loan_invalidated_at;
    std::vector<CfgEdge> cfg_edges;
    std::vector<SubsetConstraint> subset_constraints;
    std::vector<OriginLiveAt> origin_live_at;

    // --- Computed facts ---

    /// origin_contains_loan_at[origin][point] = set of loans
    /// Propagated from loan_issued_at through cfg_edge + subset constraints.
    std::unordered_map<OriginId, std::unordered_map<PointId, std::unordered_set<LoanId>>>
        origin_contains_loan_at;

    /// Detected errors: (loan, point) pairs where a loan is invalidated
    /// while still reachable through a live origin.
    std::vector<std::pair<LoanId, PointId>> errors;

    // --- Metadata for error reporting ---
    std::unordered_map<OriginId, Origin> origins;
    std::unordered_map<LoanId, Loan> loans;
    std::unordered_map<PointId, Point> points;

    // --- Allocators ---

    /// Allocates a new origin with a debug name.
    auto fresh_origin(const std::string& debug_name, PlaceId ref_place) -> OriginId;

    /// Allocates a new loan for a borrow operation.
    auto fresh_loan(PlaceId place, const Place& full_place, BorrowKind kind, SourceSpan span)
        -> LoanId;

    /// Allocates a new program point.
    auto fresh_point(size_t stmt_index, PointPosition pos, SourceSpan span) -> PointId;

    /// Clears all facts (for reuse between functions).
    void clear();

private:
    OriginId next_origin_id_ = 0;
    LoanId next_loan_id_ = 0;
    PointId next_point_id_ = 0;
};

// ============================================================================
// PoloniusFacts — Generates facts from AST (10.3)
// ============================================================================

/// Generates Polonius input facts by traversing the AST.
///
/// Parallels the existing `BorrowChecker` AST traversal but instead of
/// checking rules directly, emits facts into a `FactTable`.
class PoloniusFacts {
public:
    explicit PoloniusFacts(const types::TypeEnv& type_env);

    /// Generate all facts for a function.
    void generate_function(const parser::FuncDecl& func);

    /// Access the generated facts (mutable, for solver).
    auto facts() -> FactTable& {
        return facts_;
    }

    /// Access the generated facts (const).
    auto facts() const -> const FactTable& {
        return facts_;
    }

private:
    FactTable facts_;
    const types::TypeEnv* type_env_;

    /// Borrow environment for place tracking (reuse existing infrastructure).
    BorrowEnv env_;

    /// Current statement index for point generation.
    size_t current_stmt_ = 0;

    /// Maps PlaceId → OriginId for reference-typed places.
    std::unordered_map<PlaceId, OriginId> place_origins_;

    /// Maps PlaceId → set of LoanIds for loans on that place.
    std::unordered_map<PlaceId, std::vector<LoanId>> place_loans_;

    /// Last emitted point (for linear CFG edges).
    PointId last_point_ = INVALID_POINT;

    /// Function exit point (for return edges).
    PointId exit_point_ = INVALID_POINT;

    /// Stack of loop header points (for back edges).
    std::vector<PointId> loop_headers_;

    /// Stack of loop exit points (for break edges).
    std::vector<PointId> loop_exits_;

    // --- AST traversal ---
    void visit_block(const parser::BlockExpr& block);
    void visit_stmt(const parser::Stmt& stmt);
    void visit_let(const parser::LetStmt& let);
    void visit_expr_stmt(const parser::ExprStmt& expr_stmt);
    void visit_expr(const parser::Expr& expr);
    void visit_ident(const parser::IdentExpr& ident, SourceSpan span);
    void visit_binary(const parser::BinaryExpr& binary);
    void visit_unary(const parser::UnaryExpr& unary);
    void visit_call(const parser::CallExpr& call);
    void visit_method_call(const parser::MethodCallExpr& call);
    void visit_field_access(const parser::FieldExpr& field);
    void visit_index(const parser::IndexExpr& idx);
    void visit_if(const parser::IfExpr& if_expr);
    void visit_when(const parser::WhenExpr& when);
    void visit_loop(const parser::LoopExpr& loop);
    void visit_for(const parser::ForExpr& for_expr);
    void visit_return(const parser::ReturnExpr& ret);
    void visit_break(const parser::BreakExpr& brk);
    void visit_closure(const parser::ClosureExpr& closure);
    void visit_struct_expr(const parser::StructExpr& struct_expr);
    void visit_tuple(const parser::TupleExpr& tuple);
    void visit_array(const parser::ArrayExpr& array);

    // --- Fact emission helpers ---

    /// Advance to the next program point, emit a linear CFG edge.
    auto advance_point(SourceSpan span) -> PointId;

    /// Create a point without a CFG edge from the previous point.
    auto create_point(SourceSpan span) -> PointId;

    /// Emit a loan_issued_at fact.
    void emit_loan(PlaceId borrowed_place, const Place& full_place, BorrowKind kind,
                   PlaceId ref_place, SourceSpan span);

    /// Emit loan_invalidated_at facts for all loans on a place.
    void emit_invalidation(PlaceId place, SourceSpan span);

    /// Emit a CFG edge.
    void emit_cfg_edge(PointId from, PointId to);

    /// Emit a subset constraint.
    void emit_subset(OriginId sub, OriginId sup, PointId point);

    /// Compute origin liveness (backward dataflow).
    void compute_liveness();

    // --- Type helpers ---
    auto is_copy_type(const types::TypePtr& type) const -> bool;
    auto is_ref_type(const types::TypePtr& type) const -> bool;
    auto extract_place(const parser::Expr& expr) -> std::optional<Place>;
};

// ============================================================================
// PoloniusSolver — Fixed-point constraint solver (10.4 + 10.5)
// ============================================================================

/// Solves Polonius constraints using worklist-based fixed-point iteration.
///
/// Propagates loans through CFG edges and subset constraints, filtered by
/// origin liveness. Detects errors where loans are invalidated while still
/// reachable through a live origin.
class PoloniusSolver {
public:
    explicit PoloniusSolver(FactTable& facts);

    /// Location-insensitive pre-check (10.6).
    /// Returns true if no potential conflicts exist (can skip full solve).
    auto quick_check() -> bool;

    /// Run the full location-sensitive solver.
    void solve();

    /// Get detected errors after solving.
    auto errors() const -> const std::vector<std::pair<LoanId, PointId>>& {
        return facts_.errors;
    }

private:
    FactTable& facts_;

    /// Pre-computed index: point → successor points
    std::unordered_map<PointId, std::vector<PointId>> cfg_successors_;

    /// Pre-computed index: origin → subset constraints where this origin is sub
    std::unordered_map<OriginId, std::vector<std::pair<OriginId, PointId>>> subset_by_sub_;

    /// Pre-computed set for O(1) liveness lookup: (origin, point) → is live
    std::unordered_set<uint64_t> liveness_set_;

    /// Build pre-computed indices.
    void build_indices();

    /// Check if an origin is live at a point.
    auto is_origin_live(OriginId origin, PointId point) const -> bool;

    /// Encode (origin, point) pair for liveness set lookup.
    static auto encode_pair(OriginId origin, PointId point) -> uint64_t {
        return (static_cast<uint64_t>(origin) << 32) | static_cast<uint64_t>(point);
    }

    /// Detect error conditions after propagation.
    void check_invalidations();
};

// ============================================================================
// PoloniusChecker — Main entry point (10.7)
// ============================================================================

/// Main Polonius borrow checker, drop-in alternative to `BorrowChecker`.
///
/// Produces the same `Result<bool, std::vector<BorrowError>>` output as the
/// NLL checker, so the rest of the compiler pipeline is unaffected.
class PoloniusChecker {
public:
    /// Constructs a Polonius checker with access to type environment.
    explicit PoloniusChecker(const types::TypeEnv& type_env);

    /// Checks an entire module for borrow violations.
    [[nodiscard]] auto check_module(const parser::Module& module)
        -> Result<bool, std::vector<BorrowError>>;

private:
    const types::TypeEnv* type_env_;

    /// Check a single function and return any errors found.
    auto check_function(const parser::FuncDecl& func) -> std::vector<BorrowError>;

    /// Convert Polonius errors to BorrowError format.
    auto convert_errors(const FactTable& facts) -> std::vector<BorrowError>;

    /// Convert a single (loan, point) error to a BorrowError.
    auto make_error(const FactTable& facts, LoanId loan, PointId point) -> BorrowError;
};

} // namespace tml::borrow::polonius

#endif // TML_BORROW_POLONIUS_HPP
