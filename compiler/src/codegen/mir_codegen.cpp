//! # MIR-based LLVM IR Code Generator
//!
//! This file generates LLVM IR directly from MIR (Mid-level IR).
//!
//! ## Advantages of MIR-based Codegen
//!
//! MIR is already in SSA form, which maps naturally to LLVM IR:
//! - No need for SSA construction during codegen
//! - Direct mapping from MIR values to LLVM registers
//! - Simplified control flow handling
//!
//! ## Generation Pipeline
//!
//! | Phase            | Method              | Output                |
//! |------------------|---------------------|-----------------------|
//! | Preamble         | `emit_preamble`     | Target triple, attrs  |
//! | Type definitions | `emit_type_defs`    | Struct/enum layouts   |
//! | Functions        | `emit_function`     | Function definitions  |
//! | Basic blocks     | `emit_basic_block`  | Labels and terminators|
//! | Instructions     | `emit_instruction`  | LLVM instructions     |
//!
//! ## Value Mapping
//!
//! `value_regs_` maps MIR value IDs to LLVM register names (%t0, %t1, etc.).

#include "codegen/mir_codegen.hpp"

#include <iomanip>
#include <sstream>

namespace tml::codegen {

MirCodegen::MirCodegen(MirCodegenOptions options) : options_(std::move(options)) {}

void MirCodegen::emit(const std::string& s) {
    output_ << s;
}

void MirCodegen::emitln(const std::string& s) {
    output_ << s << "\n";
}

void MirCodegen::emit_comment(const std::string& s) {
    if (options_.emit_comments) {
        emitln("; " + s);
    }
}

auto MirCodegen::new_temp() -> std::string {
    return "%t" + std::to_string(temp_counter_++);
}

auto MirCodegen::generate(const mir::Module& module) -> std::string {
    output_.str("");
    output_.clear();
    temp_counter_ = 0;
    value_regs_.clear();
    block_labels_.clear();
    emitted_types_.clear();

    emit_preamble();
    emit_type_defs(module);

    // Emit functions
    for (const auto& func : module.functions) {
        emit_function(func);
    }

    return output_.str();
}

void MirCodegen::emit_preamble() {
    emit_comment("Generated by TML MIR Codegen");
    emitln("target triple = \"" + options_.target_triple + "\"");
    emitln();

    // Declare printf for print builtin
    emitln("declare i32 @printf(ptr, ...)");
    emitln();

    // String format constants
    // %d\n\0 = 4 chars, %lld\n\0 = 6 chars, %f\n\0 = 4 chars, %s\n\0 = 4 chars
    emitln("@.str.int = private constant [4 x i8] c\"%d\\0A\\00\"");
    emitln("@.str.long = private constant [6 x i8] c\"%lld\\0A\\00\"");
    emitln("@.str.float = private constant [4 x i8] c\"%f\\0A\\00\"");
    emitln("@.str.str = private constant [4 x i8] c\"%s\\0A\\00\"");
    emitln("@.str.bool.true = private constant [5 x i8] c\"true\\00\"");
    emitln("@.str.bool.false = private constant [6 x i8] c\"false\\00\"");
    emitln();
}

void MirCodegen::emit_type_defs(const mir::Module& module) {
    // Emit struct definitions
    for (const auto& s : module.structs) {
        emit_struct_def(s);
    }

    // Emit enum definitions
    for (const auto& e : module.enums) {
        emit_enum_def(e);
    }

    if (!module.structs.empty() || !module.enums.empty()) {
        emitln();
    }
}

void MirCodegen::emit_struct_def(const mir::StructDef& s) {
    std::string type_name = "%struct." + s.name;
    if (emitted_types_.count(type_name)) {
        return;
    }
    emitted_types_.insert(type_name);

    emit(type_name + " = type { ");
    for (size_t i = 0; i < s.fields.size(); ++i) {
        if (i > 0) {
            emit(", ");
        }
        emit(mir_type_to_llvm(s.fields[i].type));
    }
    emitln(" }");
}

void MirCodegen::emit_enum_def(const mir::EnumDef& e) {
    // Enums are represented as tagged unions
    // { i32 tag, [max_payload_size x i8] payload }
    std::string type_name = "%enum." + e.name;
    if (emitted_types_.count(type_name)) {
        return;
    }
    emitted_types_.insert(type_name);

    // Calculate max payload size
    size_t max_payload_size = 0;
    for (const auto& v : e.variants) {
        size_t payload_size = 0;
        for (const auto& t : v.payload_types) {
            // Estimate size based on type
            if (t->is_integer()) {
                payload_size += t->bit_width() / 8;
            } else if (t->is_float()) {
                payload_size += t->bit_width() / 8;
            } else if (t->is_bool()) {
                payload_size += 1;
            } else if (std::holds_alternative<mir::MirPointerType>(t->kind)) {
                payload_size += 8; // 64-bit pointer
            } else if (auto* p = std::get_if<mir::MirPrimitiveType>(&t->kind);
                       p && p->kind == mir::PrimitiveType::Str) {
                payload_size += 8; // String pointer
            } else {
                payload_size += 8; // Default
            }
        }
        max_payload_size = std::max(max_payload_size, payload_size);
    }

    // Minimum 8 bytes for alignment
    if (max_payload_size < 8) {
        max_payload_size = 8;
    }

    emitln(type_name + " = type { i32, [" + std::to_string(max_payload_size) + " x i8] }");
}

void MirCodegen::emit_function(const mir::Function& func) {
    current_func_ = func.name;
    value_regs_.clear();
    block_labels_.clear();

    // Setup block labels - use block ID, not index
    for (const auto& blk : func.blocks) {
        block_labels_[blk.id] = blk.name;
    }

    // Setup parameter registers
    for (const auto& param : func.params) {
        value_regs_[param.value_id] = "%" + param.name;
    }

    // Function signature
    std::string linkage = "define";
    if (options_.dll_export && func.is_public) {
        linkage = "define dllexport";
    }

    std::string ret_type = mir_type_to_llvm(func.return_type);
    emit(linkage + " " + ret_type + " @" + func.name + "(");

    for (size_t i = 0; i < func.params.size(); ++i) {
        if (i > 0) {
            emit(", ");
        }
        emit(mir_type_to_llvm(func.params[i].type) + " %" + func.params[i].name);
    }

    emitln(") {");

    // Emit basic blocks
    for (const auto& block : func.blocks) {
        emit_block(block);
    }

    emitln("}");
    emitln();
}

void MirCodegen::emit_block(const mir::BasicBlock& block) {
    emitln(block.name + ":");

    // Emit instructions
    for (const auto& inst : block.instructions) {
        emit_instruction(inst);
    }

    // Emit terminator
    if (block.terminator.has_value()) {
        emit_terminator(*block.terminator);
    }
}

void MirCodegen::emit_instruction(const mir::InstructionData& inst) {
    std::string result_reg;
    if (inst.result != mir::INVALID_VALUE) {
        result_reg = "%v" + std::to_string(inst.result);
        value_regs_[inst.result] = result_reg;
    }

    std::visit(
        [this, &result_reg](const auto& i) {
            using T = std::decay_t<decltype(i)>;

            if constexpr (std::is_same_v<T, mir::BinaryInst>) {
                std::string left = get_value_reg(i.left);
                std::string right = get_value_reg(i.right);

                // Use result_type if available, otherwise use left operand's type
                mir::MirTypePtr type_ptr = i.result_type ? i.result_type : i.left.type;
                if (!type_ptr) {
                    // Fallback to i32 if no type info
                    type_ptr = mir::make_i32_type();
                }
                std::string type_str = mir_type_to_llvm(type_ptr);

                bool is_float = type_ptr->is_float();
                bool is_signed = type_ptr->is_signed();

                // Check if it's a comparison
                if (i.op >= mir::BinOp::Eq && i.op <= mir::BinOp::Ge) {
                    std::string pred = get_cmp_predicate(i.op, is_float, is_signed);
                    if (is_float) {
                        emitln("    " + result_reg + " = fcmp " + pred + " " + type_str + " " +
                               left + ", " + right);
                    } else {
                        emitln("    " + result_reg + " = icmp " + pred + " " + type_str + " " +
                               left + ", " + right);
                    }
                } else {
                    std::string op_name = get_binop_name(i.op, is_float, is_signed);
                    emitln("    " + result_reg + " = " + op_name + " " + type_str + " " + left +
                           ", " + right);
                }

            } else if constexpr (std::is_same_v<T, mir::UnaryInst>) {
                std::string operand = get_value_reg(i.operand);

                // Use result_type if available, otherwise use operand's type
                mir::MirTypePtr type_ptr = i.result_type ? i.result_type : i.operand.type;
                if (!type_ptr) {
                    type_ptr = mir::make_i32_type();
                }
                std::string type_str = mir_type_to_llvm(type_ptr);

                switch (i.op) {
                case mir::UnaryOp::Neg:
                    if (type_ptr->is_float()) {
                        emitln("    " + result_reg + " = fneg " + type_str + " " + operand);
                    } else {
                        emitln("    " + result_reg + " = sub " + type_str + " 0, " + operand);
                    }
                    break;
                case mir::UnaryOp::Not:
                    emitln("    " + result_reg + " = xor i1 " + operand + ", true");
                    break;
                case mir::UnaryOp::BitNot:
                    emitln("    " + result_reg + " = xor " + type_str + " " + operand + ", -1");
                    break;
                }

            } else if constexpr (std::is_same_v<T, mir::LoadInst>) {
                std::string ptr = get_value_reg(i.ptr);
                mir::MirTypePtr type_ptr = i.result_type ? i.result_type : mir::make_i32_type();
                std::string type_str = mir_type_to_llvm(type_ptr);
                emitln("    " + result_reg + " = load " + type_str + ", ptr " + ptr);

            } else if constexpr (std::is_same_v<T, mir::StoreInst>) {
                std::string value = get_value_reg(i.value);
                std::string ptr = get_value_reg(i.ptr);
                mir::MirTypePtr type_ptr = i.value_type ? i.value_type : i.value.type;
                if (!type_ptr) {
                    type_ptr = mir::make_i32_type();
                }
                std::string type_str = mir_type_to_llvm(type_ptr);
                emitln("    store " + type_str + " " + value + ", ptr " + ptr);

            } else if constexpr (std::is_same_v<T, mir::AllocaInst>) {
                mir::MirTypePtr type_ptr = i.alloc_type ? i.alloc_type : mir::make_i32_type();
                std::string type_str = mir_type_to_llvm(type_ptr);
                emitln("    " + result_reg + " = alloca " + type_str);

            } else if constexpr (std::is_same_v<T, mir::GetElementPtrInst>) {
                std::string base = get_value_reg(i.base);
                mir::MirTypePtr type_ptr = i.base_type ? i.base_type : mir::make_i32_type();
                std::string type_str = mir_type_to_llvm(type_ptr);
                emit("    " + result_reg + " = getelementptr " + type_str + ", ptr " + base);
                for (const auto& idx : i.indices) {
                    emit(", i32 " + get_value_reg(idx));
                }
                emitln();

            } else if constexpr (std::is_same_v<T, mir::ExtractValueInst>) {
                std::string agg = get_value_reg(i.aggregate);
                mir::MirTypePtr type_ptr = i.aggregate_type ? i.aggregate_type : i.aggregate.type;
                std::string agg_type = mir_type_to_llvm(type_ptr);
                emit("    " + result_reg + " = extractvalue " + agg_type + " " + agg);
                for (auto idx : i.indices) {
                    emit(", " + std::to_string(idx));
                }
                emitln();

            } else if constexpr (std::is_same_v<T, mir::InsertValueInst>) {
                std::string agg = get_value_reg(i.aggregate);
                std::string val = get_value_reg(i.value);
                mir::MirTypePtr agg_ptr = i.aggregate_type ? i.aggregate_type : i.aggregate.type;
                mir::MirTypePtr val_ptr = i.value_type ? i.value_type : i.value.type;
                std::string agg_type = mir_type_to_llvm(agg_ptr);
                std::string val_type = mir_type_to_llvm(val_ptr);
                emit("    " + result_reg + " = insertvalue " + agg_type + " " + agg + ", " +
                     val_type + " " + val);
                for (auto idx : i.indices) {
                    emit(", " + std::to_string(idx));
                }
                emitln();

            } else if constexpr (std::is_same_v<T, mir::CallInst>) {
                // Skip drop_ calls for primitive types (they don't need runtime cleanup)
                // These are generated by the MIR builder for RAII but primitives don't need them
                if (i.func_name.rfind("drop_", 0) == 0) {
                    // Check if it's a primitive type drop (drop_I32, drop_Bool, etc.)
                    std::string suffix = i.func_name.substr(5);
                    if (suffix == "I8" || suffix == "I16" || suffix == "I32" || suffix == "I64" ||
                        suffix == "U8" || suffix == "U16" || suffix == "U32" || suffix == "U64" ||
                        suffix == "F32" || suffix == "F64" || suffix == "Bool" || suffix == "Unit" ||
                        suffix == "Char") {
                        return; // Skip primitive drops
                    }
                }

                mir::MirTypePtr ret_ptr = i.return_type ? i.return_type : mir::make_unit_type();
                std::string ret_type = mir_type_to_llvm(ret_ptr);
                if (ret_type != "void" && !result_reg.empty()) {
                    emit("    " + result_reg + " = ");
                } else {
                    emit("    ");
                }
                emit("call " + ret_type + " @" + i.func_name + "(");
                for (size_t j = 0; j < i.args.size(); ++j) {
                    if (j > 0) {
                        emit(", ");
                    }
                    mir::MirTypePtr arg_ptr = (j < i.arg_types.size() && i.arg_types[j])
                                                  ? i.arg_types[j]
                                                  : i.args[j].type;
                    if (!arg_ptr) {
                        arg_ptr = mir::make_i32_type();
                    }
                    std::string arg_type = mir_type_to_llvm(arg_ptr);
                    std::string arg = get_value_reg(i.args[j]);
                    emit(arg_type + " " + arg);
                }
                emitln(")");

            } else if constexpr (std::is_same_v<T, mir::MethodCallInst>) {
                // Method calls are similar to regular calls
                mir::MirTypePtr ret_ptr = i.return_type ? i.return_type : mir::make_unit_type();
                std::string ret_type = mir_type_to_llvm(ret_ptr);
                if (ret_type != "void" && !result_reg.empty()) {
                    emit("    " + result_reg + " = ");
                } else {
                    emit("    ");
                }
                // Method name is mangled: Type__method
                emit("call " + ret_type + " @" + i.receiver_type + "__" + i.method_name + "(");
                // First argument is self/receiver
                std::string receiver = get_value_reg(i.receiver);
                emit("ptr " + receiver);
                for (size_t j = 0; j < i.args.size(); ++j) {
                    emit(", ");
                    mir::MirTypePtr arg_ptr = (j < i.arg_types.size() && i.arg_types[j])
                                                  ? i.arg_types[j]
                                                  : i.args[j].type;
                    if (!arg_ptr) {
                        arg_ptr = mir::make_i32_type();
                    }
                    std::string arg_type = mir_type_to_llvm(arg_ptr);
                    std::string arg = get_value_reg(i.args[j]);
                    emit(arg_type + " " + arg);
                }
                emitln(")");

            } else if constexpr (std::is_same_v<T, mir::CastInst>) {
                std::string operand = get_value_reg(i.operand);
                mir::MirTypePtr src_ptr = i.source_type ? i.source_type : i.operand.type;
                if (!src_ptr) {
                    src_ptr = mir::make_i32_type();
                }
                mir::MirTypePtr tgt_ptr = i.target_type ? i.target_type : mir::make_i32_type();
                std::string src_type = mir_type_to_llvm(src_ptr);
                std::string tgt_type = mir_type_to_llvm(tgt_ptr);

                static const char* cast_names[] = {"bitcast", "trunc",  "zext",     "sext",
                                                   "fptrunc", "fpext",  "fptosi",   "fptoui",
                                                   "sitofp",  "uitofp", "ptrtoint", "inttoptr"};
                std::string cast_name = cast_names[static_cast<int>(i.kind)];

                emitln("    " + result_reg + " = " + cast_name + " " + src_type + " " + operand +
                       " to " + tgt_type);

            } else if constexpr (std::is_same_v<T, mir::PhiInst>) {
                mir::MirTypePtr type_ptr = i.result_type ? i.result_type : mir::make_i32_type();
                std::string type_str = mir_type_to_llvm(type_ptr);
                emit("    " + result_reg + " = phi " + type_str + " ");
                for (size_t j = 0; j < i.incoming.size(); ++j) {
                    if (j > 0) {
                        emit(", ");
                    }
                    std::string val = get_value_reg(i.incoming[j].first);
                    std::string label = block_labels_[i.incoming[j].second];
                    emit("[ " + val + ", %" + label + " ]");
                }
                emitln();

            } else if constexpr (std::is_same_v<T, mir::ConstantInst>) {
                std::visit(
                    [this, &result_reg](const auto& c) {
                        using C = std::decay_t<decltype(c)>;
                        if constexpr (std::is_same_v<C, mir::ConstInt>) {
                            std::string type_str = "i" + std::to_string(c.bit_width);
                            emitln("    " + result_reg + " = add " + type_str + " 0, " +
                                   std::to_string(c.value));
                        } else if constexpr (std::is_same_v<C, mir::ConstFloat>) {
                            std::string type_str = c.is_f64 ? "double" : "float";
                            std::ostringstream ss;
                            ss << std::scientific << std::setprecision(17) << c.value;
                            emitln("    " + result_reg + " = fadd " + type_str + " 0.0, " +
                                   ss.str());
                        } else if constexpr (std::is_same_v<C, mir::ConstBool>) {
                            emitln("    " + result_reg + " = add i1 0, " +
                                   std::string(c.value ? "1" : "0"));
                        } else if constexpr (std::is_same_v<C, mir::ConstString>) {
                            // Strings are handled specially - emit global constant
                            std::string global = "@.str." + std::to_string(temp_counter_++);
                            // Note: String handling would need global emission
                            emitln("    " + result_reg + " = bitcast ptr " + global + " to ptr");
                        } else if constexpr (std::is_same_v<C, mir::ConstUnit>) {
                            // Unit type - no value needed
                        }
                    },
                    i.value);

            } else if constexpr (std::is_same_v<T, mir::SelectInst>) {
                std::string cond = get_value_reg(i.condition);
                std::string true_val = get_value_reg(i.true_val);
                std::string false_val = get_value_reg(i.false_val);
                mir::MirTypePtr type_ptr = i.result_type ? i.result_type : i.true_val.type;
                if (!type_ptr) {
                    type_ptr = mir::make_i32_type();
                }
                std::string type_str = mir_type_to_llvm(type_ptr);
                emitln("    " + result_reg + " = select i1 " + cond + ", " + type_str + " " +
                       true_val + ", " + type_str + " " + false_val);

            } else if constexpr (std::is_same_v<T, mir::StructInitInst>) {
                // Initialize struct by inserting values one by one
                std::string struct_type = "%struct." + i.struct_name;
                std::string current = "undef";
                for (size_t j = 0; j < i.fields.size(); ++j) {
                    std::string field_val = get_value_reg(i.fields[j]);
                    mir::MirTypePtr field_ptr = (j < i.field_types.size() && i.field_types[j])
                                                    ? i.field_types[j]
                                                    : i.fields[j].type;
                    if (!field_ptr) {
                        field_ptr = mir::make_i32_type();
                    }
                    std::string field_type = mir_type_to_llvm(field_ptr);
                    std::string next = (j == i.fields.size() - 1)
                                           ? result_reg
                                           : "%tmp" + std::to_string(temp_counter_++);
                    emitln("    " + next + " = insertvalue " + struct_type + " " + current + ", " +
                           field_type + " " + field_val + ", " + std::to_string(j));
                    current = next;
                }

            } else if constexpr (std::is_same_v<T, mir::EnumInitInst>) {
                // Initialize enum: { tag, payload }
                std::string enum_type = "%enum." + i.enum_name;
                // Insert tag
                std::string with_tag = "%tmp" + std::to_string(temp_counter_++);
                emitln("    " + with_tag + " = insertvalue " + enum_type + " undef, i32 " +
                       std::to_string(i.variant_index) + ", 0");
                // For simplicity, we're not handling payload here yet
                emitln("    " + result_reg + " = " + with_tag);

            } else if constexpr (std::is_same_v<T, mir::TupleInitInst>) {
                // Similar to struct init
                std::string current = "undef";
                mir::MirTypePtr tuple_ptr = i.result_type ? i.result_type : mir::make_i32_type();
                std::string tuple_type = mir_type_to_llvm(tuple_ptr);
                for (size_t j = 0; j < i.elements.size(); ++j) {
                    std::string elem_val = get_value_reg(i.elements[j]);
                    mir::MirTypePtr elem_ptr = (j < i.element_types.size() && i.element_types[j])
                                                   ? i.element_types[j]
                                                   : i.elements[j].type;
                    if (!elem_ptr) {
                        elem_ptr = mir::make_i32_type();
                    }
                    std::string elem_type = mir_type_to_llvm(elem_ptr);
                    std::string next = (j == i.elements.size() - 1)
                                           ? result_reg
                                           : "%tmp" + std::to_string(temp_counter_++);
                    emitln("    " + next + " = insertvalue " + tuple_type + " " + current + ", " +
                           elem_type + " " + elem_val + ", " + std::to_string(j));
                    current = next;
                }

            } else if constexpr (std::is_same_v<T, mir::ArrayInitInst>) {
                // Array initialization
                std::string current = "undef";
                mir::MirTypePtr array_ptr = i.result_type ? i.result_type : mir::make_i32_type();
                std::string array_type = mir_type_to_llvm(array_ptr);
                mir::MirTypePtr elem_ptr = i.element_type ? i.element_type : mir::make_i32_type();
                std::string elem_type = mir_type_to_llvm(elem_ptr);
                for (size_t j = 0; j < i.elements.size(); ++j) {
                    std::string elem_val = get_value_reg(i.elements[j]);
                    std::string next = (j == i.elements.size() - 1)
                                           ? result_reg
                                           : "%tmp" + std::to_string(temp_counter_++);
                    emitln("    " + next + " = insertvalue " + array_type + " " + current + ", " +
                           elem_type + " " + elem_val + ", " + std::to_string(j));
                    current = next;
                }
            }
        },
        inst.inst);
}

void MirCodegen::emit_terminator(const mir::Terminator& term) {
    std::visit(
        [this](const auto& t) {
            using T = std::decay_t<decltype(t)>;

            if constexpr (std::is_same_v<T, mir::ReturnTerm>) {
                if (t.value.has_value()) {
                    std::string val = get_value_reg(*t.value);
                    // Get type from the value itself
                    std::string type_str = t.value->type ? mir_type_to_llvm(t.value->type) : "void";
                    emitln("    ret " + type_str + " " + val);
                } else {
                    emitln("    ret void");
                }

            } else if constexpr (std::is_same_v<T, mir::BranchTerm>) {
                std::string target = block_labels_[t.target];
                emitln("    br label %" + target);

            } else if constexpr (std::is_same_v<T, mir::CondBranchTerm>) {
                std::string cond = get_value_reg(t.condition);
                std::string true_label = block_labels_[t.true_block];
                std::string false_label = block_labels_[t.false_block];
                emitln("    br i1 " + cond + ", label %" + true_label + ", label %" + false_label);

            } else if constexpr (std::is_same_v<T, mir::SwitchTerm>) {
                std::string disc = get_value_reg(t.discriminant);
                std::string default_label = block_labels_[t.default_block];
                emit("    switch i32 " + disc + ", label %" + default_label + " [");
                for (const auto& [val, block] : t.cases) {
                    std::string label = block_labels_[block];
                    emit(" i32 " + std::to_string(val) + ", label %" + label);
                }
                emitln(" ]");

            } else if constexpr (std::is_same_v<T, mir::UnreachableTerm>) {
                emitln("    unreachable");
            }
        },
        term);
}

auto MirCodegen::get_value_reg(const mir::Value& val) -> std::string {
    if (!val.is_valid()) {
        return "<invalid>";
    }
    auto it = value_regs_.find(val.id);
    if (it != value_regs_.end()) {
        return it->second;
    }
    // If not found, create a new register name
    std::string reg = "%v" + std::to_string(val.id);
    value_regs_[val.id] = reg;
    return reg;
}

auto MirCodegen::mir_type_to_llvm(const mir::MirTypePtr& type) -> std::string {
    if (!type) {
        return "void";
    }

    return std::visit(
        [this](const auto& t) -> std::string {
            using T = std::decay_t<decltype(t)>;

            if constexpr (std::is_same_v<T, mir::MirPrimitiveType>) {
                return mir_primitive_to_llvm(t.kind);

            } else if constexpr (std::is_same_v<T, mir::MirPointerType>) {
                return "ptr";

            } else if constexpr (std::is_same_v<T, mir::MirArrayType>) {
                return "[" + std::to_string(t.size) + " x " + mir_type_to_llvm(t.element) + "]";

            } else if constexpr (std::is_same_v<T, mir::MirSliceType>) {
                // Slice is { ptr, i64 }
                return "{ ptr, i64 }";

            } else if constexpr (std::is_same_v<T, mir::MirTupleType>) {
                std::string result = "{ ";
                for (size_t i = 0; i < t.elements.size(); ++i) {
                    if (i > 0) {
                        result += ", ";
                    }
                    result += mir_type_to_llvm(t.elements[i]);
                }
                result += " }";
                return result;

            } else if constexpr (std::is_same_v<T, mir::MirStructType>) {
                return "%struct." + t.name;

            } else if constexpr (std::is_same_v<T, mir::MirEnumType>) {
                return "%enum." + t.name;

            } else if constexpr (std::is_same_v<T, mir::MirFunctionType>) {
                std::string result = mir_type_to_llvm(t.return_type) + " (";
                for (size_t i = 0; i < t.params.size(); ++i) {
                    if (i > 0) {
                        result += ", ";
                    }
                    result += mir_type_to_llvm(t.params[i]);
                }
                result += ")*";
                return result;
            } else {
                // Should not be reached if all variant types are handled
                return "void";
            }
        },
        type->kind);
}

auto MirCodegen::mir_primitive_to_llvm(mir::PrimitiveType kind) -> std::string {
    switch (kind) {
    case mir::PrimitiveType::Unit:
        return "void";
    case mir::PrimitiveType::Bool:
        return "i1";
    case mir::PrimitiveType::I8:
    case mir::PrimitiveType::U8:
        return "i8";
    case mir::PrimitiveType::I16:
    case mir::PrimitiveType::U16:
        return "i16";
    case mir::PrimitiveType::I32:
    case mir::PrimitiveType::U32:
        return "i32";
    case mir::PrimitiveType::I64:
    case mir::PrimitiveType::U64:
        return "i64";
    case mir::PrimitiveType::I128:
    case mir::PrimitiveType::U128:
        return "i128";
    case mir::PrimitiveType::F32:
        return "float";
    case mir::PrimitiveType::F64:
        return "double";
    case mir::PrimitiveType::Ptr:
        return "ptr";
    case mir::PrimitiveType::Str:
        return "ptr"; // Strings are represented as pointers
    default:
        return "void";
    }
}

auto MirCodegen::get_binop_name(mir::BinOp op, bool is_float, bool is_signed) -> std::string {
    if (is_float) {
        switch (op) {
        case mir::BinOp::Add:
            return "fadd";
        case mir::BinOp::Sub:
            return "fsub";
        case mir::BinOp::Mul:
            return "fmul";
        case mir::BinOp::Div:
            return "fdiv";
        case mir::BinOp::Mod:
            return "frem";
        default:
            return "fadd";
        }
    } else {
        switch (op) {
        case mir::BinOp::Add:
            return "add";
        case mir::BinOp::Sub:
            return "sub";
        case mir::BinOp::Mul:
            return "mul";
        case mir::BinOp::Div:
            return is_signed ? "sdiv" : "udiv";
        case mir::BinOp::Mod:
            return is_signed ? "srem" : "urem";
        case mir::BinOp::And:
            return "and";
        case mir::BinOp::Or:
            return "or";
        case mir::BinOp::BitAnd:
            return "and";
        case mir::BinOp::BitOr:
            return "or";
        case mir::BinOp::BitXor:
            return "xor";
        case mir::BinOp::Shl:
            return "shl";
        case mir::BinOp::Shr:
            return is_signed ? "ashr" : "lshr";
        default:
            return "add";
        }
    }
}

auto MirCodegen::get_cmp_predicate(mir::BinOp op, bool is_float, bool is_signed) -> std::string {
    if (is_float) {
        switch (op) {
        case mir::BinOp::Eq:
            return "oeq";
        case mir::BinOp::Ne:
            return "one";
        case mir::BinOp::Lt:
            return "olt";
        case mir::BinOp::Le:
            return "ole";
        case mir::BinOp::Gt:
            return "ogt";
        case mir::BinOp::Ge:
            return "oge";
        default:
            return "oeq";
        }
    } else {
        switch (op) {
        case mir::BinOp::Eq:
            return "eq";
        case mir::BinOp::Ne:
            return "ne";
        case mir::BinOp::Lt:
            return is_signed ? "slt" : "ult";
        case mir::BinOp::Le:
            return is_signed ? "sle" : "ule";
        case mir::BinOp::Gt:
            return is_signed ? "sgt" : "ugt";
        case mir::BinOp::Ge:
            return is_signed ? "sge" : "uge";
        default:
            return "eq";
        }
    }
}

} // namespace tml::codegen
