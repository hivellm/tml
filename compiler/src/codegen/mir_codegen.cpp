//! # MIR-based LLVM IR Code Generator
//!
//! This file generates LLVM IR directly from MIR (Mid-level IR).
//!
//! ## Advantages of MIR-based Codegen
//!
//! MIR is already in SSA form, which maps naturally to LLVM IR:
//! - No need for SSA construction during codegen
//! - Direct mapping from MIR values to LLVM registers
//! - Simplified control flow handling
//!
//! ## Generation Pipeline
//!
//! | Phase            | Method              | Output                |
//! |------------------|---------------------|-----------------------|
//! | Preamble         | `emit_preamble`     | Target triple, attrs  |
//! | Type definitions | `emit_type_defs`    | Struct/enum layouts   |
//! | Functions        | `emit_function`     | Function definitions  |
//! | Basic blocks     | `emit_basic_block`  | Labels and terminators|
//! | Instructions     | `emit_instruction`  | LLVM instructions     |
//!
//! ## Value Mapping
//!
//! `value_regs_` maps MIR value IDs to LLVM register names (%t0, %t1, etc.).
//!
//! ## Code Organization
//!
//! The implementation is split across multiple files:
//! - mir_codegen.cpp: Core generation (this file)
//! - mir/instructions.cpp: Instruction emission
//! - mir/terminators.cpp: Terminator emission
//! - mir/types.cpp: Type conversion
//! - mir/helpers.cpp: Helper methods

#include "codegen/mir_codegen.hpp"

#include <sstream>

namespace tml::codegen {

MirCodegen::MirCodegen(MirCodegenOptions options) : options_(std::move(options)) {}

void MirCodegen::emit(const std::string& s) {
    output_ << s;
}

void MirCodegen::emitln(const std::string& s) {
    output_ << s << "\n";
}

void MirCodegen::emit_comment(const std::string& s) {
    if (options_.emit_comments) {
        emitln("; " + s);
    }
}

auto MirCodegen::new_temp() -> std::string {
    return "%t" + std::to_string(temp_counter_++);
}

auto MirCodegen::generate(const mir::Module& module) -> std::string {
    output_.str("");
    output_.clear();
    temp_counter_ = 0;
    spill_counter_ = 0;
    value_regs_.clear();
    value_types_.clear();
    struct_field_types_.clear();
    block_labels_.clear();
    emitted_types_.clear();
    string_constants_.clear();
    value_string_contents_.clear();

    // First pass: collect string constants from all functions
    for (const auto& func : module.functions) {
        for (const auto& block : func.blocks) {
            for (const auto& inst : block.instructions) {
                if (auto* const_inst = std::get_if<mir::ConstantInst>(&inst.inst)) {
                    if (auto* str_const = std::get_if<mir::ConstString>(&const_inst->value)) {
                        if (string_constants_.find(str_const->value) == string_constants_.end()) {
                            std::string global_name =
                                "@.str." + std::to_string(string_constants_.size());
                            string_constants_[str_const->value] = global_name;
                        }
                    }
                }
            }
        }
    }

    emit_preamble();

    // Emit string constants after preamble
    for (const auto& [value, name] : string_constants_) {
        std::string escaped;
        for (char c : value) {
            if (c == '\n') {
                escaped += "\\0A";
            } else if (c == '\r') {
                escaped += "\\0D";
            } else if (c == '"') {
                escaped += "\\22";
            } else if (c == '\\') {
                escaped += "\\5C";
            } else if (c == '\0') {
                escaped += "\\00";
            } else {
                escaped += c;
            }
        }
        size_t len = value.size() + 1; // +1 for null terminator
        emitln(name + " = private constant [" + std::to_string(len) + " x i8] c\"" + escaped +
               "\\00\"");
    }
    if (!string_constants_.empty()) {
        emitln();
    }

    emit_type_defs(module);

    // Collect sret functions (those with uses_sret flag set by RVO pass)
    sret_functions_.clear();
    for (const auto& func : module.functions) {
        if (func.uses_sret && func.original_return_type) {
            sret_functions_[func.name] = mir_type_to_llvm(func.original_return_type);
        }
    }

    // Emit functions
    for (const auto& func : module.functions) {
        emit_function(func);
    }

    return output_.str();
}

void MirCodegen::emit_preamble() {
    emit_comment("Generated by TML MIR Codegen");
    emitln("target triple = \"" + options_.target_triple + "\"");
    emitln();

    // Declare printf, println, and abort for print builtins
    emitln("declare i32 @printf(ptr, ...)");
    emitln("declare void @println(ptr)");
    emitln("declare void @abort() noreturn");
    emitln("declare ptr @str_concat(ptr, ptr)");
    emitln("declare ptr @str_concat_opt(ptr, ptr)");         // O(1) amortized concatenation
    emitln("declare ptr @str_concat_3(ptr, ptr, ptr)");      // Fused 3-string concat
    emitln("declare ptr @str_concat_4(ptr, ptr, ptr, ptr)"); // Fused 4-string concat
    emitln("declare ptr @i32_to_string(i32)");
    emitln("declare ptr @i64_to_string(i64)");
    emitln("declare i64 @time_ns()");
    emitln();

    // Black box functions (prevent optimization)
    emitln("declare i32 @black_box_i32(i32)");
    emitln("declare i64 @black_box_i64(i64)");
    emitln("declare double @black_box_f64(double)");
    emitln();

    // String format constants
    // %d\n\0 = 4 chars, %lld\n\0 = 6 chars, %f\n\0 = 4 chars, %s\n\0 = 4 chars
    emitln("@.str.int = private constant [4 x i8] c\"%d\\0A\\00\"");
    emitln("@.str.long = private constant [6 x i8] c\"%lld\\0A\\00\"");
    emitln("@.str.float = private constant [4 x i8] c\"%f\\0A\\00\"");
    emitln("@.str.str = private constant [4 x i8] c\"%s\\0A\\00\"");
    emitln("@.str.bool.true = private constant [5 x i8] c\"true\\00\"");
    emitln("@.str.bool.false = private constant [6 x i8] c\"false\\00\"");
    emitln("@.str.assert = private constant [18 x i8] c\"assertion failed\\0A\\00\"");
    emitln();

    // Digit pairs lookup table for fast int-to-string conversion (00-99)
    emitln("@.digit_pairs = private constant [200 x i8] c\"00010203040506070809"
           "10111213141516171819"
           "20212223242526272829"
           "30313233343536373839"
           "40414243444546474849"
           "50515253545556575859"
           "60616263646566676869"
           "70717273747576777879"
           "80818283848586878889"
           "90919293949596979899\"");
    emitln();

    // Assert implementation
    emitln("define void @assert(i1 %cond) {");
    emitln("entry:");
    emitln("    br i1 %cond, label %ok, label %fail");
    emitln("ok:");
    emitln("    ret void");
    emitln("fail:");
    emitln("    %msg = getelementptr [18 x i8], ptr @.str.assert, i32 0, i32 0");
    emitln("    call i32 @printf(ptr %msg)");
    emitln("    call void @abort()");
    emitln("    unreachable");
    emitln("}");
    emitln();

    // Assert_eq implementation for i64
    emitln(
        "@.str.assert_eq = private constant [32 x i8] c\"assert_eq failed: %lld != %lld\\0A\\00\"");
    emitln("define void @assert_eq(i64 %a, i64 %b) {");
    emitln("entry:");
    emitln("    %cmp = icmp eq i64 %a, %b");
    emitln("    br i1 %cmp, label %ok, label %fail");
    emitln("ok:");
    emitln("    ret void");
    emitln("fail:");
    emitln("    %msg = getelementptr [32 x i8], ptr @.str.assert_eq, i32 0, i32 0");
    emitln("    call i32 (ptr, ...) @printf(ptr %msg, i64 %a, i64 %b)");
    emitln("    call void @abort()");
    emitln("    unreachable");
    emitln("}");
    emitln();

    // Assert_eq implementation for i32
    emitln(
        "@.str.assert_eq_i32 = private constant [28 x i8] c\"assert_eq failed: %d != %d\\0A\\00\"");
    emitln("define void @assert_eq_i32(i32 %a, i32 %b) {");
    emitln("entry:");
    emitln("    %cmp = icmp eq i32 %a, %b");
    emitln("    br i1 %cmp, label %ok, label %fail");
    emitln("ok:");
    emitln("    ret void");
    emitln("fail:");
    emitln("    %msg = getelementptr [28 x i8], ptr @.str.assert_eq_i32, i32 0, i32 0");
    emitln("    call i32 (ptr, ...) @printf(ptr %msg, i32 %a, i32 %b)");
    emitln("    call void @abort()");
    emitln("    unreachable");
    emitln("}");
    emitln();

    // Drop functions (no-ops for simple types) - alwaysinline for zero overhead
    emitln("define void @drop_Ptr(ptr %p) alwaysinline {");
    emitln("entry:");
    emitln("    ret void");
    emitln("}");
    emitln();

    emitln("define void @drop_F64(double %v) alwaysinline {");
    emitln("entry:");
    emitln("    ret void");
    emitln("}");
    emitln();
}

void MirCodegen::emit_type_defs(const mir::Module& module) {
    // Emit struct definitions
    for (const auto& s : module.structs) {
        emit_struct_def(s);
    }

    // Emit enum definitions
    for (const auto& e : module.enums) {
        emit_enum_def(e);
    }

    if (!module.structs.empty() || !module.enums.empty()) {
        emitln();
    }

    // Emit drop functions for struct types (no-ops, just for RAII compatibility)
    // Use alwaysinline for zero overhead
    for (const auto& s : module.structs) {
        std::string type_name = "%struct." + s.name;
        emitln("define void @drop_" + s.name + "(" + type_name + " %v) alwaysinline {");
        emitln("entry:");
        emitln("    ret void");
        emitln("}");
        emitln();
    }
}

void MirCodegen::emit_struct_def(const mir::StructDef& s) {
    std::string type_name = "%struct." + s.name;
    if (emitted_types_.count(type_name)) {
        return;
    }
    emitted_types_.insert(type_name);

    // Store field types for later use in struct initialization coercion
    std::vector<std::string> field_types;

    emit(type_name + " = type { ");
    for (size_t i = 0; i < s.fields.size(); ++i) {
        if (i > 0) {
            emit(", ");
        }
        std::string field_type = mir_type_to_llvm(s.fields[i].type);
        emit(field_type);
        field_types.push_back(field_type);
    }
    emitln(" }");

    struct_field_types_[s.name] = std::move(field_types);
}

void MirCodegen::emit_enum_def(const mir::EnumDef& e) {
    // Enums are represented as tagged unions
    // { i32 tag, [max_payload_size x i8] payload }
    std::string type_name = "%enum." + e.name;
    if (emitted_types_.count(type_name)) {
        return;
    }
    emitted_types_.insert(type_name);

    // Calculate max payload size
    size_t max_payload_size = 0;
    for (const auto& v : e.variants) {
        size_t payload_size = 0;
        for (const auto& t : v.payload_types) {
            // Estimate size based on type
            if (t->is_integer()) {
                payload_size += t->bit_width() / 8;
            } else if (t->is_float()) {
                payload_size += t->bit_width() / 8;
            } else if (t->is_bool()) {
                payload_size += 1;
            } else if (std::holds_alternative<mir::MirPointerType>(t->kind)) {
                payload_size += 8; // 64-bit pointer
            } else if (auto* p = std::get_if<mir::MirPrimitiveType>(&t->kind);
                       p && p->kind == mir::PrimitiveType::Str) {
                payload_size += 8; // String pointer
            } else {
                payload_size += 8; // Default
            }
        }
        max_payload_size = std::max(max_payload_size, payload_size);
    }

    // Minimum 8 bytes for alignment
    if (max_payload_size < 8) {
        max_payload_size = 8;
    }

    emitln(type_name + " = type { i32, [" + std::to_string(max_payload_size) + " x i8] }");
}

void MirCodegen::emit_function(const mir::Function& func) {
    current_func_ = func.name;
    value_regs_.clear();
    block_labels_.clear();
    value_types_.clear(); // Clear type tracking for new function

    // Setup block labels - use block ID, not index
    for (const auto& blk : func.blocks) {
        block_labels_[blk.id] = blk.name;
    }

    // Find fallback label for missing block targets
    // Prefer first block with a return terminator, otherwise use last block
    fallback_label_.clear();
    for (const auto& blk : func.blocks) {
        if (blk.terminator.has_value()) {
            if (std::holds_alternative<mir::ReturnTerm>(*blk.terminator)) {
                fallback_label_ = blk.name;
                break;
            }
        }
    }
    // If no return block found, use the last block
    if (fallback_label_.empty() && !func.blocks.empty()) {
        fallback_label_ = func.blocks.back().name;
    }

    // Setup parameter registers and track parameter info for indirect calls
    param_info_.clear();
    for (const auto& param : func.params) {
        value_regs_[param.value_id] = "%" + param.name;
        // Also store parameter types for correct type tracking
        if (param.type) {
            value_types_[param.value_id] = mir_type_to_llvm(param.type);
            // Track parameter info for function pointer indirect calls
            param_info_[param.name] = {param.value_id, param.type};
        }
    }

    // Function signature
    std::string linkage = "define";
    if (options_.dll_export && func.is_public) {
        linkage = "define dllexport";
    }

    // Add inline hints for small functions to help LLVM optimizer
    std::string inline_attr;
    size_t total_instructions = 0;
    for (const auto& blk : func.blocks) {
        total_instructions += blk.instructions.size();
    }

    // Check if this is an iterator method that should always inline
    // Iterator methods are critical for zero-cost abstraction in for loops
    bool is_iterator_method = func.name.find("Iter__next") != std::string::npos ||
                              func.name.find("__into_iter") != std::string::npos ||
                              func.name.find("ArrayIter__") != std::string::npos ||
                              func.name.find("SliceIter__") != std::string::npos ||
                              func.name.find("Chunks__next") != std::string::npos ||
                              func.name.find("Windows__next") != std::string::npos ||
                              func.name.find("ChunksExact__next") != std::string::npos;

    // Small functions (<=10 instructions, single block) get inlinehint
    // drop_ functions and iterator methods get alwaysinline
    if (func.name.rfind("drop_", 0) == 0 || is_iterator_method) {
        inline_attr = " alwaysinline";
    } else if (total_instructions <= 10 && func.blocks.size() <= 2) {
        inline_attr = " inlinehint";
    }

    std::string ret_type = mir_type_to_llvm(func.return_type);
    emit(linkage + " " + ret_type + " @" + func.name + "(");

    for (size_t i = 0; i < func.params.size(); ++i) {
        if (i > 0) {
            emit(", ");
        }
        std::string param_type = mir_type_to_llvm(func.params[i].type);
        // If this function uses sret, the first parameter gets the sret attribute
        if (func.uses_sret && i == 0 && func.original_return_type) {
            std::string orig_ret_type = mir_type_to_llvm(func.original_return_type);
            emit(param_type + " sret(" + orig_ret_type + ") %" + func.params[i].name);
        } else {
            emit(param_type + " %" + func.params[i].name);
        }
    }

    emitln(")" + inline_attr + " {");

    // Emit basic blocks
    for (const auto& block : func.blocks) {
        emit_block(block);
    }

    emitln("}");
    emitln();
}

void MirCodegen::emit_block(const mir::BasicBlock& block) {
    emitln(block.name + ":");

    // Emit instructions
    for (const auto& inst : block.instructions) {
        emit_instruction(inst);
    }

    // Emit terminator
    if (block.terminator.has_value()) {
        emit_terminator(*block.terminator);
    }
}

} // namespace tml::codegen
