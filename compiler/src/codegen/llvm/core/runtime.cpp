//! # LLVM IR Generator - Runtime Declarations
//!
//! This file emits the target header and runtime type/function declarations.
//! Module import codegen is in runtime_modules.cpp.
//!
//! ## Emitted Sections
//!
//! | Method                         | Emits                         |
//! |--------------------------------|-------------------------------|
//! | `emit_header`                  | Target triple, comments       |
//! | `emit_runtime_decls`           | Struct types, C functions     |
//!
//! ## Runtime Types
//!
//! | Type            | Layout              | Purpose             |
//! |-----------------|---------------------|---------------------|
//! | `%struct.tml_str` | `{ ptr, i64 }`    | String slice        |
//! | `%struct.Ordering` | `{ i32 }`        | Comparison result   |
//!
//! ## External Functions
//!
//! Declares C standard library functions: printf, puts, malloc, free, exit.

#include "codegen/llvm/llvm_ir_gen.hpp"
#include "lexer/lexer.hpp"
#include "lexer/source.hpp"
#include "parser/parser.hpp"

#include <filesystem>
#include <unordered_set>

namespace tml::codegen {

void LLVMIRGen::emit_header() {
    emit_line("; Generated by TML Compiler");
    emit_line("target triple = \"" + options_.target_triple + "\"");
    emit_line("");
}

void LLVMIRGen::emit_runtime_decls() {
    // String type: { ptr, i64 } (pointer to data, length)
    emit_line("; Runtime type declarations");
    emit_line("%struct.tml_str = type { ptr, i64 }");

    // Core comparison type (core::cmp)
    // Ordering is a simple enum: Less=0, Equal=1, Greater=2
    emit_line("%struct.Ordering = type { i32 }");
    struct_types_["Ordering"] = "%struct.Ordering";
    struct_fields_["Ordering"] = {{"value", 0, "i32", types::make_i32()}};

    // HashMapIter type for iterating over HashMap entries
    emit_line("%struct.HashMapIter = type { ptr }");
    struct_types_["HashMapIter"] = "%struct.HashMapIter";
    struct_fields_["HashMapIter"] = {{"handle", 0, "ptr", types::make_ptr(types::make_unit())}};

    // Thread types (from std::thread) - needed for @extern function declarations
    emit_line("%struct.RawThread = type { i64 }"); // _handle: U64
    struct_types_["RawThread"] = "%struct.RawThread";
    struct_fields_["RawThread"] = {
        {"_handle", 0, "i64", types::make_primitive(types::PrimitiveKind::U64)}};
    emit_line("%struct.RawPtr = type { i64 }"); // addr: I64
    struct_types_["RawPtr"] = "%struct.RawPtr";
    struct_fields_["RawPtr"] = {{"addr", 0, "i64", types::make_i64()}};
    emit_line("");

    // External C functions
    emit_line("; External function declarations");
    emit_line("declare i32 @printf(ptr, ...)");
    emit_line("declare i32 @puts(ptr)");
    emit_line("declare i32 @putchar(i32)");
    emit_line("declare ptr @malloc(i64)");
    emit_line("declare void @free(ptr)");
    emit_line("declare void @exit(i32) noreturn");
    emit_line("declare i64 @strlen(ptr)");
    emit_line("declare i32 @strcmp(ptr, ptr)");
    emit_line("declare i32 @memcmp(ptr, ptr, i64)");
    emit_line("declare i32 @snprintf(ptr, i64, ptr, ...)");
    emit_line("");

    // LLVM intrinsics for optimized codegen
    emit_line("; LLVM intrinsics");
    emit_line("declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)");
    emit_line("declare void @llvm.memmove.p0.p0.i64(ptr, ptr, i64, i1)");
    emit_line("declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)");
    emit_line("declare void @llvm.assume(i1) nounwind");
    emit_line("");

    // TML runtime functions
    emit_line("; TML runtime functions");
    emit_line("declare void @panic(ptr) noreturn");
    emit_line("declare void @assert_tml_loc(i32, ptr, ptr, i32) noreturn");
    emit_line("");

    // Panic catching for @should_panic tests
    emit_line("; Panic catching (for @should_panic tests)");
    emit_line("declare i32 @tml_run_should_panic(ptr)");
    emit_line("declare i32 @tml_panic_message_contains(ptr)");
    emit_line("");

    // Backtrace support (--backtrace flag enables printing stack trace on panic)
    emit_line("; Backtrace support");
    emit_line("declare void @tml_enable_backtrace_on_panic()");
    emit_line("");

    // Note: TML test assertions are in the test module's TML code (call panic() internally)

    // TML code coverage functions (only when coverage is enabled)
    if (options_.coverage_enabled) {
        emit_line("; TML code coverage");
        emit_line("declare void @tml_cover_func(ptr)");
        emit_line("declare void @print_coverage_report()");
        emit_line("declare void @write_coverage_json(ptr)");
        emit_line("declare void @write_coverage_html(ptr)");
        emit_line("");
        // Register in declared_externals_ to prevent duplicate declarations
        // when test::coverage module is imported (it has @extern("tml_cover_func"))
        declared_externals_.insert("tml_cover_func");
        declared_externals_.insert("print_coverage_report");
        declared_externals_.insert("write_coverage_json");
        declared_externals_.insert("write_coverage_html");
    }

    // Debug intrinsics (for DWARF debug info)
    if (options_.emit_debug_info) {
        emit_line("; Debug intrinsics");
        emit_line("declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone");
        emit_line("declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone");
        emit_line("");
    }

    // LLVM instrumentation profile intrinsic (for source-based coverage)
    if (options_.llvm_source_coverage) {
        emit_line("; LLVM instrumentation profile intrinsics (source-based coverage)");
        emit_line("declare void @llvm.instrprof.increment(ptr, i64, i32, i32) #1");
        emit_line("");
    }

    // Stack save/restore intrinsics (for loop alloca cleanup)
    emit_line("; Stack management intrinsics");
    emit_line("declare ptr @llvm.stacksave() nounwind");
    emit_line("declare void @llvm.stackrestore(ptr) nounwind");
    emit_line("");

    // Lifetime intrinsics (for stack slot optimization)
    emit_line("; Lifetime intrinsics for stack optimization");
    emit_line("declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("");

    // I/O functions
    emit_line("; I/O functions (check output suppression)");
    emit_line("declare void @print(ptr)");
    emit_line("declare void @println(ptr)");
    emit_line("declare void @print_i32(i32)");
    emit_line("declare void @print_i64(i64)");
    emit_line("declare void @print_f64(double)");
    emit_line("declare void @print_bool(i32)");
    emit_line("");

    // Float functions still in essential.c (keep as declare)
    emit_line("; Float functions (essential.c)");
    emit_line("declare ptr @float_to_precision(double, i32)");
    emit_line("declare ptr @float_to_exp(double, i32)");
    emit_line("");

    // Nextafter from libm (keep as declare)
    emit_line("; Nextafter (libm)");
    emit_line("declare double @nextafter(double, double)");
    emit_line("");

    // Integer/bool to_string — defined as inline IR below (Phase 31)
    // (see define @i32_to_string, @i64_to_string, @bool_to_string in string utilities section)

    // --- On-demand runtime declares ---
    // Compute which optional categories are needed based on imports.
    // In library_ir_only mode (shared library for test suites), emit everything
    // because the shared lib is linked against multiple workers with varying imports.
    bool needs_sync_atomics = options_.library_ir_only;
    bool needs_logging = options_.library_ir_only;
    bool needs_glob = options_.library_ir_only;

    if (!options_.library_ir_only) {
        const auto& imports = env_.all_imports();
        for (const auto& [name, sym] : imports) {
            const auto& path = sym.module_path;
            if (!needs_sync_atomics &&
                (path.find("std::sync") == 0 || path.find("std::thread") == 0 ||
                 path.find("core::sync") == 0))
                needs_sync_atomics = true;
            if (!needs_logging && path.find("std::log") == 0)
                needs_logging = true;
            if (!needs_glob && (path.find("std::fs::glob") == 0 || path.find("std::glob") == 0))
                needs_glob = true;
            if (needs_sync_atomics && needs_logging && needs_glob)
                break;
        }
    }

    // Typed atomic operations — only when sync/thread modules are imported
    if (needs_sync_atomics) {
        emit_line("; Typed atomic operations runtime");
        emit_line("declare i32 @atomic_fetch_add_i32(ptr, i32)");
        declared_externals_.insert("atomic_fetch_add_i32");
        emit_line("declare i32 @atomic_fetch_sub_i32(ptr, i32)");
        declared_externals_.insert("atomic_fetch_sub_i32");
        emit_line("declare i32 @atomic_load_i32(ptr)");
        declared_externals_.insert("atomic_load_i32");
        emit_line("declare void @atomic_store_i32(ptr, i32)");
        declared_externals_.insert("atomic_store_i32");
        emit_line("declare i32 @atomic_compare_exchange_i32(ptr, i32, i32)");
        declared_externals_.insert("atomic_compare_exchange_i32");
        emit_line("declare i32 @atomic_swap_i32(ptr, i32)");
        declared_externals_.insert("atomic_swap_i32");
        emit_line("declare void @atomic_fence()");
        declared_externals_.insert("atomic_fence");
        emit_line("declare void @atomic_fence_acquire()");
        declared_externals_.insert("atomic_fence_acquire");
        emit_line("declare void @atomic_fence_release()");
        declared_externals_.insert("atomic_fence_release");
        emit_line("");
    }

    // Log runtime declarations — only when std::log is imported
    if (needs_logging) {
        emit_line("; Log runtime");
        emit_line("declare void @rt_log_msg(i32, ptr, ptr)");
        declared_externals_.insert("rt_log_msg");
        emit_line("declare void @rt_log_set_level(i32)");
        declared_externals_.insert("rt_log_set_level");
        emit_line("declare i32 @rt_log_get_level()");
        declared_externals_.insert("rt_log_get_level");
        emit_line("declare i32 @rt_log_enabled(i32)");
        declared_externals_.insert("rt_log_enabled");
        emit_line("");

        emit_line("declare void @rt_log_set_filter(ptr)");
        declared_externals_.insert("rt_log_set_filter");
        emit_line("declare i32 @rt_log_module_enabled(i32, ptr)");
        declared_externals_.insert("rt_log_module_enabled");
        emit_line("declare void @rt_log_structured(i32, ptr, ptr, ptr)");
        declared_externals_.insert("rt_log_structured");
        emit_line("declare void @rt_log_set_format(i32)");
        declared_externals_.insert("rt_log_set_format");
        emit_line("declare i32 @rt_log_get_format()");
        declared_externals_.insert("rt_log_get_format");
        emit_line("declare i32 @rt_log_open_file(ptr)");
        declared_externals_.insert("rt_log_open_file");
        emit_line("declare void @rt_log_close_file()");
        declared_externals_.insert("rt_log_close_file");
        emit_line("declare i32 @rt_log_init_from_env()");
        declared_externals_.insert("rt_log_init_from_env");
        emit_line("");

        // Register log functions in functions_ map for lowlevel calls
        functions_["rt_log_msg"] =
            FuncInfo{"@rt_log_msg", "void (i32, ptr, ptr)", "void", {"i32", "ptr", "ptr"}};
        functions_["rt_log_set_level"] =
            FuncInfo{"@rt_log_set_level", "void (i32)", "void", {"i32"}};
        functions_["rt_log_get_level"] = FuncInfo{"@rt_log_get_level", "i32 ()", "i32", {}};
        functions_["rt_log_enabled"] = FuncInfo{"@rt_log_enabled", "i32 (i32)", "i32", {"i32"}};
        functions_["rt_log_set_filter"] =
            FuncInfo{"@rt_log_set_filter", "void (ptr)", "void", {"ptr"}};
        functions_["rt_log_module_enabled"] =
            FuncInfo{"@rt_log_module_enabled", "i32 (i32, ptr)", "i32", {"i32", "ptr"}};
        functions_["rt_log_structured"] = FuncInfo{"@rt_log_structured",
                                                   "void (i32, ptr, ptr, ptr)",
                                                   "void",
                                                   {"i32", "ptr", "ptr", "ptr"}};
        functions_["rt_log_set_format"] =
            FuncInfo{"@rt_log_set_format", "void (i32)", "void", {"i32"}};
        functions_["rt_log_get_format"] = FuncInfo{"@rt_log_get_format", "i32 ()", "i32", {}};
        functions_["rt_log_open_file"] = FuncInfo{"@rt_log_open_file", "i32 (ptr)", "i32", {"ptr"}};
        functions_["rt_log_close_file"] = FuncInfo{"@rt_log_close_file", "void ()", "void", {}};
        functions_["rt_log_init_from_env"] = FuncInfo{"@rt_log_init_from_env", "i32 ()", "i32", {}};
    }

    // Glob runtime declarations — only when std::fs::glob is imported
    if (needs_glob) {
        emit_line("; Glob runtime");
        emit_line("declare ptr @glob_match(ptr, ptr)");
        declared_externals_.insert("glob_match");
        emit_line("declare ptr @glob_result_next(ptr)");
        declared_externals_.insert("glob_result_next");
        emit_line("declare i64 @glob_result_count(ptr)");
        declared_externals_.insert("glob_result_count");
        emit_line("declare void @glob_result_free(ptr)");
        declared_externals_.insert("glob_result_free");
        emit_line("declare i1 @glob_pattern_matches(ptr, ptr)");
        declared_externals_.insert("glob_pattern_matches");

        functions_["glob_match"] = FuncInfo{"@glob_match", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
        functions_["glob_result_next"] = FuncInfo{"@glob_result_next", "ptr (ptr)", "ptr", {"ptr"}};
        functions_["glob_result_count"] =
            FuncInfo{"@glob_result_count", "i64 (ptr)", "i64", {"ptr"}};
        functions_["glob_result_free"] =
            FuncInfo{"@glob_result_free", "void (ptr)", "void", {"ptr"}};
        functions_["glob_pattern_matches"] =
            FuncInfo{"@glob_pattern_matches", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
        emit_line("");
    }

    // String utilities — inline LLVM IR implementations (Phase 31)
    // These replace the previous C runtime declarations from string.c.
    // By using 'define' instead of 'declare', the functions are compiled
    // directly into each module without needing the C runtime library.

    // str_eq: null-safe string equality using libc strcmp
    emit_line("; String utilities (inline IR — no C runtime dependency)");
    emit_line("define internal i32 @str_eq(ptr %a, ptr %b) {");
    emit_line("entry:");
    emit_line("  %a_null = icmp eq ptr %a, null");
    emit_line("  %b_null = icmp eq ptr %b, null");
    emit_line("  %both_null = and i1 %a_null, %b_null");
    emit_line("  br i1 %both_null, label %ret_true, label %check_either");
    emit_line("ret_true:");
    emit_line("  ret i32 1");
    emit_line("check_either:");
    emit_line("  %either_null = or i1 %a_null, %b_null");
    emit_line("  br i1 %either_null, label %ret_false, label %compare");
    emit_line("ret_false:");
    emit_line("  ret i32 0");
    emit_line("compare:");
    emit_line("  %cmp = call i32 @strcmp(ptr %a, ptr %b)");
    emit_line("  %eq = icmp eq i32 %cmp, 0");
    emit_line("  %result = zext i1 %eq to i32");
    emit_line("  ret i32 %result");
    emit_line("}");
    emit_line("");

    // str_concat_opt: null-safe string concatenation using strlen+malloc+memcpy
    emit_line("@.str.empty = private constant [1 x i8] c\"\\00\"");
    emit_line("define internal ptr @str_concat_opt(ptr %a, ptr %b) {");
    emit_line("entry:");
    emit_line("  %a_null = icmp eq ptr %a, null");
    emit_line("  %a_safe = select i1 %a_null, ptr @.str.empty, ptr %a");
    emit_line("  %b_null = icmp eq ptr %b, null");
    emit_line("  %b_safe = select i1 %b_null, ptr @.str.empty, ptr %b");
    emit_line("  %len_a = call i64 @strlen(ptr %a_safe)");
    emit_line("  %len_b = call i64 @strlen(ptr %b_safe)");
    emit_line("  %total = add i64 %len_a, %len_b");
    emit_line("  %alloc = add i64 %total, 1");
    emit_line("  %buf = call ptr @malloc(i64 %alloc)");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %buf, ptr %a_safe, i64 %len_a, i1 false)");
    emit_line("  %dst = getelementptr i8, ptr %buf, i64 %len_a");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %b_safe, i64 %len_b, i1 false)");
    emit_line("  %end = getelementptr i8, ptr %buf, i64 %total");
    emit_line("  store i8 0, ptr %end");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // str_hash: FNV-1a hash for strings (used by HashMap)
    emit_line("define internal i32 @str_hash(ptr %s) {");
    emit_line("entry:");
    emit_line("  %is_null = icmp eq ptr %s, null");
    emit_line("  br i1 %is_null, label %ret_zero, label %loop_start");
    emit_line("ret_zero:");
    emit_line("  ret i32 0");
    emit_line("loop_start:");
    emit_line("  br label %loop");
    emit_line("loop:");
    emit_line("  %hash = phi i32 [ 2166136261, %loop_start ], [ %new_hash, %loop_body ]");
    emit_line("  %idx = phi i64 [ 0, %loop_start ], [ %next_idx, %loop_body ]");
    emit_line("  %ptr = getelementptr i8, ptr %s, i64 %idx");
    emit_line("  %byte = load i8, ptr %ptr");
    emit_line("  %is_zero = icmp eq i8 %byte, 0");
    emit_line("  br i1 %is_zero, label %done, label %loop_body");
    emit_line("loop_body:");
    emit_line("  %byte_i32 = zext i8 %byte to i32");
    emit_line("  %xored = xor i32 %hash, %byte_i32");
    emit_line("  %new_hash = mul i32 %xored, 16777619");
    emit_line("  %next_idx = add i64 %idx, 1");
    emit_line("  br label %loop");
    emit_line("done:");
    emit_line("  ret i32 %hash");
    emit_line("}");
    emit_line("");

    // i64_to_str: integer to string using libc snprintf with %lld format
    emit_line("@.fmt.lld = private constant [5 x i8] c\"%lld\\00\"");
    emit_line("define internal ptr @i64_to_str(i64 %val) {");
    emit_line("entry:");
    emit_line("  %buf = call ptr @malloc(i64 21)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 21, ptr @.fmt.lld, i64 "
              "%val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // i32_to_string: sign-extend to i64 and delegate
    emit_line("define internal ptr @i32_to_string(i32 %val) {");
    emit_line("entry:");
    emit_line("  %ext = sext i32 %val to i64");
    emit_line("  %result = call ptr @i64_to_str(i64 %ext)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // i64_to_string: alias to i64_to_str
    emit_line("define internal ptr @i64_to_string(i64 %val) {");
    emit_line("entry:");
    emit_line("  %result = call ptr @i64_to_str(i64 %val)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // bool_to_string: select between "true" and "false" string constants
    emit_line("define internal ptr @bool_to_string(i1 %val) {");
    emit_line("entry:");
    emit_line("  %result = select i1 %val, ptr @.str.true, ptr @.str.false");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // f64_to_str: float to string using libc snprintf with %g format
    emit_line("@.fmt.g = private constant [3 x i8] c\"%g\\00\"");
    emit_line("define internal ptr @f64_to_str(double %val) {");
    emit_line("entry:");
    emit_line("  %buf = call ptr @malloc(i64 32)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 32, ptr @.fmt.g, double "
              "%val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // str_as_bytes: returns string pointer as-is (null-safe)
    // Used by Str::as_bytes() lowlevel block in str.tml
    emit_line("define internal ptr @str_as_bytes(ptr %s) {");
    emit_line("entry:");
    emit_line("  %is_null = icmp eq ptr %s, null");
    emit_line("  %result = select i1 %is_null, ptr @.str.empty, ptr %s");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // ========================================================================
    // Math utilities — inline LLVM IR implementations (Phase 32)
    // These replace the previous C runtime declarations from math.c.
    // ========================================================================

    // --- Black box: prevent optimization using inline asm side-effect ---
    emit_line("; Black box (inline IR — Phase 32)");
    emit_line("define internal i32 @black_box_i32(i32 %val) noinline {");
    emit_line("entry:");
    emit_line("  call void asm sideeffect \"\", \"r\"(i32 %val)");
    emit_line("  ret i32 %val");
    emit_line("}");
    emit_line("define internal i64 @black_box_i64(i64 %val) noinline {");
    emit_line("entry:");
    emit_line("  call void asm sideeffect \"\", \"r\"(i64 %val)");
    emit_line("  ret i64 %val");
    emit_line("}");
    emit_line("define internal double @black_box_f64(double %val) noinline {");
    emit_line("entry:");
    emit_line("  call void asm sideeffect \"\", \"r\"(double %val)");
    emit_line("  ret double %val");
    emit_line("}");
    emit_line("");

    // --- SIMD operations (auto-vectorizable loops) ---
    emit_line("; SIMD operations (inline IR — Phase 32)");

    // simd_sum_i32: sum of i32 array into i64
    emit_line("define internal i64 @simd_sum_i32(ptr %arr, i64 %len) {");
    emit_line("entry:");
    emit_line("  %empty = icmp sle i64 %len, 0");
    emit_line("  br i1 %empty, label %done, label %loop");
    emit_line("loop:");
    emit_line("  %i = phi i64 [ 0, %entry ], [ %i_next, %loop ]");
    emit_line("  %sum = phi i64 [ 0, %entry ], [ %sum_next, %loop ]");
    emit_line("  %ptr = getelementptr i32, ptr %arr, i64 %i");
    emit_line("  %elem = load i32, ptr %ptr");
    emit_line("  %ext = sext i32 %elem to i64");
    emit_line("  %sum_next = add i64 %sum, %ext");
    emit_line("  %i_next = add i64 %i, 1");
    emit_line("  %cond = icmp slt i64 %i_next, %len");
    emit_line("  br i1 %cond, label %loop, label %done");
    emit_line("done:");
    emit_line("  %result = phi i64 [ 0, %entry ], [ %sum_next, %loop ]");
    emit_line("  ret i64 %result");
    emit_line("}");
    emit_line("");

    // simd_sum_f64: sum of f64 array
    emit_line("define internal double @simd_sum_f64(ptr %arr, i64 %len) {");
    emit_line("entry:");
    emit_line("  %empty = icmp sle i64 %len, 0");
    emit_line("  br i1 %empty, label %done, label %loop");
    emit_line("loop:");
    emit_line("  %i = phi i64 [ 0, %entry ], [ %i_next, %loop ]");
    emit_line("  %sum = phi double [ 0.0, %entry ], [ %sum_next, %loop ]");
    emit_line("  %ptr = getelementptr double, ptr %arr, i64 %i");
    emit_line("  %elem = load double, ptr %ptr");
    emit_line("  %sum_next = fadd double %sum, %elem");
    emit_line("  %i_next = add i64 %i, 1");
    emit_line("  %cond = icmp slt i64 %i_next, %len");
    emit_line("  br i1 %cond, label %loop, label %done");
    emit_line("done:");
    emit_line("  %result = phi double [ 0.0, %entry ], [ %sum_next, %loop ]");
    emit_line("  ret double %result");
    emit_line("}");
    emit_line("");

    // simd_dot_f64: dot product of two f64 arrays
    emit_line("define internal double @simd_dot_f64(ptr %a, ptr %b, i64 %len) {");
    emit_line("entry:");
    emit_line("  %empty = icmp sle i64 %len, 0");
    emit_line("  br i1 %empty, label %done, label %loop");
    emit_line("loop:");
    emit_line("  %i = phi i64 [ 0, %entry ], [ %i_next, %loop ]");
    emit_line("  %sum = phi double [ 0.0, %entry ], [ %sum_next, %loop ]");
    emit_line("  %pa = getelementptr double, ptr %a, i64 %i");
    emit_line("  %pb = getelementptr double, ptr %b, i64 %i");
    emit_line("  %ea = load double, ptr %pa");
    emit_line("  %eb = load double, ptr %pb");
    emit_line("  %prod = fmul double %ea, %eb");
    emit_line("  %sum_next = fadd double %sum, %prod");
    emit_line("  %i_next = add i64 %i, 1");
    emit_line("  %cond = icmp slt i64 %i_next, %len");
    emit_line("  br i1 %cond, label %loop, label %done");
    emit_line("done:");
    emit_line("  %result = phi double [ 0.0, %entry ], [ %sum_next, %loop ]");
    emit_line("  ret double %result");
    emit_line("}");
    emit_line("");

    // --- Float formatting (snprintf-based) ---
    emit_line("; Float formatting (inline IR — Phase 32)");

    // Format string constants for float formatting
    emit_line("@.fmt.star_f = private constant [5 x i8] c\"%.*f\\00\"");
    emit_line("@.fmt.lower_e = private constant [3 x i8] c\"%e\\00\"");
    emit_line("@.fmt.upper_E = private constant [3 x i8] c\"%E\\00\"");

    // float_to_fixed(double, i32): format with %.*f, clamp decimals to 0..20
    emit_line("define internal ptr @float_to_fixed(double %val, i32 %decimals) {");
    emit_line("entry:");
    emit_line("  %neg = icmp slt i32 %decimals, 0");
    emit_line("  %d1 = select i1 %neg, i32 0, i32 %decimals");
    emit_line("  %over = icmp sgt i32 %d1, 20");
    emit_line("  %d2 = select i1 %over, i32 20, i32 %d1");
    emit_line("  %buf = call ptr @malloc(i64 64)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 64, ptr "
              "@.fmt.star_f, i32 %d2, double %val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // float_to_string(double): format with %g
    emit_line("define internal ptr @float_to_string(double %val) {");
    emit_line("entry:");
    emit_line("  %buf = call ptr @malloc(i64 32)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 32, ptr @.fmt.g, "
              "double %val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // f64_to_string(double): alias to float_to_string
    emit_line("define internal ptr @f64_to_string(double %val) {");
    emit_line("entry:");
    emit_line("  %result = call ptr @float_to_string(double %val)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // f32_to_string(float): fpext to double, delegate to float_to_string
    emit_line("define internal ptr @f32_to_string(float %val) {");
    emit_line("entry:");
    emit_line("  %ext = fpext float %val to double");
    emit_line("  %result = call ptr @float_to_string(double %ext)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // f64_to_string_precision(double, i64): format with %.*f, clamp precision 0..20
    emit_line("define internal ptr @f64_to_string_precision(double %val, i64 %prec) {");
    emit_line("entry:");
    emit_line("  %neg = icmp slt i64 %prec, 0");
    emit_line("  %p1 = select i1 %neg, i64 0, i64 %prec");
    emit_line("  %over = icmp sgt i64 %p1, 20");
    emit_line("  %p2 = select i1 %over, i64 20, i64 %p1");
    emit_line("  %p2_i32 = trunc i64 %p2 to i32");
    emit_line("  %buf = call ptr @malloc(i64 64)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 64, ptr "
              "@.fmt.star_f, i32 %p2_i32, double %val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // f32_to_string_precision(float, i64): fpext, delegate
    emit_line("define internal ptr @f32_to_string_precision(float %val, i64 %prec) {");
    emit_line("entry:");
    emit_line("  %ext = fpext float %val to double");
    emit_line("  %result = call ptr @f64_to_string_precision(double %ext, i64 %prec)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // f64_to_exp_string(double, i32): format with %e or %E
    emit_line("define internal ptr @f64_to_exp_string(double %val, i32 %uppercase) {");
    emit_line("entry:");
    emit_line("  %is_upper = icmp ne i32 %uppercase, 0");
    emit_line("  %fmt = select i1 %is_upper, ptr @.fmt.upper_E, ptr @.fmt.lower_e");
    emit_line("  %buf = call ptr @malloc(i64 32)");
    emit_line("  call i32 (ptr, i64, ptr, ...) @snprintf(ptr %buf, i64 32, ptr %fmt, "
              "double %val)");
    emit_line("  ret ptr %buf");
    emit_line("}");
    emit_line("");

    // f32_to_exp_string(float, i32): fpext, delegate
    emit_line("define internal ptr @f32_to_exp_string(float %val, i32 %uppercase) {");
    emit_line("entry:");
    emit_line("  %ext = fpext float %val to double");
    emit_line("  %result = call ptr @f64_to_exp_string(double %ext, i32 %uppercase)");
    emit_line("  ret ptr %result");
    emit_line("}");
    emit_line("");

    // --- Integer formatting (binary, octal, hex) ---
    emit_line("; Integer formatting (inline IR — Phase 32)");

    // Digit lookup tables
    emit_line("@.hex.lower = private constant [16 x i8] "
              "c\"0123456789abcdef\"");
    emit_line("@.hex.upper = private constant [16 x i8] "
              "c\"0123456789ABCDEF\"");

    // i64_to_binary_str(i64): convert to binary with "0b" prefix
    // Uses a 67-byte stack buffer (2 prefix + 64 bits + null), then malloc+memcpy
    emit_line("define internal ptr @i64_to_binary_str(i64 %val) {");
    emit_line("entry:");
    emit_line("  %is_zero = icmp eq i64 %val, 0");
    emit_line("  br i1 %is_zero, label %zero_case, label %loop_init");
    emit_line("zero_case:");
    emit_line("  %z = call ptr @malloc(i64 4)");
    emit_line("  store i8 48, ptr %z"); // '0'
    emit_line("  %z1 = getelementptr i8, ptr %z, i64 1");
    emit_line("  store i8 98, ptr %z1"); // 'b'
    emit_line("  %z2 = getelementptr i8, ptr %z, i64 2");
    emit_line("  store i8 48, ptr %z2"); // '0'
    emit_line("  %z3 = getelementptr i8, ptr %z, i64 3");
    emit_line("  store i8 0, ptr %z3");
    emit_line("  ret ptr %z");
    emit_line("loop_init:");
    emit_line("  %buf = alloca [67 x i8]");
    emit_line("  br label %loop");
    emit_line("loop:");
    emit_line("  %uval = phi i64 [ %val, %loop_init ], [ %shifted, %loop ]");
    emit_line("  %pos = phi i32 [ 66, %loop_init ], [ %pos_dec, %loop ]");
    emit_line("  %bit = and i64 %uval, 1");
    emit_line("  %digit = trunc i64 %bit to i8");
    emit_line("  %ch = add i8 %digit, 48");
    emit_line("  %pos_dec = sub i32 %pos, 1");
    emit_line("  %pos_ext = sext i32 %pos_dec to i64");
    emit_line("  %dst = getelementptr i8, ptr %buf, i64 %pos_ext");
    emit_line("  store i8 %ch, ptr %dst");
    emit_line("  %shifted = lshr i64 %uval, 1");
    emit_line("  %done = icmp eq i64 %shifted, 0");
    emit_line("  br i1 %done, label %prefix, label %loop");
    emit_line("prefix:");
    emit_line("  %p1 = sub i32 %pos_dec, 1");
    emit_line("  %p1_ext = sext i32 %p1 to i64");
    emit_line("  %d1 = getelementptr i8, ptr %buf, i64 %p1_ext");
    emit_line("  store i8 98, ptr %d1"); // 'b'
    emit_line("  %p0 = sub i32 %p1, 1");
    emit_line("  %p0_ext = sext i32 %p0 to i64");
    emit_line("  %d0 = getelementptr i8, ptr %buf, i64 %p0_ext");
    emit_line("  store i8 48, ptr %d0"); // '0'
    // null terminate at position 66
    emit_line("  %end = getelementptr i8, ptr %buf, i64 66");
    emit_line("  store i8 0, ptr %end");
    // compute length and malloc+memcpy
    emit_line("  %start = sext i32 %p0 to i64");
    emit_line("  %len = sub i64 67, %start");
    emit_line("  %out = call ptr @malloc(i64 %len)");
    emit_line("  %src = getelementptr i8, ptr %buf, i64 %start");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %out, ptr %src, i64 %len, i1 false)");
    emit_line("  ret ptr %out");
    emit_line("}");
    emit_line("");

    // i64_to_octal_str(i64): convert to octal with "0o" prefix
    emit_line("define internal ptr @i64_to_octal_str(i64 %val) {");
    emit_line("entry:");
    emit_line("  %is_zero = icmp eq i64 %val, 0");
    emit_line("  br i1 %is_zero, label %zero_case, label %loop_init");
    emit_line("zero_case:");
    emit_line("  %z = call ptr @malloc(i64 4)");
    emit_line("  store i8 48, ptr %z"); // '0'
    emit_line("  %z1 = getelementptr i8, ptr %z, i64 1");
    emit_line("  store i8 111, ptr %z1"); // 'o'
    emit_line("  %z2 = getelementptr i8, ptr %z, i64 2");
    emit_line("  store i8 48, ptr %z2"); // '0'
    emit_line("  %z3 = getelementptr i8, ptr %z, i64 3");
    emit_line("  store i8 0, ptr %z3");
    emit_line("  ret ptr %z");
    emit_line("loop_init:");
    emit_line("  %buf = alloca [25 x i8]");
    emit_line("  br label %loop");
    emit_line("loop:");
    emit_line("  %uval = phi i64 [ %val, %loop_init ], [ %shifted, %loop ]");
    emit_line("  %pos = phi i32 [ 24, %loop_init ], [ %pos_dec, %loop ]");
    emit_line("  %oct = and i64 %uval, 7");
    emit_line("  %digit = trunc i64 %oct to i8");
    emit_line("  %ch = add i8 %digit, 48");
    emit_line("  %pos_dec = sub i32 %pos, 1");
    emit_line("  %pos_ext = sext i32 %pos_dec to i64");
    emit_line("  %dst = getelementptr i8, ptr %buf, i64 %pos_ext");
    emit_line("  store i8 %ch, ptr %dst");
    emit_line("  %shifted = lshr i64 %uval, 3");
    emit_line("  %done = icmp eq i64 %shifted, 0");
    emit_line("  br i1 %done, label %prefix, label %loop");
    emit_line("prefix:");
    emit_line("  %p1 = sub i32 %pos_dec, 1");
    emit_line("  %p1_ext = sext i32 %p1 to i64");
    emit_line("  %d1 = getelementptr i8, ptr %buf, i64 %p1_ext");
    emit_line("  store i8 111, ptr %d1"); // 'o'
    emit_line("  %p0 = sub i32 %p1, 1");
    emit_line("  %p0_ext = sext i32 %p0 to i64");
    emit_line("  %d0 = getelementptr i8, ptr %buf, i64 %p0_ext");
    emit_line("  store i8 48, ptr %d0"); // '0'
    emit_line("  %end = getelementptr i8, ptr %buf, i64 24");
    emit_line("  store i8 0, ptr %end");
    emit_line("  %start = sext i32 %p0 to i64");
    emit_line("  %len = sub i64 25, %start");
    emit_line("  %out = call ptr @malloc(i64 %len)");
    emit_line("  %src = getelementptr i8, ptr %buf, i64 %start");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %out, ptr %src, i64 %len, i1 false)");
    emit_line("  ret ptr %out");
    emit_line("}");
    emit_line("");

    // i64_to_lower_hex_str(i64): convert to hex with "0x" prefix, lowercase
    emit_line("define internal ptr @i64_to_lower_hex_str(i64 %val) {");
    emit_line("entry:");
    emit_line("  %is_zero = icmp eq i64 %val, 0");
    emit_line("  br i1 %is_zero, label %zero_case, label %loop_init");
    emit_line("zero_case:");
    emit_line("  %z = call ptr @malloc(i64 4)");
    emit_line("  store i8 48, ptr %z"); // '0'
    emit_line("  %z1 = getelementptr i8, ptr %z, i64 1");
    emit_line("  store i8 120, ptr %z1"); // 'x'
    emit_line("  %z2 = getelementptr i8, ptr %z, i64 2");
    emit_line("  store i8 48, ptr %z2"); // '0'
    emit_line("  %z3 = getelementptr i8, ptr %z, i64 3");
    emit_line("  store i8 0, ptr %z3");
    emit_line("  ret ptr %z");
    emit_line("loop_init:");
    emit_line("  %buf = alloca [19 x i8]");
    emit_line("  br label %loop");
    emit_line("loop:");
    emit_line("  %uval = phi i64 [ %val, %loop_init ], [ %shifted, %loop ]");
    emit_line("  %pos = phi i32 [ 18, %loop_init ], [ %pos_dec, %loop ]");
    emit_line("  %nib = and i64 %uval, 15");
    emit_line("  %ch_ptr = getelementptr [16 x i8], ptr @.hex.lower, i64 0, i64 %nib");
    emit_line("  %ch = load i8, ptr %ch_ptr");
    emit_line("  %pos_dec = sub i32 %pos, 1");
    emit_line("  %pos_ext = sext i32 %pos_dec to i64");
    emit_line("  %dst = getelementptr i8, ptr %buf, i64 %pos_ext");
    emit_line("  store i8 %ch, ptr %dst");
    emit_line("  %shifted = lshr i64 %uval, 4");
    emit_line("  %done = icmp eq i64 %shifted, 0");
    emit_line("  br i1 %done, label %prefix, label %loop");
    emit_line("prefix:");
    emit_line("  %p1 = sub i32 %pos_dec, 1");
    emit_line("  %p1_ext = sext i32 %p1 to i64");
    emit_line("  %d1 = getelementptr i8, ptr %buf, i64 %p1_ext");
    emit_line("  store i8 120, ptr %d1"); // 'x'
    emit_line("  %p0 = sub i32 %p1, 1");
    emit_line("  %p0_ext = sext i32 %p0 to i64");
    emit_line("  %d0 = getelementptr i8, ptr %buf, i64 %p0_ext");
    emit_line("  store i8 48, ptr %d0"); // '0'
    emit_line("  %end = getelementptr i8, ptr %buf, i64 18");
    emit_line("  store i8 0, ptr %end");
    emit_line("  %start = sext i32 %p0 to i64");
    emit_line("  %len = sub i64 19, %start");
    emit_line("  %out = call ptr @malloc(i64 %len)");
    emit_line("  %src = getelementptr i8, ptr %buf, i64 %start");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %out, ptr %src, i64 %len, i1 false)");
    emit_line("  ret ptr %out");
    emit_line("}");
    emit_line("");

    // i64_to_upper_hex_str(i64): same as lower but uppercase
    emit_line("define internal ptr @i64_to_upper_hex_str(i64 %val) {");
    emit_line("entry:");
    emit_line("  %is_zero = icmp eq i64 %val, 0");
    emit_line("  br i1 %is_zero, label %zero_case, label %loop_init");
    emit_line("zero_case:");
    emit_line("  %z = call ptr @malloc(i64 4)");
    emit_line("  store i8 48, ptr %z"); // '0'
    emit_line("  %z1 = getelementptr i8, ptr %z, i64 1");
    emit_line("  store i8 120, ptr %z1"); // 'x'
    emit_line("  %z2 = getelementptr i8, ptr %z, i64 2");
    emit_line("  store i8 48, ptr %z2"); // '0'
    emit_line("  %z3 = getelementptr i8, ptr %z, i64 3");
    emit_line("  store i8 0, ptr %z3");
    emit_line("  ret ptr %z");
    emit_line("loop_init:");
    emit_line("  %buf = alloca [19 x i8]");
    emit_line("  br label %loop");
    emit_line("loop:");
    emit_line("  %uval = phi i64 [ %val, %loop_init ], [ %shifted, %loop ]");
    emit_line("  %pos = phi i32 [ 18, %loop_init ], [ %pos_dec, %loop ]");
    emit_line("  %nib = and i64 %uval, 15");
    emit_line("  %ch_ptr = getelementptr [16 x i8], ptr @.hex.upper, i64 0, i64 %nib");
    emit_line("  %ch = load i8, ptr %ch_ptr");
    emit_line("  %pos_dec = sub i32 %pos, 1");
    emit_line("  %pos_ext = sext i32 %pos_dec to i64");
    emit_line("  %dst = getelementptr i8, ptr %buf, i64 %pos_ext");
    emit_line("  store i8 %ch, ptr %dst");
    emit_line("  %shifted = lshr i64 %uval, 4");
    emit_line("  %done = icmp eq i64 %shifted, 0");
    emit_line("  br i1 %done, label %prefix, label %loop");
    emit_line("prefix:");
    emit_line("  %p1 = sub i32 %pos_dec, 1");
    emit_line("  %p1_ext = sext i32 %p1 to i64");
    emit_line("  %d1 = getelementptr i8, ptr %buf, i64 %p1_ext");
    emit_line("  store i8 120, ptr %d1"); // 'x'
    emit_line("  %p0 = sub i32 %p1, 1");
    emit_line("  %p0_ext = sext i32 %p0 to i64");
    emit_line("  %d0 = getelementptr i8, ptr %buf, i64 %p0_ext");
    emit_line("  store i8 48, ptr %d0"); // '0'
    emit_line("  %end = getelementptr i8, ptr %buf, i64 18");
    emit_line("  store i8 0, ptr %end");
    emit_line("  %start = sext i32 %p0 to i64");
    emit_line("  %len = sub i64 19, %start");
    emit_line("  %out = call ptr @malloc(i64 %len)");
    emit_line("  %src = getelementptr i8, ptr %buf, i64 %start");
    emit_line("  call void @llvm.memcpy.p0.p0.i64(ptr %out, ptr %src, i64 %len, i1 false)");
    emit_line("  ret ptr %out");
    emit_line("}");
    emit_line("");

    // --- nextafter32: call nextafterf from libm ---
    emit_line("; Nextafter32 (inline IR — Phase 32)");
    emit_line("declare float @nextafterf(float, float)");
    emit_line("define internal float @nextafter32(float %x, float %y) {");
    emit_line("entry:");
    emit_line("  %result = call float @nextafterf(float %x, float %y)");
    emit_line("  ret float %result");
    emit_line("}");
    emit_line("");

    emit_line("declare i64 @tml_random_seed()");
    emit_line("");

    // Register random_seed in functions_ map for lowlevel calls
    functions_["random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};
    // Also register with tml_ prefix for when called as tml_random_seed()
    functions_["tml_random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};

    // Register string runtime functions in functions_ map for lowlevel calls.
    // Most str_* functions were migrated to inline LLVM IR (Phase 31).
    // Only str_as_bytes is still needed for lowlevel blocks in str.tml.
    functions_["str_as_bytes"] = FuncInfo{"@str_as_bytes", "ptr (ptr)", "ptr", {"ptr"}};

    // Register I/O functions for lowlevel calls (used by text.tml print/println methods)
    functions_["print_str"] = FuncInfo{"@print", "void (ptr)", "void", {"ptr"}};
    functions_["println_str"] = FuncInfo{"@println", "void (ptr)", "void", {"ptr"}};

    // Register float formatting runtime functions for lowlevel calls from core::fmt::float
    // Also register f64_to_str (used by text.tml lowlevel blocks for from_f64)
    functions_["f64_to_str"] = FuncInfo{"@f64_to_str", "ptr (double)", "ptr", {"double"}};
    functions_["f64_to_string"] = FuncInfo{"@f64_to_string", "ptr (double)", "ptr", {"double"}};
    functions_["f32_to_string"] = FuncInfo{"@f32_to_string", "ptr (float)", "ptr", {"float"}};
    functions_["f64_to_string_precision"] =
        FuncInfo{"@f64_to_string_precision", "ptr (double, i64)", "ptr", {"double", "i64"}};
    functions_["f32_to_string_precision"] =
        FuncInfo{"@f32_to_string_precision", "ptr (float, i64)", "ptr", {"float", "i64"}};
    functions_["f64_to_exp_string"] =
        FuncInfo{"@f64_to_exp_string", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["f32_to_exp_string"] =
        FuncInfo{"@f32_to_exp_string", "ptr (float, i32)", "ptr", {"float", "i32"}};

    // Register math runtime functions for lowlevel calls (Phase 32)
    functions_["float_to_fixed"] =
        FuncInfo{"@float_to_fixed", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["float_to_string"] = FuncInfo{"@float_to_string", "ptr (double)", "ptr", {"double"}};
    functions_["i64_to_binary_str"] = FuncInfo{"@i64_to_binary_str", "ptr (i64)", "ptr", {"i64"}};
    functions_["i64_to_octal_str"] = FuncInfo{"@i64_to_octal_str", "ptr (i64)", "ptr", {"i64"}};
    functions_["i64_to_lower_hex_str"] =
        FuncInfo{"@i64_to_lower_hex_str", "ptr (i64)", "ptr", {"i64"}};
    functions_["i64_to_upper_hex_str"] =
        FuncInfo{"@i64_to_upper_hex_str", "ptr (i64)", "ptr", {"i64"}};

    // Memory functions (matches runtime/mem.c)
    emit_line("; Memory functions");
    emit_line("declare ptr @mem_alloc(i64)");
    emit_line("declare ptr @mem_alloc_zeroed(i64)");
    emit_line("declare ptr @mem_realloc(ptr, i64)");
    emit_line("declare void @mem_free(ptr)");
    emit_line("declare void @mem_copy(ptr, ptr, i64)");
    emit_line("declare void @mem_move(ptr, ptr, i64)");
    emit_line("declare void @mem_set(ptr, i32, i64)");
    emit_line("declare void @mem_zero(ptr, i64)");
    emit_line("declare i32 @mem_compare(ptr, ptr, i64)");
    emit_line("declare i32 @mem_eq(ptr, ptr, i64)");
    emit_line("");

    // Object pool functions (for @pool classes)
    emit_line("; Object pool functions");
    emit_line("declare ptr @pool_acquire(ptr, i64)");
    emit_line("declare void @pool_release(ptr, ptr)");
    emit_line("");

    // Thread-local pool functions (for @pool(thread_local: true) classes)
    emit_line("; Thread-local pool functions");
    emit_line("declare ptr @tls_pool_acquire(ptr, i64)");
    emit_line("declare void @tls_pool_release(ptr, ptr, i64)");
    emit_line("");

    // Format strings for print/println
    // Size calculation: count actual bytes (each escape like \0A = 1 byte, not 3)
    emit_line("; Format strings");
    emit_line("@.fmt.int = private constant [4 x i8] c\"%d\\0A\\00\"");        // %d\n\0 = 4 bytes
    emit_line("@.fmt.int.no_nl = private constant [3 x i8] c\"%d\\00\"");      // %d\0 = 3 bytes
    emit_line("@.fmt.i64 = private constant [5 x i8] c\"%ld\\0A\\00\"");       // %ld\n\0 = 5 bytes
    emit_line("@.fmt.i64.no_nl = private constant [4 x i8] c\"%ld\\00\"");     // %ld\0 = 4 bytes
    emit_line("@.fmt.float = private constant [4 x i8] c\"%f\\0A\\00\"");      // %f\n\0 = 4 bytes
    emit_line("@.fmt.float.no_nl = private constant [3 x i8] c\"%f\\00\"");    // %f\0 = 3 bytes
    emit_line("@.fmt.float3 = private constant [6 x i8] c\"%.3f\\0A\\00\"");   // %.3f\n\0 = 6 bytes
    emit_line("@.fmt.float3.no_nl = private constant [5 x i8] c\"%.3f\\00\""); // %.3f\0 = 5 bytes
    emit_line("@.fmt.str.no_nl = private constant [3 x i8] c\"%s\\00\"");      // %s\0 = 3 bytes
    emit_line("@.str.true = private constant [5 x i8] c\"true\\00\"");         // true\0 = 5 bytes
    emit_line("@.str.false = private constant [6 x i8] c\"false\\00\"");       // false\0 = 6 bytes
    emit_line("@.str.space = private constant [2 x i8] c\" \\00\"");           // " "\0 = 2 bytes
    emit_line("@.str.newline = private constant [2 x i8] c\"\\0A\\00\"");      // \n\0 = 2 bytes
    emit_line("");
}

// emit_module_lowlevel_decls, emit_module_pure_tml_functions, and
// emit_string_constants are in runtime_modules.cpp

} // namespace tml::codegen
