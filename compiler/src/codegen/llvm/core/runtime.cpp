//! # LLVM IR Generator - Runtime Declarations
//!
//! This file emits the target header and runtime type/function declarations.
//! Module import codegen is in runtime_modules.cpp.
//!
//! ## Dead Declaration Elimination (Phase 3)
//!
//! Runtime function declarations are registered in a catalog during init.
//! During codegen, emit_line() auto-detects @symbol references and marks
//! them as needed. At finalization, only needed declarations are emitted.
//!
//! ## Emitted Sections
//!
//! | Method                         | Emits                         |
//! |--------------------------------|-------------------------------|
//! | `emit_header`                  | Target triple, comments       |
//! | `emit_runtime_decls`           | Struct types, catalog init    |
//! | `finalize_runtime_decls`       | Only needed function declares |
//!
//! ## Runtime Types
//!
//! | Type            | Layout              | Purpose             |
//! |-----------------|---------------------|---------------------|
//! | `%struct.tml_str` | `{ ptr, i64 }`    | String slice        |
//! | `%struct.Ordering` | `{ i32 }`        | Comparison result   |

#include "codegen/llvm/llvm_ir_gen.hpp"
#include "lexer/lexer.hpp"
#include "lexer/source.hpp"
#include "parser/parser.hpp"

#include <filesystem>
#include <sstream>
#include <unordered_set>

namespace tml::codegen {

void LLVMIRGen::emit_header() {
    emit_line("; Generated by TML Compiler");
    emit_line("target triple = \"" + options_.target_triple + "\"");
    emit_line("");
}

// ============================================================================
// Runtime Declaration Catalog
// ============================================================================

void LLVMIRGen::init_runtime_catalog() {
    runtime_catalog_.clear();
    runtime_catalog_index_.clear();
    needed_runtime_decls_.clear();

    auto add = [&](const std::string& name, const std::string& ir,
                   std::vector<std::string> deps = {}) {
        size_t idx = runtime_catalog_.size();
        runtime_catalog_.push_back({name, ir, std::move(deps)});
        runtime_catalog_index_[name] = idx;
    };

    // --- C stdlib functions ---
    add("printf", "declare i32 @printf(ptr, ...)");
    add("puts", "declare i32 @puts(ptr)");
    add("putchar", "declare i32 @putchar(i32)");
    add("malloc", "declare ptr @malloc(i64)");
    add("free", "declare void @free(ptr)");
    add("tml_str_free", "declare void @tml_str_free(ptr)");
    add("exit", "declare void @exit(i32) noreturn");
    add("strlen", "declare i64 @strlen(ptr)");
    add("strcmp", "declare i32 @strcmp(ptr, ptr)");
    add("memcmp", "declare i32 @memcmp(ptr, ptr, i64)");

    // --- LLVM intrinsics ---
    add("llvm.memcpy.p0.p0.i64", "declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)");
    add("llvm.memmove.p0.p0.i64", "declare void @llvm.memmove.p0.p0.i64(ptr, ptr, i64, i1)");
    add("llvm.memset.p0.i64", "declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)");
    add("llvm.assume", "declare void @llvm.assume(i1) nounwind");

    // --- TML runtime ---
    add("panic", "declare void @panic(ptr) noreturn");
    add("assert_tml_loc", "declare void @assert_tml_loc(i32, ptr, ptr, i32) noreturn");

    // --- Panic catching ---
    add("tml_run_should_panic", "declare i32 @tml_run_should_panic(ptr)");
    add("tml_panic_message_contains", "declare i32 @tml_panic_message_contains(ptr)");

    // --- Backtrace ---
    add("tml_enable_backtrace_on_panic", "declare void @tml_enable_backtrace_on_panic()");

    // --- Coverage (conditional, but registered for completeness) ---
    add("tml_cover_func", "declare void @tml_cover_func(ptr)");
    add("print_coverage_report", "declare void @print_coverage_report()");
    add("write_coverage_json", "declare void @write_coverage_json(ptr)");
    add("write_coverage_html", "declare void @write_coverage_html(ptr)");

    // --- Debug intrinsics ---
    add("llvm.dbg.declare",
        "declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone");
    add("llvm.dbg.value",
        "declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone");

    // --- LLVM instrumentation profile ---
    add("llvm.instrprof.increment",
        "declare void @llvm.instrprof.increment(ptr, i64, i32, i32) #1");

    // --- Stack management ---
    add("llvm.stacksave", "declare ptr @llvm.stacksave() nounwind");
    add("llvm.stackrestore", "declare void @llvm.stackrestore(ptr) nounwind");

    // --- Lifetime intrinsics ---
    add("llvm.lifetime.start.p0",
        "declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) nounwind");
    add("llvm.lifetime.end.p0",
        "declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) nounwind");

    // --- I/O functions ---
    add("print", "declare void @print(ptr)");
    add("println", "declare void @println(ptr)");
    add("print_i32", "declare void @print_i32(i32)");
    add("print_i64", "declare void @print_i64(i64)");
    add("print_f64", "declare void @print_f64(double)");
    add("print_bool", "declare void @print_bool(i32)");

    // --- Float formatting (C runtime) ---
    add("f64_to_string", "declare ptr @f64_to_string(double)");
    add("f32_to_string", "declare ptr @f32_to_string(float)");
    add("f64_to_string_precision", "declare ptr @f64_to_string_precision(double, i64)");
    add("f32_to_string_precision", "declare ptr @f32_to_string_precision(float, i64)");
    add("f64_to_exp_string", "declare ptr @f64_to_exp_string(double, i32)");
    add("f32_to_exp_string", "declare ptr @f32_to_exp_string(float, i32)");

    // --- Random seed ---
    add("tml_random_seed", "declare i64 @tml_random_seed()");

    // --- Memory functions ---
    add("mem_alloc", "declare ptr @mem_alloc(i64)");
    add("mem_alloc_zeroed", "declare ptr @mem_alloc_zeroed(i64)");
    add("mem_realloc", "declare ptr @mem_realloc(ptr, i64)");
    add("mem_free", "declare void @mem_free(ptr)");
    add("mem_copy", "declare void @mem_copy(ptr, ptr, i64)");
    add("mem_move", "declare void @mem_move(ptr, ptr, i64)");
    add("mem_set", "declare void @mem_set(ptr, i32, i64)");
    add("mem_zero", "declare void @mem_zero(ptr, i64)");
    add("mem_compare", "declare i32 @mem_compare(ptr, ptr, i64)");
    add("mem_eq", "declare i32 @mem_eq(ptr, ptr, i64)");

    // --- Object pool ---
    add("pool_acquire", "declare ptr @pool_acquire(ptr, i64)");
    add("pool_release", "declare void @pool_release(ptr, ptr)");
    add("tls_pool_acquire", "declare ptr @tls_pool_acquire(ptr, i64)");
    add("tls_pool_release", "declare void @tls_pool_release(ptr, ptr, i64)");

    // --- Atomic operations ---
    add("atomic_fetch_add_i32", "declare i32 @atomic_fetch_add_i32(ptr, i32)");
    add("atomic_fetch_sub_i32", "declare i32 @atomic_fetch_sub_i32(ptr, i32)");
    add("atomic_load_i32", "declare i32 @atomic_load_i32(ptr)");
    add("atomic_store_i32", "declare void @atomic_store_i32(ptr, i32)");
    add("atomic_compare_exchange_i32", "declare i32 @atomic_compare_exchange_i32(ptr, i32, i32)");
    add("atomic_swap_i32", "declare i32 @atomic_swap_i32(ptr, i32)");
    add("atomic_fence", "declare void @atomic_fence()");
    add("atomic_fence_acquire", "declare void @atomic_fence_acquire()");
    add("atomic_fence_release", "declare void @atomic_fence_release()");

    // --- Log runtime ---
    add("rt_log_msg", "declare void @rt_log_msg(i32, ptr, ptr)");
    add("rt_log_set_level", "declare void @rt_log_set_level(i32)");
    add("rt_log_get_level", "declare i32 @rt_log_get_level()");
    add("rt_log_enabled", "declare i32 @rt_log_enabled(i32)");
    add("rt_log_set_filter", "declare void @rt_log_set_filter(ptr)");
    add("rt_log_module_enabled", "declare i32 @rt_log_module_enabled(i32, ptr)");
    add("rt_log_structured", "declare void @rt_log_structured(i32, ptr, ptr, ptr)");
    add("rt_log_set_format", "declare void @rt_log_set_format(i32)");
    add("rt_log_get_format", "declare i32 @rt_log_get_format()");
    add("rt_log_open_file", "declare i32 @rt_log_open_file(ptr)");
    add("rt_log_close_file", "declare void @rt_log_close_file()");
    add("rt_log_init_from_env", "declare i32 @rt_log_init_from_env()");

    // --- Inline IR definitions (multi-line, with dependencies) ---

    // str_eq depends on strcmp
    add("str_eq",
        "; String utilities (inline IR)\n"
        "define internal i32 @str_eq(ptr %a, ptr %b) {\n"
        "entry:\n"
        "  %a_null = icmp eq ptr %a, null\n"
        "  %b_null = icmp eq ptr %b, null\n"
        "  %both_null = and i1 %a_null, %b_null\n"
        "  br i1 %both_null, label %ret_true, label %check_either\n"
        "ret_true:\n"
        "  ret i32 1\n"
        "check_either:\n"
        "  %either_null = or i1 %a_null, %b_null\n"
        "  br i1 %either_null, label %ret_false, label %compare\n"
        "ret_false:\n"
        "  ret i32 0\n"
        "compare:\n"
        "  %cmp = call i32 @strcmp(ptr %a, ptr %b)\n"
        "  %eq = icmp eq i32 %cmp, 0\n"
        "  %result = zext i1 %eq to i32\n"
        "  ret i32 %result\n"
        "}",
        {"strcmp"});

    // .str.empty global needed by str_concat_opt
    add(".str.empty", "@.str.empty = private constant [1 x i8] c\"\\00\"");

    // str_concat_opt depends on strlen, mem_alloc, memcpy, .str.empty
    // Uses mem_alloc instead of malloc so the memory tracker can track
    // the allocation and tml_str_free can properly deregister it.
    add("str_concat_opt",
        "define internal ptr @str_concat_opt(ptr %a, ptr %b) {\n"
        "entry:\n"
        "  %a_null = icmp eq ptr %a, null\n"
        "  %a_safe = select i1 %a_null, ptr @.str.empty, ptr %a\n"
        "  %b_null = icmp eq ptr %b, null\n"
        "  %b_safe = select i1 %b_null, ptr @.str.empty, ptr %b\n"
        "  %len_a = call i64 @strlen(ptr %a_safe)\n"
        "  %len_b = call i64 @strlen(ptr %b_safe)\n"
        "  %total = add i64 %len_a, %len_b\n"
        "  %alloc = add i64 %total, 1\n"
        "  %buf = call ptr @mem_alloc(i64 %alloc)\n"
        "  call void @llvm.memcpy.p0.p0.i64(ptr %buf, ptr %a_safe, i64 %len_a, i1 false)\n"
        "  %dst = getelementptr i8, ptr %buf, i64 %len_a\n"
        "  call void @llvm.memcpy.p0.p0.i64(ptr %dst, ptr %b_safe, i64 %len_b, i1 false)\n"
        "  %end = getelementptr i8, ptr %buf, i64 %total\n"
        "  store i8 0, ptr %end\n"
        "  ret ptr %buf\n"
        "}",
        {"strlen", "mem_alloc", "llvm.memcpy.p0.p0.i64", ".str.empty"});

    // Black box functions (no dependencies)
    add("black_box_i32", "; Black box (inline IR)\n"
                         "define internal i32 @black_box_i32(i32 %val) noinline {\n"
                         "entry:\n"
                         "  call void asm sideeffect \"\", \"r\"(i32 %val)\n"
                         "  ret i32 %val\n"
                         "}");
    add("black_box_i64", "define internal i64 @black_box_i64(i64 %val) noinline {\n"
                         "entry:\n"
                         "  call void asm sideeffect \"\", \"r\"(i64 %val)\n"
                         "  ret i64 %val\n"
                         "}");
    add("black_box_f64", "define internal double @black_box_f64(double %val) noinline {\n"
                         "entry:\n"
                         "  call void asm sideeffect \"\", \"r\"(double %val)\n"
                         "  ret double %val\n"
                         "}");

    // --- Format string globals ---
    add(".fmt.int", "@.fmt.int = private constant [4 x i8] c\"%d\\0A\\00\"");
    add(".fmt.int.no_nl", "@.fmt.int.no_nl = private constant [3 x i8] c\"%d\\00\"");
    add(".fmt.i64", "@.fmt.i64 = private constant [5 x i8] c\"%ld\\0A\\00\"");
    add(".fmt.i64.no_nl", "@.fmt.i64.no_nl = private constant [4 x i8] c\"%ld\\00\"");
    add(".fmt.float", "@.fmt.float = private constant [4 x i8] c\"%f\\0A\\00\"");
    add(".fmt.float.no_nl", "@.fmt.float.no_nl = private constant [3 x i8] c\"%f\\00\"");
    add(".fmt.float3", "@.fmt.float3 = private constant [6 x i8] c\"%.3f\\0A\\00\"");
    add(".fmt.float3.no_nl", "@.fmt.float3.no_nl = private constant [5 x i8] c\"%.3f\\00\"");
    add(".fmt.str.no_nl", "@.fmt.str.no_nl = private constant [3 x i8] c\"%s\\00\"");
    add(".str.true", "@.str.true = private constant [5 x i8] c\"true\\00\"");
    add(".str.false", "@.str.false = private constant [6 x i8] c\"false\\00\"");
    add(".str.space", "@.str.space = private constant [2 x i8] c\" \\00\"");
    add(".str.newline", "@.str.newline = private constant [2 x i8] c\"\\0A\\00\"");
}

void LLVMIRGen::require_runtime_decl(const std::string& name) {
    if (needed_runtime_decls_.count(name))
        return; // already marked
    auto it = runtime_catalog_index_.find(name);
    if (it == runtime_catalog_index_.end())
        return; // not a catalog entry
    needed_runtime_decls_.insert(name);
    // Transitively require dependencies
    for (const auto& dep : runtime_catalog_[it->second].deps)
        require_runtime_decl(dep);
}

void LLVMIRGen::scan_for_runtime_refs(const std::string& text) {
    if (runtime_catalog_index_.empty() || needed_runtime_decls_.size() >= runtime_catalog_.size())
        return;
    size_t pos = text.find('@');
    while (pos != std::string::npos) {
        pos++; // skip '@'
        size_t end = pos;
        while (end < text.size() && (std::isalnum(static_cast<unsigned char>(text[end])) ||
                                     text[end] == '_' || text[end] == '.'))
            end++;
        if (end > pos) {
            auto it = runtime_catalog_index_.find(text.substr(pos, end - pos));
            if (it != runtime_catalog_index_.end())
                require_runtime_decl(runtime_catalog_[it->second].name);
        }
        pos = text.find('@', end);
    }
}

void LLVMIRGen::finalize_runtime_decls() {
    // In library_ir_only mode, force ALL declarations (workers may need any of them)
    if (options_.library_ir_only) {
        for (const auto& entry : runtime_catalog_) {
            needed_runtime_decls_.insert(entry.name);
        }
    }

    std::ostringstream decls;
    decls << "; Runtime declarations (on-demand)\n";
    for (const auto& entry : runtime_catalog_) {
        if (needed_runtime_decls_.count(entry.name)) {
            decls << entry.ir_text << "\n";
        }
    }
    decls << "\n";
    deferred_runtime_decls_ = decls.str();
}

// ============================================================================
// emit_runtime_decls â€” emits types + initializes catalog (no function declares)
// ============================================================================

void LLVMIRGen::emit_runtime_decls() {
    // String type: { ptr, i64 } (pointer to data, length)
    emit_line("; Runtime type declarations");
    emit_line("%struct.tml_str = type { ptr, i64 }");

    // Core comparison type (core::cmp)
    // Ordering is a simple enum: Less=0, Equal=1, Greater=2
    emit_line("%struct.Ordering = type { i32 }");
    struct_types_["Ordering"] = "%struct.Ordering";
    struct_fields_["Ordering"] = {{"value", 0, "i32", types::make_i32()}};

    // --- On-demand type declarations (Phase 51) ---
    // Compute which optional categories are needed based on imports.
    // In library_ir_only mode (shared library for test suites), emit everything
    // because the shared lib is linked against multiple workers with varying imports.
    bool needs_sync_atomics = options_.library_ir_only;
    bool needs_logging = options_.library_ir_only;
    bool needs_collections = options_.library_ir_only;
    bool needs_thread = options_.library_ir_only;

    if (!options_.library_ir_only) {
        const auto& imports = env_.all_imports();
        for (const auto& [name, sym] : imports) {
            const auto& path = sym.module_path;
            if (!needs_sync_atomics &&
                (path.find("std::sync") == 0 || path.find("std::thread") == 0 ||
                 path.find("core::sync") == 0))
                needs_sync_atomics = true;
            if (!needs_logging && path.find("std::log") == 0)
                needs_logging = true;
            if (!needs_collections && path.find("std::collections") == 0)
                needs_collections = true;
            if (!needs_thread && path.find("std::thread") == 0)
                needs_thread = true;
        }
    }

    // Deferred type declarations (depend on import scan results)
    if (needs_collections) {
        emit_line("%struct.HashMapIter = type { ptr }");
        struct_types_["HashMapIter"] = "%struct.HashMapIter";
        struct_fields_["HashMapIter"] = {{"handle", 0, "ptr", types::make_ptr(types::make_unit())}};
    }
    if (needs_thread || needs_sync_atomics) {
        emit_line("%struct.RawThread = type { i64 }");
        struct_types_["RawThread"] = "%struct.RawThread";
        struct_fields_["RawThread"] = {
            {"_handle", 0, "i64", types::make_primitive(types::PrimitiveKind::U64)}};
        emit_line("%struct.RawPtr = type { i64 }");
        struct_types_["RawPtr"] = "%struct.RawPtr";
        struct_fields_["RawPtr"] = {{"addr", 0, "i64", types::make_i64()}};
    }
    emit_line("");

    // Initialize the runtime declaration catalog
    init_runtime_catalog();

    // Force-require conditional categories based on imports
    if (options_.coverage_enabled) {
        require_runtime_decl("tml_cover_func");
        require_runtime_decl("print_coverage_report");
        require_runtime_decl("write_coverage_json");
        require_runtime_decl("write_coverage_html");
        declared_externals_.insert("tml_cover_func");
        declared_externals_.insert("print_coverage_report");
        declared_externals_.insert("write_coverage_json");
        declared_externals_.insert("write_coverage_html");
    }

    if (options_.emit_debug_info) {
        require_runtime_decl("llvm.dbg.declare");
        require_runtime_decl("llvm.dbg.value");
    }

    if (options_.llvm_source_coverage) {
        require_runtime_decl("llvm.instrprof.increment");
    }

    if (needs_sync_atomics) {
        require_runtime_decl("atomic_fetch_add_i32");
        require_runtime_decl("atomic_fetch_sub_i32");
        require_runtime_decl("atomic_load_i32");
        require_runtime_decl("atomic_store_i32");
        require_runtime_decl("atomic_compare_exchange_i32");
        require_runtime_decl("atomic_swap_i32");
        require_runtime_decl("atomic_fence");
        require_runtime_decl("atomic_fence_acquire");
        require_runtime_decl("atomic_fence_release");
        declared_externals_.insert("atomic_fetch_add_i32");
        declared_externals_.insert("atomic_fetch_sub_i32");
        declared_externals_.insert("atomic_load_i32");
        declared_externals_.insert("atomic_store_i32");
        declared_externals_.insert("atomic_compare_exchange_i32");
        declared_externals_.insert("atomic_swap_i32");
        declared_externals_.insert("atomic_fence");
        declared_externals_.insert("atomic_fence_acquire");
        declared_externals_.insert("atomic_fence_release");
    }

    if (needs_logging) {
        require_runtime_decl("rt_log_msg");
        require_runtime_decl("rt_log_set_level");
        require_runtime_decl("rt_log_get_level");
        require_runtime_decl("rt_log_enabled");
        require_runtime_decl("rt_log_set_filter");
        require_runtime_decl("rt_log_module_enabled");
        require_runtime_decl("rt_log_structured");
        require_runtime_decl("rt_log_set_format");
        require_runtime_decl("rt_log_get_format");
        require_runtime_decl("rt_log_open_file");
        require_runtime_decl("rt_log_close_file");
        require_runtime_decl("rt_log_init_from_env");
        declared_externals_.insert("rt_log_msg");
        declared_externals_.insert("rt_log_set_level");
        declared_externals_.insert("rt_log_get_level");
        declared_externals_.insert("rt_log_enabled");
        declared_externals_.insert("rt_log_set_filter");
        declared_externals_.insert("rt_log_module_enabled");
        declared_externals_.insert("rt_log_structured");
        declared_externals_.insert("rt_log_set_format");
        declared_externals_.insert("rt_log_get_format");
        declared_externals_.insert("rt_log_open_file");
        declared_externals_.insert("rt_log_close_file");
        declared_externals_.insert("rt_log_init_from_env");

        // Register log functions in functions_ map for lowlevel calls
        functions_["rt_log_msg"] =
            FuncInfo{"@rt_log_msg", "void (i32, ptr, ptr)", "void", {"i32", "ptr", "ptr"}};
        functions_["rt_log_set_level"] =
            FuncInfo{"@rt_log_set_level", "void (i32)", "void", {"i32"}};
        functions_["rt_log_get_level"] = FuncInfo{"@rt_log_get_level", "i32 ()", "i32", {}};
        functions_["rt_log_enabled"] = FuncInfo{"@rt_log_enabled", "i32 (i32)", "i32", {"i32"}};
        functions_["rt_log_set_filter"] =
            FuncInfo{"@rt_log_set_filter", "void (ptr)", "void", {"ptr"}};
        functions_["rt_log_module_enabled"] =
            FuncInfo{"@rt_log_module_enabled", "i32 (i32, ptr)", "i32", {"i32", "ptr"}};
        functions_["rt_log_structured"] = FuncInfo{"@rt_log_structured",
                                                   "void (i32, ptr, ptr, ptr)",
                                                   "void",
                                                   {"i32", "ptr", "ptr", "ptr"}};
        functions_["rt_log_set_format"] =
            FuncInfo{"@rt_log_set_format", "void (i32)", "void", {"i32"}};
        functions_["rt_log_get_format"] = FuncInfo{"@rt_log_get_format", "i32 ()", "i32", {}};
        functions_["rt_log_open_file"] = FuncInfo{"@rt_log_open_file", "i32 (ptr)", "i32", {"ptr"}};
        functions_["rt_log_close_file"] = FuncInfo{"@rt_log_close_file", "void ()", "void", {}};
        functions_["rt_log_init_from_env"] = FuncInfo{"@rt_log_init_from_env", "i32 ()", "i32", {}};
    }

    // Register functions_ map entries for lowlevel calls (lightweight, no IR emitted)
    functions_["random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};
    functions_["tml_random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};
    functions_["print_str"] = FuncInfo{"@print", "void (ptr)", "void", {"ptr"}};
    functions_["println_str"] = FuncInfo{"@println", "void (ptr)", "void", {"ptr"}};
    functions_["f64_to_string"] = FuncInfo{"@f64_to_string", "ptr (double)", "ptr", {"double"}};
    functions_["f32_to_string"] = FuncInfo{"@f32_to_string", "ptr (float)", "ptr", {"float"}};
    functions_["f64_to_string_precision"] =
        FuncInfo{"@f64_to_string_precision", "ptr (double, i64)", "ptr", {"double", "i64"}};
    functions_["f32_to_string_precision"] =
        FuncInfo{"@f32_to_string_precision", "ptr (float, i64)", "ptr", {"float", "i64"}};
    functions_["f64_to_exp_string"] =
        FuncInfo{"@f64_to_exp_string", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["f32_to_exp_string"] =
        FuncInfo{"@f32_to_exp_string", "ptr (float, i32)", "ptr", {"float", "i32"}};

    // Placeholder for deferred declarations (will be replaced in generate())
    emit_line("; {{RUNTIME_DECLS_PLACEHOLDER}}");
    emit_line("");
}

// emit_module_lowlevel_decls, emit_module_pure_tml_functions, and
// emit_string_constants are in runtime_modules.cpp

} // namespace tml::codegen
