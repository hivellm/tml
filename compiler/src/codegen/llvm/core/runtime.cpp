//! # LLVM IR Generator - Runtime Declarations
//!
//! This file emits runtime declarations and module imports.
//!
//! ## Emitted Sections
//!
//! | Method                         | Emits                         |
//! |--------------------------------|-------------------------------|
//! | `emit_header`                  | Target triple, comments       |
//! | `emit_runtime_decls`           | Struct types, C functions     |
//! | `emit_module_lowlevel_decls`   | FFI function declarations     |
//! | `emit_module_pure_tml_functions`| Imported TML functions       |
//! | `emit_string_constants`        | Global string literals        |
//!
//! ## Runtime Types
//!
//! | Type            | Layout              | Purpose             |
//! |-----------------|---------------------|---------------------|
//! | `%struct.tml_str` | `{ ptr, i64 }`    | String slice        |
//! | `%struct.File`  | `{ ptr }`           | File handle         |
//! | `%struct.Path`  | `{ ptr }`           | Path string         |
//! | `%struct.Ordering` | `{ i32 }`        | Comparison result   |
//!
//! ## External Functions
//!
//! Declares C standard library functions: printf, puts, malloc, free, exit.

#include "codegen/llvm/llvm_ir_gen.hpp"
#include "lexer/lexer.hpp"
#include "lexer/source.hpp"
#include "parser/parser.hpp"

#include <filesystem>
#include <unordered_set>

namespace tml::codegen {

// Helper: Get the LLVM type string for a constant's declared type
static std::string get_const_llvm_type(const parser::TypePtr& type) {
    if (!type)
        return "i64"; // Default fallback

    if (type->is<parser::NamedType>()) {
        const auto& named = type->as<parser::NamedType>();
        if (!named.path.segments.empty()) {
            const std::string& name = named.path.segments.back();
            // Map TML primitive types to LLVM types
            if (name == "I8" || name == "U8")
                return "i8";
            if (name == "I16" || name == "U16")
                return "i16";
            if (name == "I32" || name == "U32")
                return "i32";
            if (name == "I64" || name == "U64")
                return "i64";
            if (name == "I128" || name == "U128")
                return "i128";
            if (name == "Bool")
                return "i1";
            if (name == "Isize" || name == "Usize")
                return "i64";
        }
    }
    return "i64"; // Default for unknown types
}

void LLVMIRGen::emit_header() {
    emit_line("; Generated by TML Compiler");
    emit_line("target triple = \"" + options_.target_triple + "\"");
    emit_line("");
}

void LLVMIRGen::emit_runtime_decls() {
    // String type: { ptr, i64 } (pointer to data, length)
    emit_line("; Runtime type declarations");
    emit_line("%struct.tml_str = type { ptr, i64 }");

    // File I/O types (from std::file)
    emit_line("%struct.File = type { ptr }"); // handle field
    emit_line("%struct.Path = type { ptr }"); // path string field

    // Core comparison type (core::cmp)
    // Ordering is a simple enum: Less=0, Equal=1, Greater=2
    emit_line("%struct.Ordering = type { i32 }");

    // HashMapIter type for iterating over HashMap entries
    emit_line("%struct.HashMapIter = type { ptr }");

    // Buffer type (from std::collections)
    emit_line("%struct.Buffer = type { ptr }"); // handle field

    // Register Buffer fields for field access codegen
    struct_types_["Buffer"] = "%struct.Buffer";
    struct_fields_["Buffer"] = {{"handle", 0, "ptr", types::make_ptr(types::make_unit())}};

    // Thread types (from std::thread) - needed for @extern function declarations
    emit_line("%struct.RawThread = type { i64 }"); // _handle: U64
    struct_types_["RawThread"] = "%struct.RawThread";
    struct_fields_["RawThread"] = {
        {"_handle", 0, "i64", types::make_primitive(types::PrimitiveKind::U64)}};
    emit_line("%struct.RawPtr = type { i64 }"); // addr: I64
    struct_types_["RawPtr"] = "%struct.RawPtr";
    struct_fields_["RawPtr"] = {{"addr", 0, "i64", types::make_i64()}};
    emit_line("");

    // External C functions
    emit_line("; External function declarations");
    emit_line("declare i32 @printf(ptr, ...)");
    emit_line("declare i32 @puts(ptr)");
    emit_line("declare i32 @putchar(i32)");
    emit_line("declare ptr @malloc(i64)");
    emit_line("declare void @free(ptr)");
    emit_line("declare void @exit(i32) noreturn");
    emit_line("declare i64 @strlen(ptr)");
    emit_line("");

    // LLVM intrinsics for optimized codegen
    emit_line("; LLVM intrinsics");
    emit_line("declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)");
    emit_line("declare void @llvm.assume(i1) nounwind");
    emit_line("");

    // TML runtime functions
    emit_line("; TML runtime functions");
    emit_line("declare void @panic(ptr) noreturn");
    emit_line("declare void @assert_tml_loc(i32, ptr, ptr, i32) noreturn");
    emit_line("");

    // Panic catching for @should_panic tests
    // Uses a callback approach: pass function pointer to tml_run_should_panic()
    emit_line("; Panic catching (for @should_panic tests)");
    emit_line("declare i32 @tml_run_should_panic(ptr)");
    emit_line("declare ptr @tml_get_panic_message()");
    emit_line("declare i32 @tml_panic_message_contains(ptr)");
    emit_line("");

    // Backtrace support (--backtrace flag enables printing stack trace on panic)
    emit_line("; Backtrace support");
    emit_line("declare void @tml_enable_backtrace_on_panic()");
    emit_line("");

    // Note: TML test assertions are now provided by the test module's TML code
    // They call panic() internally and don't need external declarations
    emit_line("");

    // TML code coverage functions (only when coverage is enabled)
    if (options_.coverage_enabled) {
        emit_line("; TML code coverage");
        emit_line("declare void @tml_cover_func(ptr)");
        emit_line("declare void @print_coverage_report()");
        emit_line("declare void @write_coverage_json(ptr)");
        emit_line("declare void @write_coverage_html(ptr)");
        emit_line("");
    }

    // Debug intrinsics (for DWARF debug info)
    if (options_.emit_debug_info) {
        emit_line("; Debug intrinsics");
        emit_line("declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone");
        emit_line("declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone");
        emit_line("");
    }

    // LLVM instrumentation profile intrinsic (for source-based coverage)
    if (options_.llvm_source_coverage) {
        emit_line("; LLVM instrumentation profile intrinsics (source-based coverage)");
        emit_line("declare void @llvm.instrprof.increment(ptr, i64, i32, i32) #1");
        emit_line("");
    }

    // Stack save/restore intrinsics (for loop alloca cleanup)
    emit_line("; Stack management intrinsics");
    emit_line("declare ptr @llvm.stacksave() nounwind");
    emit_line("declare void @llvm.stackrestore(ptr) nounwind");
    emit_line("");

    // Lifetime intrinsics (for stack slot optimization)
    emit_line("; Lifetime intrinsics for stack optimization");
    emit_line("declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("");

    // Threading runtime declarations
    emit_line("; Threading runtime (tml_runtime.c)");
    emit_line("declare ptr @thread_spawn(ptr, ptr)");
    emit_line("declare void @thread_join(ptr)");
    emit_line("declare void @thread_yield()");
    emit_line("declare void @thread_sleep(i32)");
    emit_line("declare i32 @thread_id()");
    emit_line("");

    // I/O functions - all check output suppression flag
    emit_line("; I/O functions (check output suppression)");
    emit_line("declare void @print(ptr)");
    emit_line("declare void @println(ptr)");
    emit_line("declare void @print_i32(i32)");
    emit_line("declare void @print_i64(i64)");
    emit_line("declare void @print_f32(float)");
    emit_line("declare void @print_f64(double)");
    emit_line("declare void @print_bool(i32)");
    emit_line("declare void @print_char(i32)");
    emit_line("");

    // NOTE: Math functions moved to core::math module
    // Import with: use core::math

    // NOTE: Assertion functions moved to test module
    // Import with: use test
    emit_line("; Black box (prevent optimization)");
    emit_line("declare i32 @black_box_i32(i32)");
    emit_line("declare i64 @black_box_i64(i64)");
    emit_line("declare double @black_box_f64(double)");
    emit_line("; SIMD operations (auto-vectorized)");
    emit_line("declare i64 @simd_sum_i32(ptr, i64)");
    emit_line("declare i64 @simd_sum_i64(ptr, i64)");
    emit_line("declare double @simd_sum_f64(ptr, i64)");
    emit_line("declare double @simd_dot_f64(ptr, ptr, i64)");
    emit_line("declare void @simd_fill_i32(ptr, i32, i64)");
    emit_line("declare void @simd_add_i32(ptr, ptr, ptr, i64)");
    emit_line("declare void @simd_mul_i32(ptr, ptr, ptr, i64)");
    emit_line("");

    // Float functions
    emit_line("; Float functions");
    emit_line("declare ptr @float_to_fixed(double, i32)");
    emit_line("declare ptr @float_to_precision(double, i32)");
    emit_line("declare ptr @float_to_string(double)");
    emit_line("declare ptr @f64_to_string(double)"); // F64.to_string() method
    emit_line("declare ptr @f32_to_string(float)");  // F32.to_string() method
    emit_line("declare ptr @float_to_exp(double, i32)");
    emit_line("declare ptr @f64_to_string_precision(double, i64)");
    emit_line("declare ptr @f32_to_string_precision(float, i64)");
    emit_line("declare ptr @f64_to_exp_string(double, i32)");
    emit_line("declare ptr @f32_to_exp_string(float, i32)");
    emit_line("declare i32 @f64_is_nan(double)");
    emit_line("declare i32 @f64_is_infinite(double)");
    emit_line("declare i32 @f32_is_nan(float)");
    emit_line("declare i32 @f32_is_infinite(float)");
    emit_line("declare double @int_to_float(i32)");
    emit_line("declare double @i64_to_float(i64)");
    emit_line("declare i32 @float_to_int(double)");
    emit_line("declare i64 @float_to_i64(double)");
    emit_line("declare i32 @float_round(double)");
    emit_line("declare i32 @float_floor(double)");
    emit_line("declare i32 @float_ceil(double)");
    emit_line("declare double @float_abs(double)");
    emit_line("declare double @float_sqrt(double)");
    emit_line("declare double @float_pow(double, i32)");
    emit_line("");

    // Integer to string conversion
    emit_line("; Integer to string");
    emit_line("declare ptr @i32_to_string(i32)");
    emit_line("declare ptr @i64_to_string(i64)");
    emit_line("declare ptr @bool_to_string(i1)");
    emit_line("");

    // Integer formatting (binary, octal, hex)
    emit_line("; Integer formatting");
    emit_line("declare ptr @i64_to_binary_str(i64)");
    emit_line("declare ptr @i64_to_octal_str(i64)");
    emit_line("declare ptr @i64_to_lower_hex_str(i64)");
    emit_line("declare ptr @i64_to_upper_hex_str(i64)");
    emit_line("");

    // Overloaded abs functions
    emit_line("; Overloaded abs");
    emit_line("declare i32 @abs_i32(i32)");
    emit_line("declare double @abs_f64(double)");
    emit_line("");

    // Bit manipulation runtime declarations
    emit_line("; Bit manipulation runtime");
    emit_line("declare i32 @float32_bits(float)");
    emit_line("declare float @float32_from_bits(i32)");
    emit_line("declare i64 @float64_bits(double)");
    emit_line("declare double @float64_from_bits(i64)");
    emit_line("");

    // Special float value runtime declarations
    emit_line("; Special float values runtime");
    emit_line("declare double @infinity(i32)");
    emit_line("declare double @nan()");
    emit_line("declare i32 @is_inf(double, i32)");
    emit_line("declare i32 @is_nan(double)");
    emit_line("");

    // Nextafter runtime declarations
    emit_line("; Nextafter runtime");
    emit_line("declare double @nextafter(double, double)");
    emit_line("declare float @nextafter32(float, float)");
    emit_line("");

    // Channel runtime declarations
    emit_line("; Channel runtime (Go-style)");
    emit_line("declare ptr @channel_create()");
    emit_line("declare i32 @channel_send(ptr, i32)");
    emit_line("declare i32 @channel_recv(ptr, ptr)");
    emit_line("declare i32 @channel_try_send(ptr, i32)");
    emit_line("declare i32 @channel_try_recv(ptr, ptr)");
    emit_line("declare void @channel_close(ptr)");
    emit_line("declare void @channel_destroy(ptr)");
    emit_line("declare i32 @channel_len(ptr)");
    emit_line("");

    // Mutex runtime declarations
    emit_line("; Mutex runtime");
    emit_line("declare ptr @mutex_create()");
    emit_line("declare void @mutex_lock(ptr)");
    emit_line("declare void @mutex_unlock(ptr)");
    emit_line("declare i32 @mutex_try_lock(ptr)");
    emit_line("declare void @mutex_destroy(ptr)");
    emit_line("");

    // WaitGroup runtime declarations
    emit_line("; WaitGroup runtime (Go-style)");
    emit_line("declare ptr @waitgroup_create()");
    emit_line("declare void @waitgroup_add(ptr, i32)");
    emit_line("declare void @waitgroup_done(ptr)");
    emit_line("declare void @waitgroup_wait(ptr)");
    emit_line("declare void @waitgroup_destroy(ptr)");
    emit_line("");

    // Atomic counter runtime declarations
    emit_line("; Atomic counter runtime");
    emit_line("declare ptr @atomic_counter_create(i32)");
    emit_line("declare i32 @atomic_counter_inc(ptr)");
    emit_line("declare i32 @atomic_counter_dec(ptr)");
    emit_line("declare i32 @atomic_counter_get(ptr)");
    emit_line("declare void @atomic_counter_set(ptr, i32)");
    emit_line("declare void @atomic_counter_destroy(ptr)");
    emit_line("");

    // Typed atomic operations runtime (also declared in sync.tml with @extern)
    // We declare them here AND register in declared_externals_ so that:
    // 1. Tests using atomics directly work without importing sync.tml
    // 2. When sync.tml is imported, its @extern won't cause redefinition errors
    emit_line("; Typed atomic operations runtime");
    emit_line("declare i32 @atomic_fetch_add_i32(ptr, i32)");
    declared_externals_.insert("atomic_fetch_add_i32");
    emit_line("declare i32 @atomic_fetch_sub_i32(ptr, i32)");
    declared_externals_.insert("atomic_fetch_sub_i32");
    emit_line("declare i32 @atomic_load_i32(ptr)");
    declared_externals_.insert("atomic_load_i32");
    emit_line("declare void @atomic_store_i32(ptr, i32)");
    declared_externals_.insert("atomic_store_i32");
    emit_line("declare i32 @atomic_compare_exchange_i32(ptr, i32, i32)");
    declared_externals_.insert("atomic_compare_exchange_i32");
    emit_line("declare i32 @atomic_swap_i32(ptr, i32)");
    declared_externals_.insert("atomic_swap_i32");
    emit_line("declare void @atomic_fence()");
    declared_externals_.insert("atomic_fence");
    emit_line("declare void @atomic_fence_acquire()");
    declared_externals_.insert("atomic_fence_acquire");
    emit_line("declare void @atomic_fence_release()");
    declared_externals_.insert("atomic_fence_release");
    emit_line("");

    // List runtime declarations
    // Register in declared_externals_ to prevent duplicate declarations from @extern modules
    emit_line("; List (dynamic array) runtime");
    emit_line("declare ptr @list_create(i64)");
    declared_externals_.insert("list_create");
    emit_line("declare void @list_destroy(ptr)");
    declared_externals_.insert("list_destroy");
    emit_line("declare void @list_push(ptr, i64)");
    declared_externals_.insert("list_push");
    emit_line("declare i64 @list_pop(ptr)");
    declared_externals_.insert("list_pop");
    emit_line("declare i64 @list_get(ptr, i64)");
    declared_externals_.insert("list_get");
    emit_line("declare void @list_set(ptr, i64, i64)");
    declared_externals_.insert("list_set");
    emit_line("declare i64 @list_len(ptr)");
    declared_externals_.insert("list_len");
    emit_line("declare i64 @list_capacity(ptr)");
    declared_externals_.insert("list_capacity");
    emit_line("declare void @list_clear(ptr)");
    declared_externals_.insert("list_clear");
    emit_line("declare i32 @list_is_empty(ptr)");
    declared_externals_.insert("list_is_empty");
    emit_line("declare void @list_remove(ptr, i64)");
    declared_externals_.insert("list_remove");
    emit_line("declare i64 @list_first(ptr)");
    declared_externals_.insert("list_first");
    emit_line("declare i64 @list_last(ptr)");
    declared_externals_.insert("list_last");
    emit_line("");

    // HashMap runtime declarations
    // Register in declared_externals_ to prevent duplicate declarations from @extern modules
    emit_line("; HashMap runtime");
    emit_line("declare ptr @hashmap_create(i64)");
    declared_externals_.insert("hashmap_create");
    emit_line("declare void @hashmap_destroy(ptr)");
    declared_externals_.insert("hashmap_destroy");
    emit_line("declare void @hashmap_set(ptr, i64, i64)");
    declared_externals_.insert("hashmap_set");
    emit_line("declare i64 @hashmap_get(ptr, i64)");
    declared_externals_.insert("hashmap_get");
    emit_line("declare i32 @hashmap_has(ptr, i64)");
    declared_externals_.insert("hashmap_has");
    emit_line("declare i32 @hashmap_remove(ptr, i64)");
    declared_externals_.insert("hashmap_remove");
    emit_line("declare i64 @hashmap_len(ptr)");
    declared_externals_.insert("hashmap_len");
    emit_line("declare void @hashmap_clear(ptr)");
    declared_externals_.insert("hashmap_clear");
    emit_line("declare ptr @hashmap_iter_create(ptr)");
    declared_externals_.insert("hashmap_iter_create");
    emit_line("declare void @hashmap_iter_destroy(ptr)");
    declared_externals_.insert("hashmap_iter_destroy");
    emit_line("declare i32 @hashmap_iter_has_next(ptr)");
    declared_externals_.insert("hashmap_iter_has_next");
    emit_line("declare i64 @hashmap_iter_key(ptr)");
    declared_externals_.insert("hashmap_iter_key");
    emit_line("declare i64 @hashmap_iter_value(ptr)");
    declared_externals_.insert("hashmap_iter_value");
    emit_line("declare void @hashmap_iter_next(ptr)");
    declared_externals_.insert("hashmap_iter_next");
    emit_line("");

    // Buffer runtime declarations
    // Register in declared_externals_ to prevent duplicate declarations from @extern modules
    emit_line("; Buffer runtime");
    emit_line("declare ptr @buffer_create(i64)");
    declared_externals_.insert("buffer_create");
    emit_line("declare void @buffer_destroy(ptr)");
    declared_externals_.insert("buffer_destroy");
    emit_line("declare void @buffer_write_byte(ptr, i32)");
    declared_externals_.insert("buffer_write_byte");
    emit_line("declare void @buffer_write_i32(ptr, i32)");
    declared_externals_.insert("buffer_write_i32");
    emit_line("declare void @buffer_write_i64(ptr, i64)");
    declared_externals_.insert("buffer_write_i64");
    emit_line("declare i32 @buffer_read_byte(ptr)");
    declared_externals_.insert("buffer_read_byte");
    emit_line("declare i32 @buffer_read_i32(ptr)");
    declared_externals_.insert("buffer_read_i32");
    emit_line("declare i64 @buffer_read_i64(ptr)");
    declared_externals_.insert("buffer_read_i64");
    emit_line("declare i64 @buffer_len(ptr)");
    declared_externals_.insert("buffer_len");
    emit_line("declare i64 @buffer_capacity(ptr)");
    declared_externals_.insert("buffer_capacity");
    emit_line("declare i64 @buffer_remaining(ptr)");
    declared_externals_.insert("buffer_remaining");
    emit_line("declare void @buffer_clear(ptr)");
    declared_externals_.insert("buffer_clear");
    emit_line("declare void @buffer_reset_read(ptr)");
    declared_externals_.insert("buffer_reset_read");
    emit_line("");

    // File I/O runtime declarations
    // Register in declared_externals_ to prevent duplicate declarations from @extern modules
    emit_line("; File I/O runtime");
    emit_line("declare ptr @file_open_read(ptr)");
    declared_externals_.insert("file_open_read");
    emit_line("declare ptr @file_open_write(ptr)");
    declared_externals_.insert("file_open_write");
    emit_line("declare ptr @file_open_append(ptr)");
    declared_externals_.insert("file_open_append");
    emit_line("declare void @file_close(ptr)");
    declared_externals_.insert("file_close");
    emit_line("declare i1 @file_is_open(ptr)");
    declared_externals_.insert("file_is_open");
    emit_line("declare ptr @file_read_line(ptr)");
    declared_externals_.insert("file_read_line");
    emit_line("declare i1 @file_write_str(ptr, ptr)");
    declared_externals_.insert("file_write_str");
    emit_line("declare i64 @file_size(ptr)");
    declared_externals_.insert("file_size");
    emit_line("declare ptr @file_read_all(ptr)");
    declared_externals_.insert("file_read_all");
    emit_line("declare i1 @file_write_all(ptr, ptr)");
    declared_externals_.insert("file_write_all");
    emit_line("declare i1 @file_append_all(ptr, ptr)");
    declared_externals_.insert("file_append_all");
    emit_line("");

    // Register file I/O functions in functions_ map for lowlevel calls from module functions
    functions_["file_open_read"] = FuncInfo{"@file_open_read", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["file_open_write"] = FuncInfo{"@file_open_write", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["file_open_append"] = FuncInfo{"@file_open_append", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["file_close"] = FuncInfo{"@file_close", "void (ptr)", "void", {"ptr"}};
    functions_["file_is_open"] = FuncInfo{"@file_is_open", "i1 (ptr)", "i1", {"ptr"}};
    functions_["file_read_line"] = FuncInfo{"@file_read_line", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["file_write_str"] =
        FuncInfo{"@file_write_str", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    functions_["file_size"] = FuncInfo{"@file_size", "i64 (ptr)", "i64", {"ptr"}};
    functions_["file_read_all"] = FuncInfo{"@file_read_all", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["file_write_all"] =
        FuncInfo{"@file_write_all", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    functions_["file_append_all"] =
        FuncInfo{"@file_append_all", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};

    // Log runtime declarations (matches runtime/log.c)
    emit_line("; Log runtime");
    emit_line("declare void @rt_log_msg(i32, ptr, ptr)");
    declared_externals_.insert("rt_log_msg");
    emit_line("declare void @rt_log_set_level(i32)");
    declared_externals_.insert("rt_log_set_level");
    emit_line("declare i32 @rt_log_get_level()");
    declared_externals_.insert("rt_log_get_level");
    emit_line("declare i32 @rt_log_enabled(i32)");
    declared_externals_.insert("rt_log_enabled");
    emit_line("");

    // Phase 4.4: Advanced log runtime declarations
    emit_line("declare void @rt_log_set_filter(ptr)");
    declared_externals_.insert("rt_log_set_filter");
    emit_line("declare i32 @rt_log_module_enabled(i32, ptr)");
    declared_externals_.insert("rt_log_module_enabled");
    emit_line("declare void @rt_log_structured(i32, ptr, ptr, ptr)");
    declared_externals_.insert("rt_log_structured");
    emit_line("declare void @rt_log_set_format(i32)");
    declared_externals_.insert("rt_log_set_format");
    emit_line("declare i32 @rt_log_get_format()");
    declared_externals_.insert("rt_log_get_format");
    emit_line("declare i32 @rt_log_open_file(ptr)");
    declared_externals_.insert("rt_log_open_file");
    emit_line("declare void @rt_log_close_file()");
    declared_externals_.insert("rt_log_close_file");
    emit_line("declare i32 @rt_log_init_from_env()");
    declared_externals_.insert("rt_log_init_from_env");
    emit_line("");

    // Register log functions in functions_ map for lowlevel calls
    functions_["rt_log_msg"] =
        FuncInfo{"@rt_log_msg", "void (i32, ptr, ptr)", "void", {"i32", "ptr", "ptr"}};
    functions_["rt_log_set_level"] = FuncInfo{"@rt_log_set_level", "void (i32)", "void", {"i32"}};
    functions_["rt_log_get_level"] = FuncInfo{"@rt_log_get_level", "i32 ()", "i32", {}};
    functions_["rt_log_enabled"] = FuncInfo{"@rt_log_enabled", "i32 (i32)", "i32", {"i32"}};
    // Phase 4.4 function registrations
    functions_["rt_log_set_filter"] = FuncInfo{"@rt_log_set_filter", "void (ptr)", "void", {"ptr"}};
    functions_["rt_log_module_enabled"] =
        FuncInfo{"@rt_log_module_enabled", "i32 (i32, ptr)", "i32", {"i32", "ptr"}};
    functions_["rt_log_structured"] = FuncInfo{
        "@rt_log_structured", "void (i32, ptr, ptr, ptr)", "void", {"i32", "ptr", "ptr", "ptr"}};
    functions_["rt_log_set_format"] = FuncInfo{"@rt_log_set_format", "void (i32)", "void", {"i32"}};
    functions_["rt_log_get_format"] = FuncInfo{"@rt_log_get_format", "i32 ()", "i32", {}};
    functions_["rt_log_open_file"] = FuncInfo{"@rt_log_open_file", "i32 (ptr)", "i32", {"ptr"}};
    functions_["rt_log_close_file"] = FuncInfo{"@rt_log_close_file", "void ()", "void", {}};
    functions_["rt_log_init_from_env"] = FuncInfo{"@rt_log_init_from_env", "i32 ()", "i32", {}};

    // Path utilities runtime declarations
    // Register in declared_externals_ to prevent duplicate declarations from @extern modules
    emit_line("; Path utilities runtime");
    emit_line("declare i1 @path_exists(ptr)");
    declared_externals_.insert("path_exists");
    emit_line("declare i1 @path_is_file(ptr)");
    declared_externals_.insert("path_is_file");
    emit_line("declare i1 @path_is_dir(ptr)");
    declared_externals_.insert("path_is_dir");
    emit_line("declare i1 @path_create_dir(ptr)");
    declared_externals_.insert("path_create_dir");
    emit_line("declare i1 @path_create_dir_all(ptr)");
    declared_externals_.insert("path_create_dir_all");
    emit_line("declare i1 @path_remove(ptr)");
    declared_externals_.insert("path_remove");
    emit_line("declare i1 @path_remove_dir(ptr)");
    declared_externals_.insert("path_remove_dir");
    emit_line("declare i1 @path_rename(ptr, ptr)");
    declared_externals_.insert("path_rename");
    emit_line("declare i1 @path_copy(ptr, ptr)");
    declared_externals_.insert("path_copy");
    emit_line("declare ptr @path_join(ptr, ptr)");
    declared_externals_.insert("path_join");
    emit_line("declare ptr @path_parent(ptr)");
    declared_externals_.insert("path_parent");
    emit_line("declare ptr @path_filename(ptr)");
    declared_externals_.insert("path_filename");
    emit_line("declare ptr @path_extension(ptr)");
    declared_externals_.insert("path_extension");
    emit_line("declare ptr @path_absolute(ptr)");
    declared_externals_.insert("path_absolute");

    // Register path functions in functions_ map for lowlevel calls from module functions
    // (e.g., Dir::create calls lowlevel { path_create_dir(path) })
    functions_["path_exists"] = FuncInfo{"@path_exists", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_is_file"] = FuncInfo{"@path_is_file", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_is_dir"] = FuncInfo{"@path_is_dir", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_create_dir"] = FuncInfo{"@path_create_dir", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_create_dir_all"] = FuncInfo{"@path_create_dir_all", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_remove"] = FuncInfo{"@path_remove", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_remove_dir"] = FuncInfo{"@path_remove_dir", "i1 (ptr)", "i1", {"ptr"}};
    functions_["path_rename"] = FuncInfo{"@path_rename", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    functions_["path_copy"] = FuncInfo{"@path_copy", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    functions_["path_join"] = FuncInfo{"@path_join", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["path_parent"] = FuncInfo{"@path_parent", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["path_filename"] = FuncInfo{"@path_filename", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["path_extension"] = FuncInfo{"@path_extension", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["path_absolute"] = FuncInfo{"@path_absolute", "ptr (ptr)", "ptr", {"ptr"}};
    emit_line("");

    // Glob runtime declarations
    emit_line("; Glob runtime");
    emit_line("declare ptr @glob_match(ptr, ptr)");
    declared_externals_.insert("glob_match");
    emit_line("declare ptr @glob_result_next(ptr)");
    declared_externals_.insert("glob_result_next");
    emit_line("declare i64 @glob_result_count(ptr)");
    declared_externals_.insert("glob_result_count");
    emit_line("declare void @glob_result_free(ptr)");
    declared_externals_.insert("glob_result_free");
    emit_line("declare i1 @glob_pattern_matches(ptr, ptr)");
    declared_externals_.insert("glob_pattern_matches");

    functions_["glob_match"] = FuncInfo{"@glob_match", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["glob_result_next"] = FuncInfo{"@glob_result_next", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["glob_result_count"] = FuncInfo{"@glob_result_count", "i64 (ptr)", "i64", {"ptr"}};
    functions_["glob_result_free"] = FuncInfo{"@glob_result_free", "void (ptr)", "void", {"ptr"}};
    functions_["glob_pattern_matches"] =
        FuncInfo{"@glob_pattern_matches", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    emit_line("");

    // String utilities (matches runtime/string.c)
    emit_line("; String utilities");
    emit_line("declare i32 @str_len(ptr)");
    emit_line("declare i32 @str_eq(ptr, ptr)");
    emit_line("declare i32 @str_hash(ptr)");
    emit_line("declare ptr @str_concat(ptr, ptr)");
    emit_line("declare ptr @str_concat_opt(ptr, ptr)");         // O(1) amortized
    emit_line("declare ptr @str_concat_3(ptr, ptr, ptr)");      // Fused 3-string concat
    emit_line("declare ptr @str_concat_4(ptr, ptr, ptr, ptr)"); // Fused 4-string concat
    emit_line("declare ptr @str_substring(ptr, i32, i32)");
    emit_line("declare ptr @str_slice(ptr, i64, i64)");
    emit_line("declare i32 @str_contains(ptr, ptr)");
    emit_line("declare i32 @str_starts_with(ptr, ptr)");
    emit_line("declare i32 @str_ends_with(ptr, ptr)");
    emit_line("declare ptr @str_to_upper(ptr)");
    emit_line("declare ptr @str_to_lower(ptr)");
    emit_line("declare ptr @str_trim(ptr)");
    emit_line("declare ptr @str_trim_start(ptr)");
    emit_line("declare ptr @str_trim_end(ptr)");
    emit_line("declare i32 @str_char_at(ptr, i32)");
    emit_line("declare i64 @str_find(ptr, ptr)");
    emit_line("declare i64 @str_rfind(ptr, ptr)");
    emit_line("declare i64 @str_parse_i64(ptr)");
    emit_line("declare ptr @str_replace(ptr, ptr, ptr)");
    emit_line("declare ptr @str_replace_first(ptr, ptr, ptr)");
    emit_line("declare ptr @str_split(ptr, ptr)");
    emit_line("declare ptr @str_split_whitespace(ptr)");
    emit_line("declare ptr @str_lines(ptr)");
    emit_line("declare ptr @str_chars(ptr)");
    emit_line("declare ptr @str_repeat(ptr, i32)");
    emit_line("declare i32 @str_parse_i32(ptr)");
    emit_line("declare double @str_parse_f64(ptr)");
    emit_line("declare ptr @str_join(ptr, ptr)");
    emit_line("declare ptr @str_as_bytes(ptr)");
    emit_line("declare ptr @i64_to_str(i64)");
    emit_line("declare ptr @f64_to_str(double)");
    emit_line("");

    // Char utilities (matches runtime/string.c)
    emit_line("; Char utilities");
    emit_line("declare i32 @char_is_alphabetic(i32)");
    emit_line("declare i32 @char_is_numeric(i32)");
    emit_line("declare i32 @char_is_alphanumeric(i32)");
    emit_line("declare i32 @char_is_whitespace(i32)");
    emit_line("declare i32 @char_is_uppercase(i32)");
    emit_line("declare i32 @char_is_lowercase(i32)");
    emit_line("declare i32 @char_is_ascii(i32)");
    emit_line("declare i32 @char_is_control(i32)");
    emit_line("declare i32 @char_to_uppercase(i32)");
    emit_line("declare i32 @char_to_lowercase(i32)");
    emit_line("declare i32 @char_to_digit(i32, i32)");
    emit_line("declare i32 @char_from_digit(i32, i32)");
    emit_line("declare i32 @char_code(i32)");
    emit_line("declare i32 @char_from_code(i32)");
    emit_line("declare ptr @char_to_string(i8)");
    emit_line("declare ptr @utf8_2byte_to_string(i8, i8)");
    emit_line("declare ptr @utf8_3byte_to_string(i8, i8, i8)");
    emit_line("declare ptr @utf8_4byte_to_string(i8, i8, i8, i8)");
    emit_line("declare i64 @tml_random_seed()");
    emit_line("");

    // Register random_seed in functions_ map for lowlevel calls
    functions_["random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};
    // Also register with tml_ prefix for when called as tml_random_seed()
    functions_["tml_random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};

    // Register UTF-8 encoding functions for lowlevel calls
    functions_["char_to_string"] = FuncInfo{"@char_to_string", "ptr (i8)", "ptr", {"i8"}};
    functions_["utf8_2byte_to_string"] =
        FuncInfo{"@utf8_2byte_to_string", "ptr (i8, i8)", "ptr", {"i8", "i8"}};
    functions_["utf8_3byte_to_string"] =
        FuncInfo{"@utf8_3byte_to_string", "ptr (i8, i8, i8)", "ptr", {"i8", "i8", "i8"}};
    functions_["utf8_4byte_to_string"] =
        FuncInfo{"@utf8_4byte_to_string", "ptr (i8, i8, i8, i8)", "ptr", {"i8", "i8", "i8", "i8"}};

    // Register string runtime functions in functions_ map for lowlevel calls from core::str
    functions_["str_len"] = FuncInfo{"@str_len", "i32 (ptr)", "i32", {"ptr"}};
    functions_["str_eq"] = FuncInfo{"@str_eq", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["str_hash"] = FuncInfo{"@str_hash", "i32 (ptr)", "i32", {"ptr"}};
    functions_["str_concat"] = FuncInfo{"@str_concat", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["str_concat_opt"] =
        FuncInfo{"@str_concat_opt", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["str_concat_3"] =
        FuncInfo{"@str_concat_3", "ptr (ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr"}};
    functions_["str_concat_4"] =
        FuncInfo{"@str_concat_4", "ptr (ptr, ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr", "ptr"}};
    functions_["str_substring"] =
        FuncInfo{"@str_substring", "ptr (ptr, i32, i32)", "ptr", {"ptr", "i32", "i32"}};
    functions_["str_slice"] =
        FuncInfo{"@str_slice", "ptr (ptr, i64, i64)", "ptr", {"ptr", "i64", "i64"}};
    functions_["str_contains"] = FuncInfo{"@str_contains", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["str_starts_with"] =
        FuncInfo{"@str_starts_with", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["str_ends_with"] =
        FuncInfo{"@str_ends_with", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["str_to_upper"] = FuncInfo{"@str_to_upper", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_to_lower"] = FuncInfo{"@str_to_lower", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_trim"] = FuncInfo{"@str_trim", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_trim_start"] = FuncInfo{"@str_trim_start", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_trim_end"] = FuncInfo{"@str_trim_end", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_char_at"] = FuncInfo{"@str_char_at", "i32 (ptr, i32)", "i32", {"ptr", "i32"}};
    functions_["str_find"] = FuncInfo{"@str_find", "i64 (ptr, ptr)", "i64", {"ptr", "ptr"}};
    functions_["str_rfind"] = FuncInfo{"@str_rfind", "i64 (ptr, ptr)", "i64", {"ptr", "ptr"}};
    functions_["str_parse_i64"] = FuncInfo{"@str_parse_i64", "i64 (ptr)", "i64", {"ptr"}};
    functions_["str_replace"] =
        FuncInfo{"@str_replace", "ptr (ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr"}};
    functions_["str_split"] = FuncInfo{"@str_split", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["str_split_whitespace"] =
        FuncInfo{"@str_split_whitespace", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_lines"] = FuncInfo{"@str_lines", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_chars"] = FuncInfo{"@str_chars", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_replace_first"] =
        FuncInfo{"@str_replace_first", "ptr (ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr"}};
    functions_["str_repeat"] = FuncInfo{"@str_repeat", "ptr (ptr, i32)", "ptr", {"ptr", "i32"}};
    functions_["str_parse_i32"] = FuncInfo{"@str_parse_i32", "i32 (ptr)", "i32", {"ptr"}};
    functions_["str_parse_f64"] = FuncInfo{"@str_parse_f64", "double (ptr)", "double", {"ptr"}};
    functions_["str_join"] = FuncInfo{"@str_join", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["str_as_bytes"] = FuncInfo{"@str_as_bytes", "ptr (ptr)", "ptr", {"ptr"}};
    // Also register names used in lowlevel blocks that differ from runtime names
    functions_["str_to_uppercase"] = FuncInfo{"@str_to_upper", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["str_to_lowercase"] = FuncInfo{"@str_to_lower", "ptr (ptr)", "ptr", {"ptr"}};

    // Register float formatting runtime functions for lowlevel calls from core::fmt::float
    functions_["f64_to_string"] = FuncInfo{"@f64_to_string", "ptr (double)", "ptr", {"double"}};
    functions_["f32_to_string"] = FuncInfo{"@f32_to_string", "ptr (float)", "ptr", {"float"}};
    functions_["f64_to_string_precision"] =
        FuncInfo{"@f64_to_string_precision", "ptr (double, i64)", "ptr", {"double", "i64"}};
    functions_["f32_to_string_precision"] =
        FuncInfo{"@f32_to_string_precision", "ptr (float, i64)", "ptr", {"float", "i64"}};
    functions_["f64_to_exp_string"] =
        FuncInfo{"@f64_to_exp_string", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["f32_to_exp_string"] =
        FuncInfo{"@f32_to_exp_string", "ptr (float, i32)", "ptr", {"float", "i32"}};
    functions_["f64_is_nan"] = FuncInfo{"@f64_is_nan", "i32 (double)", "i32", {"double"}};
    functions_["f64_is_infinite"] = FuncInfo{"@f64_is_infinite", "i32 (double)", "i32", {"double"}};
    functions_["f32_is_nan"] = FuncInfo{"@f32_is_nan", "i32 (float)", "i32", {"float"}};
    functions_["f32_is_infinite"] = FuncInfo{"@f32_is_infinite", "i32 (float)", "i32", {"float"}};

    // StringBuilder utilities (matches runtime/string.c)
    emit_line("; StringBuilder utilities");
    emit_line("declare ptr @strbuilder_create(i64)");
    emit_line("declare void @strbuilder_destroy(ptr)");
    emit_line("declare void @strbuilder_push(ptr, i32)");
    emit_line("declare void @strbuilder_push_str(ptr, ptr)");
    emit_line("declare i64 @strbuilder_len(ptr)");
    emit_line("declare i64 @strbuilder_capacity(ptr)");
    emit_line("declare void @strbuilder_clear(ptr)");
    emit_line("declare ptr @strbuilder_to_str(ptr)");
    emit_line("declare ptr @strbuilder_as_str(ptr)");
    emit_line("");

    // Text type runtime (matches runtime/text.c)
    emit_line("; Text type runtime (dynamic strings with SSO)");
    emit_line("declare ptr @tml_text_new()");
    emit_line("declare ptr @tml_text_from_str(ptr)");
    emit_line("declare ptr @tml_text_with_capacity(i64)");
    emit_line("declare ptr @tml_text_clone(ptr)");
    emit_line("declare void @tml_text_drop(ptr)");
    emit_line("declare i64 @tml_text_len(ptr)");
    emit_line("declare i64 @tml_text_capacity(ptr)");
    emit_line("declare i32 @tml_text_is_empty(ptr)");
    emit_line("declare ptr @tml_text_data(ptr)");
    emit_line("declare i32 @tml_text_byte_at(ptr, i64)");
    emit_line("declare void @tml_text_clear(ptr)");
    emit_line("declare ptr @tml_text_data_ptr(ptr)");
    emit_line("declare void @tml_text_set_len(ptr, i64)");
    emit_line("declare void @tml_text_push(ptr, i32)");
    emit_line("declare void @tml_text_push_str(ptr, ptr)");
    emit_line("declare void @tml_text_push_str_len(ptr, ptr, i64)");
    emit_line("declare void @tml_text_push_i64(ptr, i64)");
    emit_line("declare i64 @tml_text_push_i64_unsafe(ptr, i64)");
    emit_line("declare void @tml_text_push_formatted(ptr, ptr, i64, i64, ptr, i64)");
    emit_line("declare void @tml_text_push_log(ptr, ptr, i64, i64, ptr, i64, i64, ptr, i64, i64, "
              "ptr, i64)");
    emit_line("declare void @tml_text_reserve(ptr, i64)");
    emit_line("declare void @tml_text_fill_char(ptr, i32, i64)");
    emit_line("declare void @tml_text_push_path(ptr, ptr, i64, i64, ptr, i64, i64, ptr, i64)");
    emit_line("declare i64 @tml_text_index_of(ptr, ptr)");
    emit_line("declare i64 @tml_text_last_index_of(ptr, ptr)");
    emit_line("declare i32 @tml_text_starts_with(ptr, ptr)");
    emit_line("declare i32 @tml_text_ends_with(ptr, ptr)");
    emit_line("declare i32 @tml_text_contains(ptr, ptr)");
    emit_line("declare ptr @tml_text_to_upper(ptr)");
    emit_line("declare ptr @tml_text_to_lower(ptr)");
    emit_line("declare ptr @tml_text_trim(ptr)");
    emit_line("declare ptr @tml_text_trim_start(ptr)");
    emit_line("declare ptr @tml_text_trim_end(ptr)");
    emit_line("declare ptr @tml_text_substring(ptr, i64, i64)");
    emit_line("declare ptr @tml_text_repeat(ptr, i64)");
    emit_line("declare ptr @tml_text_replace(ptr, ptr, ptr)");
    emit_line("declare ptr @tml_text_replace_all(ptr, ptr, ptr)");
    emit_line("declare ptr @tml_text_reverse(ptr)");
    emit_line("declare ptr @tml_text_pad_start(ptr, i64, i32)");
    emit_line("declare ptr @tml_text_pad_end(ptr, i64, i32)");
    emit_line("declare i32 @tml_text_compare(ptr, ptr)");
    emit_line("declare i32 @tml_text_equals(ptr, ptr)");
    emit_line("declare ptr @tml_text_concat(ptr, ptr)");
    emit_line("declare ptr @tml_text_concat_str(ptr, ptr)");
    emit_line("declare ptr @tml_text_as_cstr(ptr)");
    emit_line("declare ptr @tml_text_from_i64(i64)");
    emit_line("declare ptr @tml_text_from_u64(i64)");
    emit_line("declare ptr @tml_text_from_f64(double, i32)");
    emit_line("declare ptr @tml_text_from_bool(i32)");
    emit_line("declare void @tml_text_print(ptr)");
    emit_line("declare void @tml_text_println(ptr)");
    emit_line("");

    // Register text runtime functions in functions_ map for lowlevel calls
    // Key is function name without tml_ prefix (used in lowlevel blocks)
    functions_["text_new"] = FuncInfo{"@tml_text_new", "ptr ()", "ptr", {}};
    functions_["text_from_str"] = FuncInfo{"@tml_text_from_str", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_with_capacity"] =
        FuncInfo{"@tml_text_with_capacity", "ptr (i64)", "ptr", {"i64"}};
    functions_["text_clone"] = FuncInfo{"@tml_text_clone", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_drop"] = FuncInfo{"@tml_text_drop", "void (ptr)", "void", {"ptr"}};
    functions_["text_len"] = FuncInfo{"@tml_text_len", "i64 (ptr)", "i64", {"ptr"}};
    functions_["text_capacity"] = FuncInfo{"@tml_text_capacity", "i64 (ptr)", "i64", {"ptr"}};
    functions_["text_is_empty"] = FuncInfo{"@tml_text_is_empty", "i32 (ptr)", "i32", {"ptr"}};
    functions_["text_data"] = FuncInfo{"@tml_text_data", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_byte_at"] =
        FuncInfo{"@tml_text_byte_at", "i32 (ptr, i64)", "i32", {"ptr", "i64"}};
    functions_["text_clear"] = FuncInfo{"@tml_text_clear", "void (ptr)", "void", {"ptr"}};
    functions_["text_data_ptr"] = FuncInfo{"@tml_text_data_ptr", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_set_len"] =
        FuncInfo{"@tml_text_set_len", "void (ptr, i64)", "void", {"ptr", "i64"}};
    functions_["text_push"] = FuncInfo{"@tml_text_push", "void (ptr, i32)", "void", {"ptr", "i32"}};
    functions_["text_push_str"] =
        FuncInfo{"@tml_text_push_str", "void (ptr, ptr)", "void", {"ptr", "ptr"}};
    functions_["text_push_str_len"] =
        FuncInfo{"@tml_text_push_str_len", "void (ptr, ptr, i64)", "void", {"ptr", "ptr", "i64"}};
    functions_["text_push_i64"] =
        FuncInfo{"@tml_text_push_i64", "void (ptr, i64)", "void", {"ptr", "i64"}};
    functions_["text_push_formatted"] = FuncInfo{"@tml_text_push_formatted",
                                                 "void (ptr, ptr, i64, i64, ptr, i64)",
                                                 "void",
                                                 {"ptr", "ptr", "i64", "i64", "ptr", "i64"}};
    functions_["text_push_log"] = FuncInfo{
        "@tml_text_push_log",
        "void (ptr, ptr, i64, i64, ptr, i64, i64, ptr, i64, i64, ptr, i64)",
        "void",
        {"ptr", "ptr", "i64", "i64", "ptr", "i64", "i64", "ptr", "i64", "i64", "ptr", "i64"}};
    functions_["text_reserve"] =
        FuncInfo{"@tml_text_reserve", "void (ptr, i64)", "void", {"ptr", "i64"}};
    functions_["text_fill_char"] =
        FuncInfo{"@tml_text_fill_char", "void (ptr, i32, i64)", "void", {"ptr", "i32", "i64"}};
    functions_["text_push_path"] =
        FuncInfo{"@tml_text_push_path",
                 "void (ptr, ptr, i64, i64, ptr, i64, i64, ptr, i64)",
                 "void",
                 {"ptr", "ptr", "i64", "i64", "ptr", "i64", "i64", "ptr", "i64"}};
    functions_["text_index_of"] =
        FuncInfo{"@tml_text_index_of", "i64 (ptr, ptr)", "i64", {"ptr", "ptr"}};
    functions_["text_last_index_of"] =
        FuncInfo{"@tml_text_last_index_of", "i64 (ptr, ptr)", "i64", {"ptr", "ptr"}};
    functions_["text_starts_with"] =
        FuncInfo{"@tml_text_starts_with", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["text_ends_with"] =
        FuncInfo{"@tml_text_ends_with", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["text_contains"] =
        FuncInfo{"@tml_text_contains", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["text_to_upper"] = FuncInfo{"@tml_text_to_upper", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_to_lower"] = FuncInfo{"@tml_text_to_lower", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_trim"] = FuncInfo{"@tml_text_trim", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_trim_start"] = FuncInfo{"@tml_text_trim_start", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_trim_end"] = FuncInfo{"@tml_text_trim_end", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_substring"] =
        FuncInfo{"@tml_text_substring", "ptr (ptr, i64, i64)", "ptr", {"ptr", "i64", "i64"}};
    functions_["text_repeat"] =
        FuncInfo{"@tml_text_repeat", "ptr (ptr, i64)", "ptr", {"ptr", "i64"}};
    functions_["text_replace"] =
        FuncInfo{"@tml_text_replace", "ptr (ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr"}};
    functions_["text_replace_all"] =
        FuncInfo{"@tml_text_replace_all", "ptr (ptr, ptr, ptr)", "ptr", {"ptr", "ptr", "ptr"}};
    functions_["text_reverse"] = FuncInfo{"@tml_text_reverse", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_pad_start"] =
        FuncInfo{"@tml_text_pad_start", "ptr (ptr, i64, i32)", "ptr", {"ptr", "i64", "i32"}};
    functions_["text_pad_end"] =
        FuncInfo{"@tml_text_pad_end", "ptr (ptr, i64, i32)", "ptr", {"ptr", "i64", "i32"}};
    functions_["text_compare"] =
        FuncInfo{"@tml_text_compare", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["text_equals"] =
        FuncInfo{"@tml_text_equals", "i32 (ptr, ptr)", "i32", {"ptr", "ptr"}};
    functions_["text_concat"] =
        FuncInfo{"@tml_text_concat", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["text_concat_str"] =
        FuncInfo{"@tml_text_concat_str", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["text_as_cstr"] = FuncInfo{"@tml_text_as_cstr", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["text_from_i64"] = FuncInfo{"@tml_text_from_i64", "ptr (i64)", "ptr", {"i64"}};
    functions_["text_from_u64"] = FuncInfo{"@tml_text_from_u64", "ptr (i64)", "ptr", {"i64"}};
    functions_["text_from_f64"] =
        FuncInfo{"@tml_text_from_f64", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["text_from_bool"] = FuncInfo{"@tml_text_from_bool", "ptr (i32)", "ptr", {"i32"}};
    functions_["text_print"] = FuncInfo{"@tml_text_print", "void (ptr)", "void", {"ptr"}};
    functions_["text_println"] = FuncInfo{"@tml_text_println", "void (ptr)", "void", {"ptr"}};

    // Time functions (matches runtime/time.c)
    emit_line("; Time functions");
    emit_line("declare i32 @time_ms()");
    emit_line("declare i64 @time_us()");
    emit_line("declare i64 @time_ns()");
    emit_line("declare void @sleep_ms(i32)");
    emit_line("declare void @sleep_us(i64)");
    emit_line("declare i32 @elapsed_ms(i32)");
    emit_line("declare i64 @elapsed_us(i64)");
    emit_line("declare i64 @elapsed_ns(i64)");
    emit_line("");

    // Memory functions (matches runtime/mem.c)
    emit_line("; Memory functions");
    emit_line("declare ptr @mem_alloc(i64)");
    emit_line("declare ptr @mem_alloc_zeroed(i64)");
    emit_line("declare ptr @mem_realloc(ptr, i64)");
    emit_line("declare void @mem_free(ptr)");
    emit_line("declare void @mem_copy(ptr, ptr, i64)");
    emit_line("declare void @mem_move(ptr, ptr, i64)");
    emit_line("declare void @mem_set(ptr, i32, i64)");
    emit_line("declare void @mem_zero(ptr, i64)");
    emit_line("declare i32 @mem_compare(ptr, ptr, i64)");
    emit_line("declare i32 @mem_eq(ptr, ptr, i64)");
    emit_line("");

    // Object pool functions (for @pool classes)
    emit_line("; Object pool functions");
    emit_line("declare ptr @pool_acquire(ptr, i64)");
    emit_line("declare void @pool_release(ptr, ptr)");
    emit_line("declare void @pool_init(ptr, i64, i64)");
    emit_line("declare void @pool_destroy(ptr)");
    emit_line("declare i64 @pool_count(ptr)");
    emit_line("declare i64 @pool_capacity(ptr)");
    emit_line("");

    // Thread-local pool functions (for @pool(thread_local: true) classes)
    emit_line("; Thread-local pool functions");
    emit_line("declare ptr @tls_pool_acquire(ptr, i64)");
    emit_line("declare void @tls_pool_release(ptr, ptr, i64)");
    emit_line("declare void @tls_pools_cleanup()");
    emit_line("declare i32 @tls_pool_stats(ptr, ptr, ptr)");
    emit_line("");

    // Network socket functions (matches runtime/net.c)
    // Track in declared_externals_ to prevent duplicate declarations from lowlevel funcs
    emit_line("; Network socket functions");
    emit_line("declare i64 @sys_socket_raw(i32, i32, i32)");
    declared_externals_.insert("sys_socket_raw");
    emit_line("declare i32 @sys_bind_v4(i64, i32, i16)");
    declared_externals_.insert("sys_bind_v4");
    emit_line("declare i32 @sys_bind_v6(i64, ptr, i16, i32, i32)");
    declared_externals_.insert("sys_bind_v6");
    emit_line("declare i32 @sys_listen_raw(i64, i32)");
    declared_externals_.insert("sys_listen_raw");
    emit_line("declare i64 @sys_accept_v4(i64, ptr, ptr)");
    declared_externals_.insert("sys_accept_v4");
    emit_line("declare i32 @sys_connect_v4(i64, i32, i16)");
    declared_externals_.insert("sys_connect_v4");
    emit_line("declare i32 @sys_connect_v6(i64, ptr, i16, i32, i32)");
    declared_externals_.insert("sys_connect_v6");
    emit_line("declare i64 @sys_send_raw(i64, ptr, i64, i32)");
    declared_externals_.insert("sys_send_raw");
    emit_line("declare i64 @sys_recv_raw(i64, ptr, i64, i32)");
    declared_externals_.insert("sys_recv_raw");
    emit_line("declare i64 @sys_sendto_v4(i64, ptr, i64, i32, i32, i16)");
    declared_externals_.insert("sys_sendto_v4");
    emit_line("declare i64 @sys_recvfrom_v4(i64, ptr, i64, i32, ptr, ptr)");
    declared_externals_.insert("sys_recvfrom_v4");
    emit_line("declare i32 @sys_shutdown_raw(i64, i32)");
    declared_externals_.insert("sys_shutdown_raw");
    emit_line("declare i32 @sys_close_raw(i64)");
    declared_externals_.insert("sys_close_raw");
    emit_line("declare i32 @sys_set_nonblocking_raw(i64, i32)");
    declared_externals_.insert("sys_set_nonblocking_raw");
    emit_line("declare i32 @sys_setsockopt_raw(i64, i32, i32, i32)");
    declared_externals_.insert("sys_setsockopt_raw");
    emit_line("declare i32 @sys_getsockname_v4(i64, ptr, ptr)");
    declared_externals_.insert("sys_getsockname_v4");
    emit_line("declare i32 @sys_getpeername_v4(i64, ptr, ptr)");
    declared_externals_.insert("sys_getpeername_v4");
    emit_line("declare i32 @sys_get_last_error()");
    declared_externals_.insert("sys_get_last_error");
    emit_line("declare i32 @sys_wsa_startup()");
    declared_externals_.insert("sys_wsa_startup");
    emit_line("declare void @sys_wsa_cleanup()");
    declared_externals_.insert("sys_wsa_cleanup");
    emit_line("");

    // TLS/SSL functions (matches runtime/net/tls.c)
    emit_line("; TLS/SSL functions");
    emit_line("declare void @tls_init()");
    declared_externals_.insert("tls_init");
    emit_line("declare ptr @tls_context_client_new()");
    declared_externals_.insert("tls_context_client_new");
    emit_line("declare ptr @tls_context_server_new()");
    declared_externals_.insert("tls_context_server_new");
    emit_line("declare void @tls_context_free(ptr)");
    declared_externals_.insert("tls_context_free");
    emit_line("declare i32 @tls_context_set_certificate(ptr, ptr)");
    declared_externals_.insert("tls_context_set_certificate");
    emit_line("declare i32 @tls_context_set_private_key(ptr, ptr)");
    declared_externals_.insert("tls_context_set_private_key");
    emit_line("declare i32 @tls_context_set_ca(ptr, ptr, ptr)");
    declared_externals_.insert("tls_context_set_ca");
    emit_line("declare void @tls_context_set_verify_mode(ptr, i32)");
    declared_externals_.insert("tls_context_set_verify_mode");
    emit_line("declare i32 @tls_context_set_min_version(ptr, i32)");
    declared_externals_.insert("tls_context_set_min_version");
    emit_line("declare i32 @tls_context_set_max_version(ptr, i32)");
    declared_externals_.insert("tls_context_set_max_version");
    emit_line("declare i32 @tls_context_set_alpn(ptr, ptr, i32)");
    declared_externals_.insert("tls_context_set_alpn");
    emit_line("declare i32 @tls_context_set_ciphers(ptr, ptr)");
    declared_externals_.insert("tls_context_set_ciphers");
    emit_line("declare i32 @tls_context_set_ciphersuites(ptr, ptr)");
    declared_externals_.insert("tls_context_set_ciphersuites");
    emit_line("declare ptr @tls_stream_new(ptr, i64)");
    declared_externals_.insert("tls_stream_new");
    emit_line("declare i32 @tls_stream_set_hostname(ptr, ptr)");
    declared_externals_.insert("tls_stream_set_hostname");
    emit_line("declare i32 @tls_stream_connect(ptr)");
    declared_externals_.insert("tls_stream_connect");
    emit_line("declare i32 @tls_stream_accept(ptr)");
    declared_externals_.insert("tls_stream_accept");
    emit_line("declare i64 @tls_stream_read(ptr, ptr, i64)");
    declared_externals_.insert("tls_stream_read");
    emit_line("declare i64 @tls_stream_write(ptr, ptr, i64)");
    declared_externals_.insert("tls_stream_write");
    emit_line("declare i32 @tls_stream_shutdown(ptr)");
    declared_externals_.insert("tls_stream_shutdown");
    emit_line("declare void @tls_stream_free(ptr)");
    declared_externals_.insert("tls_stream_free");
    emit_line("declare ptr @tls_stream_get_version(ptr)");
    declared_externals_.insert("tls_stream_get_version");
    emit_line("declare ptr @tls_stream_get_cipher(ptr)");
    declared_externals_.insert("tls_stream_get_cipher");
    emit_line("declare ptr @tls_stream_get_alpn(ptr)");
    declared_externals_.insert("tls_stream_get_alpn");
    emit_line("declare ptr @tls_stream_get_peer_cn(ptr)");
    declared_externals_.insert("tls_stream_get_peer_cn");
    emit_line("declare ptr @tls_stream_get_peer_cert_pem(ptr)");
    declared_externals_.insert("tls_stream_get_peer_cert_pem");
    emit_line("declare i32 @tls_stream_get_verify_result(ptr)");
    declared_externals_.insert("tls_stream_get_verify_result");
    emit_line("declare i32 @tls_stream_peer_verified(ptr)");
    declared_externals_.insert("tls_stream_peer_verified");
    emit_line("declare ptr @tls_get_error()");
    declared_externals_.insert("tls_get_error");
    // Lowlevel wrappers (tml_ prefix for buffer-passing functions)
    emit_line("declare i64 @tml_tls_stream_read(ptr, ptr, i64)");
    declared_externals_.insert("tml_tls_stream_read");
    emit_line("declare i64 @tml_tls_stream_write(ptr, ptr, i64)");
    declared_externals_.insert("tml_tls_stream_write");
    emit_line("declare i64 @tml_tls_stream_write_str(ptr, ptr, i64)");
    declared_externals_.insert("tml_tls_stream_write_str");
    emit_line("");

    // Format strings for print/println
    // Size calculation: count actual bytes (each escape like \0A = 1 byte, not 3)
    emit_line("; Format strings");
    emit_line("@.fmt.int = private constant [4 x i8] c\"%d\\0A\\00\"");        // %d\n\0 = 4 bytes
    emit_line("@.fmt.int.no_nl = private constant [3 x i8] c\"%d\\00\"");      // %d\0 = 3 bytes
    emit_line("@.fmt.i64 = private constant [5 x i8] c\"%ld\\0A\\00\"");       // %ld\n\0 = 5 bytes
    emit_line("@.fmt.i64.no_nl = private constant [4 x i8] c\"%ld\\00\"");     // %ld\0 = 4 bytes
    emit_line("@.fmt.float = private constant [4 x i8] c\"%f\\0A\\00\"");      // %f\n\0 = 4 bytes
    emit_line("@.fmt.float.no_nl = private constant [3 x i8] c\"%f\\00\"");    // %f\0 = 3 bytes
    emit_line("@.fmt.float3 = private constant [6 x i8] c\"%.3f\\0A\\00\"");   // %.3f\n\0 = 6 bytes
    emit_line("@.fmt.float3.no_nl = private constant [5 x i8] c\"%.3f\\00\""); // %.3f\0 = 5 bytes
    emit_line("@.fmt.str.no_nl = private constant [3 x i8] c\"%s\\00\"");      // %s\0 = 3 bytes
    emit_line("@.str.true = private constant [5 x i8] c\"true\\00\"");         // true\0 = 5 bytes
    emit_line("@.str.false = private constant [6 x i8] c\"false\\00\"");       // false\0 = 6 bytes
    emit_line("@.str.space = private constant [2 x i8] c\" \\00\"");           // " "\0 = 2 bytes
    emit_line("@.str.newline = private constant [2 x i8] c\"\\0A\\00\"");      // \n\0 = 2 bytes
    emit_line("");
}

void LLVMIRGen::emit_module_lowlevel_decls() {
    // Emit declarations for lowlevel functions from imported modules
    if (!env_.module_registry()) {
        return;
    }

    emit_line("; Lowlevel functions from imported modules");

    // Get all modules from registry
    const auto& registry = env_.module_registry();
    const auto& all_modules = registry->get_all_modules();

    for (const auto& [module_name, module] : all_modules) {
        for (const auto& [func_name, func_sig] : module.functions) {
            if (func_sig.is_lowlevel) {
                // Generate LLVM declaration using semantic types
                std::string llvm_ret_type = llvm_type_from_semantic(func_sig.return_type);

                std::string params_str;
                for (size_t i = 0; i < func_sig.params.size(); ++i) {
                    if (i > 0)
                        params_str += ", ";
                    params_str += llvm_type_from_semantic(func_sig.params[i]);
                }

                // Sanitize function name: replace :: with _ for valid LLVM identifiers
                std::string sanitized_name = func_name;
                size_t pos = 0;
                while ((pos = sanitized_name.find("::", pos)) != std::string::npos) {
                    sanitized_name.replace(pos, 2, "_");
                    pos += 1;
                }

                // Emit declaration with tml_ prefix
                emit_line("declare " + llvm_ret_type + " @tml_" + sanitized_name + "(" +
                          params_str + ")");
            }
        }
    }

    emit_line("");
}

void LLVMIRGen::emit_module_pure_tml_functions() {
    // Emit LLVM IR for pure TML functions from imported modules
    if (!env_.module_registry()) {
        return;
    }

    const auto& registry = env_.module_registry();
    const auto& all_modules = registry->get_all_modules();

    // Collect imported module paths AND type names for filtering
    // This dramatically reduces codegen time by skipping unneeded modules
    std::unordered_set<std::string> imported_types;
    std::unordered_set<std::string> imported_module_paths;
    const auto& all_imports = env_.all_imports();
    for (const auto& [name, sym] : all_imports) {
        imported_types.insert(sym.original_name);
        imported_types.insert(name); // Also add local alias
        // Track the module path this symbol was imported from
        if (!sym.module_path.empty()) {
            imported_module_paths.insert(sym.module_path);
        }
    }

    // --- Compute conditional sync module requirements ---
    // Only include sync essential modules when sync/thread is actually imported.
    // This avoids processing ~1400 lines of atomic.tml + mutex/condvar for non-sync tests.
    bool needs_sync_atomic_essential = false;
    bool needs_sync_mutex_essential = false;
    bool needs_sync_condvar_essential = false;

    for (const auto& imported_path : imported_module_paths) {
        // Any sync/thread import needs atomic (for Ordering used by all sync types)
        if (imported_path.find("std::sync") == 0 || imported_path.find("std::thread") == 0) {
            needs_sync_atomic_essential = true;
        }
        // Mutex module needed when mutex/mpsc/barrier/once/rwlock is used
        if (imported_path.find("std::sync::mutex") == 0 ||
            imported_path.find("std::sync::mpsc") == 0 ||
            imported_path.find("std::sync::barrier") == 0 ||
            imported_path.find("std::sync::once") == 0 ||
            imported_path.find("std::sync::rwlock") == 0 || imported_path == "std::sync") {
            needs_sync_mutex_essential = true;
        }
        // Condvar module needed when condvar/mpsc/barrier is used
        if (imported_path.find("std::sync::condvar") == 0 ||
            imported_path.find("std::sync::mpsc") == 0 ||
            imported_path.find("std::sync::barrier") == 0 || imported_path == "std::sync") {
            needs_sync_condvar_essential = true;
        }
    }
    // Also check direct type imports
    if (imported_types.count("Mutex") || imported_types.count("MutexGuard")) {
        needs_sync_mutex_essential = true;
        needs_sync_atomic_essential = true;
    }
    if (imported_types.count("Condvar")) {
        needs_sync_condvar_essential = true;
        needs_sync_atomic_essential = true;
    }
    if (imported_types.count("Arc") || imported_types.count("Weak")) {
        needs_sync_atomic_essential = true;
    }

    // Build dynamic always_generate set based on actual import needs
    // This replaces the static set that generated ALL sync types unconditionally
    std::unordered_set<std::string> dynamic_always_generate = {
        "Ordering",
        "Layout",
        "LayoutError",
    };
    // Arc dependencies
    if (imported_types.count("Arc") || imported_types.count("Weak") ||
        imported_types.count("ArcInner")) {
        dynamic_always_generate.insert("AtomicUsize");
        dynamic_always_generate.insert("Weak");
        dynamic_always_generate.insert("ArcInner");
    }
    // Mutex dependencies
    if (needs_sync_mutex_essential) {
        dynamic_always_generate.insert("Mutex");
        dynamic_always_generate.insert("RawMutex");
        dynamic_always_generate.insert("MutexGuard");
    }
    // Condvar dependencies
    if (needs_sync_condvar_essential) {
        dynamic_always_generate.insert("Condvar");
        dynamic_always_generate.insert("RawCondvar");
    }
    // Thread module dependencies
    bool has_thread_import = false;
    for (const auto& p : imported_module_paths) {
        if (p.find("std::thread") == 0) {
            has_thread_import = true;
            break;
        }
    }
    if (has_thread_import) {
        dynamic_always_generate.insert("AtomicBool");
        dynamic_always_generate.insert("AtomicPtr");
        dynamic_always_generate.insert("AtomicUsize");
    }
    // RwLock dependencies
    if (imported_types.count("RwLock") || imported_types.count("RwLockReadGuard") ||
        imported_types.count("RwLockWriteGuard")) {
        dynamic_always_generate.insert("RwLockReadGuard");
        dynamic_always_generate.insert("RwLockWriteGuard");
    }

    // Pre-scan: collect types imported by modules that will be processed.
    // This enriches imported_types with transitive dependencies, allowing
    // the impl block filter to skip unused types more precisely.
    for (const auto& [module_name, module] : all_modules) {
        if (!module.has_pure_tml_functions || module.source_code.empty()) {
            continue;
        }
        // Check if this module will be processed (same logic as main loop)
        bool will_process = false;
        for (const auto& imported_path : imported_module_paths) {
            if (module_name == imported_path || imported_path.find(module_name + "::") == 0 ||
                module_name.find(imported_path + "::") == 0) {
                will_process = true;
                break;
            }
        }
        if (!will_process) {
            static const std::unordered_set<std::string> core_essential = {
                "core::ordering",
                "core::alloc",
                "core::option",
                "core::types",
            };
            will_process = core_essential.count(module_name) > 0;
            // Conditionally add sync essential modules
            if (!will_process) {
                if (module_name == "std::sync::atomic" && needs_sync_atomic_essential)
                    will_process = true;
                else if (module_name == "std::sync::mutex" && needs_sync_mutex_essential)
                    will_process = true;
                else if (module_name == "std::sync::condvar" && needs_sync_condvar_essential)
                    will_process = true;
            }
            if (!will_process) {
                std::string last_seg = module_name;
                auto sep = module_name.rfind("::");
                if (sep != std::string::npos)
                    last_seg = module_name.substr(sep + 2);
                static const std::unordered_set<std::string> essential_segs = {
                    "ordering",
                    "alloc",
                    "option",
                };
                will_process = essential_segs.count(last_seg) > 0;
            }
        }
        if (!will_process)
            continue;

        // Quick scan: extract type names from use declarations in module source
        // Look for patterns like: use std::sync::atomic::{AtomicBool, AtomicUsize}
        // and: use std::sync::arc::Arc
        const auto& src = module.source_code;
        size_t pos = 0;
        while ((pos = src.find("use ", pos)) != std::string::npos) {
            // Make sure this is at line start (preceded by newline or start of file)
            if (pos > 0 && src[pos - 1] != '\n' && src[pos - 1] != '\r') {
                pos += 4;
                continue;
            }
            size_t line_end = src.find('\n', pos);
            if (line_end == std::string::npos)
                line_end = src.size();
            std::string line = src.substr(pos, line_end - pos);

            // Handle grouped imports: use foo::{Bar, Baz}
            auto brace_start = line.find('{');
            if (brace_start != std::string::npos) {
                auto brace_end = line.find('}', brace_start);
                if (brace_end != std::string::npos) {
                    std::string symbols = line.substr(brace_start + 1, brace_end - brace_start - 1);
                    // Split by comma
                    size_t s = 0;
                    while (s < symbols.size()) {
                        while (s < symbols.size() && (symbols[s] == ' ' || symbols[s] == ','))
                            ++s;
                        size_t e = s;
                        while (e < symbols.size() && symbols[e] != ',' && symbols[e] != ' ')
                            ++e;
                        if (e > s) {
                            std::string sym = symbols.substr(s, e - s);
                            // Only add type-like names (start with uppercase)
                            if (!sym.empty() && std::isupper(sym[0])) {
                                imported_types.insert(sym);
                            }
                        }
                        s = e;
                    }
                }
            } else {
                // Handle simple imports: use foo::bar::Baz
                auto last_sep = line.rfind("::");
                if (last_sep != std::string::npos && last_sep + 2 < line.size()) {
                    std::string sym = line.substr(last_sep + 2);
                    // Trim trailing whitespace
                    while (!sym.empty() &&
                           (sym.back() == '\r' || sym.back() == '\n' || sym.back() == ' '))
                        sym.pop_back();
                    if (!sym.empty() && std::isupper(sym[0])) {
                        imported_types.insert(sym);
                    }
                }
            }
            pos = line_end;
        }
    }

    emit_line("; Pure TML functions from imported modules");

    // Collect eligible modules: filter, parse ASTs, store per-module info
    struct ModuleInfo {
        std::string module_name;
        std::string mod_name; // stem of file path
        std::string sanitized_prefix;
        const types::Module* module_ptr;
        const parser::Module* parsed_module_ptr;
    };
    std::vector<ModuleInfo> eligible_modules;

    for (const auto& [module_name, module] : all_modules) {
        // Check if module has pure TML functions
        if (!module.has_pure_tml_functions || module.source_code.empty()) {
            continue;
        }

        // Early skip: Only process modules that were actually imported from
        // This avoids expensive re-parsing of modules we don't need
        if (!imported_module_paths.empty()) {
            bool should_process = false;

            // Check if this module path matches, is a parent/child, or sibling of an imported
            // module
            for (const auto& imported_path : imported_module_paths) {
                if (module_name == imported_path) {
                    should_process = true;
                    break;
                }
                // Module is parent of imported (e.g., core::unicode for core::unicode::char)
                if (imported_path.find(module_name + "::") == 0) {
                    should_process = true;
                    break;
                }
                // Module is child of imported (e.g., core::unicode::char for core::unicode)
                if (module_name.find(imported_path + "::") == 0) {
                    should_process = true;
                    break;
                }
                // Sibling module: same parent prefix (e.g., core::unicode::unicode_data
                // is sibling of core::unicode::char  both under core::unicode)
                auto mod_sep = module_name.rfind("::");
                auto imp_sep = imported_path.rfind("::");
                if (mod_sep != std::string::npos && imp_sep != std::string::npos) {
                    std::string mod_parent = module_name.substr(0, mod_sep);
                    std::string imp_parent = imported_path.substr(0, imp_sep);
                    if (mod_parent == imp_parent) {
                        should_process = true;
                        break;
                    }
                }
            }

            // Essential modules: core always needed, sync conditionally
            if (!should_process) {
                static const std::unordered_set<std::string> core_essential_modules = {
                    "core::ordering",
                    "core::alloc",
                    "core::option",
                    "core::types",
                };
                should_process = core_essential_modules.count(module_name) > 0;
                if (!should_process) {
                    if (module_name == "std::sync::atomic" && needs_sync_atomic_essential)
                        should_process = true;
                    else if (module_name == "std::sync::mutex" && needs_sync_mutex_essential)
                        should_process = true;
                    else if (module_name == "std::sync::condvar" && needs_sync_condvar_essential)
                        should_process = true;
                }
                if (!should_process) {
                    std::string last_segment = module_name;
                    auto last_sep = module_name.rfind("::");
                    if (last_sep != std::string::npos) {
                        last_segment = module_name.substr(last_sep + 2);
                    }
                    static const std::unordered_set<std::string> essential_last_segments = {
                        "ordering",
                        "alloc",
                        "option",
                    };
                    should_process = essential_last_segments.count(last_segment) > 0;
                }
            }

            if (!should_process) {
                TML_DEBUG_LN("[MODULE] Early skip module: " << module_name);
                continue;
            }
        }

        // Parse or retrieve cached AST
        const parser::Module* cached_ast = nullptr;
        if (GlobalASTCache::should_cache(module_name)) {
            cached_ast = GlobalASTCache::instance().get(module_name);
        }

        const parser::Module* parsed_module_ptr = nullptr;
        auto mod_name = std::filesystem::path(module.file_path).stem().string();

        if (cached_ast) {
            TML_DEBUG_LN("[CODEGEN] AST cache hit for: " << module_name);
            parsed_module_ptr = cached_ast;
        } else {
            auto source = lexer::Source::from_string(module.source_code, module.file_path);
            lexer::Lexer lex(source);
            auto tokens = lex.tokenize();

            if (lex.has_errors()) {
                TML_DEBUG_LN("[MODULE] Lex errors for: " << module_name);
                continue;
            }

            parser::Parser parser(std::move(tokens));
            auto parse_result = parser.parse_module(mod_name);

            if (std::holds_alternative<std::vector<parser::ParseError>>(parse_result)) {
                const auto& errs = std::get<std::vector<parser::ParseError>>(parse_result);
                TML_DEBUG_LN("[MODULE] Parse errors for: " << module_name << " (" << errs.size()
                                                           << " errors)");
                for (const auto& e : errs) {
                    TML_DEBUG_LN("[MODULE]   " << e.span.start.line << ":" << e.span.start.column
                                               << " " << e.message);
                }
                continue;
            }

            auto parsed_mod = std::get<parser::Module>(std::move(parse_result));

            if (GlobalASTCache::should_cache(module_name)) {
                GlobalASTCache::instance().put(module_name, std::move(parsed_mod));
                parsed_module_ptr = GlobalASTCache::instance().get(module_name);
                TML_DEBUG_LN("[CODEGEN] AST cached: " << module_name);
            } else {
                imported_module_asts_.push_back(std::move(parsed_mod));
                parsed_module_ptr = &imported_module_asts_.back();
            }
        }

        if (!parsed_module_ptr) {
            continue;
        }

        // Compute sanitized module prefix
        std::string sanitized_prefix = module_name;
        size_t pos = 0;
        while ((pos = sanitized_prefix.find("::", pos)) != std::string::npos) {
            sanitized_prefix.replace(pos, 2, "_");
            pos += 1;
        }

        eligible_modules.push_back(
            {module_name, mod_name, sanitized_prefix, &module, parsed_module_ptr});
    }

    // ========================================================================
    // PHASE 1: Register ALL types (structs, enums, constants, function signatures)
    // from ALL modules BEFORE generating any code. This ensures types like
    // "Ordering" are registered before any impl method tries to use them,
    // regardless of unordered_map iteration order.
    // ========================================================================
    for (const auto& info : eligible_modules) {
        const auto& parsed_module = *info.parsed_module_ptr;
        current_module_prefix_ = info.sanitized_prefix;
        current_submodule_name_ = info.mod_name;

        // First pass: register struct/enum declarations (including generic ones)
        // IMPORTANT: Register ALL structs/enums, not just public ones!
        // Private types like StackNode[T] are still used internally and need to be
        // instantiated when size_of[T]() or similar intrinsics are called.
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::StructDecl>()) {
                const auto& s = decl->as<parser::StructDecl>();
                // Register all structs (public AND private) for generic instantiation
                // Private types are needed for internal use (e.g., size_of[StackNode[T]])
                gen_struct_decl(s);
            } else if (decl->is<parser::EnumDecl>()) {
                const auto& e = decl->as<parser::EnumDecl>();
                // Register all enums (public AND private) for generic instantiation
                gen_enum_decl(e);
            } else if (decl->is<parser::ClassDecl>()) {
                const auto& c = decl->as<parser::ClassDecl>();
                // Register class types so %class.ClassName is properly sized.
                // Use emit_external_class_type for type + field registration,
                // then gen_class_vtable for vtable type + global.
                // First try the env's lookup (works for imported classes), then
                // fall back to direct module registry lookup (for non-imported
                // classes in the same module file, e.g. exception subclasses).
                auto class_def = env_.lookup_class(c.name);
                if (!class_def.has_value() && env_.module_registry()) {
                    class_def = env_.module_registry()->lookup_class(info.module_name, c.name);
                }
                if (class_def.has_value()) {
                    emit_external_class_type(c.name, *class_def);
                    // Generate vtable type and global constant.
                    // gen_class_vtable emits the vtable type and global with
                    // method pointers. Methods themselves are generated in PHASE 2.
                    gen_class_vtable(c);
                }
            } else if (decl->is<parser::ConstDecl>()) {
                // Register module-level constants for use in functions
                const auto& const_decl = decl->as<parser::ConstDecl>();
                std::string value;

                // Support literal constants
                if (const_decl.value->is<parser::LiteralExpr>()) {
                    const auto& lit = const_decl.value->as<parser::LiteralExpr>();
                    if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                        value = std::to_string(lit.token.int_value().value);
                    } else if (lit.token.kind == lexer::TokenKind::BoolLiteral) {
                        value = lit.token.bool_value() ? "1" : "0";
                    } else if (lit.token.kind == lexer::TokenKind::NullLiteral) {
                        value = "null";
                    }
                }
                // Support cast expressions (e.g., 14695981039346656037 as U64)
                else if (const_decl.value->is<parser::CastExpr>()) {
                    const auto& cast = const_decl.value->as<parser::CastExpr>();
                    if (cast.expr && cast.expr->is<parser::LiteralExpr>()) {
                        const auto& lit = cast.expr->as<parser::LiteralExpr>();
                        if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                            value = std::to_string(lit.token.int_value().value);
                        }
                    } else if (cast.expr && cast.expr->is<parser::UnaryExpr>()) {
                        const auto& unary = cast.expr->as<parser::UnaryExpr>();
                        if (unary.op == parser::UnaryOp::Neg &&
                            unary.operand->is<parser::LiteralExpr>()) {
                            const auto& lit = unary.operand->as<parser::LiteralExpr>();
                            if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                int64_t int_val = static_cast<int64_t>(lit.token.int_value().value);
                                value = std::to_string(-int_val);
                            }
                        }
                    }
                }
                // Support unary expressions (e.g., -128)
                else if (const_decl.value->is<parser::UnaryExpr>()) {
                    const auto& unary = const_decl.value->as<parser::UnaryExpr>();
                    if (unary.op == parser::UnaryOp::Neg &&
                        unary.operand->is<parser::LiteralExpr>()) {
                        const auto& lit = unary.operand->as<parser::LiteralExpr>();
                        if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                            int64_t int_val = static_cast<int64_t>(lit.token.int_value().value);
                            value = std::to_string(-int_val);
                        }
                    }
                }

                if (!value.empty()) {
                    std::string llvm_type = get_const_llvm_type(const_decl.type);
                    // Register both with and without module prefix
                    global_constants_[const_decl.name] = {value, llvm_type};
                    // Also register with qualified name for explicit lookups
                    std::string qualified_name = info.module_name + "::" + const_decl.name;
                    global_constants_[qualified_name] = {value, llvm_type};
                }
            } else if (decl->is<parser::UseDecl>()) {
                // Handle wildcard imports: "use module::*" brings all constants into scope
                const auto& use_decl = decl->as<parser::UseDecl>();
                if (use_decl.is_glob && !use_decl.path.segments.empty()) {
                    // Build the imported module path
                    std::string import_path;
                    for (size_t i = 0; i < use_decl.path.segments.size(); ++i) {
                        if (i > 0)
                            import_path += "::";
                        import_path += use_decl.path.segments[i];
                    }

                    // Look up the imported module and register its constants
                    auto imported_mod = registry->get_module(import_path);
                    if (imported_mod) {
                        // Import constants directly from the module
                        for (const auto& [const_name, const_info] : imported_mod->constants) {
                            // Only import non-qualified constants (not Type::CONST)
                            if (const_name.find("::") == std::string::npos) {
                                // Convert TML type to LLVM type
                                std::string llvm_type = llvm_type_name(const_info.tml_type);
                                global_constants_[const_name] = {const_info.value, llvm_type};
                                TML_DEBUG_LN("[MODULE] Imported constant via wildcard: "
                                             << const_name << " = " << const_info.value << " from "
                                             << import_path);
                            }
                        }

                        // Also follow re-exports (pub use) to import constants from
                        // re-exported modules. This handles chains like:
                        // std::zlib -> std::zlib::constants (via pub use zlib::constants::*)
                        for (const auto& re_export : imported_mod->re_exports) {
                            if (re_export.is_glob) {
                                auto re_exported_mod = registry->get_module(re_export.source_path);
                                if (re_exported_mod) {
                                    for (const auto& [const_name, const_info] :
                                         re_exported_mod->constants) {
                                        if (const_name.find("::") == std::string::npos) {
                                            std::string llvm_type =
                                                llvm_type_name(const_info.tml_type);
                                            global_constants_[const_name] = {const_info.value,
                                                                             llvm_type};
                                            TML_DEBUG_LN(
                                                "[MODULE] Imported constant via re-export: "
                                                << const_name << " = " << const_info.value
                                                << " from " << re_export.source_path);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (decl->is<parser::TraitDecl>()) {
                // Register behavior/trait declarations so that default method
                // bodies can be generated for impl blocks in Phase 2.
                const auto& trait = decl->as<parser::TraitDecl>();
                if (trait_decls_.find(trait.name) == trait_decls_.end()) {
                    trait_decls_[trait.name] = &trait;
                }
            }
        }

        // Pre-register ALL function signatures before generating any code
        // This ensures intra-module calls (like mod.tml calling unicode_data::func) resolve
        // correctly. Includes PRIVATE functions to support same-module calls.
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::FuncDecl>()) {
                const auto& func = decl->as<parser::FuncDecl>();
                if (!func.is_unsafe && func.body.has_value()) {
                    pre_register_func(func);
                }
            }
        }
    }
    current_module_prefix_.clear();

    // ========================================================================
    // PHASE 2: Generate code for functions and impl methods.
    // All types are now registered from Phase 1, so type lookups
    // (like "Ordering") will always find their definitions.
    //
    // In library_decls_only mode, gen_func_decl and gen_impl_method emit
    // `declare` statements instead of full function definitions. The
    // implementations come from a shared library object compiled once per suite.
    // ========================================================================
    for (const auto& info : eligible_modules) {
        const auto& parsed_module = *info.parsed_module_ptr;
        const auto& module_name = info.module_name;
        current_module_prefix_ = info.sanitized_prefix;
        current_submodule_name_ = info.mod_name;

        emit_line("; Module: " + module_name);

        // Collect types defined in THIS module (struct/enum/class declarations)
        // so their impl blocks are not skipped by the imported_types filter
        std::unordered_set<std::string> module_defined_types;
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::StructDecl>()) {
                const auto& s = decl->as<parser::StructDecl>();
                if (!s.name.empty())
                    module_defined_types.insert(s.name);
            } else if (decl->is<parser::EnumDecl>()) {
                const auto& e = decl->as<parser::EnumDecl>();
                if (!e.name.empty())
                    module_defined_types.insert(e.name);
            } else if (decl->is<parser::ClassDecl>()) {
                const auto& c = decl->as<parser::ClassDecl>();
                if (!c.name.empty())
                    module_defined_types.insert(c.name);
            }
        }

        // Generate code for each function (both public AND private)
        TML_DEBUG_LN("[MODULE] Processing " << parsed_module.decls.size() << " decls for "
                                            << module_name);
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::FuncDecl>()) {
                const auto& func = decl->as<parser::FuncDecl>();

                // Process extern functions - emit declarations
                if (func.extern_abi.has_value()) {
                    TML_DEBUG_LN("[MODULE] Found @extern func: " << func.name
                                                                 << " abi=" << *func.extern_abi);
                    gen_func_decl(func);
                    continue;
                }

                // Generate code for both public AND private functions with bodies
                // Private functions are needed for intra-module helper functions
                if (!func.is_unsafe && func.body.has_value()) {
                    gen_func_decl(func);
                }
            }
            // Also handle impl blocks - generate methods for imported types
            else if (decl->is<parser::ImplDecl>()) {
                const auto& impl = decl->as<parser::ImplDecl>();

                // Register impl block for vtable generation (enables dyn dispatch)
                register_impl(&impl);

                // Skip generic impls - they need to be instantiated on demand
                // Generic impls have type parameters like impl[T] or impl[I: Iterator]
                if (!impl.generics.empty()) {
                    TML_DEBUG_LN("[MODULE] Skipping generic impl with " << impl.generics.size()
                                                                        << " type params");
                    continue;
                }

                // Get the type name for the impl
                std::string type_name;
                if (impl.self_type && impl.self_type->is<parser::NamedType>()) {
                    const auto& named = impl.self_type->as<parser::NamedType>();
                    if (!named.path.segments.empty()) {
                        type_name = named.path.segments.back();
                    }
                }

                // Skip impl blocks for types that aren't actually imported
                // This dramatically reduces codegen time (e.g., don't generate AtomicBool when only
                // Arc is used). Uses dynamic_always_generate computed based on actual imports.
                // IMPORTANT: Never skip impl blocks for primitive types (I32, U8, etc.)
                // because behavior impls like `impl PartialEq for I32` must always be
                // generated  primitives are builtin types that are never "imported".
                auto is_primitive_type = [](const std::string& name) {
                    return name == "I8" || name == "I16" || name == "I32" || name == "I64" ||
                           name == "I128" || name == "U8" || name == "U16" || name == "U32" ||
                           name == "U64" || name == "U128" || name == "F32" || name == "F64" ||
                           name == "Bool" || name == "Str";
                };
                if (!type_name.empty() && !imported_types.empty() &&
                    imported_types.find(type_name) == imported_types.end() &&
                    !is_primitive_type(type_name)) {
                    if (dynamic_always_generate.find(type_name) == dynamic_always_generate.end() &&
                        module_defined_types.find(type_name) == module_defined_types.end()) {
                        TML_DEBUG_LN("[MODULE] Skipping impl for non-imported type: " << type_name);
                        continue;
                    }
                }

                if (!type_name.empty()) {
                    // Extract constants from impl block (e.g., I32::MIN, I32::MAX)
                    for (const auto& const_decl : impl.constants) {
                        std::string qualified_name = type_name + "::" + const_decl.name;
                        std::string value;

                        // Support: literal constants
                        if (const_decl.value->is<parser::LiteralExpr>()) {
                            const auto& lit = const_decl.value->as<parser::LiteralExpr>();
                            if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                value = std::to_string(lit.token.int_value().value);
                            } else if (lit.token.kind == lexer::TokenKind::BoolLiteral) {
                                value = lit.token.bool_value() ? "1" : "0";
                            }
                        }
                        // Support: cast expressions (e.g., -2147483648 as I32)
                        else if (const_decl.value->is<parser::CastExpr>()) {
                            const auto& cast = const_decl.value->as<parser::CastExpr>();
                            if (cast.expr && cast.expr->is<parser::LiteralExpr>()) {
                                const auto& lit = cast.expr->as<parser::LiteralExpr>();
                                if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                    value = std::to_string(lit.token.int_value().value);
                                }
                            } else if (cast.expr && cast.expr->is<parser::UnaryExpr>()) {
                                const auto& unary = cast.expr->as<parser::UnaryExpr>();
                                if (unary.op == parser::UnaryOp::Neg &&
                                    unary.operand->is<parser::LiteralExpr>()) {
                                    const auto& lit = unary.operand->as<parser::LiteralExpr>();
                                    if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                        int64_t int_val =
                                            static_cast<int64_t>(lit.token.int_value().value);
                                        value = std::to_string(-int_val);
                                    }
                                }
                            }
                        }
                        // Support: unary expressions (e.g., -128)
                        else if (const_decl.value->is<parser::UnaryExpr>()) {
                            const auto& unary = const_decl.value->as<parser::UnaryExpr>();
                            if (unary.op == parser::UnaryOp::Neg &&
                                unary.operand->is<parser::LiteralExpr>()) {
                                const auto& lit = unary.operand->as<parser::LiteralExpr>();
                                if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                    int64_t int_val =
                                        static_cast<int64_t>(lit.token.int_value().value);
                                    value = std::to_string(-int_val);
                                }
                            } else if (unary.operand->is<parser::CastExpr>()) {
                                const auto& cast = unary.operand->as<parser::CastExpr>();
                                if (cast.expr && cast.expr->is<parser::LiteralExpr>()) {
                                    const auto& lit = cast.expr->as<parser::LiteralExpr>();
                                    if (lit.token.kind == lexer::TokenKind::IntLiteral) {
                                        int64_t int_val =
                                            static_cast<int64_t>(lit.token.int_value().value);
                                        value = std::to_string(-int_val);
                                    }
                                }
                            }
                        }

                        if (!value.empty()) {
                            std::string llvm_type = get_const_llvm_type(const_decl.type);
                            global_constants_[qualified_name] = {value, llvm_type};
                        }
                    }

                    // For generic types (like Maybe[T]), ensure the generic struct type exists
                    // This is needed because impl methods use the base type name
                    auto enum_it = pending_generic_enums_.find(type_name);
                    if (enum_it != pending_generic_enums_.end()) {
                        // Check if generic struct type already declared
                        if (struct_types_.find(type_name) == struct_types_.end()) {
                            // Emit generic type definition with i64 payload (fits all
                            // instantiations)
                            type_defs_buffer_ << "%struct." << type_name
                                              << " = type { i32, i64 }\n";
                            struct_types_[type_name] = "%struct." + type_name;
                        }
                    }

                    // First pass: pre-instantiate generic types used in method signatures
                    for (const auto& method : impl.methods) {
                        if (method.return_type.has_value()) {
                            const auto& ret_type = *method.return_type;
                            if (ret_type->is<parser::NamedType>()) {
                                const auto& named = ret_type->as<parser::NamedType>();
                                if (named.generics.has_value() && !named.generics->args.empty()) {
                                    // Check if this is a pending generic enum
                                    std::string base_name;
                                    if (!named.path.segments.empty()) {
                                        base_name = named.path.segments.back();
                                    }
                                    auto it = pending_generic_enums_.find(base_name);
                                    if (it != pending_generic_enums_.end()) {
                                        // Convert parser type args to semantic types
                                        std::vector<types::TypePtr> type_args;
                                        for (const auto& arg : named.generics->args) {
                                            if (arg.is_type()) {
                                                type_args.push_back(resolve_parser_type_with_subs(
                                                    *arg.as_type(), {}));
                                            }
                                        }
                                        // Check if already instantiated
                                        std::string mangled =
                                            mangle_struct_name(base_name, type_args);
                                        if (struct_types_.find(mangled) == struct_types_.end()) {
                                            gen_enum_instantiation(*it->second, type_args);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Second pass: generate the methods
                    for (const auto& method : impl.methods) {
                        // Generate code for public, non-lowlevel methods with bodies
                        if (method.vis == parser::Visibility::Public && !method.is_unsafe &&
                            method.body.has_value()) {
                            gen_impl_method(type_name, method);
                        }
                    }
                }
            }
            // Handle class declarations - generate methods for imported classes
            // This ensures class methods like Object::reference_equals get declare statements
            else if (decl->is<parser::ClassDecl>()) {
                const auto& cls = decl->as<parser::ClassDecl>();
                std::string class_name = cls.name;

                // Apply same filter as impl blocks
                if (!class_name.empty() && !imported_types.empty() &&
                    imported_types.find(class_name) == imported_types.end()) {
                    if (dynamic_always_generate.find(class_name) == dynamic_always_generate.end() &&
                        module_defined_types.find(class_name) == module_defined_types.end()) {
                        TML_DEBUG_LN(
                            "[MODULE] Skipping class for non-imported type: " << class_name);
                        continue;
                    }
                }

                // Generate methods for this class
                // gen_class_method handles library_decls_only mode
                for (const auto& method : cls.methods) {
                    if (!method.generics.empty()) {
                        continue; // Skip generic methods
                    }
                    gen_class_method(cls, method);
                }
            }
        }

        // Clear module prefix after processing this module
        current_module_prefix_.clear();
    }

    emit_line("");
}

void LLVMIRGen::emit_string_constants() {
    if (string_literals_.empty())
        return;

    emit_line("; String constants");
    for (const auto& [name, value] : string_literals_) {
        // Escape the string and add null terminator
        std::string escaped;
        for (char c : value) {
            if (c == '\n')
                escaped += "\\0A";
            else if (c == '\t')
                escaped += "\\09";
            else if (c == '\\')
                escaped += "\\5C";
            else if (c == '"')
                escaped += "\\22";
            else
                escaped += c;
        }
        escaped += "\\00";

        emit_line(name + " = private constant [" + std::to_string(value.size() + 1) + " x i8] c\"" +
                  escaped + "\"");
    }
    emit_line("");
}

} // namespace tml::codegen
