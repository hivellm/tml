//! # LLVM IR Generator - Runtime Declarations
//!
//! This file emits the target header and runtime type/function declarations.
//! Module import codegen is in runtime_modules.cpp.
//!
//! ## Emitted Sections
//!
//! | Method                         | Emits                         |
//! |--------------------------------|-------------------------------|
//! | `emit_header`                  | Target triple, comments       |
//! | `emit_runtime_decls`           | Struct types, C functions     |
//!
//! ## Runtime Types
//!
//! | Type            | Layout              | Purpose             |
//! |-----------------|---------------------|---------------------|
//! | `%struct.tml_str` | `{ ptr, i64 }`    | String slice        |
//! | `%struct.Ordering` | `{ i32 }`        | Comparison result   |
//!
//! ## External Functions
//!
//! Declares C standard library functions: printf, puts, malloc, free, exit.

#include "codegen/llvm/llvm_ir_gen.hpp"
#include "lexer/lexer.hpp"
#include "lexer/source.hpp"
#include "parser/parser.hpp"

#include <filesystem>
#include <unordered_set>

namespace tml::codegen {

void LLVMIRGen::emit_header() {
    emit_line("; Generated by TML Compiler");
    emit_line("target triple = \"" + options_.target_triple + "\"");
    emit_line("");
}

void LLVMIRGen::emit_runtime_decls() {
    // String type: { ptr, i64 } (pointer to data, length)
    emit_line("; Runtime type declarations");
    emit_line("%struct.tml_str = type { ptr, i64 }");

    // Core comparison type (core::cmp)
    // Ordering is a simple enum: Less=0, Equal=1, Greater=2
    emit_line("%struct.Ordering = type { i32 }");
    struct_types_["Ordering"] = "%struct.Ordering";
    struct_fields_["Ordering"] = {{"value", 0, "i32", types::make_i32()}};

    // HashMapIter type for iterating over HashMap entries
    emit_line("%struct.HashMapIter = type { ptr }");
    struct_types_["HashMapIter"] = "%struct.HashMapIter";
    struct_fields_["HashMapIter"] = {{"handle", 0, "ptr", types::make_ptr(types::make_unit())}};

    // Thread types (from std::thread) - needed for @extern function declarations
    emit_line("%struct.RawThread = type { i64 }"); // _handle: U64
    struct_types_["RawThread"] = "%struct.RawThread";
    struct_fields_["RawThread"] = {
        {"_handle", 0, "i64", types::make_primitive(types::PrimitiveKind::U64)}};
    emit_line("%struct.RawPtr = type { i64 }"); // addr: I64
    struct_types_["RawPtr"] = "%struct.RawPtr";
    struct_fields_["RawPtr"] = {{"addr", 0, "i64", types::make_i64()}};
    emit_line("");

    // External C functions
    emit_line("; External function declarations");
    emit_line("declare i32 @printf(ptr, ...)");
    emit_line("declare i32 @puts(ptr)");
    emit_line("declare i32 @putchar(i32)");
    emit_line("declare ptr @malloc(i64)");
    emit_line("declare void @free(ptr)");
    emit_line("declare void @exit(i32) noreturn");
    emit_line("declare i64 @strlen(ptr)");
    emit_line("");

    // LLVM intrinsics for optimized codegen
    emit_line("; LLVM intrinsics");
    emit_line("declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)");
    emit_line("declare void @llvm.memmove.p0.p0.i64(ptr, ptr, i64, i1)");
    emit_line("declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)");
    emit_line("declare void @llvm.assume(i1) nounwind");
    emit_line("");

    // TML runtime functions
    emit_line("; TML runtime functions");
    emit_line("declare void @panic(ptr) noreturn");
    emit_line("declare void @assert_tml_loc(i32, ptr, ptr, i32) noreturn");
    emit_line("");

    // Panic catching for @should_panic tests
    // Uses a callback approach: pass function pointer to tml_run_should_panic()
    emit_line("; Panic catching (for @should_panic tests)");
    emit_line("declare i32 @tml_run_should_panic(ptr)");
    emit_line("declare ptr @tml_get_panic_message()");
    emit_line("declare i32 @tml_panic_message_contains(ptr)");
    emit_line("");

    // Backtrace support (--backtrace flag enables printing stack trace on panic)
    emit_line("; Backtrace support");
    emit_line("declare void @tml_enable_backtrace_on_panic()");
    emit_line("");

    // Note: TML test assertions are now provided by the test module's TML code
    // They call panic() internally and don't need external declarations
    emit_line("");

    // TML code coverage functions (only when coverage is enabled)
    if (options_.coverage_enabled) {
        emit_line("; TML code coverage");
        emit_line("declare void @tml_cover_func(ptr)");
        emit_line("declare void @print_coverage_report()");
        emit_line("declare void @write_coverage_json(ptr)");
        emit_line("declare void @write_coverage_html(ptr)");
        emit_line("");
        // Register in declared_externals_ to prevent duplicate declarations
        // when test::coverage module is imported (it has @extern("tml_cover_func"))
        declared_externals_.insert("tml_cover_func");
        declared_externals_.insert("print_coverage_report");
        declared_externals_.insert("write_coverage_json");
        declared_externals_.insert("write_coverage_html");
    }

    // Debug intrinsics (for DWARF debug info)
    if (options_.emit_debug_info) {
        emit_line("; Debug intrinsics");
        emit_line("declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone");
        emit_line("declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone");
        emit_line("");
    }

    // LLVM instrumentation profile intrinsic (for source-based coverage)
    if (options_.llvm_source_coverage) {
        emit_line("; LLVM instrumentation profile intrinsics (source-based coverage)");
        emit_line("declare void @llvm.instrprof.increment(ptr, i64, i32, i32) #1");
        emit_line("");
    }

    // Stack save/restore intrinsics (for loop alloca cleanup)
    emit_line("; Stack management intrinsics");
    emit_line("declare ptr @llvm.stacksave() nounwind");
    emit_line("declare void @llvm.stackrestore(ptr) nounwind");
    emit_line("");

    // Lifetime intrinsics (for stack slot optimization)
    emit_line("; Lifetime intrinsics for stack optimization");
    emit_line("declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) nounwind");
    emit_line("");

    // Threading runtime — REMOVED (Phase 24)
    // thread_spawn, thread_join, thread_yield, thread_sleep, thread_id
    // migrated to @extern("tml_thread_*") FFI in std::thread::mod.tml
    emit_line("");

    // I/O functions - all check output suppression flag
    emit_line("; I/O functions (check output suppression)");
    emit_line("declare void @print(ptr)");
    emit_line("declare void @println(ptr)");
    emit_line("declare void @print_i32(i32)");
    emit_line("declare void @print_i64(i64)");
    emit_line("declare void @print_f64(double)");
    emit_line("declare void @print_bool(i32)");
    emit_line("");

    // NOTE: Math functions moved to core::math module
    // Import with: use core::math

    // NOTE: Assertion functions moved to test module
    // Import with: use test
    emit_line("; Black box (prevent optimization)");
    emit_line("declare i32 @black_box_i32(i32)");
    emit_line("declare i64 @black_box_i64(i64)");
    emit_line("declare double @black_box_f64(double)");
    emit_line("; SIMD operations (auto-vectorized)");
    emit_line("declare i64 @simd_sum_i32(ptr, i64)");
    emit_line("declare double @simd_sum_f64(ptr, i64)");
    emit_line("declare double @simd_dot_f64(ptr, ptr, i64)");
    emit_line("");

    // Float functions
    emit_line("; Float functions");
    emit_line("declare ptr @float_to_fixed(double, i32)");
    emit_line("declare ptr @float_to_precision(double, i32)");
    emit_line("declare ptr @float_to_string(double)");
    emit_line("declare ptr @f64_to_string(double)"); // F64.to_string() method
    emit_line("declare ptr @f32_to_string(float)");  // F32.to_string() method
    emit_line("declare ptr @float_to_exp(double, i32)");
    emit_line("declare ptr @f64_to_string_precision(double, i64)");
    emit_line("declare ptr @f32_to_string_precision(float, i64)");
    emit_line("declare ptr @f64_to_exp_string(double, i32)");
    emit_line("declare ptr @f32_to_exp_string(float, i32)");
    // f32/f64_is_nan, f32/f64_is_infinite — REMOVED (Phase 27)
    // Replaced by pure LLVM IR (fcmp uno / fabs+fcmp) in string.cpp
    // float_abs, float_sqrt, float_pow, float_round, float_floor, float_ceil,
    // int_to_float, float_to_int — replaced with LLVM intrinsics/instructions in math.cpp
    emit_line("");

    // Integer to string conversion
    emit_line("; Integer to string");
    emit_line("declare ptr @i32_to_string(i32)");
    emit_line("declare ptr @i64_to_string(i64)");
    emit_line("declare ptr @bool_to_string(i1)");
    emit_line("");

    // Integer formatting (binary, octal, hex)
    emit_line("; Integer formatting");
    emit_line("declare ptr @i64_to_binary_str(i64)");
    emit_line("declare ptr @i64_to_octal_str(i64)");
    emit_line("declare ptr @i64_to_lower_hex_str(i64)");
    emit_line("declare ptr @i64_to_upper_hex_str(i64)");
    emit_line("");

    // abs functions removed — abs_i32 is pure TML in core::num::integer, abs_f64 never called
    emit_line("");

    // float32_bits, float32_from_bits, float64_bits, float64_from_bits
    // — replaced with inline LLVM bitcast in math.cpp
    emit_line("");

    // infinity, nan, is_inf, is_nan — replaced with inline LLVM constants + fcmp in math.cpp
    emit_line("");

    // Nextafter runtime declarations
    emit_line("; Nextafter runtime");
    emit_line("declare double @nextafter(double, double)");
    emit_line("declare float @nextafter32(float, float)");
    emit_line("");

    // Channel runtime — REMOVED (Phase 24)
    // channel_create/send/recv/try_send/try_recv/close/destroy/len
    // Library uses Mutex+Condvar MPSC pattern, not Go-style channels

    // Mutex runtime — REMOVED (Phase 24)
    // mutex_create/lock/unlock/try_lock/destroy
    // migrated to @extern("tml_mutex_*") FFI in std::sync::mutex.tml

    // WaitGroup runtime — REMOVED (Phase 24)
    // waitgroup_create/add/done/wait/destroy
    // No WaitGroup primitive in TML library; use other sync patterns
    emit_line("");

    // Typed atomic operations — declared at module level for correct IR placement.
    // Codegen emitters and FuncSig registrations removed (Phase 24).
    // TML code uses @extern in core::sync.tml; these ensure declarations appear at module scope
    // and declared_externals_ prevents duplicate declarations from @extern.
    emit_line("; Typed atomic operations runtime");
    emit_line("declare i32 @atomic_fetch_add_i32(ptr, i32)");
    declared_externals_.insert("atomic_fetch_add_i32");
    emit_line("declare i32 @atomic_fetch_sub_i32(ptr, i32)");
    declared_externals_.insert("atomic_fetch_sub_i32");
    emit_line("declare i32 @atomic_load_i32(ptr)");
    declared_externals_.insert("atomic_load_i32");
    emit_line("declare void @atomic_store_i32(ptr, i32)");
    declared_externals_.insert("atomic_store_i32");
    emit_line("declare i32 @atomic_compare_exchange_i32(ptr, i32, i32)");
    declared_externals_.insert("atomic_compare_exchange_i32");
    emit_line("declare i32 @atomic_swap_i32(ptr, i32)");
    declared_externals_.insert("atomic_swap_i32");
    emit_line("declare void @atomic_fence()");
    declared_externals_.insert("atomic_fence");
    emit_line("declare void @atomic_fence_acquire()");
    declared_externals_.insert("atomic_fence_acquire");
    emit_line("declare void @atomic_fence_release()");
    declared_externals_.insert("atomic_fence_release");
    emit_line("");

    // Log runtime declarations (matches runtime/log.c)
    emit_line("; Log runtime");
    emit_line("declare void @rt_log_msg(i32, ptr, ptr)");
    declared_externals_.insert("rt_log_msg");
    emit_line("declare void @rt_log_set_level(i32)");
    declared_externals_.insert("rt_log_set_level");
    emit_line("declare i32 @rt_log_get_level()");
    declared_externals_.insert("rt_log_get_level");
    emit_line("declare i32 @rt_log_enabled(i32)");
    declared_externals_.insert("rt_log_enabled");
    emit_line("");

    // Phase 4.4: Advanced log runtime declarations
    emit_line("declare void @rt_log_set_filter(ptr)");
    declared_externals_.insert("rt_log_set_filter");
    emit_line("declare i32 @rt_log_module_enabled(i32, ptr)");
    declared_externals_.insert("rt_log_module_enabled");
    emit_line("declare void @rt_log_structured(i32, ptr, ptr, ptr)");
    declared_externals_.insert("rt_log_structured");
    emit_line("declare void @rt_log_set_format(i32)");
    declared_externals_.insert("rt_log_set_format");
    emit_line("declare i32 @rt_log_get_format()");
    declared_externals_.insert("rt_log_get_format");
    emit_line("declare i32 @rt_log_open_file(ptr)");
    declared_externals_.insert("rt_log_open_file");
    emit_line("declare void @rt_log_close_file()");
    declared_externals_.insert("rt_log_close_file");
    emit_line("declare i32 @rt_log_init_from_env()");
    declared_externals_.insert("rt_log_init_from_env");
    emit_line("");

    // Register log functions in functions_ map for lowlevel calls
    functions_["rt_log_msg"] =
        FuncInfo{"@rt_log_msg", "void (i32, ptr, ptr)", "void", {"i32", "ptr", "ptr"}};
    functions_["rt_log_set_level"] = FuncInfo{"@rt_log_set_level", "void (i32)", "void", {"i32"}};
    functions_["rt_log_get_level"] = FuncInfo{"@rt_log_get_level", "i32 ()", "i32", {}};
    functions_["rt_log_enabled"] = FuncInfo{"@rt_log_enabled", "i32 (i32)", "i32", {"i32"}};
    // Phase 4.4 function registrations
    functions_["rt_log_set_filter"] = FuncInfo{"@rt_log_set_filter", "void (ptr)", "void", {"ptr"}};
    functions_["rt_log_module_enabled"] =
        FuncInfo{"@rt_log_module_enabled", "i32 (i32, ptr)", "i32", {"i32", "ptr"}};
    functions_["rt_log_structured"] = FuncInfo{
        "@rt_log_structured", "void (i32, ptr, ptr, ptr)", "void", {"i32", "ptr", "ptr", "ptr"}};
    functions_["rt_log_set_format"] = FuncInfo{"@rt_log_set_format", "void (i32)", "void", {"i32"}};
    functions_["rt_log_get_format"] = FuncInfo{"@rt_log_get_format", "i32 ()", "i32", {}};
    functions_["rt_log_open_file"] = FuncInfo{"@rt_log_open_file", "i32 (ptr)", "i32", {"ptr"}};
    functions_["rt_log_close_file"] = FuncInfo{"@rt_log_close_file", "void ()", "void", {}};
    functions_["rt_log_init_from_env"] = FuncInfo{"@rt_log_init_from_env", "i32 ()", "i32", {}};

    // Glob runtime declarations
    emit_line("; Glob runtime");
    emit_line("declare ptr @glob_match(ptr, ptr)");
    declared_externals_.insert("glob_match");
    emit_line("declare ptr @glob_result_next(ptr)");
    declared_externals_.insert("glob_result_next");
    emit_line("declare i64 @glob_result_count(ptr)");
    declared_externals_.insert("glob_result_count");
    emit_line("declare void @glob_result_free(ptr)");
    declared_externals_.insert("glob_result_free");
    emit_line("declare i1 @glob_pattern_matches(ptr, ptr)");
    declared_externals_.insert("glob_pattern_matches");

    functions_["glob_match"] = FuncInfo{"@glob_match", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["glob_result_next"] = FuncInfo{"@glob_result_next", "ptr (ptr)", "ptr", {"ptr"}};
    functions_["glob_result_count"] = FuncInfo{"@glob_result_count", "i64 (ptr)", "i64", {"ptr"}};
    functions_["glob_result_free"] = FuncInfo{"@glob_result_free", "void (ptr)", "void", {"ptr"}};
    functions_["glob_pattern_matches"] =
        FuncInfo{"@glob_pattern_matches", "i1 (ptr, ptr)", "i1", {"ptr", "ptr"}};
    emit_line("");

    // String utilities (matches runtime/string.c)
    // Dead declares removed: str_concat, str_concat_3, str_concat_4, str_trim_start,
    // str_trim_end, str_find, str_rfind, str_parse_i64, str_replace, str_replace_first,
    // str_split, str_split_whitespace, str_lines, str_chars, str_repeat, str_parse_i32,
    // str_parse_f64, str_join — all migrated to pure TML in str.tml
    emit_line("; String utilities");
    emit_line("declare i32 @str_len(ptr)");
    emit_line("declare i32 @str_eq(ptr, ptr)");
    emit_line("declare i32 @str_hash(ptr)");
    emit_line("declare ptr @str_concat_opt(ptr, ptr)"); // O(1) amortized
    emit_line("declare ptr @str_substring(ptr, i32, i32)");
    emit_line("declare ptr @str_slice(ptr, i64, i64)");
    emit_line("declare i32 @str_contains(ptr, ptr)");
    emit_line("declare i32 @str_starts_with(ptr, ptr)");
    emit_line("declare i32 @str_ends_with(ptr, ptr)");
    emit_line("declare ptr @str_to_upper(ptr)");
    emit_line("declare ptr @str_to_lower(ptr)");
    emit_line("declare ptr @str_trim(ptr)");
    emit_line("declare i32 @str_char_at(ptr, i32)");
    emit_line("declare ptr @str_as_bytes(ptr)"); // used by Str::as_bytes() lowlevel
    emit_line("declare ptr @i64_to_str(i64)");
    emit_line("declare ptr @f64_to_str(double)");
    emit_line("");

    // Char/UTF-8 to string — REMOVED (Phase 18.2)
    // char_to_string, utf8_2byte/3byte/4byte_to_string migrated to pure TML
    // using mem_alloc + ptr_write in char/methods.tml and char/decode.tml
    emit_line("declare i64 @tml_random_seed()");
    emit_line("");

    // Register random_seed in functions_ map for lowlevel calls
    functions_["random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};
    // Also register with tml_ prefix for when called as tml_random_seed()
    functions_["tml_random_seed"] = FuncInfo{"@tml_random_seed", "i64 ()", "i64", {}};

    // Register string runtime functions in functions_ map for lowlevel calls
    // Only functions actively called from lowlevel blocks need entries here.
    // Functions called via compiler codegen (method_primitive_ext.cpp) or tests
    // go through try_gen_builtin_string() in call.cpp and don't need functions_[] entries.
    functions_["str_len"] = FuncInfo{"@str_len", "i32 (ptr)", "i32", {"ptr"}};
    functions_["str_hash"] = FuncInfo{"@str_hash", "i32 (ptr)", "i32", {"ptr"}};
    functions_["str_concat_opt"] =
        FuncInfo{"@str_concat_opt", "ptr (ptr, ptr)", "ptr", {"ptr", "ptr"}};
    functions_["str_substring"] =
        FuncInfo{"@str_substring", "ptr (ptr, i32, i32)", "ptr", {"ptr", "i32", "i32"}};
    functions_["str_slice"] =
        FuncInfo{"@str_slice", "ptr (ptr, i64, i64)", "ptr", {"ptr", "i64", "i64"}};
    functions_["str_char_at"] = FuncInfo{"@str_char_at", "i32 (ptr, i32)", "i32", {"ptr", "i32"}};
    functions_["str_as_bytes"] = FuncInfo{"@str_as_bytes", "ptr (ptr)", "ptr", {"ptr"}};

    // Register I/O functions for lowlevel calls (used by text.tml print/println methods)
    functions_["print_str"] = FuncInfo{"@print", "void (ptr)", "void", {"ptr"}};
    functions_["println_str"] = FuncInfo{"@println", "void (ptr)", "void", {"ptr"}};

    // Register float formatting runtime functions for lowlevel calls from core::fmt::float
    // Also register f64_to_str (used by text.tml lowlevel blocks for from_f64)
    functions_["f64_to_str"] = FuncInfo{"@f64_to_str", "ptr (double)", "ptr", {"double"}};
    functions_["f64_to_string"] = FuncInfo{"@f64_to_string", "ptr (double)", "ptr", {"double"}};
    functions_["f32_to_string"] = FuncInfo{"@f32_to_string", "ptr (float)", "ptr", {"float"}};
    functions_["f64_to_string_precision"] =
        FuncInfo{"@f64_to_string_precision", "ptr (double, i64)", "ptr", {"double", "i64"}};
    functions_["f32_to_string_precision"] =
        FuncInfo{"@f32_to_string_precision", "ptr (float, i64)", "ptr", {"float", "i64"}};
    functions_["f64_to_exp_string"] =
        FuncInfo{"@f64_to_exp_string", "ptr (double, i32)", "ptr", {"double", "i32"}};
    functions_["f32_to_exp_string"] =
        FuncInfo{"@f32_to_exp_string", "ptr (float, i32)", "ptr", {"float", "i32"}};
    // f32/f64_is_nan, f32/f64_is_infinite — REMOVED (Phase 27)
    // Now pure LLVM IR in string.cpp + pure TML in fmt/float.tml

    // Text type: now pure TML — all tml_text_* C runtime functions removed

    // Time functions: Phase 25 — migrated to @extern FFI in std::time.tml
    // Removed 10 declares: time_ms, time_us, time_ns, sleep_ms, sleep_us,
    // elapsed_ms, elapsed_us, elapsed_ns, instant_now, instant_elapsed

    // Memory functions (matches runtime/mem.c)
    emit_line("; Memory functions");
    emit_line("declare ptr @mem_alloc(i64)");
    emit_line("declare ptr @mem_alloc_zeroed(i64)");
    emit_line("declare ptr @mem_realloc(ptr, i64)");
    emit_line("declare void @mem_free(ptr)");
    emit_line("declare void @mem_copy(ptr, ptr, i64)");
    emit_line("declare void @mem_move(ptr, ptr, i64)");
    emit_line("declare void @mem_set(ptr, i32, i64)");
    emit_line("declare void @mem_zero(ptr, i64)");
    emit_line("declare i32 @mem_compare(ptr, ptr, i64)");
    emit_line("declare i32 @mem_eq(ptr, ptr, i64)");
    emit_line("");

    // Object pool functions (for @pool classes)
    emit_line("; Object pool functions");
    emit_line("declare ptr @pool_acquire(ptr, i64)");
    emit_line("declare void @pool_release(ptr, ptr)");
    emit_line("declare void @pool_init(ptr, i64, i64)");
    emit_line("declare void @pool_destroy(ptr)");
    emit_line("declare i64 @pool_count(ptr)");
    emit_line("declare i64 @pool_capacity(ptr)");
    emit_line("");

    // Thread-local pool functions (for @pool(thread_local: true) classes)
    emit_line("; Thread-local pool functions");
    emit_line("declare ptr @tls_pool_acquire(ptr, i64)");
    emit_line("declare void @tls_pool_release(ptr, ptr, i64)");
    emit_line("declare void @tls_pools_cleanup()");
    emit_line("declare i32 @tls_pool_stats(ptr, ptr, ptr)");
    emit_line("");

    // Network socket and TLS declarations removed — now handled by @extern in
    // std::net::sys, std::net::tls, and emit_module_lowlevel_decls()

    // Format strings for print/println
    // Size calculation: count actual bytes (each escape like \0A = 1 byte, not 3)
    emit_line("; Format strings");
    emit_line("@.fmt.int = private constant [4 x i8] c\"%d\\0A\\00\"");        // %d\n\0 = 4 bytes
    emit_line("@.fmt.int.no_nl = private constant [3 x i8] c\"%d\\00\"");      // %d\0 = 3 bytes
    emit_line("@.fmt.i64 = private constant [5 x i8] c\"%ld\\0A\\00\"");       // %ld\n\0 = 5 bytes
    emit_line("@.fmt.i64.no_nl = private constant [4 x i8] c\"%ld\\00\"");     // %ld\0 = 4 bytes
    emit_line("@.fmt.float = private constant [4 x i8] c\"%f\\0A\\00\"");      // %f\n\0 = 4 bytes
    emit_line("@.fmt.float.no_nl = private constant [3 x i8] c\"%f\\00\"");    // %f\0 = 3 bytes
    emit_line("@.fmt.float3 = private constant [6 x i8] c\"%.3f\\0A\\00\"");   // %.3f\n\0 = 6 bytes
    emit_line("@.fmt.float3.no_nl = private constant [5 x i8] c\"%.3f\\00\""); // %.3f\0 = 5 bytes
    emit_line("@.fmt.str.no_nl = private constant [3 x i8] c\"%s\\00\"");      // %s\0 = 3 bytes
    emit_line("@.str.true = private constant [5 x i8] c\"true\\00\"");         // true\0 = 5 bytes
    emit_line("@.str.false = private constant [6 x i8] c\"false\\00\"");       // false\0 = 6 bytes
    emit_line("@.str.space = private constant [2 x i8] c\" \\00\"");           // " "\0 = 2 bytes
    emit_line("@.str.newline = private constant [2 x i8] c\"\\0A\\00\"");      // \n\0 = 2 bytes
    emit_line("");
}

// emit_module_lowlevel_decls, emit_module_pure_tml_functions, and
// emit_string_constants are in runtime_modules.cpp

} // namespace tml::codegen
