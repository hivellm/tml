// LLVM IR generator - Runtime declarations and module imports
// Handles: emit_header, emit_runtime_decls, emit_module_lowlevel_decls
// Handles: emit_module_pure_tml_functions, emit_string_constants

#include "codegen/llvm_ir_gen.hpp"
#include "lexer/lexer.hpp"
#include "lexer/source.hpp"
#include "parser/parser.hpp"

#include <filesystem>

namespace tml::codegen {

void LLVMIRGen::emit_header() {
    emit_line("; Generated by TML Compiler");
    emit_line("target triple = \"" + options_.target_triple + "\"");
    emit_line("");
}

void LLVMIRGen::emit_runtime_decls() {
    // String type: { ptr, i64 } (pointer to data, length)
    emit_line("; Runtime type declarations");
    emit_line("%struct.tml_str = type { ptr, i64 }");

    // File I/O types (from std::file)
    emit_line("%struct.File = type { ptr }"); // handle field
    emit_line("%struct.Path = type { ptr }"); // path string field

    // Core comparison type (core::cmp)
    // Ordering is a simple enum: Less=0, Equal=1, Greater=2
    emit_line("%struct.Ordering = type { i32 }");
    emit_line("");

    // External C functions
    emit_line("; External function declarations");
    emit_line("declare i32 @printf(ptr, ...)");
    emit_line("declare i32 @puts(ptr)");
    emit_line("declare i32 @putchar(i32)");
    emit_line("declare ptr @malloc(i64)");
    emit_line("declare void @free(ptr)");
    emit_line("declare void @exit(i32) noreturn");
    emit_line("");

    // TML runtime functions
    emit_line("; TML runtime functions");
    emit_line("declare void @panic(ptr) noreturn");
    emit_line("");

    // Note: TML test assertions are now provided by the test module's TML code
    // They call panic() internally and don't need external declarations
    emit_line("");

    // TML code coverage functions
    emit_line("; TML code coverage");
    emit_line("declare void @cover_func(ptr)");
    emit_line("declare void @cover_line(ptr, i32)");
    emit_line("declare void @cover_branch(ptr, i32, i32)");
    emit_line("declare void @print_coverage_report()");
    emit_line("declare i32 @get_covered_func_count()");
    emit_line("declare i32 @get_covered_line_count()");
    emit_line("declare i32 @get_covered_branch_count()");
    emit_line("declare void @reset_coverage()");
    emit_line("declare i32 @is_func_covered(ptr)");
    emit_line("declare i32 @get_coverage_percent()");
    emit_line("");

    // Threading runtime declarations
    emit_line("; Threading runtime (tml_runtime.c)");
    emit_line("declare ptr @thread_spawn(ptr, ptr)");
    emit_line("declare void @thread_join(ptr)");
    emit_line("declare void @thread_yield()");
    emit_line("declare void @thread_sleep(i32)");
    emit_line("declare i32 @thread_id()");
    emit_line("");

    // I/O functions (print, println) - polymorphic, accept any type
    emit_line("; I/O functions");
    emit_line("declare void @print(ptr)");
    emit_line("declare void @println(ptr)");
    emit_line("");

    // NOTE: Math functions moved to core::math module
    // Import with: use core::math

    // NOTE: Assertion functions moved to test module
    // Import with: use test
    emit_line("; Black box (prevent optimization)");
    emit_line("declare i32 @black_box_i32(i32)");
    emit_line("declare i64 @black_box_i64(i64)");
    emit_line("; SIMD operations (auto-vectorized)");
    emit_line("declare i64 @simd_sum_i32(ptr, i64)");
    emit_line("declare i64 @simd_sum_i64(ptr, i64)");
    emit_line("declare double @simd_sum_f64(ptr, i64)");
    emit_line("declare double @simd_dot_f64(ptr, ptr, i64)");
    emit_line("declare void @simd_fill_i32(ptr, i32, i64)");
    emit_line("declare void @simd_add_i32(ptr, ptr, ptr, i64)");
    emit_line("declare void @simd_mul_i32(ptr, ptr, ptr, i64)");
    emit_line("");

    // Float functions
    emit_line("; Float functions");
    emit_line("declare ptr @float_to_fixed(double, i32)");
    emit_line("declare ptr @float_to_precision(double, i32)");
    emit_line("declare ptr @float_to_string(double)");
    emit_line("declare double @int_to_float(i32)");
    emit_line("declare double @i64_to_float(i64)");
    emit_line("declare i32 @float_to_int(double)");
    emit_line("declare i64 @float_to_i64(double)");
    emit_line("declare i32 @float_round(double)");
    emit_line("declare i32 @float_floor(double)");
    emit_line("declare i32 @float_ceil(double)");
    emit_line("declare double @float_abs(double)");
    emit_line("declare double @float_sqrt(double)");
    emit_line("declare double @float_pow(double, i32)");
    emit_line("");

    // Integer to string conversion
    emit_line("; Integer to string");
    emit_line("declare ptr @i32_to_string(i32)");
    emit_line("declare ptr @i64_to_string(i64)");
    emit_line("declare ptr @bool_to_string(i1)");
    emit_line("");

    // Overloaded abs functions
    emit_line("; Overloaded abs");
    emit_line("declare i32 @abs_i32(i32)");
    emit_line("declare double @abs_f64(double)");
    emit_line("");

    // Bit manipulation runtime declarations
    emit_line("; Bit manipulation runtime");
    emit_line("declare i32 @float32_bits(float)");
    emit_line("declare float @float32_from_bits(i32)");
    emit_line("declare i64 @float64_bits(double)");
    emit_line("declare double @float64_from_bits(i64)");
    emit_line("");

    // Special float value runtime declarations
    emit_line("; Special float values runtime");
    emit_line("declare double @infinity(i32)");
    emit_line("declare double @nan()");
    emit_line("declare i32 @is_inf(double, i32)");
    emit_line("declare i32 @is_nan(double)");
    emit_line("");

    // Nextafter runtime declarations
    emit_line("; Nextafter runtime");
    emit_line("declare double @nextafter(double, double)");
    emit_line("declare float @nextafter32(float, float)");
    emit_line("");

    // Channel runtime declarations
    emit_line("; Channel runtime (Go-style)");
    emit_line("declare ptr @channel_create()");
    emit_line("declare i32 @channel_send(ptr, i32)");
    emit_line("declare i32 @channel_recv(ptr, ptr)");
    emit_line("declare i32 @channel_try_send(ptr, i32)");
    emit_line("declare i32 @channel_try_recv(ptr, ptr)");
    emit_line("declare void @channel_close(ptr)");
    emit_line("declare void @channel_destroy(ptr)");
    emit_line("declare i32 @channel_len(ptr)");
    emit_line("");

    // Mutex runtime declarations
    emit_line("; Mutex runtime");
    emit_line("declare ptr @mutex_create()");
    emit_line("declare void @mutex_lock(ptr)");
    emit_line("declare void @mutex_unlock(ptr)");
    emit_line("declare i32 @mutex_try_lock(ptr)");
    emit_line("declare void @mutex_destroy(ptr)");
    emit_line("");

    // WaitGroup runtime declarations
    emit_line("; WaitGroup runtime (Go-style)");
    emit_line("declare ptr @waitgroup_create()");
    emit_line("declare void @waitgroup_add(ptr, i32)");
    emit_line("declare void @waitgroup_done(ptr)");
    emit_line("declare void @waitgroup_wait(ptr)");
    emit_line("declare void @waitgroup_destroy(ptr)");
    emit_line("");

    // Atomic counter runtime declarations
    emit_line("; Atomic counter runtime");
    emit_line("declare ptr @atomic_counter_create(i32)");
    emit_line("declare i32 @atomic_counter_inc(ptr)");
    emit_line("declare i32 @atomic_counter_dec(ptr)");
    emit_line("declare i32 @atomic_counter_get(ptr)");
    emit_line("declare void @atomic_counter_set(ptr, i32)");
    emit_line("declare void @atomic_counter_destroy(ptr)");
    emit_line("");

    // List runtime declarations
    emit_line("; List (dynamic array) runtime");
    emit_line("declare ptr @list_create(i64)");
    emit_line("declare void @list_destroy(ptr)");
    emit_line("declare void @list_push(ptr, i64)");
    emit_line("declare i64 @list_pop(ptr)");
    emit_line("declare i64 @list_get(ptr, i64)");
    emit_line("declare void @list_set(ptr, i64, i64)");
    emit_line("declare i64 @list_len(ptr)");
    emit_line("declare i64 @list_capacity(ptr)");
    emit_line("declare void @list_clear(ptr)");
    emit_line("declare i32 @list_is_empty(ptr)");
    emit_line("");

    // HashMap runtime declarations
    emit_line("; HashMap runtime");
    emit_line("declare ptr @hashmap_create(i64)");
    emit_line("declare void @hashmap_destroy(ptr)");
    emit_line("declare void @hashmap_set(ptr, i64, i64)");
    emit_line("declare i64 @hashmap_get(ptr, i64)");
    emit_line("declare i1 @hashmap_has(ptr, i64)");
    emit_line("declare i1 @hashmap_remove(ptr, i64)");
    emit_line("declare i64 @hashmap_len(ptr)");
    emit_line("declare void @hashmap_clear(ptr)");
    emit_line("");

    // Buffer runtime declarations
    emit_line("; Buffer runtime");
    emit_line("declare ptr @buffer_create(i64)");
    emit_line("declare void @buffer_destroy(ptr)");
    emit_line("declare void @buffer_write_byte(ptr, i32)");
    emit_line("declare void @buffer_write_i32(ptr, i32)");
    emit_line("declare void @buffer_write_i64(ptr, i64)");
    emit_line("declare i32 @buffer_read_byte(ptr)");
    emit_line("declare i32 @buffer_read_i32(ptr)");
    emit_line("declare i64 @buffer_read_i64(ptr)");
    emit_line("declare i64 @buffer_len(ptr)");
    emit_line("declare i64 @buffer_capacity(ptr)");
    emit_line("declare i64 @buffer_remaining(ptr)");
    emit_line("declare void @buffer_clear(ptr)");
    emit_line("declare void @buffer_reset_read(ptr)");
    emit_line("");

    // File I/O runtime declarations
    emit_line("; File I/O runtime");
    emit_line("declare ptr @file_open_read(ptr)");
    emit_line("declare ptr @file_open_write(ptr)");
    emit_line("declare ptr @file_open_append(ptr)");
    emit_line("declare void @file_close(ptr)");
    emit_line("declare i1 @file_is_open(ptr)");
    emit_line("declare ptr @file_read_line(ptr)");
    emit_line("declare i1 @file_write_str(ptr, ptr)");
    emit_line("declare i64 @file_size(ptr)");
    emit_line("declare ptr @file_read_all(ptr)");
    emit_line("declare i1 @file_write_all(ptr, ptr)");
    emit_line("declare i1 @file_append_all(ptr, ptr)");
    emit_line("");

    // Path utilities runtime declarations
    emit_line("; Path utilities runtime");
    emit_line("declare i1 @path_exists(ptr)");
    emit_line("declare i1 @path_is_file(ptr)");
    emit_line("declare i1 @path_is_dir(ptr)");
    emit_line("declare i1 @path_create_dir(ptr)");
    emit_line("declare i1 @path_create_dir_all(ptr)");
    emit_line("declare i1 @path_remove(ptr)");
    emit_line("declare i1 @path_remove_dir(ptr)");
    emit_line("declare i1 @path_rename(ptr, ptr)");
    emit_line("declare i1 @path_copy(ptr, ptr)");
    emit_line("declare ptr @path_join(ptr, ptr)");
    emit_line("declare ptr @path_parent(ptr)");
    emit_line("declare ptr @path_filename(ptr)");
    emit_line("declare ptr @path_extension(ptr)");
    emit_line("declare ptr @path_absolute(ptr)");
    emit_line("");

    // String utilities (matches runtime/string.c)
    emit_line("; String utilities");
    emit_line("declare i32 @str_len(ptr)");
    emit_line("declare i32 @str_eq(ptr, ptr)");
    emit_line("declare i32 @str_hash(ptr)");
    emit_line("declare ptr @str_concat(ptr, ptr)");
    emit_line("declare ptr @str_substring(ptr, i32, i32)");
    emit_line("declare i32 @str_contains(ptr, ptr)");
    emit_line("declare i32 @str_starts_with(ptr, ptr)");
    emit_line("declare i32 @str_ends_with(ptr, ptr)");
    emit_line("declare ptr @str_to_upper(ptr)");
    emit_line("declare ptr @str_to_lower(ptr)");
    emit_line("declare ptr @str_trim(ptr)");
    emit_line("declare i32 @str_char_at(ptr, i32)");
    emit_line("declare ptr @i64_to_str(i64)");
    emit_line("declare ptr @f64_to_str(double)");
    emit_line("");

    // Char utilities (matches runtime/string.c)
    emit_line("; Char utilities");
    emit_line("declare i32 @char_is_alphabetic(i32)");
    emit_line("declare i32 @char_is_numeric(i32)");
    emit_line("declare i32 @char_is_alphanumeric(i32)");
    emit_line("declare i32 @char_is_whitespace(i32)");
    emit_line("declare i32 @char_is_uppercase(i32)");
    emit_line("declare i32 @char_is_lowercase(i32)");
    emit_line("declare i32 @char_is_ascii(i32)");
    emit_line("declare i32 @char_is_control(i32)");
    emit_line("declare i32 @char_to_uppercase(i32)");
    emit_line("declare i32 @char_to_lowercase(i32)");
    emit_line("declare i32 @char_to_digit(i32, i32)");
    emit_line("declare i32 @char_from_digit(i32, i32)");
    emit_line("declare i32 @char_code(i32)");
    emit_line("declare i32 @char_from_code(i32)");
    emit_line("");

    // StringBuilder utilities (matches runtime/string.c)
    emit_line("; StringBuilder utilities");
    emit_line("declare ptr @strbuilder_create(i64)");
    emit_line("declare void @strbuilder_destroy(ptr)");
    emit_line("declare void @strbuilder_push(ptr, i32)");
    emit_line("declare void @strbuilder_push_str(ptr, ptr)");
    emit_line("declare i64 @strbuilder_len(ptr)");
    emit_line("declare i64 @strbuilder_capacity(ptr)");
    emit_line("declare void @strbuilder_clear(ptr)");
    emit_line("declare ptr @strbuilder_to_str(ptr)");
    emit_line("declare ptr @strbuilder_as_str(ptr)");
    emit_line("");

    // Time functions (matches runtime/time.c)
    emit_line("; Time functions");
    emit_line("declare i32 @time_ms()");
    emit_line("declare i64 @time_us()");
    emit_line("declare i64 @time_ns()");
    emit_line("declare void @sleep_ms(i32)");
    emit_line("declare void @sleep_us(i64)");
    emit_line("declare i32 @elapsed_ms(i32)");
    emit_line("declare i64 @elapsed_us(i64)");
    emit_line("declare i64 @elapsed_ns(i64)");
    emit_line("");

    // Memory functions (matches runtime/mem.c)
    emit_line("; Memory functions");
    emit_line("declare ptr @mem_alloc(i64)");
    emit_line("declare ptr @mem_alloc_zeroed(i64)");
    emit_line("declare ptr @mem_realloc(ptr, i64)");
    emit_line("declare void @mem_free(ptr)");
    emit_line("declare void @mem_copy(ptr, ptr, i64)");
    emit_line("declare void @mem_move(ptr, ptr, i64)");
    emit_line("declare void @mem_set(ptr, i32, i64)");
    emit_line("declare void @mem_zero(ptr, i64)");
    emit_line("declare i32 @mem_compare(ptr, ptr, i64)");
    emit_line("declare i32 @mem_eq(ptr, ptr, i64)");
    emit_line("");

    // Format strings for print/println
    // Size calculation: count actual bytes (each escape like \0A = 1 byte, not 3)
    emit_line("; Format strings");
    emit_line("@.fmt.int = private constant [4 x i8] c\"%d\\0A\\00\"");        // %d\n\0 = 4 bytes
    emit_line("@.fmt.int.no_nl = private constant [3 x i8] c\"%d\\00\"");      // %d\0 = 3 bytes
    emit_line("@.fmt.i64 = private constant [5 x i8] c\"%ld\\0A\\00\"");       // %ld\n\0 = 5 bytes
    emit_line("@.fmt.i64.no_nl = private constant [4 x i8] c\"%ld\\00\"");     // %ld\0 = 4 bytes
    emit_line("@.fmt.float = private constant [4 x i8] c\"%f\\0A\\00\"");      // %f\n\0 = 4 bytes
    emit_line("@.fmt.float.no_nl = private constant [3 x i8] c\"%f\\00\"");    // %f\0 = 3 bytes
    emit_line("@.fmt.float3 = private constant [6 x i8] c\"%.3f\\0A\\00\"");   // %.3f\n\0 = 6 bytes
    emit_line("@.fmt.float3.no_nl = private constant [5 x i8] c\"%.3f\\00\""); // %.3f\0 = 5 bytes
    emit_line("@.fmt.str.no_nl = private constant [3 x i8] c\"%s\\00\"");      // %s\0 = 3 bytes
    emit_line("@.str.true = private constant [5 x i8] c\"true\\00\"");         // true\0 = 5 bytes
    emit_line("@.str.false = private constant [6 x i8] c\"false\\00\"");       // false\0 = 6 bytes
    emit_line("@.str.space = private constant [2 x i8] c\" \\00\"");           // " "\0 = 2 bytes
    emit_line("@.str.newline = private constant [2 x i8] c\"\\0A\\00\"");      // \n\0 = 2 bytes
    emit_line("");
}

void LLVMIRGen::emit_module_lowlevel_decls() {
    // Emit declarations for lowlevel functions from imported modules
    if (!env_.module_registry()) {
        return;
    }

    emit_line("; Lowlevel functions from imported modules");

    // Get all modules from registry
    const auto& registry = env_.module_registry();
    const auto& all_modules = registry->get_all_modules();

    for (const auto& [module_name, module] : all_modules) {
        for (const auto& [func_name, func_sig] : module.functions) {
            if (func_sig.is_lowlevel) {
                // Generate LLVM declaration using semantic types
                std::string llvm_ret_type = llvm_type_from_semantic(func_sig.return_type);

                std::string params_str;
                for (size_t i = 0; i < func_sig.params.size(); ++i) {
                    if (i > 0)
                        params_str += ", ";
                    params_str += llvm_type_from_semantic(func_sig.params[i]);
                }

                // Emit declaration with tml_ prefix
                emit_line("declare " + llvm_ret_type + " @tml_" + func_name + "(" + params_str +
                          ")");
            }
        }
    }

    emit_line("");
}

void LLVMIRGen::emit_module_pure_tml_functions() {
    // Emit LLVM IR for pure TML functions from imported modules
    if (!env_.module_registry()) {
        return;
    }

    const auto& registry = env_.module_registry();
    const auto& all_modules = registry->get_all_modules();

    emit_line("; Pure TML functions from imported modules");

    for (const auto& [module_name, module] : all_modules) {
        // Check if module has pure TML functions
        if (!module.has_pure_tml_functions || module.source_code.empty()) {
            continue;
        }

        // Re-parse the module source code
        auto source = lexer::Source::from_string(module.source_code, module.file_path);
        lexer::Lexer lex(source);
        auto tokens = lex.tokenize();

        if (lex.has_errors()) {
            continue; // Skip modules with lexer errors
        }

        parser::Parser parser(std::move(tokens));
        auto mod_name = std::filesystem::path(module.file_path).stem().string();
        auto parse_result = parser.parse_module(mod_name);

        if (std::holds_alternative<std::vector<parser::ParseError>>(parse_result)) {
            continue; // Skip modules with parse errors
        }

        // Store the AST persistently so that pending_generic_funcs_ pointers remain valid
        imported_module_asts_.push_back(std::get<parser::Module>(std::move(parse_result)));
        const auto& parsed_module = imported_module_asts_.back();

        emit_line("; Module: " + module_name);

        // Set module prefix for function name generation
        current_module_prefix_ = module_name;

        // First pass: register struct/enum declarations (including generic ones)
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::StructDecl>()) {
                const auto& s = decl->as<parser::StructDecl>();
                if (s.vis == parser::Visibility::Public) {
                    gen_struct_decl(
                        s); // This registers generic structs in pending_generic_structs_
                }
            } else if (decl->is<parser::EnumDecl>()) {
                const auto& e = decl->as<parser::EnumDecl>();
                if (e.vis == parser::Visibility::Public) {
                    gen_enum_decl(e); // This registers generic enums in pending_generic_enums_
                }
            }
        }

        // Second pass: generate code for each public function
        for (const auto& decl : parsed_module.decls) {
            if (decl->is<parser::FuncDecl>()) {
                const auto& func = decl->as<parser::FuncDecl>();

                // Only generate code for public, non-lowlevel functions with bodies
                if (func.vis == parser::Visibility::Public && !func.is_unsafe &&
                    func.body.has_value()) {
                    gen_func_decl(func);
                }
            }
            // Also handle impl blocks - generate methods for imported types
            else if (decl->is<parser::ImplDecl>()) {
                const auto& impl = decl->as<parser::ImplDecl>();

                // Get the type name for the impl
                std::string type_name;
                if (impl.self_type && impl.self_type->is<parser::NamedType>()) {
                    const auto& named = impl.self_type->as<parser::NamedType>();
                    if (!named.path.segments.empty()) {
                        type_name = named.path.segments.back();
                    }
                }

                if (!type_name.empty()) {
                    // For generic types (like Maybe[T]), ensure the generic struct type exists
                    // This is needed because impl methods use the base type name
                    auto enum_it = pending_generic_enums_.find(type_name);
                    if (enum_it != pending_generic_enums_.end()) {
                        // Check if generic struct type already declared
                        if (struct_types_.find(type_name) == struct_types_.end()) {
                            // Emit generic type definition with i64 payload (fits all
                            // instantiations)
                            type_defs_buffer_ << "%struct." << type_name
                                              << " = type { i32, i64 }\n";
                            struct_types_[type_name] = "%struct." + type_name;
                        }
                    }

                    // First pass: pre-instantiate generic types used in method signatures
                    for (const auto& method : impl.methods) {
                        if (method.return_type.has_value()) {
                            const auto& ret_type = *method.return_type;
                            if (ret_type->is<parser::NamedType>()) {
                                const auto& named = ret_type->as<parser::NamedType>();
                                if (named.generics.has_value() && !named.generics->args.empty()) {
                                    // Check if this is a pending generic enum
                                    std::string base_name;
                                    if (!named.path.segments.empty()) {
                                        base_name = named.path.segments.back();
                                    }
                                    auto it = pending_generic_enums_.find(base_name);
                                    if (it != pending_generic_enums_.end()) {
                                        // Convert parser type args to semantic types
                                        std::vector<types::TypePtr> type_args;
                                        for (const auto& arg : named.generics->args) {
                                            type_args.push_back(
                                                resolve_parser_type_with_subs(*arg, {}));
                                        }
                                        // Check if already instantiated
                                        std::string mangled =
                                            mangle_struct_name(base_name, type_args);
                                        if (struct_types_.find(mangled) == struct_types_.end()) {
                                            gen_enum_instantiation(*it->second, type_args);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Second pass: generate the methods
                    for (const auto& method : impl.methods) {
                        // Generate code for public, non-lowlevel methods with bodies
                        if (method.vis == parser::Visibility::Public && !method.is_unsafe &&
                            method.body.has_value()) {
                            // Generate impl method with qualified name
                            gen_impl_method(type_name, method);
                        }
                    }
                }
            }
        }

        // Clear module prefix after processing this module
        current_module_prefix_.clear();
    }

    emit_line("");
}

void LLVMIRGen::emit_string_constants() {
    if (string_literals_.empty())
        return;

    emit_line("; String constants");
    for (const auto& [name, value] : string_literals_) {
        // Escape the string and add null terminator
        std::string escaped;
        for (char c : value) {
            if (c == '\n')
                escaped += "\\0A";
            else if (c == '\t')
                escaped += "\\09";
            else if (c == '\\')
                escaped += "\\5C";
            else if (c == '"')
                escaped += "\\22";
            else
                escaped += c;
        }
        escaped += "\\00";

        emit_line(name + " = private constant [" + std::to_string(value.size() + 1) + " x i8] c\"" +
                  escaped + "\"");
    }
    emit_line("");
}

} // namespace tml::codegen
