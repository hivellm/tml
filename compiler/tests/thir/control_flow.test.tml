use test

// ============================================================================
// THIR Control Flow Tests
//
// Tests that THIR correctly lowers control flow constructs (if/else, when,
// loops, break, continue, return) to MIR basic blocks.
// ============================================================================

// ============ If/Else ============

@test
func test_if_else_value() -> I32 {
    let x: I32 = 10
    let result: I32 = if x > 5 then 1 else 0
    assert_eq(result, 1, "if x > 5 then 1 else 0")
    return 0
}

@test
func test_nested_if() -> I32 {
    let x: I32 = 15
    let result: I32 = if x > 20 then 3
        else if x > 10 then 2
        else 1
    assert_eq(result, 2, "nested if: 15 > 10 so result is 2")
    return 0
}

@test
func test_if_with_block() -> I32 {
    let x: I32 = 5
    let mut result: I32 = 0
    if x > 3 {
        result = 10
    } else {
        result = 20
    }
    assert_eq(result, 10, "if block: x > 3 so result is 10")
    return 0
}

// ============ While Loops ============

@test
func test_while_loop() -> I32 {
    let mut i: I32 = 0
    let mut sum: I32 = 0
    while i < 5 {
        sum = sum + i
        i = i + 1
    }
    assert_eq(sum, 10, "sum of 0..4 = 10")
    assert_eq(i, 5, "loop counter ends at 5")
    return 0
}

@test
func test_while_break() -> I32 {
    let mut i: I32 = 0
    while true {
        if i >= 3 {
            break
        }
        i = i + 1
    }
    assert_eq(i, 3, "break at i == 3")
    return 0
}

@test
func test_while_continue() -> I32 {
    let mut i: I32 = 0
    let mut sum: I32 = 0
    while i < 10 {
        i = i + 1
        if i % 2 == 0 {
            continue
        }
        sum = sum + i
    }
    // sum of odd numbers 1,3,5,7,9 = 25
    assert_eq(sum, 25, "sum of odd 1..9 = 25")
    return 0
}

// ============ Early Return ============

func helper_early_return(x: I32) -> I32 {
    if x < 0 {
        return -1
    }
    if x == 0 {
        return 0
    }
    return 1
}

@test
func test_early_return() -> I32 {
    assert_eq(helper_early_return(-5), -1, "negative returns -1")
    assert_eq(helper_early_return(0), 0, "zero returns 0")
    assert_eq(helper_early_return(10), 1, "positive returns 1")
    return 0
}

// ============ Nested Loops ============

@test
func test_nested_while() -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 0
    while i < 3 {
        let mut j: I32 = 0
        while j < 3 {
            count = count + 1
            j = j + 1
        }
        i = i + 1
    }
    assert_eq(count, 9, "3x3 nested loop = 9 iterations")
    return 0
}
