use test

// ============================================================================
// THIR Closures & Higher-Order Functions Tests
// ============================================================================

// ============ Basic Closures ============

@test
func test_closure_simple() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    assert_eq(double(7), 14, "closure: 7 * 2 = 14")
    return 0
}

@test
func test_closure_capture() -> I32 {
    let x: I32 = 10
    let add_x: func(I32) -> I32 = do(y: I32) -> I32 { x + y }
    assert_eq(add_x(5), 15, "closure: x(10) + 5 = 15")
    return 0
}

@test
func test_closure_multi_arg() -> I32 {
    let add: func(I32, I32) -> I32 = do(a: I32, b: I32) -> I32 { a + b }
    assert_eq(add(3, 4), 7, "closure: 3 + 4 = 7")
    return 0
}

// ============ Functions as Arguments ============

func apply_fn(f: func(I32) -> I32, value: I32) -> I32 {
    return f(value)
}

@test
func test_function_as_argument() -> I32 {
    let triple: func(I32) -> I32 = do(x: I32) -> I32 { x * 3 }
    let result: I32 = apply_fn(triple, 5)
    assert_eq(result, 15, "apply(triple, 5) = 15")
    return 0
}

// ============ Closures with Conditionals ============

@test
func test_closure_with_if() -> I32 {
    let abs_val: func(I32) -> I32 = do(x: I32) -> I32 {
        if x < 0 then 0 - x else x
    }
    assert_eq(abs_val(5), 5, "abs(5) = 5")
    assert_eq(abs_val(-3), 3, "abs(-3) = 3")
    return 0
}
