// Test capturing closures with fat pointer architecture
// Verifies that closures that capture variables work correctly
// even when stored in variables and called indirectly.
use test

@test
func test_capture_single_var() -> I32 {
    let offset: I32 = 10
    let add_offset = do(x: I32) -> I32 { x + offset }
    let result: I32 = add_offset(5)
    assert_eq(result, 15, "5 + 10 should be 15")
    return 0
}

@test
func test_capture_multiple_vars() -> I32 {
    let a: I32 = 3
    let b: I32 = 7
    let sum_with = do(x: I32) -> I32 { x + a + b }
    let result: I32 = sum_with(5)
    assert_eq(result, 15, "5 + 3 + 7 should be 15")
    return 0
}

@test
func test_capture_in_annotated_var() -> I32 {
    let multiplier: I32 = 4
    let mul: func(I32) -> I32 = do(x: I32) -> I32 { x * multiplier }
    let result: I32 = mul(5)
    assert_eq(result, 20, "5 * 4 should be 20")
    return 0
}

@test
func test_non_capturing_to_func_type() -> I32 {
    // Non-capturing closure stored as func type should work
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = double(21)
    assert_eq(result, 42, "21 * 2 should be 42")
    return 0
}

// Helper function that takes a function pointer
func apply_func(f: func(I32) -> I32, x: I32) -> I32 {
    return f(x)
}

@test
func test_non_capturing_passed_to_function() -> I32 {
    // Non-capturing closure passed to function expecting func(I32) -> I32
    let result: I32 = apply_func(do(x: I32) -> I32 { x + 100 }, 5)
    assert_eq(result, 105, "5 + 100 should be 105")
    return 0
}
