// Test for associated type lookup from concrete types
// This tests the lookup_associated_type helper function
use test
use core::range::*

// This test uses the concrete RangeIterI64 type which has:
// impl Iterator for RangeIterI64 { type Item = I64 }
//
// When other code resolves I::Item where I -> RangeIterI64,
// it should find that Item = I64

@test
func test_range_iter_basic() -> I32 {
    var iter: RangeIterI64 = RangeIterI64 { current: 0, end: 5 }

    // Test that next() returns Maybe[I64]
    when iter.next() {
        Just(v) => assert_eq(v, 0, "first should be 0"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 1, "second should be 1"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 2, "third should be 2"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 3, "fourth should be 3"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 4, "fifth should be 4"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(_) => assert(false, "should be Nothing after exhausted"),
        Nothing => assert(true, "correctly exhausted")
    }

    return 0
}

@test
func test_range_inclusive_iter() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: 1,
        end: 3,
        exhausted: false
    }

    // Inclusive range [1, 3] should yield 1, 2, 3
    when iter.next() {
        Just(v) => assert_eq(v, 1, "first should be 1"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 2, "second should be 2"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(v) => assert_eq(v, 3, "third should be 3"),
        Nothing => assert(false, "should not be Nothing")
    }

    when iter.next() {
        Just(_) => assert(false, "should be Nothing after 3"),
        Nothing => assert(true, "correctly exhausted")
    }

    return 0
}
