// Test async/await type checking and execution
use test::*

// Simple async function
async func async_simple() -> I64 {
    return 42
}

// Async function that calls another async function (postfix .await style)
async func async_chain_postfix() -> I64 {
    let result: I64 = async_simple().await
    return result + 1
}

// Async function that calls another async function (prefix await style)
async func async_chain_prefix() -> I64 {
    let result: I64 = await async_simple()
    return result + 1
}

// Async function with multiple awaits (mixed styles)
async func async_multiple() -> I64 {
    let a: I64 = async_simple().await
    let b: I64 = await async_simple()
    return a + b
}

// Async function with computation
async func async_compute(x: I64) -> I64 {
    return x * 2 + 10
}

@test
func test_async_simple() {
    // Test block_on with simple async function
    let result: I64 = block_on(async_simple())
    assert_eq(result, 42)
}

@test
func test_async_chain_postfix() {
    // Test chained async with postfix .await
    let result: I64 = block_on(async_chain_postfix())
    assert_eq(result, 43)
}

@test
func test_async_chain_prefix() {
    // Test chained async with prefix await
    let result: I64 = block_on(async_chain_prefix())
    assert_eq(result, 43)
}

@test
func test_async_multiple() {
    // Test multiple awaits
    let result: I64 = block_on(async_multiple())
    assert_eq(result, 84)
}

@test
func test_async_with_args() {
    // Test async function with arguments
    let result: I64 = block_on(async_compute(5))
    assert_eq(result, 20)
}

// ============================================================================
// State Machine / Suspension Point Tests
// ============================================================================

// Test local variables preserved across a single suspension point
async func async_preserve_local() -> I64 {
    let x: I64 = 10
    let y: I64 = await async_compute(5)  // x must be preserved across this await
    return x + y  // Should be 10 + 20 = 30
}

@test
func test_async_preserve_local() {
    let result: I64 = block_on(async_preserve_local())
    assert_eq(result, 30)
}

// Test multiple locals preserved across suspension
async func async_preserve_multiple_locals() -> I64 {
    let a: I64 = 1
    let b: I64 = 2
    let c: I64 = 3
    let sum1: I64 = await async_simple()  // a, b, c must be preserved
    return a + b + c + sum1  // 1 + 2 + 3 + 42 = 48
}

@test
func test_async_preserve_multiple_locals() {
    let result: I64 = block_on(async_preserve_multiple_locals())
    assert_eq(result, 48)
}

// Test locals preserved across multiple suspension points
async func async_multiple_suspensions() -> I64 {
    let x: I64 = 5
    let a: I64 = await async_compute(x)    // First suspension, x preserved
    let b: I64 = await async_compute(a)    // Second suspension, a preserved
    return x + a + b  // 5 + 20 + 50 = 75
}

@test
func test_async_multiple_suspensions() {
    let result: I64 = block_on(async_multiple_suspensions())
    assert_eq(result, 75)
}

// Test nested awaits with intermediate results
async func async_intermediate_helper(x: I64) -> I64 {
    return x * 3
}

async func async_nested_awaits() -> I64 {
    let step1: I64 = await async_simple()              // 42
    let step2: I64 = await async_compute(step1)        // 42 * 2 + 10 = 94
    let step3: I64 = await async_intermediate_helper(step2)  // 94 * 3 = 282
    return step3
}

@test
func test_async_nested_awaits() {
    let result: I64 = block_on(async_nested_awaits())
    assert_eq(result, 282)
}

// Test computation between suspension points
async func async_interleaved_compute() -> I64 {
    let x: I64 = 10
    let a: I64 = await async_simple()  // 42
    let y: I64 = x * 2                 // 20 (computed between suspensions)
    let b: I64 = await async_compute(y)  // 20 * 2 + 10 = 50
    return a + b + y  // 42 + 50 + 20 = 112
}

@test
func test_async_interleaved_compute() {
    let result: I64 = block_on(async_interleaved_compute())
    assert_eq(result, 112)
}

// ============================================================================
// Deep Nesting and Complex Control Flow Tests
// ============================================================================

// Deeply nested async calls (3+ levels)
async func async_level_1() -> I64 {
    return 1
}

async func async_level_2() -> I64 {
    let x: I64 = await async_level_1()
    return x + 2
}

async func async_level_3() -> I64 {
    let x: I64 = await async_level_2()
    return x + 3
}

async func async_level_4() -> I64 {
    let x: I64 = await async_level_3()
    return x + 4
}

async func async_level_5() -> I64 {
    let x: I64 = await async_level_4()
    return x + 5
}

@test
func test_async_deep_nesting() {
    // 1 + 2 + 3 + 4 + 5 = 15
    let result: I64 = block_on(async_level_5())
    assert_eq(result, 15)
}

// ============================================================================
// Async with Different Return Types
// ============================================================================

async func async_return_i32() -> I32 {
    return 123
}

// Note: block_on currently returns I64, so we test with I64 return types
// Bool and F64 async returns require block_on to be generic

@test
func test_async_return_i32() {
    // block_on returns I64, so we cast to I32
    let result: I64 = block_on(async_return_i32())
    assert_eq(result, 123)
}

// ============================================================================
// Async with Multiple Parameters
// ============================================================================

async func async_add(a: I64, b: I64) -> I64 {
    return a + b
}

async func async_mul(a: I64, b: I64, c: I64) -> I64 {
    return a * b * c
}

async func async_complex_params(a: I64, b: I64, c: I64) -> I64 {
    let sum: I64 = await async_add(a, b)
    let product: I64 = await async_mul(sum, c, 2)
    return product
}

@test
func test_async_add() {
    let result: I64 = block_on(async_add(10, 20))
    assert_eq(result, 30)
}

@test
func test_async_mul() {
    let result: I64 = block_on(async_mul(2, 3, 4))
    assert_eq(result, 24)
}

@test
func test_async_complex_params() {
    // a=3, b=4, c=5
    // sum = 3 + 4 = 7
    // product = 7 * 5 * 2 = 70
    let result: I64 = block_on(async_complex_params(3, 4, 5))
    assert_eq(result, 70)
}

// ============================================================================
// Async with Conditionals
// ============================================================================

async func async_conditional(x: I64) -> I64 {
    if x > 0 {
        return await async_compute(x)  // x * 2 + 10
    } else {
        return await async_simple()    // 42
    }
}

@test
func test_async_conditional_positive() {
    let result: I64 = block_on(async_conditional(5))
    // 5 * 2 + 10 = 20
    assert_eq(result, 20)
}

@test
func test_async_conditional_negative() {
    let result: I64 = block_on(async_conditional(-5))
    assert_eq(result, 42)
}

@test
func test_async_conditional_zero() {
    let result: I64 = block_on(async_conditional(0))
    assert_eq(result, 42)
}

// Multiple awaits in different branches
async func async_multi_branch(x: I64) -> I64 {
    let b: I64 = await async_simple()  // 42
    if x > 10 {
        let y: I64 = await async_compute(x)
        return b + y
    } else if x > 0 {
        let y: I64 = await async_add(x, b)
        return y
    } else {
        return b
    }
}

@test
func test_async_multi_branch_high() {
    // x=20 > 10: 42 + (20 * 2 + 10) = 42 + 50 = 92
    let result: I64 = block_on(async_multi_branch(20))
    assert_eq(result, 92)
}

@test
func test_async_multi_branch_mid() {
    // x=5 > 0: 5 + 42 = 47
    let result: I64 = block_on(async_multi_branch(5))
    assert_eq(result, 47)
}

@test
func test_async_multi_branch_low() {
    // x=-1: 42
    let result: I64 = block_on(async_multi_branch(-1))
    assert_eq(result, 42)
}

// ============================================================================
// Async Fibonacci (Recursive Async)
// ============================================================================

async func async_fib(n: I64) -> I64 {
    if n <= 1 {
        return n
    }
    let a: I64 = await async_fib(n - 1)
    let b: I64 = await async_fib(n - 2)
    return a + b
}

@test
func test_async_fib_0() {
    let result: I64 = block_on(async_fib(0))
    assert_eq(result, 0)
}

@test
func test_async_fib_1() {
    let result: I64 = block_on(async_fib(1))
    assert_eq(result, 1)
}

@test
func test_async_fib_5() {
    // fib(5) = 5
    let result: I64 = block_on(async_fib(5))
    assert_eq(result, 5)
}

@test
func test_async_fib_10() {
    // fib(10) = 55
    let result: I64 = block_on(async_fib(10))
    assert_eq(result, 55)
}

// ============================================================================
// Async Factorial
// ============================================================================

async func async_factorial(n: I64) -> I64 {
    if n <= 1 {
        return 1
    }
    let sub: I64 = await async_factorial(n - 1)
    return n * sub
}

@test
func test_async_factorial_0() {
    let result: I64 = block_on(async_factorial(0))
    assert_eq(result, 1)
}

@test
func test_async_factorial_1() {
    let result: I64 = block_on(async_factorial(1))
    assert_eq(result, 1)
}

@test
func test_async_factorial_5() {
    // 5! = 120
    let result: I64 = block_on(async_factorial(5))
    assert_eq(result, 120)
}

@test
func test_async_factorial_10() {
    // 10! = 3628800
    let result: I64 = block_on(async_factorial(10))
    assert_eq(result, 3628800)
}

// ============================================================================
// Async with Loops
// ============================================================================

async func async_sum_loop(n: I64) -> I64 {
    let mut sum: I64 = 0
    let mut i: I64 = 1
    loop {
        if i > n {
            break
        }
        let current: I64 = await async_add(sum, i)
        sum = current
        i = i + 1
    }
    return sum
}

@test
func test_async_sum_loop() {
    // Sum 1+2+3+4+5 = 15
    let result: I64 = block_on(async_sum_loop(5))
    assert_eq(result, 15)
}

@test
func test_async_sum_loop_large() {
    // Sum 1+2+...+10 = 55
    let result: I64 = block_on(async_sum_loop(10))
    assert_eq(result, 55)
}

// ============================================================================
// Async Expression Positions
// ============================================================================

async func async_expr_in_binary() -> I64 {
    // Await inside binary expression
    let result: I64 = (await async_simple()) + (await async_compute(5))
    return result  // 42 + 20 = 62
}

@test
func test_async_expr_in_binary() {
    let result: I64 = block_on(async_expr_in_binary())
    assert_eq(result, 62)
}

async func async_expr_nested() -> I64 {
    // Nested await as argument
    let result: I64 = await async_compute(await async_level_1())
    return result  // async_level_1() = 1, compute(1) = 1*2+10 = 12
}

@test
func test_async_expr_nested() {
    let result: I64 = block_on(async_expr_nested())
    assert_eq(result, 12)
}

// ============================================================================
// Async void-like (returning unit type as I64 = 0)
// ============================================================================

async func async_void_style() -> I64 {
    let _: I64 = await async_simple()  // Discard result
    return 0  // Simulate void return
}

@test
func test_async_void_style() {
    let result: I64 = block_on(async_void_style())
    assert_eq(result, 0)
}

// ============================================================================
// Stress Test - Many Sequential Awaits
// ============================================================================

async func async_many_awaits() -> I64 {
    let a: I64 = await async_simple()
    let b: I64 = await async_simple()
    let c: I64 = await async_simple()
    let d: I64 = await async_simple()
    let e: I64 = await async_simple()
    let f: I64 = await async_simple()
    let g: I64 = await async_simple()
    let h: I64 = await async_simple()
    let i: I64 = await async_simple()
    let j: I64 = await async_simple()
    return a + b + c + d + e + f + g + h + i + j  // 42 * 10 = 420
}

@test
func test_async_many_awaits() {
    let result: I64 = block_on(async_many_awaits())
    assert_eq(result, 420)
}

// ============================================================================
// Mixed Postfix and Prefix Await
// ============================================================================

async func async_mixed_await_styles() -> I64 {
    let a: I64 = async_simple().await       // postfix
    let b: I64 = await async_simple()       // prefix
    let c: I64 = async_compute(a).await     // postfix with arg
    let d: I64 = await async_compute(b)     // prefix with arg
    return a + b + c + d  // 42 + 42 + 94 + 94 = 272
}

@test
func test_async_mixed_await_styles() {
    let result: I64 = block_on(async_mixed_await_styles())
    assert_eq(result, 272)
}
