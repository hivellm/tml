// Polymorphic assertions
func assert_eq[T](left: T, right: T, message: Str) {
    if left != right {
        panic(message)
    }
}

func assert(condition: Bool, message: Str) {
    if not condition {
        panic(message)
    }
}

// ============ Basic Time Functions ============

@test
func test_time_ms() {
    let t: I32 = time_ms()
    assert(t >= 0, "time_ms should be non-negative")
}

@test
func test_time_us() {
    let t: I64 = time_us()
    // Can't easily compare I64 > 0, but we verify it runs
}

@test
func test_time_ns() {
    let t: I64 = time_ns()
    // Can't easily compare I64 > 0, but we verify it runs
}

// ============ Time Monotonicity ============

@test
func test_time_ms_monotonic() {
    let t1: I32 = time_ms()

    // Do some work
    let mut sum: I32 = 0
    let mut i: I32 = 0
    loop {
        if i >= 100 then break
        sum = sum + i
        i = i + 1
    }

    let t2: I32 = time_ms()
    assert(t2 >= t1, "time should be monotonic")
}

// ============ Duration Calculation ============

@test
func test_elapsed_time() {
    let start: I32 = time_ms()

    // Do some work
    let mut product: I32 = 1
    let mut i: I32 = 1
    loop {
        if i > 10 then break
        product = product * i
        i = i + 1
    }

    let end: I32 = time_ms()
    let elapsed: I32 = end - start

    assert(elapsed >= 0, "elapsed time should be non-negative")
}

// ============ Time Comparison ============

@test
func test_time_comparison() {
    let t1: I32 = time_ms()
    let t2: I32 = time_ms()

    // t2 should be >= t1 (might be equal if fast)
    assert(t2 >= t1, "later time should be >= earlier time")
}

func main() -> I32 {
    test_time_ms()
    test_time_us()
    test_time_ns()
    test_time_ms_monotonic()
    test_elapsed_time()
    test_time_comparison()
    print("PASS: All tests passed!")
    return 0
}
