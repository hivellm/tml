use test
use core::str

// ============================================================================
// Comprehensive String Builtin Tests
// Phase 29: Migrated from bare str_* builtins to method calls and operators.
// Tests string concat, substring, contains, starts_with, ends_with,
// to_uppercase, to_lowercase, trim, char_at
// ============================================================================

// ============================================================================
// String Concat Tests (+ operator)
// ============================================================================

@test
func test_str_concat_basic() -> I32 {
    let result: Str = "Hello" + " World"
    assert_eq(result, "Hello World", "concat should join strings")
    return 0
}

@test
func test_str_concat_empty_left() -> I32 {
    let result: Str = "" + "World"
    assert_eq(result, "World", "concat with empty left should return right")
    return 0
}

@test
func test_str_concat_empty_right() -> I32 {
    let result: Str = "Hello" + ""
    assert_eq(result, "Hello", "concat with empty right should return left")
    return 0
}

@test
func test_str_concat_both_empty() -> I32 {
    let result: Str = "" + ""
    assert_eq(result.len(), 0, "concat of two empty strings should be empty")
    return 0
}

// ============================================================================
// String Slice Tests (.slice() method â€” start, end)
// ============================================================================

@test
func test_str_slice_middle() -> I32 {
    let result: Str = "Hello World".slice(6, 11)
    assert_eq(result, "World", "slice should extract middle")
    return 0
}

@test
func test_str_slice_start() -> I32 {
    let result: Str = "Hello World".slice(0, 5)
    assert_eq(result, "Hello", "slice should extract start")
    return 0
}

@test
func test_str_slice_single_char() -> I32 {
    let result: Str = "Hello".slice(1, 2)
    assert_eq(result, "e", "slice of 1 char should work")
    return 0
}

// ============================================================================
// String Contains Tests (.contains() method)
// ============================================================================

@test
func test_str_contains_found() -> I32 {
    assert("Hello World".contains("World"), "should find contained substring")
    return 0
}

@test
func test_str_contains_not_found() -> I32 {
    assert(not "Hello World".contains("Foo"), "should not find missing substring")
    return 0
}

@test
func test_str_contains_empty_needle() -> I32 {
    assert("Hello".contains(""), "empty string should be found in any string")
    return 0
}

@test
func test_str_contains_at_start() -> I32 {
    assert("Hello World".contains("Hello"), "should find at start")
    return 0
}

@test
func test_str_contains_at_end() -> I32 {
    assert("Hello World".contains("World"), "should find at end")
    return 0
}

// ============================================================================
// String starts_with Tests (.starts_with() method)
// ============================================================================

@test
func test_str_starts_with_true() -> I32 {
    assert("Hello World".starts_with("Hello"), "should detect prefix")
    return 0
}

@test
func test_str_starts_with_false() -> I32 {
    assert(not "Hello World".starts_with("World"), "World is not a prefix")
    return 0
}

@test
func test_str_starts_with_empty() -> I32 {
    assert("Hello".starts_with(""), "empty string is prefix of anything")
    return 0
}

@test
func test_str_starts_with_full_match() -> I32 {
    assert("Hello".starts_with("Hello"), "full match should be prefix")
    return 0
}

// ============================================================================
// String ends_with Tests (.ends_with() method)
// ============================================================================

@test
func test_str_ends_with_true() -> I32 {
    assert("Hello World".ends_with("World"), "should detect suffix")
    return 0
}

@test
func test_str_ends_with_false() -> I32 {
    assert(not "Hello World".ends_with("Hello"), "Hello is not a suffix")
    return 0
}

@test
func test_str_ends_with_empty() -> I32 {
    assert("Hello".ends_with(""), "empty string is suffix of anything")
    return 0
}

// ============================================================================
// String to_uppercase Tests (.to_uppercase() method)
// ============================================================================

@test
func test_str_to_upper_lowercase() -> I32 {
    assert_eq("hello".to_uppercase(), "HELLO", "should convert to uppercase")
    return 0
}

@test
func test_str_to_upper_mixed() -> I32 {
    assert_eq("Hello World".to_uppercase(), "HELLO WORLD", "should convert mixed case")
    return 0
}

@test
func test_str_to_upper_already_upper() -> I32 {
    assert_eq("HELLO".to_uppercase(), "HELLO", "already upper should stay same")
    return 0
}

// ============================================================================
// String to_lowercase Tests (.to_lowercase() method)
// ============================================================================

@test
func test_str_to_lower_uppercase() -> I32 {
    assert_eq("HELLO".to_lowercase(), "hello", "should convert to lowercase")
    return 0
}

@test
func test_str_to_lower_mixed() -> I32 {
    assert_eq("Hello World".to_lowercase(), "hello world", "should convert mixed case")
    return 0
}

// ============================================================================
// String trim Tests (.trim() method)
// ============================================================================

@test
func test_str_trim_spaces() -> I32 {
    assert_eq("  hello  ".trim(), "hello", "should trim leading and trailing spaces")
    return 0
}

@test
func test_str_trim_no_spaces() -> I32 {
    assert_eq("hello".trim(), "hello", "no trim needed")
    return 0
}

@test
func test_str_trim_only_spaces() -> I32 {
    assert_eq("   ".trim().len(), 0, "all spaces should result in empty")
    return 0
}

// ============================================================================
// String char_at Tests (.char_at() method)
// ============================================================================

@test
func test_str_char_at_first() -> I32 {
    let result: I32 = "Hello".char_at(0)
    assert_eq(result, 72, "H should be ASCII 72")
    return 0
}

@test
func test_str_char_at_middle() -> I32 {
    let result: I32 = "Hello".char_at(2)
    assert_eq(result, 108, "l should be ASCII 108")
    return 0
}

@test
func test_str_char_at_last() -> I32 {
    let result: I32 = "Hello".char_at(4)
    assert_eq(result, 111, "o should be ASCII 111")
    return 0
}
