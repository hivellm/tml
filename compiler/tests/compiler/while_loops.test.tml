use test

// ============ Basic Loops ============

@test
func test_simple_loop() -> I32 {
    let mut i: I32 = 0
    let mut sum: I32 = 0

    loop (i < 5) {
        sum = sum + i
        i = i + 1
    }

    assert_eq(sum, 10, "sum 0-4")
    assert_eq(i, 5, "loop counter")

    return 0
}

@test
func test_countdown() -> I32 {
    let mut n: I32 = 10
    let mut count: I32 = 0

    loop (n > 0) {
        count = count + 1
        n = n - 1
    }

    assert_eq(count, 10, "10 iterations")
    assert_eq(n, 0, "n at 0")

    return 0
}

// ============ Loop with Continue ============

@test
func test_skip_evens() -> I32 {
    let mut i: I32 = 0
    let mut sum: I32 = 0

    loop (i < 10) {
        i = i + 1
        if i % 2 == 0 then { continue }
        sum = sum + i
    }

    // Sum of odd numbers 1-9: 1+3+5+7+9 = 25
    assert_eq(sum, 25, "sum of odds")

    return 0
}

// ============ Loop with Early Break ============

@test
func test_find_first() -> I32 {
    let mut i: I32 = 0
    let mut found: I32 = 0 - 1

    loop (true) {
        if i >= 100 then { break }
        if i * i > 50 then {
            found = i
            break
        }
        i = i + 1
    }

    // First i where i^2 > 50 is 8 (64 > 50)
    assert_eq(found, 8, "first i where i^2 > 50")

    return 0
}

// ============ Nested Loops ============

@test
func test_nested_simple() -> I32 {
    let mut total: I32 = 0
    let mut i: I32 = 0

    loop (i < 3) {
        let mut j: I32 = 0
        loop (j < 4) {
            total = total + 1
            j = j + 1
        }

        i = i + 1
    }

    assert_eq(total, 12, "3x4 iterations")

    return 0
}

@test
func test_nested_with_dependency() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 1

    // Sum of triangular numbers: 1 + (1+2) + (1+2+3) + (1+2+3+4)
    loop (i <= 4) {
        let mut j: I32 = 1
        loop (j <= i) {
            sum = sum + j
            j = j + 1
        }

        i = i + 1
    }

    // 1 + 3 + 6 + 10 = 20
    assert_eq(sum, 20, "sum of triangular numbers")

    return 0
}

// ============ Loop Control Variables ============

@test
func test_multiple_counters() -> I32 {
    let mut i: I32 = 0
    let mut j: I32 = 10

    loop (i < j) {
        i = i + 1
        j = j - 1
    }

    // They meet in the middle
    assert_eq(i, 5, "i at 5")
    assert_eq(j, 5, "j at 5")

    return 0
}

// ============ Loop with Accumulator ============

@test
func test_factorial_loop() -> I32 {
    let mut n: I32 = 5
    let mut result: I32 = 1

    loop (n > 1) {
        result = result * n
        n = n - 1
    }

    assert_eq(result, 120, "5!")

    return 0
}

@test
func test_power_loop() -> I32 {
    let b: I32 = 2
    let exp: I32 = 10
    let mut result: I32 = 1
    let mut i: I32 = 0

    loop (i < exp) {
        result = result * b
        i = i + 1
    }

    assert_eq(result, 1024, "2^10")

    return 0
}

// ============ Loop Boundary Conditions ============

@test
func test_zero_iterations() -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 10

    loop (i < 10) {  // Immediately exit
        count = count + 1
        i = i + 1
    }

    assert_eq(count, 0, "zero iterations")

    return 0
}

@test
func test_single_iteration() -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 0

    loop (i < 1) {
        count = count + 1
        i = i + 1
    }

    assert_eq(count, 1, "single iteration")

    return 0
}

// ============ Loop with Conditional Updates ============

@test
func test_conditional_increment() -> I32 {
    let mut i: I32 = 0
    let mut sum: I32 = 0

    loop (i < 20) {
        if i % 3 == 0 then {
            sum = sum + i
        }

        i = i + 1
    }

    // Multiples of 3 up to 18: 0+3+6+9+12+15+18 = 63
    assert_eq(sum, 63, "sum of multiples of 3")

    return 0
}

// ============ Collatz Sequence ============

func collatz_steps(n: I32) -> I32 {
    let mut steps: I32 = 0
    let mut current: I32 = n

    loop (current != 1) {
        if current % 2 == 0 then {
            current = current / 2
        } else {
            current = current * 3 + 1
        }
        steps = steps + 1
    }

    return steps
}

@test
func test_collatz() -> I32 {
    assert_eq(collatz_steps(1), 0, "collatz(1)")
    assert_eq(collatz_steps(2), 1, "collatz(2)")
    assert_eq(collatz_steps(4), 2, "collatz(4)")
    assert_eq(collatz_steps(8), 3, "collatz(8)")

    return 0
}
