// Test: basic let-else pattern matching
// let Pattern = expr else { diverging_block }

use test

// Helper functions that return Maybe/Outcome
func get_just() -> Maybe[I32] {
    return Just(42)
}

func get_nothing() -> Maybe[I32] {
    return Nothing
}

func get_ok() -> Outcome[I32, Str] {
    return Ok(100)
}

func get_err() -> Outcome[I32, Str] {
    return Err("error")
}

// Test let-else with Maybe - success case
func unwrap_or_return_maybe(m: Maybe[I32]) -> I32 {
    let Just(x): Maybe[I32] = m else {
        return 0
    }
    return x
}

@test
func test_let_else_just() -> I32 {
    let result: I32 = unwrap_or_return_maybe(get_just())
    assert_eq(result, 42, "should unwrap Just value")
    return 0
}

@test
func test_let_else_nothing() -> I32 {
    let result: I32 = unwrap_or_return_maybe(get_nothing())
    assert_eq(result, 0, "should return 0 for Nothing")
    return 0
}

// Test let-else with Outcome - success case
func unwrap_or_return_outcome(o: Outcome[I32, Str]) -> I32 {
    let Ok(x): Outcome[I32, Str] = o else {
        return -1
    }
    return x
}

@test
func test_let_else_ok() -> I32 {
    let result: I32 = unwrap_or_return_outcome(get_ok())
    assert_eq(result, 100, "should unwrap Ok value")
    return 0
}

@test
func test_let_else_err() -> I32 {
    let result: I32 = unwrap_or_return_outcome(get_err())
    assert_eq(result, -1, "should return -1 for Err")
    return 0
}
