// Comprehensive OOP tests for TML compiler
// Tests classes, inheritance, interfaces, 'is' operator, and classes as types
use test

// ============================================================================
// Basic Class Definitions
// ============================================================================

/// Simple point class with x, y coordinates
class Point {
    x: I32
    y: I32

    // Factory function - static method
    static func create(x: I32, y: I32) -> Point {
        return Point { x: x, y: y }
    }

    func get_x(this) -> I32 {
        return this.x
    }

    func get_y(this) -> I32 {
        return this.y
    }

    func set_x(mut this, x: I32) {
        this.x = x
    }

    func set_y(mut this, y: I32) {
        this.y = y
    }

    func distance_from_origin(this) -> I32 {
        // Simplified: return sum of absolute values (Manhattan distance)
        let abs_x: I32 = if this.x < 0 { 0 - this.x } else { this.x }
        let abs_y: I32 = if this.y < 0 { 0 - this.y } else { this.y }
        return abs_x + abs_y
    }

    func add(this, other: Point) -> Point {
        return Point::create(this.x + other.get_x(), this.y + other.get_y())
    }
}

/// Rectangle class composed of two Points
class Rectangle {
    top_left: Point
    bottom_right: Point

    static func create(x1: I32, y1: I32, x2: I32, y2: I32) -> Rectangle {
        return Rectangle {
            top_left: Point::create(x1, y1),
            bottom_right: Point::create(x2, y2)
        }
    }

    func width(this) -> I32 {
        let x1: I32 = this.top_left.get_x()
        let x2: I32 = this.bottom_right.get_x()
        if x2 > x1 { return x2 - x1 }
        return x1 - x2
    }

    func height(this) -> I32 {
        let y1: I32 = this.top_left.get_y()
        let y2: I32 = this.bottom_right.get_y()
        if y2 > y1 { return y2 - y1 }
        return y1 - y2
    }

    func area(this) -> I32 {
        return this.width() * this.height()
    }

    func get_top_left(this) -> Point {
        return this.top_left
    }

    func get_bottom_right(this) -> Point {
        return this.bottom_right
    }
}

/// Counter class with static field
class Counter {
    value: I32

    static count: I32 = 0

    static func create() -> Counter {
        Counter::count = Counter::count + 1
        return Counter { value: 0 }
    }

    func increment(mut this) {
        this.value = this.value + 1
    }

    func get_value(this) -> I32 {
        return this.value
    }

    static func get_instance_count() -> I32 {
        return Counter::count
    }

    static func reset_count() {
        Counter::count = 0
    }
}

// ============================================================================
// Inheritance Hierarchy
// ============================================================================

/// Base class for shapes
class Shape {
    name: I32  // Using I32 as identifier for now

    static func create(name: I32) -> Shape {
        return Shape { name: name }
    }

    func get_name(this) -> I32 {
        return this.name
    }

    func area(this) -> I32 {
        return 0
    }
}

/// Circle inherits from Shape
class Circle extends Shape {
    radius: I32

    static func create(radius: I32) -> Circle {
        // Note: Only initialize own fields, not inherited
        return Circle { radius: radius }
    }

    func get_radius(this) -> I32 {
        return this.radius
    }

    func area(this) -> I32 {
        // Simplified: using 3 * r * r instead of PI * r^2
        return 3 * this.radius * this.radius
    }

    func circumference(this) -> I32 {
        // Simplified: using 6 * r instead of 2 * PI * r
        return 6 * this.radius
    }
}

/// Square inherits from Shape
class Square extends Shape {
    side: I32

    static func create(side: I32) -> Square {
        // Note: Only initialize own fields, not inherited
        return Square { side: side }
    }

    func get_side(this) -> I32 {
        return this.side
    }

    func area(this) -> I32 {
        return this.side * this.side
    }

    func perimeter(this) -> I32 {
        return 4 * this.side
    }
}

// ============================================================================
// Interface Definition
// ============================================================================

interface Drawable {
    func draw(this) -> I32
}

class Canvas implements Drawable {
    width: I32
    height: I32

    static func create(w: I32, h: I32) -> Canvas {
        return Canvas { width: w, height: h }
    }

    func draw(this) -> I32 {
        // Return a value indicating "drawn"
        return this.width * this.height
    }

    func get_width(this) -> I32 {
        return this.width
    }
}

// ============================================================================
// Basic Class Instantiation Tests
// ============================================================================

@test
func test_basic_class_instantiation() -> I32 {
    let p: Point = Point::create(10, 20)
    assert_eq(p.get_x(), 10, "Point x should be 10")
    assert_eq(p.get_y(), 20, "Point y should be 20")
    return 0
}

@test
func test_class_method_calls() -> I32 {
    let p: Point = Point::create(3, 4)
    let dist: I32 = p.distance_from_origin()
    assert_eq(dist, 7, "Manhattan distance from origin should be 7")
    return 0
}

@test
func test_class_with_negative_values() -> I32 {
    let p: Point = Point::create(-5, -10)
    assert_eq(p.get_x(), -5, "Point x should be -5")
    assert_eq(p.get_y(), -10, "Point y should be -10")
    assert_eq(p.distance_from_origin(), 15, "Distance should be 15")
    return 0
}

// ============================================================================
// Classes as Variable Types Tests
// ============================================================================

@test
func test_class_as_variable_type() -> I32 {
    // Declare variable with class type
    let point: Point = Point::create(1, 2)

    // Reassign to new instance
    let other: Point = Point::create(3, 4)

    assert_eq(point.get_x(), 1, "First point x")
    assert_eq(other.get_x(), 3, "Second point x")
    return 0
}

@test
func test_multiple_class_variables() -> I32 {
    let p1: Point = Point::create(1, 1)
    let p2: Point = Point::create(2, 2)
    let p3: Point = Point::create(3, 3)

    assert_eq(p1.get_x(), 1, "p1.x = 1")
    assert_eq(p2.get_x(), 2, "p2.x = 2")
    assert_eq(p3.get_x(), 3, "p3.x = 3")

    let sum: I32 = p1.get_x() + p2.get_x() + p3.get_x()
    assert_eq(sum, 6, "Sum of x values")
    return 0
}

@test
func test_class_variable_in_expressions() -> I32 {
    let p: Point = Point::create(10, 20)

    // Use class in expressions
    let x_plus_y: I32 = p.get_x() + p.get_y()
    assert_eq(x_plus_y, 30, "x + y = 30")

    let x_times_y: I32 = p.get_x() * p.get_y()
    assert_eq(x_times_y, 200, "x * y = 200")

    return 0
}

// ============================================================================
// Nested Class Access Tests
// ============================================================================

@test
func test_nested_class_composition() -> I32 {
    let rect: Rectangle = Rectangle::create(0, 0, 10, 5)

    assert_eq(rect.width(), 10, "Rectangle width")
    assert_eq(rect.height(), 5, "Rectangle height")
    assert_eq(rect.area(), 50, "Rectangle area")
    return 0
}

@test
func test_nested_class_field_access() -> I32 {
    let rect: Rectangle = Rectangle::create(1, 2, 11, 7)

    let tl: Point = rect.get_top_left()
    let br: Point = rect.get_bottom_right()

    assert_eq(tl.get_x(), 1, "Top left x")
    assert_eq(tl.get_y(), 2, "Top left y")
    assert_eq(br.get_x(), 11, "Bottom right x")
    assert_eq(br.get_y(), 7, "Bottom right y")
    return 0
}

@test
func test_deep_nested_access() -> I32 {
    let rect: Rectangle = Rectangle::create(5, 10, 15, 20)

    // Chain through nested objects
    let top_left_x: I32 = rect.get_top_left().get_x()
    let bottom_right_y: I32 = rect.get_bottom_right().get_y()

    assert_eq(top_left_x, 5, "Chained access to top_left.x")
    assert_eq(bottom_right_y, 20, "Chained access to bottom_right.y")
    return 0
}

// ============================================================================
// Class Method with Class Parameters Tests
// ============================================================================

@test
func test_class_method_with_class_param() -> I32 {
    let p1: Point = Point::create(1, 2)
    let p2: Point = Point::create(3, 4)

    let p3: Point = p1.add(p2)

    assert_eq(p3.get_x(), 4, "Added point x = 1 + 3")
    assert_eq(p3.get_y(), 6, "Added point y = 2 + 4")
    return 0
}

// ============================================================================
// Static Field and Method Tests
// ============================================================================

@test
func test_static_field_access() -> I32 {
    Counter::reset_count()

    let initial: I32 = Counter::get_instance_count()
    assert_eq(initial, 0, "Initial count should be 0")

    let c1: Counter = Counter::create()
    assert_eq(Counter::get_instance_count(), 1, "After first instance")

    let c2: Counter = Counter::create()
    assert_eq(Counter::get_instance_count(), 2, "After second instance")

    return 0
}

@test
func test_static_method_call() -> I32 {
    Counter::reset_count()
    assert_eq(Counter::get_instance_count(), 0, "Count reset to 0")
    return 0
}

// ============================================================================
// Instance Method State Tests
// ============================================================================

@test
func test_instance_method_modifies_state() -> I32 {
    let c: Counter = Counter::create()

    assert_eq(c.get_value(), 0, "Initial counter value")

    c.increment()
    assert_eq(c.get_value(), 1, "After first increment")

    c.increment()
    c.increment()
    assert_eq(c.get_value(), 3, "After three increments")

    return 0
}

// ============================================================================
// Inheritance Tests
// ============================================================================

@test
func test_basic_inheritance() -> I32 {
    let c: Circle = Circle::create(5)

    // Access own field - tests that inheritance doesn't break own fields
    assert_eq(c.get_radius(), 5, "Circle radius")

    // Note: Inherited field initialization in struct literals not yet supported
    // c.get_name() would return uninitialized value

    return 0
}

@test
func test_method_override() -> I32 {
    let c: Circle = Circle::create(10)
    let s: Square = Square::create(10)

    // Circle area: 3 * 10 * 10 = 300
    assert_eq(c.area(), 300, "Circle area")

    // Square area: 10 * 10 = 100
    assert_eq(s.area(), 100, "Square area")

    return 0
}

@test
func test_subclass_specific_methods() -> I32 {
    let c: Circle = Circle::create(7)
    let s: Square = Square::create(5)

    // Circle-specific method
    assert_eq(c.circumference(), 42, "Circle circumference: 6 * 7")

    // Square-specific method
    assert_eq(s.perimeter(), 20, "Square perimeter: 4 * 5")

    return 0
}

// ============================================================================
// Interface Implementation Tests
// ============================================================================

@test
func test_interface_implementation() -> I32 {
    let canvas: Canvas = Canvas::create(100, 50)

    // Call interface method
    let result: I32 = canvas.draw()
    assert_eq(result, 5000, "Canvas draw returns width * height")

    return 0
}

@test
func test_interface_with_regular_methods() -> I32 {
    let canvas: Canvas = Canvas::create(80, 60)

    // Regular method
    assert_eq(canvas.get_width(), 80, "Canvas width")

    // Interface method
    assert_eq(canvas.draw(), 4800, "Canvas draw")

    return 0
}

// ============================================================================
// 'is' Operator Tests
// ============================================================================

@test
func test_is_operator_same_type() -> I32 {
    let c: Circle = Circle::create(5)

    if c is Circle {
        return 0  // Expected: Circle is Circle
    }

    assert(false, "Circle should be Circle")
    return 1
}

@test
func test_is_operator_different_types() -> I32 {
    let c: Circle = Circle::create(5)
    let s: Square = Square::create(5)

    // These should work with different types
    let c_is_circle: Bool = c is Circle
    let s_is_square: Bool = s is Square

    assert(c_is_circle, "Circle is Circle")
    assert(s_is_square, "Square is Square")

    return 0
}

@test
func test_is_operator_in_conditional() -> I32 {
    let mut shape_id: I32 = 0
    let c: Circle = Circle::create(10)

    if c is Circle {
        shape_id = 1
    }

    assert_eq(shape_id, 1, "Conditional with is operator")
    return 0
}

// ============================================================================
// Complex Class Interaction Tests
// ============================================================================

@test
func test_class_returning_class() -> I32 {
    let rect: Rectangle = Rectangle::create(0, 0, 20, 10)
    let corner: Point = rect.get_top_left()

    // The returned class should be fully functional
    let x: I32 = corner.get_x()
    let y: I32 = corner.get_y()

    assert_eq(x, 0, "Returned point x")
    assert_eq(y, 0, "Returned point y")
    return 0
}

@test
func test_chained_method_calls_on_classes() -> I32 {
    let rect: Rectangle = Rectangle::create(5, 5, 25, 15)

    // Chain: rect -> get_bottom_right() -> get_x()
    let br_x: I32 = rect.get_bottom_right().get_x()
    assert_eq(br_x, 25, "Chained bottom_right.x")

    // Chain: rect -> get_top_left() -> distance_from_origin()
    let dist: I32 = rect.get_top_left().distance_from_origin()
    assert_eq(dist, 10, "Chained top_left distance")

    return 0
}

@test
func test_multiple_classes_interacting() -> I32 {
    // Create multiple objects of different classes
    let p1: Point = Point::create(0, 0)
    let p2: Point = Point::create(10, 10)
    let rect: Rectangle = Rectangle::create(0, 0, 10, 10)
    let circle: Circle = Circle::create(5)
    let square: Square = Square::create(10)

    // All should be independent and functional
    assert_eq(p1.distance_from_origin(), 0, "p1 at origin")
    assert_eq(p2.distance_from_origin(), 20, "p2 distance")
    assert_eq(rect.area(), 100, "rect area")
    assert_eq(circle.area(), 75, "circle area: 3 * 5 * 5")
    assert_eq(square.area(), 100, "square area")

    return 0
}

// ============================================================================
// Edge Cases
// ============================================================================

@test
func test_class_with_zero_values() -> I32 {
    let p: Point = Point::create(0, 0)
    assert_eq(p.get_x(), 0, "Zero x")
    assert_eq(p.get_y(), 0, "Zero y")
    assert_eq(p.distance_from_origin(), 0, "Zero distance")
    return 0
}

@test
func test_class_with_large_values() -> I32 {
    let p: Point = Point::create(1000000, 2000000)
    assert_eq(p.get_x(), 1000000, "Large x")
    assert_eq(p.get_y(), 2000000, "Large y")
    return 0
}

@test
func test_multiple_method_calls_same_object() -> I32 {
    let c: Counter = Counter::create()

    // Call same method multiple times
    c.increment()
    c.increment()
    c.increment()
    c.increment()
    c.increment()

    assert_eq(c.get_value(), 5, "Five increments")
    return 0
}

// ============================================================================
// 'as' Operator Tests - Safe Class Casting
// ============================================================================

@test
func test_as_operator_upcast() -> I32 {
    // Upcast from Circle to Shape (always succeeds)
    let c: Circle = Circle::create(5)

    // Upcast should just return the pointer directly (no Maybe wrapping)
    let s: Shape = c as Shape
    assert_eq(s.area(), 0, "Upcast to Shape - base method called")
    return 0
}

@test
func test_as_operator_same_type() -> I32 {
    // Cast to same type (always succeeds)
    let c: Circle = Circle::create(7)

    // Same type cast should just return the pointer directly
    let c2: Circle = c as Circle
    assert_eq(c2.get_radius(), 7, "Same type cast preserves value")
    return 0
}

// ============================================================================
// Constructor Overloading Tests
// ============================================================================

/// Class with multiple constructors (overloading)
class Vector3D {
    x: I32
    y: I32
    z: I32

    // Default constructor - creates zero vector
    new() {
        this.x = 0
        this.y = 0
        this.z = 0
    }

    // Single-value constructor - creates vector with same value for all
    new(val: I32) {
        this.x = val
        this.y = val
        this.z = val
    }

    // Full constructor - creates vector with specific values
    new(x: I32, y: I32, z: I32) {
        this.x = x
        this.y = y
        this.z = z
    }

    func get_x(this) -> I32 { return this.x }
    func get_y(this) -> I32 { return this.y }
    func get_z(this) -> I32 { return this.z }

    func magnitude_squared(this) -> I32 {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
}

@test
func test_constructor_overload_default() -> I32 {
    let v: Vector3D = Vector3D::new()
    assert_eq(v.get_x(), 0, "Default constructor x")
    assert_eq(v.get_y(), 0, "Default constructor y")
    assert_eq(v.get_z(), 0, "Default constructor z")
    return 0
}

@test
func test_constructor_overload_single() -> I32 {
    let v: Vector3D = Vector3D::new(5)
    assert_eq(v.get_x(), 5, "Single-value constructor x")
    assert_eq(v.get_y(), 5, "Single-value constructor y")
    assert_eq(v.get_z(), 5, "Single-value constructor z")
    return 0
}

@test
func test_constructor_overload_full() -> I32 {
    let v: Vector3D = Vector3D::new(1, 2, 3)
    assert_eq(v.get_x(), 1, "Full constructor x")
    assert_eq(v.get_y(), 2, "Full constructor y")
    assert_eq(v.get_z(), 3, "Full constructor z")
    assert_eq(v.magnitude_squared(), 14, "Magnitude squared: 1+4+9=14")
    return 0
}

// ============================================================================
// Static Generic Method Tests
// ============================================================================

/// Utility class with static generic methods
class Utils {
    x: I32  // Dummy field - classes need at least one field

    // Identity function - returns the input unchanged
    static func identity[T](val: T) -> T {
        return val
    }

    // Return the first of two values
    static func first[T](a: T, b: T) -> T {
        return a
    }

    // Return the second of two values
    static func second[T](a: T, b: T) -> T {
        return b
    }
}

@test
func test_static_generic_identity_i32() -> I32 {
    let x: I32 = Utils::identity[I32](42)
    assert_eq(x, 42, "identity[I32](42) should return 42")
    return 0
}

@test
func test_static_generic_identity_i64() -> I32 {
    let x: I64 = Utils::identity[I64](100)
    assert_eq(x as I32, 100, "identity[I64](100) should return 100")
    return 0
}

@test
func test_static_generic_first() -> I32 {
    let x: I32 = Utils::first[I32](10, 20)
    assert_eq(x, 10, "first[I32](10, 20) should return 10")
    return 0
}

@test
func test_static_generic_second() -> I32 {
    let x: I32 = Utils::second[I32](10, 20)
    assert_eq(x, 20, "second[I32](10, 20) should return 20")
    return 0
}

// ============================================================================
// Design Patterns - Strategy Pattern
// ============================================================================

/// Strategy interface for payment methods
interface PaymentStrategy {
    func pay(this, amount: I32) -> I32
}

/// Credit card payment strategy
class CreditCardPayment implements PaymentStrategy {
    fee: I32  // Percentage fee (e.g., 3 = 3%)

    static func create(fee: I32) -> CreditCardPayment {
        return CreditCardPayment { fee: fee }
    }

    func pay(this, amount: I32) -> I32 {
        // Returns amount plus fee
        return amount + (amount * this.fee / 100)
    }
}

/// Cash payment strategy (no fee)
class CashPayment implements PaymentStrategy {
    discount: I32  // Discount percentage for cash

    static func create(discount: I32) -> CashPayment {
        return CashPayment { discount: discount }
    }

    func pay(this, amount: I32) -> I32 {
        // Returns amount minus discount
        return amount - (amount * this.discount / 100)
    }
}

/// Context that uses a payment strategy
class PaymentProcessor {
    base_amount: I32

    static func create(amount: I32) -> PaymentProcessor {
        return PaymentProcessor { base_amount: amount }
    }

    func process_with_credit(this, card: CreditCardPayment) -> I32 {
        return card.pay(this.base_amount)
    }

    func process_with_cash(this, cash: CashPayment) -> I32 {
        return cash.pay(this.base_amount)
    }
}

@test
func test_strategy_pattern_credit() -> I32 {
    let processor: PaymentProcessor = PaymentProcessor::create(100)
    let credit: CreditCardPayment = CreditCardPayment::create(3)  // 3% fee
    let total: I32 = processor.process_with_credit(credit)
    assert_eq(total, 103, "Credit card payment with 3% fee")
    return 0
}

@test
func test_strategy_pattern_cash() -> I32 {
    let processor: PaymentProcessor = PaymentProcessor::create(100)
    let cash: CashPayment = CashPayment::create(5)  // 5% discount
    let total: I32 = processor.process_with_cash(cash)
    assert_eq(total, 95, "Cash payment with 5% discount")
    return 0
}

// ============================================================================
// Design Patterns - Decorator Pattern
// ============================================================================

/// Base coffee interface
interface Coffee {
    func cost(this) -> I32
}

/// Simple coffee implementation
class SimpleCoffee implements Coffee {
    base_cost: I32

    static func create() -> SimpleCoffee {
        return SimpleCoffee { base_cost: 10 }
    }

    func cost(this) -> I32 {
        return this.base_cost
    }
}

/// Milk decorator - adds cost
class MilkDecorator implements Coffee {
    wrapped_cost: I32

    static func create(coffee_cost: I32) -> MilkDecorator {
        return MilkDecorator { wrapped_cost: coffee_cost + 2 }
    }

    func cost(this) -> I32 {
        return this.wrapped_cost
    }
}

/// Sugar decorator - adds cost
class SugarDecorator implements Coffee {
    wrapped_cost: I32

    static func create(coffee_cost: I32) -> SugarDecorator {
        return SugarDecorator { wrapped_cost: coffee_cost + 1 }
    }

    func cost(this) -> I32 {
        return this.wrapped_cost
    }
}

@test
func test_decorator_pattern_simple() -> I32 {
    let coffee: SimpleCoffee = SimpleCoffee::create()
    assert_eq(coffee.cost(), 10, "Simple coffee costs 10")
    return 0
}

@test
func test_decorator_pattern_with_milk() -> I32 {
    let coffee: SimpleCoffee = SimpleCoffee::create()
    let with_milk: MilkDecorator = MilkDecorator::create(coffee.cost())
    assert_eq(with_milk.cost(), 12, "Coffee with milk costs 12")
    return 0
}

@test
func test_decorator_pattern_full() -> I32 {
    // Build up: coffee + milk + sugar
    let simple_coffee: SimpleCoffee = SimpleCoffee::create()
    let with_milk: MilkDecorator = MilkDecorator::create(simple_coffee.cost())
    let with_sugar: SugarDecorator = SugarDecorator::create(with_milk.cost())
    assert_eq(with_sugar.cost(), 13, "Coffee with milk and sugar costs 13")
    return 0
}

// ============================================================================
// Design Patterns - Template Method Pattern
// ============================================================================

/// Abstract document processor with template method
class DocumentProcessor {
    doc_type: I32  // 1=text, 2=pdf, 3=html

    static func create(doc_type: I32) -> DocumentProcessor {
        return DocumentProcessor { doc_type: doc_type }
    }

    // Template method - defines the algorithm structure
    func process(this) -> I32 {
        let step1: I32 = this.open_document()
        let step2: I32 = this.parse_content()
        let step3: I32 = this.close_document()
        return step1 + step2 + step3
    }

    // Steps that vary by document type
    func open_document(this) -> I32 {
        return this.doc_type * 10  // Base: 10, 20, 30 for different types
    }

    func parse_content(this) -> I32 {
        return this.doc_type * 5  // Base: 5, 10, 15 for different types
    }

    func close_document(this) -> I32 {
        return 1  // Always 1 for cleanup
    }
}

/// Text document processor
class TextProcessor extends DocumentProcessor {
    line_count: I32

    static func create(lines: I32) -> TextProcessor {
        return TextProcessor { line_count: lines }
    }

    func parse_content(this) -> I32 {
        // Text parsing: 1 unit per line
        return this.line_count
    }
}

/// PDF document processor
class PdfProcessor extends DocumentProcessor {
    page_count: I32

    static func create(pages: I32) -> PdfProcessor {
        return PdfProcessor { page_count: pages }
    }

    func parse_content(this) -> I32 {
        // PDF parsing: 10 units per page (more complex)
        return this.page_count * 10
    }
}

@test
func test_template_method_base() -> I32 {
    let doc: DocumentProcessor = DocumentProcessor::create(1)  // Text type
    let result: I32 = doc.process()
    // open(10) + parse(5) + close(1) = 16
    assert_eq(result, 16, "Base document processing")
    return 0
}

@test
func test_template_method_text() -> I32 {
    let doc: TextProcessor = TextProcessor::create(25)  // 25 lines
    // TextProcessor inherits from DocumentProcessor
    // parse_content is overridden to return line_count
    let parse_result: I32 = doc.parse_content()
    assert_eq(parse_result, 25, "Text parsing 25 lines")
    return 0
}

@test
func test_template_method_pdf() -> I32 {
    let doc: PdfProcessor = PdfProcessor::create(5)  // 5 pages
    // PdfProcessor inherits from DocumentProcessor
    // parse_content is overridden to return page_count * 10
    let parse_result: I32 = doc.parse_content()
    assert_eq(parse_result, 50, "PDF parsing 5 pages")
    return 0
}

// ============================================================================
// Generic Class Tests
// ============================================================================

/// Generic container class
class Box[T] {
    value: T

    new(value: T) {
        this.value = value
    }

    func get(this) -> T {
        return this.value
    }

    func set(mut this, value: T) {
        this.value = value
    }
}

@test
func test_generic_class_i32() -> I32 {
    let b: Box[I32] = Box::new(42)
    assert_eq(b.get(), 42, "Box[I32] should hold 42")
    return 0
}

@test
func test_generic_class_i64() -> I32 {
    let b: Box[I64] = Box::new(999999 as I64)
    assert_eq(b.get() as I32, 999999, "Box[I64] should hold 999999")
    return 0
}
