use test

// Edge case tests for CFG and PHI node handling
// These tests verify that SimplifyCfgPass correctly handles PHI nodes

// Test 1: Empty block removal with PHI nodes
@test
func test_empty_block_phi() -> I32 {
    let x: I32 = 10
    let y: I32 = 20

    // This creates control flow that may have empty blocks after optimization
    let result: I32 = if x > 5 then {
        if y > 10 then { x + y } else { x }
    } else {
        y
    }

    assert_eq(result, 30, "nested if with x=10, y=20 should return 30")
    return 0
}

// Test 2: Unreachable block removal with PHI nodes
@test
func test_unreachable_phi() -> I32 {
    let x: I32 = 10

    // One branch is always taken, other becomes unreachable
    let result: I32 = if true then {
        x + 5
    } else {
        x * 2  // unreachable
    }

    assert_eq(result, 15, "if true should return x + 5 = 15")
    return 0
}

// Test 3: Constant branch simplification with PHI in target
@test
func test_constant_branch_phi() -> I32 {
    let a: I32 = 1
    let b: I32 = 2

    // Multiple paths merging with different values
    let result: I32 = if a == 1 then {
        if b == 2 then { 100 } else { 200 }
    } else {
        300
    }

    assert_eq(result, 100, "a=1, b=2 should return 100")
    return 0
}

// Test 4: Loop with PHI nodes
@test
func test_loop_phi() -> I32 {
    var sum: I32 = 0
    for i in 0 to 5 {
        sum = sum + i  // PHI for sum at loop header
    }
    // 0+1+2+3+4 = 10
    assert_eq(sum, 10, "sum of 0 to 4 should equal 10")
    return 0
}

// Test 5: Nested loops with PHI nodes
@test
func test_nested_loop_phi() -> I32 {
    var total: I32 = 0
    for i in 0 to 3 {
        for j in 0 to 3 {
            total = total + 1
        }
    }
    assert_eq(total, 9, "3x3 nested loop should count to 9")
    return 0
}

// Test 6: Loop with early exit
@test
func test_loop_early_exit() -> I32 {
    var count: I32 = 0
    var i: I32 = 0

    loop (i < 10) {
        count = count + 1
        if count == 5 then {
            break
        }
        i = i + 1
    }

    assert_eq(count, 5, "loop with break at 5 should count to 5")
    return 0
}

// Test 7: Complex control flow with multiple PHI merges
@test
func test_complex_cfg() -> I32 {
    let a: I32 = 3
    let b: I32 = 4

    let result: I32 = if a > 2 then {
        let temp: I32 = if b > 3 then { a + b } else { a }
        temp * 2
    } else {
        if b > 5 then { b } else { 0 }
    }

    // (3+4)*2 = 14
    assert_eq(result, 14, "(a+b)*2 with a=3, b=4 should equal 14")
    return 0
}

// Test 8: Switch-like pattern with multiple branches
@test
func test_switch_pattern() -> I32 {
    let x: I32 = 2

    let result: I32 = if x == 1 then {
        10
    } else if x == 2 then {
        20
    } else if x == 3 then {
        30
    } else {
        0
    }

    assert_eq(result, 20, "x=2 should match second branch returning 20")
    return 0
}
