// Test generic types - monomorphization

use test

// ============ Generic Struct ============

type Pair[T] {
    first: T,
    second: T,
}

@test
func test_generic_struct_i32() {
    let p: Pair[I32] = Pair { first: 10, second: 20 }
    assert_eq(p.first, 10, "first should be 10")
    assert_eq(p.second, 20, "second should be 20")
}

@test
func test_generic_struct_multiple() {
    let p1: Pair[I32] = Pair { first: 1, second: 2 }
    let p2: Pair[I32] = Pair { first: 100, second: 200 }
    assert_eq(p1.first, 1, "p1.first should be 1")
    assert_eq(p2.first, 100, "p2.first should be 100")
}

// ============ Generic Enum ============

type Maybe[T] {
    Just(T),
    Nothing,
}

@test
func test_generic_enum_just() {
    let m: Maybe[I32] = Just(42)
    when m {
        Just(v) => assert_eq(v, 42, "value should be 42"),
        Nothing => assert(false, "should not be Nothing"),
    }
}

@test
func test_generic_enum_nothing() {
    let m: Maybe[I32] = Nothing
    when m {
        Just(_) => assert(false, "should not be Just"),
        Nothing => assert(true, "should be Nothing"),
    }
}

// ============ Multi-parameter Generic ============

type Entry[K, V] {
    key: K,
    value: V,
}

@test
func test_multi_param_generic() {
    let e: Entry[I32, I32] = Entry { key: 1, value: 100 }
    assert_eq(e.key, 1, "key should be 1")
    assert_eq(e.value, 100, "value should be 100")
}
