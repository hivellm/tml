// Tests for generic ownership bounds (Phase 4 of memory-safety-parity)
//
// This file tests the Duplicate and Copy behavior bounds on generic types.

use test

// =============================================================================
// Working Tests (Copy/Duplicate behavior on primitives)
// =============================================================================

@test
func primitive_copy_works() -> I32 {
    // Primitives implement Copy, so they can be copied implicitly
    let x: I32 = 42
    let y: I32 = x  // Copy
    assert_eq(x, 42, "x should still be usable after copy")
    assert_eq(y, 42, "y should have the copied value")
    return 0
}

@test
func primitive_duplicate_works() -> I32 {
    // Primitives also implement Duplicate
    let x: I32 = 42
    let y: I32 = x.duplicate()
    assert_eq(x, 42, "x should still be usable after duplicate")
    assert_eq(y, 42, "y should have the duplicated value")
    return 0
}

// =============================================================================
// Generic Functions with Duplicate Bounds (Documented)
// =============================================================================

// The following tests document expected behavior for generic bounds.
// Some tests are commented out pending full generic codegen support.

// Generic function that requires Duplicate bound
// func duplicate_value[T: Duplicate](val: T) -> T {
//     return val.duplicate()
// }

// @test
// func generic_duplicate_i32() -> I32 {
//     let x: I32 = 42
//     let y: I32 = duplicate_value(x)
//     assert_eq(y, 42, "generic duplicate should work with I32")
//     return 0
// }

// =============================================================================
// Copy Behavior Tests
// =============================================================================

// Copy types can be implicitly copied in assignment
@test
func copy_type_assignment() -> I32 {
    let a: I32 = 10
    let b: I32 = a  // Copy, not move
    let c: I32 = a  // Can use a again because it's Copy
    assert_eq(a + b + c, 30, "Copy types should allow multiple uses")
    return 0
}

// Copy types can be passed to functions without moving
func take_copy(x: I32) -> I32 {
    return x * 2
}

@test
func copy_type_function_call() -> I32 {
    let val: I32 = 21
    let result1: I32 = take_copy(val)
    let result2: I32 = take_copy(val)  // val still usable
    assert_eq(result1 + result2, 84, "Copy types should be usable after function calls")
    return 0
}

// =============================================================================
// Tuple Copy Semantics
// =============================================================================

// Note: Tuple literals default to I64, not I32. This test is commented out
// pending full tuple type inference support.
// @test
// func tuple_of_copy_types() -> I32 {
//     // Tuples of Copy types are also Copy
//     let t1: (I32, I32) = (1, 2)
//     let t2: (I32, I32) = t1  // Copy
//     let t3: (I32, I32) = t1  // Copy again
//     assert_eq(t1.0 + t2.0 + t3.0, 3, "Tuple of Copy types should be Copy")
//     return 0
// }

// =============================================================================
// Error Cases (Documented)
// =============================================================================

// ERROR: Type does not implement Duplicate
// @test
// func error_missing_duplicate_bound() -> I32 {
//     // NonCopyType doesn't implement Duplicate
//     // let val: NonCopyType = NonCopyType {}
//     // let dup = duplicate_value(val)  // ERROR: type does not satisfy Duplicate bound
//     return 0
// }

// ERROR: Owned type used after move
// @test
// func error_use_after_move() -> I32 {
//     // String is Owned (non-Copy)
//     // let s1: Str = "hello"
//     // let s2: Str = s1  // Move
//     // print(s1)  // ERROR: use of moved value
//     return 0
// }

// =============================================================================
// Maybe[T] with Duplicate Bound
// =============================================================================

@test
func maybe_duplicate() -> I32 {
    // Maybe[T] implements Duplicate when T: Duplicate
    let m1: Maybe[I32] = Just(42)
    let m2: Maybe[I32] = m1.duplicate()

    when m1 {
        Just(val) => assert_eq(val, 42, "m1 should still have value"),
        Nothing => return 1,
    }

    when m2 {
        Just(val) => assert_eq(val, 42, "m2 should have duplicated value"),
        Nothing => return 1,
    }

    return 0
}

// =============================================================================
// Outcome[T, E] with Duplicate Bound
// =============================================================================

@test
func outcome_duplicate_ok() -> I32 {
    // Outcome[T, E] implements Duplicate when T: Duplicate and E: Duplicate
    let r1: Outcome[I32, I32] = Ok(42)
    let r2: Outcome[I32, I32] = r1.duplicate()

    when r1 {
        Ok(val) => assert_eq(val, 42, "r1 should still have value"),
        Err(_) => return 1,
    }

    when r2 {
        Ok(val) => assert_eq(val, 42, "r2 should have duplicated value"),
        Err(_) => return 1,
    }

    return 0
}

@test
func outcome_duplicate_err() -> I32 {
    let r1: Outcome[I32, I32] = Err(100)
    let r2: Outcome[I32, I32] = r1.duplicate()

    when r1 {
        Ok(_) => return 1,
        Err(e) => assert_eq(e, 100, "r1 should still have error"),
    }

    when r2 {
        Ok(_) => return 1,
        Err(e) => assert_eq(e, 100, "r2 should have duplicated error"),
    }

    return 0
}
