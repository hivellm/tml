// Tests for partial move tracking (Phase 2 of memory-safety-parity)
//
// These tests verify that the borrow checker correctly tracks partial moves
// of struct fields, tuple elements, and array elements.

use test

// =============================================================================
// Type Definitions (must be at top level)
// =============================================================================

type Point {
    x: I32,
    y: I32
}

type Inner {
    value: I32
}

type Outer {
    inner: Inner,
    other: I32
}

// =============================================================================
// Basic Partial Move Tests
// =============================================================================

// Test: moving one field doesn't invalidate other fields
// This should work: we move p.a but can still use p.b
// Note: Requires codegen support for partial moves - documented test
// @test
// func partial_move_field_access() -> I32 {
//     type Pair {
//         a: I32,
//         b: I32,
//     }
//     let p: Pair = Pair { a: 1, b: 2 }
//     let x: I32 = p.a  // Move p.a (but I32 is Copy, so this just copies)
//     let y: I32 = p.b  // This should be fine
//     assert_eq(x + y, 3, "partial move should allow using other fields")
//     return 0
// }

// =============================================================================
// Copy Type Field Access (Should Always Work)
// =============================================================================

@test
func copy_field_access() -> I32 {
    // Copy types don't actually move, so all fields remain accessible
    let p: Point = Point { x: 10, y: 20 }
    let a: I32 = p.x  // Copy, not move
    let b: I32 = p.y  // Copy, not move
    let c: I32 = p.x  // Still accessible because I32 is Copy
    assert_eq(a + b + c, 40, "copy types should be accessible after use")
    return 0
}

// =============================================================================
// Nested Field Access
// =============================================================================

@test
func nested_field_access() -> I32 {
    // Accessing nested fields of copy types
    let o: Outer = Outer { inner: Inner { value: 42 }, other: 10 }
    let x: I32 = o.inner.value  // Access nested field
    let y: I32 = o.other        // Access sibling field
    assert_eq(x + y, 52, "nested field access should work")
    return 0
}

// =============================================================================
// Error Cases (Documented - should fail to compile)
// =============================================================================

// ERROR B016: use of partially moved value
// When a non-Copy field is moved, the whole struct cannot be used
// @test
// func error_use_after_partial_move() -> I32 {
//     type Container {
//         data: Str,
//         count: I32,
//     }
//     let c: Container = Container { data: Str::from("hello"), count: 5 }
//     let s: Str = c.data  // Move c.data
//     // ERROR B016: use of partially moved value `c`
//     // drop(c)  // Cannot use c as a whole after partial move
//     return 0
// }

// ERROR: use of moved field
// @test
// func error_use_moved_field() -> I32 {
//     type Container {
//         data: Str,
//     }
//     let c: Container = Container { data: Str::from("hello") }
//     let s: Str = c.data  // Move c.data
//     // ERROR: use of moved value `c.data`
//     // let t: Str = c.data  // Cannot use c.data again
//     return 0
// }

// =============================================================================
// Tuple Element Access (Copy Types)
// =============================================================================

// Note: Tuple literals default to I64, not I32. Commented out pending
// full tuple type inference support.
// @test
// func tuple_element_copy() -> I32 {
//     // Tuple elements of copy types
//     let t: (I32, I32, I32) = (1, 2, 3)
//     let a: I32 = t.0
//     let b: I32 = t.1
//     let c: I32 = t.2
//     assert_eq(a + b + c, 6, "tuple element access should work")
//     return 0
// }

// =============================================================================
// Array Element Access
// =============================================================================

@test
func array_element_copy() -> I32 {
    // Array elements of copy types
    let arr: [I32; 3] = [10, 20, 30]
    let a: I32 = arr[0]
    let b: I32 = arr[1]
    let c: I32 = arr[2]
    assert_eq(a + b + c, 60, "array element access should work")
    return 0
}
