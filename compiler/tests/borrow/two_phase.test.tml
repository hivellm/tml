// Tests for two-phase borrow enhancement (Phase 6 of memory-safety-parity)
//
// Two-phase borrowing allows ergonomic patterns like `vec.push(vec.len())`
// where the mutable borrow for `push` coexists with a shared borrow for `len`.

use test

// =============================================================================
// Basic Two-Phase Borrow Infrastructure Tests
// =============================================================================

@test
func basic_sequential_borrows() -> I32 {
    // Sequential borrows are always allowed (no two-phase needed)
    let mut x: I32 = 42
    let a: I32 = x     // read x
    let b: I32 = x + 1 // read x again
    x = b + 1          // write x
    assert_eq(x, 44, "sequential borrows should work")
    return 0
}

@test
func basic_read_after_write() -> I32 {
    // Write then read is fine
    let mut x: I32 = 0
    x = 42
    let y: I32 = x
    assert_eq(y, 42, "read after write should work")
    return 0
}

// =============================================================================
// Working Tests: Struct Field Access Patterns
// =============================================================================

type Pair {
    a: I32,
    b: I32
}

type Inner {
    value: I32
}

type Outer {
    inner: Inner,
    other: I32
}

@test
func struct_field_sequential_access() -> I32 {
    // Sequential field access works
    let mut p: Pair = Pair { a: 1, b: 2 }
    let x: I32 = p.a
    let y: I32 = p.b
    p.a = x + y
    assert_eq(p.a, 3, "struct field sequential access should work")
    return 0
}

@test
func struct_different_field_borrow() -> I32 {
    // Borrowing different fields simultaneously is allowed
    let mut p: Pair = Pair { a: 10, b: 20 }
    let sum: I32 = p.a + p.b  // Both fields read simultaneously
    p.a = sum
    assert_eq(p.a, 30, "different field borrows should work")
    return 0
}

// =============================================================================
// Working Tests: Nested Scope Patterns
// =============================================================================

@test
func two_phase_scope_boundaries() -> I32 {
    // Two-phase borrow state is scoped correctly
    let mut x: I32 = 0
    {
        let a: I32 = x  // read in inner scope
        x = a + 1       // write in inner scope
    }
    let b: I32 = x      // read in outer scope
    assert_eq(b, 1, "scope boundaries should be respected")
    return 0
}

@test
func nested_struct_read() -> I32 {
    // Nested struct field read (assignment has separate codegen bug)
    let o: Outer = Outer { inner: Inner { value: 10 }, other: 20 }
    let x: I32 = o.inner.value
    let y: I32 = o.other
    let sum: I32 = x + y
    assert_eq(sum, 30, "nested struct read should work")
    return 0
}

// =============================================================================
// Documentation: Two-Phase State Machine
// =============================================================================

// The two-phase borrow state machine:
//
// TwoPhaseState::None
//     |
//     | begin_two_phase_borrow() or reserve_two_phase_borrow()
//     v
// TwoPhaseState::Reserved
//     |  - Shared borrows of the same place are allowed
//     |  - Mutable conflicts are suppressed
//     |
//     | activate_two_phase_borrow()
//     v
// TwoPhaseState::Active
//     |  - Normal borrow rules apply
//     |  - No concurrent borrows allowed
//     |
//     | end_two_phase_borrow()
//     v
// TwoPhaseState::None
//
// The TwoPhaseInfo struct tracks:
// - place: The PlaceId being borrowed
// - state: Current TwoPhaseState
// - borrow_index: Index in active_borrows
// - kind: BorrowKind (typically Mutable)
// - start: Location where borrow was created

// =============================================================================
// Two-Phase Borrow Patterns (Documented)
// =============================================================================

// Pattern 1: vec.push(vec.len())
// - push() needs &mut vec (Reserved during argument evaluation)
// - len() needs &vec (Allowed because push's borrow is Reserved)
// - push() executes (borrow becomes Active)

// Pattern 2: map[key] = compute(&map)
// - map[key] needs &mut map (Reserved during RHS evaluation)
// - compute(&map) needs &map (Allowed because map[key]'s borrow is Reserved)
// - Assignment executes (borrow becomes Active)

// These patterns are tested via borrow_test.cpp unit tests which can
// directly manipulate the TwoPhaseState.

// =============================================================================
// Summary
// =============================================================================

// Phase 6 implements:
// 1. TwoPhaseState enum: None, Reserved, Active
// 2. TwoPhaseInfo struct for tracking state
// 3. reserve_two_phase_borrow(): Create borrow in Reserved state
// 4. activate_two_phase_borrow(): Transition to Active state
// 5. is_reserved_borrow(): Check if place has reserved borrow
// 6. get_two_phase_state(): Get current state
//
// The key insight: During Reserved state, shared borrows are allowed.
// This enables patterns that were previously impossible while maintaining
// memory safety.
