use test

// Time Runtime Tests
// Tests all functions from runtime/time.c
// NOTE: Using explicit return codes instead of assert() to avoid
// potential issues with the test library shadowing the builtin assert

@test
func test_time_ms() -> I32 {
    let t: I32 = time_ms()
    // Time should be a positive value (system uptime in ms)
    if t > 0 {
        return 0  // Success
    }
    return 1  // Failure
}

@test
func test_time_us() -> I32 {
    let t: I64 = time_us()
    // Time in microseconds should be positive
    if t > 0 {
        return 0
    }
    return 1
}

// time_ns test skipped - may overflow on some systems

@test
func test_time_monotonic() -> I32 {
    let t1: I64 = time_us()
    let t2: I64 = time_us()
    // Time should be monotonically increasing or equal
    if t2 >= t1 {
        return 0
    }
    return 1
}

@test
func test_sleep_ms() -> I32 {
    let start: I32 = time_ms()
    sleep_ms(50)  // Sleep for 50ms
    let elapsed: I32 = time_ms() - start
    // Should have slept at least some time
    if elapsed >= 0 {
        return 0
    }
    return 1
}

@test
func test_elapsed_ms() -> I32 {
    let start: I32 = time_ms()
    sleep_ms(50)
    let elapsed: I32 = elapsed_ms(start)
    // Just verify it doesn't return negative
    if elapsed >= 0 {
        return 0
    }
    return 1
}

@test
func test_elapsed_us() -> I32 {
    let start: I64 = time_us()
    sleep_ms(50)
    let elapsed: I64 = elapsed_us(start)
    // Just verify it returns a non-negative value
    if elapsed >= 0 {
        return 0
    }
    return 1
}

@test
func test_sleep_us() -> I32 {
    let start: I64 = time_us()
    let sleep_time: I64 = 50000  // 50000 microseconds = 50ms
    sleep_us(sleep_time)
    let elapsed: I64 = elapsed_us(start)
    // Just verify it doesn't return negative
    if elapsed >= 0 {
        return 0
    }
    return 1
}

// elapsed_ns test skipped - uses time_ns which may overflow
