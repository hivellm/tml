use test
use std::time::Instant
use std::time::sleep

use core::time::Duration

// Time Runtime Tests
// Migrated from time_ms/time_us/elapsed_ms/elapsed_us/sleep_us builtins
// to std::time::Instant and sleep()

@test
func test_time_ns() -> I32 {
    let t = Instant::now()
    let ns = t.as_nanos()
    // Time should be a positive value
    if ns > 0 {
        return 0  // Success
    }
    return 1  // Failure
}

@test
func test_time_monotonic() -> I32 {
    let t1 = Instant::now()
    let t2 = Instant::now()
    // Time should be monotonically increasing or equal
    let diff = t2.as_nanos() - t1.as_nanos()
    if diff >= 0 {
        return 0
    }
    return 1
}

@test
func test_sleep_ms() -> I32 {
    let start = Instant::now()
    sleep(Duration::from_millis(50))  // Sleep for 50ms
    let elapsed = start.elapsed()
    let ms = elapsed.as_millis()
    // Should have slept at least some time
    if ms >= 0 {
        return 0
    }
    return 1
}

@test
func test_elapsed() -> I32 {
    let start = Instant::now()
    sleep(Duration::from_millis(50))
    let elapsed = start.elapsed()
    let nanos = elapsed.as_nanos()
    // Just verify it doesn't return negative
    if nanos >= 0 {
        return 0
    }
    return 1
}
