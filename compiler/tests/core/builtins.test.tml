use test
use std::time::Instant
use core::hash

// ============================================================================
// Comprehensive Builtin Function Tests
// Tests print, string methods, hash, time functions
// Phase 29: Migrated from bare str_len/str_eq/str_hash builtins to methods
// ============================================================================

// ============================================================================
// String Length (.len() method)
// ============================================================================

@test
func test_str_len_empty() -> I32 {
    assert_eq("".len(), 0, "empty string should have length 0")
    return 0
}

@test
func test_str_len_single_char() -> I32 {
    assert_eq("x".len(), 1, "single char should have length 1")
    return 0
}

@test
func test_str_len_word() -> I32 {
    assert_eq("hello".len(), 5, "hello should have length 5")
    return 0
}

@test
func test_str_len_sentence() -> I32 {
    assert_eq("Hello, World!".len(), 13, "Hello, World! should have length 13")
    return 0
}

@test
func test_str_len_with_spaces() -> I32 {
    assert_eq("   ".len(), 3, "three spaces should have length 3")
    return 0
}

@test
func test_str_len_numbers() -> I32 {
    assert_eq("12345".len(), 5, "12345 should have length 5")
    return 0
}

// ============================================================================
// String Equality (== operator)
// ============================================================================

@test
func test_str_eq_identical() -> I32 {
    assert("hello" == "hello", "identical strings should be equal")
    return 0
}

@test
func test_str_eq_different() -> I32 {
    assert("hello" != "world", "different strings should not be equal")
    return 0
}

@test
func test_str_eq_empty() -> I32 {
    assert("" == "", "two empty strings should be equal")
    return 0
}

@test
func test_str_eq_empty_vs_nonempty() -> I32 {
    assert("" != "a", "empty vs non-empty should not be equal")
    return 0
}

@test
func test_str_eq_case_sensitive() -> I32 {
    assert("Hello" != "hello", "case should matter in comparison")
    return 0
}

@test
func test_str_eq_same_prefix() -> I32 {
    assert("hello" != "helloworld", "prefix should not equal longer string")
    return 0
}

@test
func test_str_eq_whitespace() -> I32 {
    assert(" " == " ", "same whitespace should be equal")
    assert("a " != "a", "trailing space should matter")
    return 0
}

// ============================================================================
// String Hash (.hash() method)
// ============================================================================

@test
func test_str_hash_consistent() -> I32 {
    let hash1: I64 = "test".hash()
    let hash2: I64 = "test".hash()
    assert_eq(hash1, hash2, "same string should produce same hash")
    return 0
}

@test
func test_str_hash_different() -> I32 {
    let hash1: I64 = "hello".hash()
    let hash2: I64 = "world".hash()
    assert(hash1 != hash2, "different strings should have different hashes")
    return 0
}

@test
func test_str_hash_empty() -> I32 {
    let hash1: I64 = "".hash()
    let hash2: I64 = "".hash()
    assert_eq(hash1, hash2, "empty string hash should be consistent")
    return 0
}

@test
func test_str_hash_single_char_different() -> I32 {
    let hash_a: I64 = "a".hash()
    let hash_b: I64 = "b".hash()
    assert(hash_a != hash_b, "a and b should have different hashes")
    return 0
}

// ============================================================================
// Time Functions (via std::time::Instant)
// time_ms/time_us builtins were removed â€” use Instant::now() instead.
// ============================================================================

@test
func test_time_ns_runs() -> I32 {
    // Verify time_ns() runs via Instant::now()
    let start = Instant::now()
    let ns = start.as_nanos()
    let check: Bool = ns == ns
    assert_eq(check, true, "time_ns should return a value")
    return 0
}

// ============================================================================
// Print Functions (polymorphic)
// ============================================================================

@test
func test_print_i32() -> I32 {
    // Just verify it doesn't crash - output goes to stdout
    print(42)
    print(-100)
    print(0)
    return 0
}

@test
func test_print_bool() -> I32 {
    print(true)
    print(false)
    return 0
}

@test
func test_print_string() -> I32 {
    print("Hello from test")
    return 0
}

@test
func test_println_string() -> I32 {
    println("Test output line")
    return 0
}

@test
func test_print_mixed() -> I32 {
    print("Value: ")
    print(42)
    println("")
    return 0
}

// ============================================================================
// Panic Function (commented out - would terminate test)
// ============================================================================

// Note: panic() terminates the program, so we can't directly test it
// But we can verify it exists by referencing it in a conditional that's never true

@test
func test_panic_exists() -> I32 {
    // This should compile, showing panic exists
    // We never execute it
    if false {
        panic("This should never run")
    }
    return 0
}

// ============================================================================
// Combined Builtin Usage
// ============================================================================

@test
func test_string_operations_combined() -> I32 {
    let s1: Str = "hello"
    let s2: Str = "hello"
    let s3: Str = "world"

    // Check length
    assert_eq(s1.len(), 5, "hello length should be 5")

    // Check equality
    assert(s1 == s2, "hello == hello")
    assert(s1 != s3, "hello != world")

    // Check hash consistency
    let h1: I64 = s1.hash()
    let h2: I64 = s2.hash()
    assert_eq(h1, h2, "equal strings should have equal hashes")

    return 0
}

@test
func test_time_instant_works() -> I32 {
    // Verify Instant::now() works and returns consistent values
    let t1 = Instant::now()
    let t2 = Instant::now()
    let diff = t2.as_nanos() - t1.as_nanos()
    let check: Bool = diff >= 0
    assert_eq(check, true, "Instant should be monotonic")
    return 0
}

// ============================================================================
// Edge Cases
// ============================================================================

@test
func test_str_len_special_chars() -> I32 {
    // a, tab, b, newline, c = 5 characters
    assert_eq("a\tb\nc".len(), 5, "string with escapes should have correct length")
    return 0
}

@test
func test_str_eq_special_chars() -> I32 {
    assert("a\n" == "a\n", "strings with newlines should be equal")
    return 0
}

@test
func test_str_hash_special_chars() -> I32 {
    let h1: I64 = "a\n".hash()
    let h2: I64 = "a\n".hash()
    assert_eq(h1, h2, "special char strings should have consistent hash")
    return 0
}
