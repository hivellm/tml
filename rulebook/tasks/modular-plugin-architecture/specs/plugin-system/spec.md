# Plugin System Specification

## Overview

The TML compiler plugin system enables splitting the monolithic compiler executable into dynamically loaded modules. Each module is a shared library (DLL on Windows, .so on Linux) that exports a standardized C ABI. Modules are optionally compressed with zstd and loaded on demand based on the command being executed.

## ADDED Requirements

### Requirement: Plugin ABI Contract

The system SHALL define a stable C ABI for plugin modules consisting of:
- A `TmlPluginInfo` struct containing: ABI version (uint32), name, version, NULL-terminated capabilities array, NULL-terminated dependencies array
- Three exported functions: `tml_plugin_query()` returning metadata, `tml_plugin_init()` for initialization, `tml_plugin_shutdown()` for cleanup

#### Scenario: Plugin exports valid metadata
Given a plugin DLL compiled with `TML_PLUGIN_BUILDING` defined
When the launcher calls `tml_plugin_query()`
Then the function returns a non-null pointer to `TmlPluginInfo` with `abi_version` equal to `TML_PLUGIN_ABI_VERSION`

#### Scenario: ABI version mismatch rejection
Given a plugin DLL with `abi_version` different from the launcher's `TML_PLUGIN_ABI_VERSION`
When the launcher attempts to load the plugin
Then the launcher rejects the plugin with a clear error message and does not call `tml_plugin_init()`

### Requirement: Source Module Declaration

The system SHALL provide a `TML_MODULE("name")` macro that developers place at the top of each `.cpp` file to declare which plugin module the file belongs to. The macro MUST be a no-op at compile time with zero runtime cost. The build system MUST scan source files for this macro to generate per-module source lists.

#### Scenario: Source file with TML_MODULE annotation
Given a source file `foo.cpp` containing `TML_MODULE("codegen_x86")` on its first non-comment line
When the CMake module collection script processes the source tree
Then `foo.cpp` is assigned to the `codegen_x86` module source list

#### Scenario: Source file without TML_MODULE annotation
Given a source file `bar.cpp` that does not contain any `TML_MODULE` declaration
When the CMake module collection script processes the source tree
Then `bar.cpp` is assigned to the `compiler` module by default

### Requirement: On-Demand Plugin Loading

The system SHALL load plugin DLLs only when the command being executed requires them. The launcher MUST determine required plugins from the command name before loading any shared library.

#### Scenario: Help command loads no plugins
Given the user runs `tml --help`
When the launcher processes the command
Then no plugin DLLs are loaded and the help text is displayed from the launcher itself

#### Scenario: Check command loads only compiler
Given the user runs `tml check file.tml`
When the launcher determines required plugins
Then only `tml_compiler` is loaded and the LLVM backend plugin is not loaded

#### Scenario: Build command loads compiler and backend
Given the user runs `tml build file.tml`
When the launcher determines required plugins
Then both `tml_compiler` and `tml_codegen_x86` are loaded

### Requirement: Compressed Plugin Storage

The system SHALL support zstd-compressed plugin DLLs with the `.dll.zst` extension. Compressed plugins MUST be decompressed to a cache directory before loading. The cache MUST use hash-based invalidation to avoid redundant decompression.

#### Scenario: First load decompresses to cache
Given a compressed plugin `plugins/tml_compiler.dll.zst` exists and no cached DLL is present
When the launcher loads the `tml_compiler` plugin
Then the plugin is decompressed to `cache/plugins/tml_compiler.dll` and a hash file is written alongside it

#### Scenario: Subsequent load uses cache
Given a cached DLL `cache/plugins/tml_compiler.dll` exists with a matching hash
When the launcher loads the `tml_compiler` plugin
Then no decompression occurs and the cached DLL is loaded directly

#### Scenario: Cache invalidation on update
Given a cached DLL exists but the hash does not match the current `.dll.zst` file
When the launcher loads the plugin
Then the cached DLL is replaced with a fresh decompression of the updated `.dll.zst`

### Requirement: Plugin Manifest

The system SHALL use a `manifest.json` file in the plugins directory that describes all available plugins including: file name, compressed/uncompressed sizes, content hash, capabilities list, and dependency list. The manifest MUST be generated by the `tools/plugin_pack.tml` tool written in pure TML.

#### Scenario: Manifest lists all plugins
Given the plugin pack tool runs on a directory containing `tml_compiler.dll` and `tml_codegen_x86.dll`
When the tool completes
Then `manifest.json` is written with entries for both plugins including file paths, sizes, hashes, capabilities, and dependencies

### Requirement: Dual Build Mode

The system SHALL support both monolithic and modular build modes. The monolithic mode MUST remain the default and MUST produce identical output to the current build. The modular mode MUST be activated with `--modular` flag in the build script.

#### Scenario: Default build is monolithic
Given the user runs `scripts/build.bat` without flags
When the build completes
Then a single `tml.exe` is produced identical to the current monolithic build

#### Scenario: Modular build produces launcher and DLLs
Given the user runs `scripts/build.bat --modular`
When the build completes
Then a thin `tml.exe` launcher is produced alongside separate plugin DLLs

### Requirement: Plugin Dependency Resolution

The system SHALL resolve plugin dependencies before loading. If plugin A declares a dependency on plugin B, the system MUST load plugin B first and call its `tml_plugin_init()` before loading plugin A.

#### Scenario: Backend depends on compiler
Given `tml_codegen_x86` declares `["compiler"]` in its dependencies
When the launcher loads `tml_codegen_x86`
Then `tml_compiler` is loaded and initialized first

### Requirement: Extensibility for New Backends

The system SHALL allow new codegen backends (e.g., CUDA, OpenCL, SPIR-V) to be added as plugin DLLs without modifying the launcher or core compiler. A new backend MUST only require: source files annotated with `TML_MODULE("codegen_xxx")`, a plugin entry point exporting `TmlPluginInfo`, and a CMake SHARED target.

#### Scenario: Adding a CUDA backend
Given a developer creates `codegen/cuda/cuda_backend.cpp` with `TML_MODULE("codegen_cuda")` and the required plugin exports
When the modular build runs
Then `tml_codegen_cuda.dll` is produced as a separate plugin loadable with `--target=cuda`

### Requirement: TML-Native Tooling

The plugin packaging and verification tools MUST be written in pure TML using standard library modules (`std::zlib`, `std::crypto`, `std::json`, `std::file`, `std::glob`). No Python, Bash, or other scripting languages SHALL be used for plugin tooling.

#### Scenario: Plugin pack tool compiles with TML
Given the source file `tools/plugin_pack.tml` exists
When the user runs `tml build tools/plugin_pack.tml`
Then a standalone `plugin_pack` executable is produced that can compress DLLs and generate manifests

### Requirement: Cross-Platform Support

The plugin loader MUST work on both Windows and Linux. On Windows it SHALL use `LoadLibraryW` and `GetProcAddress`. On Linux it SHALL use `dlopen` with `RTLD_LAZY` and `dlsym`. Plugin discovery MUST search: (1) the executable directory, (2) `TML_MODULE_DIR` environment variable, (3) `../lib/tml/` relative to the executable.

#### Scenario: Plugin discovery on Windows
Given `tml.exe` is at `C:\tools\tml.exe` and `tml_compiler.dll.zst` is at `C:\tools\plugins\tml_compiler.dll.zst`
When the launcher searches for the compiler plugin
Then the plugin is found in the `plugins/` subdirectory of the executable directory
