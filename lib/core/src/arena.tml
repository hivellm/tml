//! Arena Allocator for fast bump-pointer allocation.
//!
//! This module provides `Arena`, a high-performance allocator that uses
//! bump-pointer allocation for extremely fast allocations with bulk deallocation.
//!
//! # Overview
//!
//! Arena allocators are ideal when:
//! - Many allocations are made during a phase (e.g., HTTP request handling)
//! - Individual deallocations are not needed
//! - All allocations can be freed at once when the phase completes
//!
//! # Performance
//!
//! - Allocation: O(1) - just a pointer increment
//! - Deallocation: O(1) - reset the bump pointer
//! - Memory overhead: Minimal (just arena metadata)
//!
//! # Example
//!
//! ```tml
//! use core::arena::Arena
//!
//! // Create an arena with 64KB initial capacity
//! let arena = Arena::new(65536)
//!
//! // Allocate objects - extremely fast!
//! let user = arena.alloc[User]()
//! let request = arena.alloc[Request]()
//! let items = arena.alloc_slice[Item](100)
//!
//! // Process request...
//!
//! // Reset arena - all allocations freed instantly
//! arena.reset()
//! ```
//!
//! # Thread Safety
//!
//! Each arena should be used by a single thread. For multi-threaded scenarios,
//! use one arena per thread or use ThreadLocalArena.

use core::alloc::{Layout, AllocError}
use core::sync::{atomic_load, atomic_store, atomic_cas_val, fence_acquire, fence_release}
use core::mem::size_of

// ============================================================================
// Arena Statistics
// ============================================================================

/// Statistics about arena usage.
pub type ArenaStats {
    /// Total bytes allocated in this arena
    pub bytes_allocated: I64,
    /// Peak bytes allocated before any reset
    pub peak_bytes: I64,
    /// Number of individual allocations made
    pub allocation_count: I64,
    /// Number of times the arena was reset
    pub reset_count: I64,
    /// Number of times the arena had to grow
    pub grow_count: I64,
    /// Total capacity across all chunks
    pub total_capacity: I64,
}

impl ArenaStats {
    /// Creates empty statistics.
    pub func new() -> ArenaStats {
        ArenaStats {
            bytes_allocated: 0,
            peak_bytes: 0,
            allocation_count: 0,
            reset_count: 0,
            grow_count: 0,
            total_capacity: 0,
        }
    }

    /// Returns the memory utilization as a percentage (0-100).
    pub func utilization(this) -> F64 {
        if this.total_capacity == 0 {
            return 0.0
        }
        (this.bytes_allocated as F64 / this.total_capacity as F64) * 100.0
    }
}

// ============================================================================
// ArenaChunk - Internal memory block
// ============================================================================

/// Internal memory chunk in the arena.
/// Each chunk contains a contiguous block of memory for allocations.
type ArenaChunk {
    /// Pointer to the start of the memory block
    data: I64,
    /// Size of this chunk in bytes
    size: I64,
    /// Current position (bump pointer) within the chunk
    pos: I64,
    /// Pointer to the next chunk (for chunk list)
    next: I64,
}

impl ArenaChunk {
    /// Creates a new chunk with the given capacity.
    func new(capacity: I64) -> Maybe[ArenaChunk] {
        let data = lowlevel { malloc(capacity) } as I64
        if data == 0 {
            return Nothing
        }
        Just(ArenaChunk {
            data: data,
            size: capacity,
            pos: 0,
            next: 0,
        })
    }

    /// Returns remaining space in this chunk.
    func remaining(this) -> I64 {
        this.size - this.pos
    }

    /// Tries to allocate size bytes with given alignment.
    /// Returns the pointer if successful, 0 if not enough space.
    func try_alloc(mut this, size: I64, align: I64) -> I64 {
        // Align the current position
        let aligned_pos = align_up(this.data + this.pos, align) - this.data
        let end_pos = aligned_pos + size

        if end_pos > this.size {
            return 0 // Not enough space
        }

        let ptr = this.data + aligned_pos
        this.pos = end_pos
        ptr
    }

    /// Resets this chunk to empty state.
    func reset(mut this) {
        this.pos = 0
    }

    /// Frees the memory of this chunk.
    func free(mut this) {
        if this.data != 0 {
            lowlevel { free(this.data as Ptr[U8]) }
            this.data = 0
        }
    }
}

// ============================================================================
// Arena - The main arena allocator
// ============================================================================

/// A bump-pointer arena allocator for fast allocations.
///
/// Allocations are made by simply incrementing a pointer, making them
/// extremely fast. Memory is freed all at once when the arena is reset
/// or dropped.
///
/// # Memory Layout
///
/// The arena maintains a list of memory chunks. When the current chunk
/// is full, a new larger chunk is allocated. All chunks are freed
/// together when the arena is reset or dropped.
pub type Arena {
    /// List of chunks (head is current chunk)
    chunks: List[ArenaChunk],
    /// Index of current chunk in the list
    current_chunk: I64,
    /// Default chunk size for growth
    default_chunk_size: I64,
    /// Statistics
    stats: ArenaStats,
}

impl Arena {
    /// Creates a new arena with the specified initial capacity.
    ///
    /// # Arguments
    ///
    /// * `initial_capacity` - Initial size in bytes (default: 64KB)
    ///
    /// # Example
    ///
    /// ```tml
    /// let arena = Arena::new(65536)  // 64KB
    /// ```
    pub func new(initial_capacity: I64) -> Arena {
        let capacity = if initial_capacity < 1024 { 1024 } else { initial_capacity }

        var arena = Arena {
            chunks: [],
            current_chunk: 0,
            default_chunk_size: capacity,
            stats: ArenaStats::new(),
        }

        // Allocate initial chunk
        when ArenaChunk::new(capacity) {
            Just(chunk) => {
                arena.chunks.push(chunk)
                arena.stats.total_capacity = capacity
            }
            Nothing => {
                // Allocation failed - arena will grow on first alloc
            }
        }

        arena
    }

    /// Creates an arena with default 64KB initial capacity.
    pub func default() -> Arena {
        Arena::new(65536)
    }

    /// Creates a small arena with 4KB initial capacity.
    pub func small() -> Arena {
        Arena::new(4096)
    }

    /// Creates a large arena with 1MB initial capacity.
    pub func large() -> Arena {
        Arena::new(1048576)
    }

    /// Allocates memory for a single object of type T.
    ///
    /// # Returns
    ///
    /// Pointer to uninitialized memory for type T.
    ///
    /// # Example
    ///
    /// ```tml
    /// let user_ptr = arena.alloc[User]()
    /// // Initialize the object
    /// *user_ptr = User { name: "Alice", age: 30 }
    /// ```
    pub func alloc[T](mut this) -> Ptr[T] {
        let size = 8  // Placeholder - should use size_of[T]()
        let align = 8 // Default alignment
        let ptr = this.alloc_raw(size, align)
        ptr as Ptr[T]
    }

    /// Allocates memory for a slice of count objects of type T.
    ///
    /// # Arguments
    ///
    /// * `count` - Number of objects to allocate
    ///
    /// # Returns
    ///
    /// Pointer to uninitialized memory for count objects.
    ///
    /// # Example
    ///
    /// ```tml
    /// let items = arena.alloc_slice[Item](100)
    /// ```
    pub func alloc_slice[T](mut this, count: I64) -> Ptr[T] {
        let obj_size = 8  // Placeholder - should use size_of[T]()
        let align = 8
        let total_size = obj_size * count
        let ptr = this.alloc_raw(total_size, align)
        ptr as Ptr[T]
    }

    /// Allocates raw memory with specified size and alignment.
    ///
    /// # Arguments
    ///
    /// * `size` - Number of bytes to allocate
    /// * `align` - Alignment requirement (must be power of 2)
    ///
    /// # Returns
    ///
    /// Pointer to allocated memory, or null on failure.
    pub func alloc_raw(mut this, size: I64, align: I64) -> I64 {
        if size <= 0 {
            return 0
        }

        // Try to allocate from current chunk
        if this.chunks.len() > 0 {
            let idx = this.current_chunk as I64
            if idx < this.chunks.len() {
                let ptr = this.chunks[idx].try_alloc(size, align)
                if ptr != 0 {
                    this.stats.bytes_allocated = this.stats.bytes_allocated + size
                    this.stats.allocation_count = this.stats.allocation_count + 1
                    if this.stats.bytes_allocated > this.stats.peak_bytes {
                        this.stats.peak_bytes = this.stats.bytes_allocated
                    }
                    return ptr
                }
            }
        }

        // Current chunk is full or doesn't exist, allocate new chunk
        let new_chunk_size = max_i64(size + align, this.default_chunk_size * 2)
        when ArenaChunk::new(new_chunk_size) {
            Just(chunk) => {
                this.chunks.push(chunk)
                this.current_chunk = this.chunks.len() - 1
                this.stats.total_capacity = this.stats.total_capacity + new_chunk_size
                this.stats.grow_count = this.stats.grow_count + 1
                this.default_chunk_size = new_chunk_size

                // Allocate from the new chunk
                let idx = this.current_chunk as I64
                let ptr = this.chunks[idx].try_alloc(size, align)
                if ptr != 0 {
                    this.stats.bytes_allocated = this.stats.bytes_allocated + size
                    this.stats.allocation_count = this.stats.allocation_count + 1
                    if this.stats.bytes_allocated > this.stats.peak_bytes {
                        this.stats.peak_bytes = this.stats.bytes_allocated
                    }
                }
                return ptr
            }
            Nothing => {
                return 0 // Allocation failed
            }
        }
    }

    /// Allocates and copies a string into the arena.
    ///
    /// # Arguments
    ///
    /// * `s` - String to copy
    ///
    /// # Returns
    ///
    /// Pointer to the copied string data.
    pub func alloc_str(mut this, s: Str) -> Ptr[U8] {
        let len = s.len()
        let ptr = this.alloc_raw(len + 1, 1) as Ptr[U8]
        if ptr as I64 != 0 {
            // Copy string data
            var i: I64 = 0
            loop (i < len) {
                lowlevel { ptr[i] = s.as_bytes()[i] }
                i = i + 1
            }
            // Null terminator
            lowlevel { ptr[len] = 0 }
        }
        ptr
    }

    /// Resets the arena, freeing all allocations instantly.
    ///
    /// After reset, the arena memory is reused for new allocations.
    /// All previously allocated pointers become invalid.
    ///
    /// # Example
    ///
    /// ```tml
    /// // Allocate many objects
    /// loop i in 0 to 1000 {
    ///     arena.alloc[SomeType]()
    /// }
    ///
    /// // Reset - all allocations freed instantly
    /// arena.reset()
    /// ```
    pub func reset(mut this) {
        // Reset all chunks to beginning
        var i: I64 = 0
        loop (i < this.chunks.len()) {
            this.chunks[i].reset()
            i = i + 1
        }

        // Reset to first chunk
        this.current_chunk = 0
        this.stats.bytes_allocated = 0
        this.stats.allocation_count = 0
        this.stats.reset_count = this.stats.reset_count + 1
    }

    /// Resets the arena and calls destructors on all allocated objects.
    ///
    /// Use this when allocated objects need cleanup (e.g., they hold resources).
    /// This is slower than reset() but ensures proper cleanup.
    ///
    /// Note: Currently just calls reset(). Full destructor support requires
    /// tracking allocated types.
    pub func reset_with_destructors(mut this) {
        // TODO: Track allocated objects and call their destructors
        // For now, just reset
        this.reset()
    }

    /// Returns current arena statistics.
    pub func stats(this) -> ArenaStats {
        this.stats
    }

    /// Returns total bytes currently allocated.
    pub func bytes_allocated(this) -> I64 {
        this.stats.bytes_allocated
    }

    /// Returns total capacity of the arena.
    pub func capacity(this) -> I64 {
        this.stats.total_capacity
    }

    /// Returns number of allocations made since last reset.
    pub func allocation_count(this) -> I64 {
        this.stats.allocation_count
    }

    /// Clears the arena and frees all memory.
    ///
    /// After clear, the arena is empty and all memory is returned to the system.
    pub func clear(mut this) {
        // Free all chunks
        loop (true) {
            when this.chunks.pop() {
                Just(mut chunk) => chunk.free(),
                Nothing => break
            }
        }

        this.current_chunk = 0
        this.stats = ArenaStats::new()
    }
}

// ============================================================================
// Drop implementation
// ============================================================================

impl Drop for Arena {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// ScopedArena - RAII wrapper for arena sections
// ============================================================================

/// A scoped section of an arena that automatically resets on drop.
///
/// Useful for temporary allocations within a function.
///
/// # Example
///
/// ```tml
/// func process_data(arena: mut ref Arena) {
///     // Create a scoped section
///     let scope = ScopedArena::new(arena)
///
///     // Allocations here...
///     let temp = scope.alloc[TempData]()
///
///     // When scope goes out of scope, arena resets to saved position
/// }
/// ```
pub type ScopedArena {
    /// Reference to parent arena
    arena_ptr: I64,
    /// Saved chunk index
    saved_chunk: I64,
    /// Saved position within chunk
    saved_pos: I64,
}

impl ScopedArena {
    /// Creates a new scoped arena section.
    pub func new(arena: mut ref Arena) -> ScopedArena {
        let chunk_idx = arena.current_chunk
        let pos = if arena.chunks.len() > 0 and chunk_idx < arena.chunks.len() {
            arena.chunks[chunk_idx].pos
        } else {
            0
        }

        ScopedArena {
            arena_ptr: (ref arena) as I64,
            saved_chunk: chunk_idx,
            saved_pos: pos,
        }
    }

    /// Allocates memory for a single object from the parent arena.
    pub func alloc[T](mut this) -> Ptr[T] {
        let arena = this.arena_ptr as mut ref Arena
        arena.alloc[T]()
    }

    /// Restores the arena to the saved position.
    pub func restore(mut this) {
        let arena = this.arena_ptr as mut ref Arena

        // Reset chunks after saved_chunk
        var i = arena.chunks.len() - 1
        loop (i > this.saved_chunk) {
            arena.chunks[i].reset()
            i = i - 1
        }

        // Reset current chunk to saved position
        if this.saved_chunk < arena.chunks.len() {
            arena.chunks[this.saved_chunk].pos = this.saved_pos
        }

        arena.current_chunk = this.saved_chunk
    }
}

impl Drop for ScopedArena {
    func drop(mut this) {
        this.restore()
    }
}

// ============================================================================
// ThreadLocalArena - Per-thread arena storage
// ============================================================================

/// Thread-local arena for use in multi-threaded applications.
///
/// Each thread gets its own arena instance, avoiding synchronization overhead.
///
/// # Example
///
/// ```tml
/// // Get the thread-local arena
/// let arena = ThreadLocalArena::get()
///
/// // Use it for allocations
/// let data = arena.alloc[RequestData]()
///
/// // Reset when done with the current request
/// arena.reset()
/// ```
pub type ThreadLocalArena {
    /// The underlying arena
    arena: Arena,
}

impl ThreadLocalArena {
    /// Creates a new thread-local arena.
    pub func new() -> ThreadLocalArena {
        ThreadLocalArena {
            arena: Arena::new(65536),
        }
    }

    /// Gets or creates the thread-local arena for the current thread.
    /// Note: Full thread-local storage requires runtime support.
    /// This is a placeholder that creates a new arena each call.
    pub func get() -> mut ref Arena {
        // TODO: Implement actual thread-local storage
        // For now, this is a placeholder
        static var global_arena: Arena = Arena::new(65536)
        return mut ref global_arena
    }

    /// Allocates from the arena.
    pub func alloc[T](mut this) -> Ptr[T] {
        this.arena.alloc[T]()
    }

    /// Resets the arena.
    pub func reset(mut this) {
        this.arena.reset()
    }
}

// ============================================================================
// Helper functions
// ============================================================================

/// Aligns a value up to the specified alignment.
func align_up(value: I64, align: I64) -> I64 {
    let mask = align - 1
    (value + mask) and (not mask)
}

/// Returns the maximum of two I64 values.
func max_i64(a: I64, b: I64) -> I64 {
    if a > b { a } else { b }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_arena_basic_allocation() {
    var arena = Arena::new(4096)

    // Allocate some memory
    let ptr1 = arena.alloc_raw(64, 8)
    assert(ptr1 != 0)

    let ptr2 = arena.alloc_raw(128, 8)
    assert(ptr2 != 0)
    assert(ptr2 != ptr1)

    // Pointers should be sequential (bump allocation)
    assert(ptr2 > ptr1)

    assert_eq(arena.allocation_count(), 2)
}

@test
func test_arena_reset() {
    var arena = Arena::new(4096)

    // Allocate some memory
    let ptr1 = arena.alloc_raw(64, 8)
    let ptr2 = arena.alloc_raw(128, 8)

    assert(arena.bytes_allocated() > 0)

    // Reset the arena
    arena.reset()

    assert_eq(arena.bytes_allocated(), 0)
    assert_eq(arena.allocation_count(), 0)
    assert_eq(arena.stats().reset_count, 1)

    // Can allocate again from the same memory
    let ptr3 = arena.alloc_raw(64, 8)
    assert(ptr3 != 0)
}

@test
func test_arena_growth() {
    var arena = Arena::new(128) // Small initial size

    // Allocate more than initial capacity
    let ptr1 = arena.alloc_raw(64, 8)
    let ptr2 = arena.alloc_raw(64, 8)
    let ptr3 = arena.alloc_raw(64, 8) // Should trigger growth

    assert(ptr1 != 0)
    assert(ptr2 != 0)
    assert(ptr3 != 0)

    assert(arena.stats().grow_count > 0)
}

@test
func test_arena_alignment() {
    var arena = Arena::new(4096)

    // Allocate with 8-byte alignment
    let ptr1 = arena.alloc_raw(1, 8)
    assert((ptr1 and 7) == 0) // Aligned to 8 bytes

    // Allocate with 16-byte alignment
    let ptr2 = arena.alloc_raw(1, 16)
    assert((ptr2 and 15) == 0) // Aligned to 16 bytes

    // Allocate with 64-byte alignment
    let ptr3 = arena.alloc_raw(1, 64)
    assert((ptr3 and 63) == 0) // Aligned to 64 bytes
}

@test
func test_arena_statistics() {
    var arena = Arena::new(4096)

    arena.alloc_raw(100, 8)
    arena.alloc_raw(200, 8)
    arena.alloc_raw(300, 8)

    let stats = arena.stats()
    assert_eq(stats.allocation_count, 3)
    assert(stats.bytes_allocated >= 600)
    assert(stats.peak_bytes >= 600)

    arena.reset()

    let stats2 = arena.stats()
    assert_eq(stats2.bytes_allocated, 0)
    assert_eq(stats2.reset_count, 1)
    assert(stats2.peak_bytes >= 600) // Peak preserved
}

@test
func test_scoped_arena() {
    var arena = Arena::new(4096)

    // Allocate before scope
    let ptr1 = arena.alloc_raw(64, 8)
    let before_count = arena.allocation_count()

    // Create a scope
    {
        var scope = ScopedArena::new(mut ref arena)

        // Allocate within scope
        let ptr2 = arena.alloc_raw(128, 8)
        let ptr3 = arena.alloc_raw(256, 8)

        assert(arena.allocation_count() > before_count)
    }
    // Scope dropped, arena should be restored
    // Note: In current implementation, this requires explicit restore() or drop

    // The arena should still have ptr1 valid
    assert(arena.allocation_count() >= before_count)
}

@test
func test_arena_clear() {
    var arena = Arena::new(4096)

    arena.alloc_raw(1000, 8)
    arena.alloc_raw(2000, 8)

    assert(arena.capacity() > 0)

    arena.clear()

    assert_eq(arena.capacity(), 0)
    assert_eq(arena.bytes_allocated(), 0)
}
