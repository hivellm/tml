//! Arena Allocator for fast bump-pointer allocation.
//!
//! This module provides `Arena`, a high-performance allocator that uses
//! bump-pointer allocation for extremely fast allocations with bulk deallocation.
//!
//! # Overview
//!
//! Arena allocators are ideal when:
//! - Many allocations are made during a phase (e.g., HTTP request handling)
//! - Individual deallocations are not needed
//! - All allocations can be freed at once when the phase completes
//!
//! # Performance
//!
//! - Allocation: O(1) - just a pointer increment
//! - Deallocation: O(1) - reset the bump pointer
//! - Memory overhead: Minimal (just arena metadata)
//!
//! # Example
//!
//! ```tml
//! use core::arena::Arena
//!
//! // Create an arena with 64KB initial capacity
//! var arena: Arena = Arena::new(65536)
//!
//! // Allocate raw memory
//! let ptr: I64 = arena.alloc_raw(64, 8)
//!
//! // Reset arena - all allocations freed instantly
//! arena.reset()
//! ```
//!
//! # Thread Safety
//!
//! Each arena should be used by a single thread. For multi-threaded scenarios,
//! use one arena per thread.

use test

// ============================================================================
// Arena Statistics
// ============================================================================

/// Statistics about arena usage.
pub type ArenaStats {
    /// Total bytes allocated in this arena
    pub bytes_allocated: I64,
    /// Peak bytes allocated before any reset
    pub peak_bytes: I64,
    /// Number of individual allocations made
    pub allocation_count: I64,
    /// Number of times the arena was reset
    pub reset_count: I64,
    /// Total capacity of the arena
    pub total_capacity: I64,
}

impl ArenaStats {
    /// Creates empty statistics.
    pub func new() -> ArenaStats {
        ArenaStats {
            bytes_allocated: 0,
            peak_bytes: 0,
            allocation_count: 0,
            reset_count: 0,
            total_capacity: 0,
        }
    }

    /// Returns the memory utilization as a percentage (0-100).
    pub func utilization(this) -> F64 {
        if this.total_capacity == (0 as I64) {
            return 0.0
        }
        let allocated: F64 = this.bytes_allocated as F64
        let capacity: F64 = this.total_capacity as F64
        return (allocated / capacity) * 100.0
    }
}

// ============================================================================
// Arena - The main arena allocator
// ============================================================================

/// A bump-pointer arena allocator for fast allocations.
///
/// Allocations are made by simply incrementing a pointer, making them
/// extremely fast. Memory is freed all at once when the arena is reset
/// or dropped.
///
/// This implementation uses a single pre-allocated buffer.
/// For applications needing dynamic growth, consider using multiple arenas.
pub type Arena {
    /// Base pointer of the memory buffer (stored as I64 for arithmetic)
    buffer: I64,
    /// Current bump position within the buffer
    pos: I64,
    /// Total capacity of the buffer
    capacity: I64,
    /// Statistics
    stats: ArenaStats,
}

impl Arena {
    /// Creates a new arena with the specified capacity.
    ///
    /// # Arguments
    ///
    /// * `capacity` - Size in bytes (minimum: 1024)
    ///
    /// # Example
    ///
    /// ```tml
    /// var arena: Arena = Arena::new(65536)  // 64KB
    /// ```
    pub func new(capacity: I64) -> Arena {
        let actual_cap: I64 = if capacity < 1024 { 1024 } else { capacity }

        let buf: *Unit = mem_alloc(actual_cap)
        let buf_i64: I64 = buf as I64

        var stats: ArenaStats = ArenaStats::new()
        if buf_i64 != (0 as I64) {
            stats.total_capacity = actual_cap
        }

        Arena {
            buffer: buf_i64,
            pos: 0,
            capacity: actual_cap,
            stats: stats,
        }
    }

    /// Creates an arena with default 64KB capacity.
    pub func default() -> Arena {
        Arena::new(65536)
    }

    /// Creates a small arena with 4KB capacity.
    pub func small() -> Arena {
        Arena::new(4096)
    }

    /// Creates a large arena with 1MB capacity.
    pub func large() -> Arena {
        Arena::new(1048576)
    }

    /// Allocates raw memory with specified size and alignment.
    ///
    /// # Arguments
    ///
    /// * `size` - Number of bytes to allocate
    /// * `align` - Alignment requirement (must be power of 2)
    ///
    /// # Returns
    ///
    /// Pointer to allocated memory, or 0 on failure.
    pub func alloc_raw(mut this, size: I64, align: I64) -> I64 {
        if size <= (0 as I64) or this.buffer == (0 as I64) {
            return 0
        }

        // Align the current position
        let current_addr: I64 = this.buffer + this.pos
        let aligned_addr: I64 = align_up(current_addr, align)
        let aligned_pos: I64 = aligned_addr - this.buffer
        let end_pos: I64 = aligned_pos + size

        if end_pos > this.capacity {
            return 0 // Not enough space
        }

        this.pos = end_pos
        this.stats.bytes_allocated = this.stats.bytes_allocated + size
        this.stats.allocation_count = this.stats.allocation_count + 1
        if this.stats.bytes_allocated > this.stats.peak_bytes {
            this.stats.peak_bytes = this.stats.bytes_allocated
        }

        aligned_addr
    }

    /// Resets the arena, allowing memory to be reused.
    ///
    /// After reset, the arena memory is reused for new allocations.
    /// All previously allocated pointers become invalid.
    pub func reset(mut this) {
        this.pos = 0
        this.stats.bytes_allocated = 0
        this.stats.allocation_count = 0
        this.stats.reset_count = this.stats.reset_count + 1
    }

    /// Returns current arena statistics.
    pub func stats(this) -> ArenaStats {
        this.stats
    }

    /// Returns total bytes currently allocated.
    pub func bytes_allocated(this) -> I64 {
        this.stats.bytes_allocated
    }

    /// Returns total capacity of the arena.
    pub func capacity(this) -> I64 {
        this.stats.total_capacity
    }

    /// Returns number of allocations made since last reset.
    pub func allocation_count(this) -> I64 {
        this.stats.allocation_count
    }

    /// Returns remaining space in the arena.
    pub func remaining(this) -> I64 {
        this.capacity - this.pos
    }

    /// Clears the arena and frees all memory.
    ///
    /// After clear, the arena is empty and cannot be used for allocations.
    pub func clear(mut this) {
        if this.buffer != (0 as I64) {
            let buf: *Unit = this.buffer as *Unit
            mem_free(buf)
            this.buffer = 0
        }
        this.pos = 0
        this.capacity = 0
        this.stats = ArenaStats::new()
    }
}

impl Drop for Arena {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// Helper functions
// ============================================================================

/// Aligns a value up to the specified alignment.
func align_up(value: I64, align: I64) -> I64 {
    let mask: I64 = align - 1
    return (value + mask) & (0 - align)
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_arena_basic_allocation() -> I32 {
    var arena: Arena = Arena::new(4096)

    // Allocate some memory
    let ptr1: I64 = arena.alloc_raw(64, 8)
    assert(ptr1 != (0 as I64), "first allocation should succeed")

    let ptr2: I64 = arena.alloc_raw(128, 8)
    assert(ptr2 != (0 as I64), "second allocation should succeed")
    assert(ptr2 != ptr1, "allocations should be different")

    // Pointers should be sequential (bump allocation)
    assert(ptr2 > ptr1, "second pointer should be after first")

    assert_eq(arena.allocation_count(), 2 as I64, "should have 2 allocations")
    return 0
}

@test
func test_arena_reset() -> I32 {
    var arena: Arena = Arena::new(4096)

    // Allocate some memory
    let ptr1: I64 = arena.alloc_raw(64, 8)
    let ptr2: I64 = arena.alloc_raw(128, 8)

    assert(arena.bytes_allocated() > 0 as I64, "should have allocated bytes")

    // Reset the arena
    arena.reset()

    assert_eq(arena.bytes_allocated(), 0 as I64, "bytes should be 0 after reset")
    assert_eq(arena.allocation_count(), 0 as I64, "count should be 0 after reset")
    assert_eq(arena.stats().reset_count, 1 as I64, "reset count should be 1")

    // Can allocate again from the same memory
    let ptr3: I64 = arena.alloc_raw(64, 8)
    assert(ptr3 != (0 as I64), "allocation after reset should succeed")
    return 0
}

@test
func test_arena_alignment() -> I32 {
    var arena: Arena = Arena::new(4096)

    // Allocate with 8-byte alignment
    let ptr1: I64 = arena.alloc_raw(1, 8)
    assert((ptr1 & (7 as I64)) == (0 as I64), "should be 8-byte aligned")

    // Allocate with 16-byte alignment
    let ptr2: I64 = arena.alloc_raw(1, 16)
    assert((ptr2 & (15 as I64)) == (0 as I64), "should be 16-byte aligned")

    // Allocate with 64-byte alignment
    let ptr3: I64 = arena.alloc_raw(1, 64)
    assert((ptr3 & (63 as I64)) == (0 as I64), "should be 64-byte aligned")
    return 0
}

@test
func test_arena_statistics() -> I32 {
    var arena: Arena = Arena::new(4096)

    arena.alloc_raw(100, 8)
    arena.alloc_raw(200, 8)
    arena.alloc_raw(300, 8)

    let stats: ArenaStats = arena.stats()
    assert_eq(stats.allocation_count, 3 as I64, "should have 3 allocations")
    assert(stats.bytes_allocated >= 600 as I64, "should have at least 600 bytes")
    assert(stats.peak_bytes >= 600 as I64, "peak should be at least 600")

    arena.reset()

    let stats2: ArenaStats = arena.stats()
    assert_eq(stats2.bytes_allocated, 0 as I64, "bytes should be 0 after reset")
    assert_eq(stats2.reset_count, 1 as I64, "reset count should be 1")
    assert(stats2.peak_bytes >= 600 as I64, "peak should be preserved")
    return 0
}

@test
func test_arena_clear() -> I32 {
    var arena: Arena = Arena::new(4096)

    arena.alloc_raw(1000, 8)
    arena.alloc_raw(2000, 8)

    assert(arena.capacity() > 0 as I64, "should have capacity before clear")

    arena.clear()

    assert_eq(arena.capacity(), 0 as I64, "capacity should be 0 after clear")
    assert_eq(arena.bytes_allocated(), 0 as I64, "bytes should be 0 after clear")
    return 0
}

@test
func test_arena_exhaustion() -> I32 {
    var arena: Arena = Arena::new(128)

    // Fill up the arena
    let ptr1: I64 = arena.alloc_raw(64, 8)
    let ptr2: I64 = arena.alloc_raw(64, 8)

    assert(ptr1 != (0 as I64), "first alloc should succeed")

    // This should fail - no more space
    let ptr3: I64 = arena.alloc_raw(64, 8)
    assert_eq(ptr3, 0 as I64, "should fail when arena is full")
    return 0
}

@test
func test_arena_remaining() -> I32 {
    var arena: Arena = Arena::new(1024)

    let initial: I64 = arena.remaining()
    assert_eq(initial, 1024 as I64, "initial remaining should be capacity")

    arena.alloc_raw(256, 8)
    let after_alloc: I64 = arena.remaining()
    assert(after_alloc < initial, "remaining should decrease after alloc")

    arena.reset()
    let after_reset: I64 = arena.remaining()
    assert_eq(after_reset, 1024 as I64, "remaining should be restored after reset")
    return 0
}
