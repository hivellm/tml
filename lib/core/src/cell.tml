//! Shareable mutable containers.
//!
//! This module provides types that allow mutation through shared references,
//! enabling "interior mutability" - the ability to mutate data even when there
//! are immutable references to it.
//!
//! # When to Use Interior Mutability
//!
//! TML's borrowing rules normally prevent mutation through shared references.
//! Interior mutability is useful when:
//!
//! - You need to mutate data inside an otherwise immutable structure
//! - You're implementing data structures with internal caching
//! - You need reference-counted data that can be mutated
//!
//! # Cell vs RefCell
//!
//! | Type | Use Case | Thread Safe | Panics |
//! |------|----------|-------------|--------|
//! | [`Cell[T]`] | Copy types, simple get/set | No | Never |
//! | [`RefCell[T]`] | Any type, borrow checking | No | On borrow violation |
//!
//! # Cell[T]
//!
//! [`Cell`] provides interior mutability for [`Copy`] types. It works by
//! moving values in and out rather than borrowing:
//!
//! ```tml
//! use core::cell::Cell
//!
//! let cell = Cell::new(5)
//!
//! // Get a copy of the value
//! let value = cell.get()  // 5
//!
//! // Set a new value
//! cell.set(10)
//! assert(cell.get() == 10)
//!
//! // Replace and get old value
//! let old = cell.replace(20)  // old = 10
//! ```
//!
//! # RefCell[T]
//!
//! [`RefCell`] provides interior mutability for any type, with runtime borrow
//! checking. It enforces borrowing rules at runtime instead of compile time:
//!
//! ```tml
//! use core::cell::RefCell
//!
//! let cell = RefCell::new(vec![1, 2, 3])
//!
//! // Immutable borrow
//! {
//!     let borrowed = cell.borrow()
//!     println(borrowed.get().len().to_string())
//! }  // borrow ends here
//!
//! // Mutable borrow
//! {
//!     let mut borrowed = cell.borrow_mut()
//!     borrowed.get_mut().push(4)
//! }
//! ```
//!
//! **Warning**: Violating borrow rules at runtime will panic:
//!
//! ```tml
//! let cell = RefCell::new(42)
//! let borrow1 = cell.borrow()
//! let borrow2 = cell.borrow_mut()  // PANIC: already borrowed
//! ```
//!
//! # Thread Safety
//!
//! Neither `Cell` nor `RefCell` is thread-safe. For thread-safe interior
//! mutability, use atomic types or `Mutex`/`RwLock` from `std::sync`.

// ============================================================================
// Cell[T] - Simple interior mutability for Copy types
// ============================================================================

/// A mutable memory location for [`Copy`] types.
///
/// `Cell` provides interior mutability by moving values in and out. Unlike
/// [`RefCell`], it never panics because it doesn't do borrow checking - it
/// simply copies values.
///
/// # Examples
///
/// ```tml
/// let cell = Cell::new(42)
///
/// assert(cell.get() == 42)
/// cell.set(100)
/// assert(cell.get() == 100)
/// ```
///
/// # Thread Safety
///
/// `Cell` is not `Sync` - it cannot be shared between threads. For thread-safe
/// alternatives, use atomic types.
pub type Cell[T] {
    value: T
}

impl[T: Copy] Cell[T] {
    /// Creates a new `Cell` containing the given value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(42)
    /// ```
    pub func new(value: T) -> Cell[T] {
        return Cell[T] { value: value }
    }

    /// Returns a copy of the contained value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(42)
    /// assert(cell.get() == 42)
    /// ```
    pub func get(this) -> T {
        return this.value
    }

    /// Sets the contained value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(42)
    /// cell.set(100)
    /// assert(cell.get() == 100)
    /// ```
    pub func set(mut this, value: T) {
        this.value = value
    }

    /// Replaces the contained value and returns the old value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(42)
    /// let old = cell.replace(100)
    /// assert(old == 42)
    /// assert(cell.get() == 100)
    /// ```
    pub func replace(mut this, value: T) -> T {
        let old: T = this.value
        this.value = value
        return old
    }

    /// Takes the value out of the cell, replacing it with `Default::default()`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(42)
    /// let value = cell.take()
    /// assert(value == 42)
    /// assert(cell.get() == 0)  // Default for I32
    /// ```
    pub func take(mut this) -> T where T: Default {
        return this.replace(T::default())
    }

    /// Updates the contained value using a function.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = Cell::new(5)
    /// cell.update(do(x) x * 2)
    /// assert(cell.get() == 10)
    /// ```
    pub func update(mut this, f: func(T) -> T) {
        this.value = f(this.value)
    }
}

impl[T: Default + Copy] Default for Cell[T] {
    pub func default() -> Cell[T] {
        return Cell[T]::new(T::default())
    }
}

// ============================================================================
// RefCell[T] - Runtime borrow checking
// ============================================================================

/// The borrow state of a RefCell.
type BorrowState {
    /// No active borrows
    Unused,
    /// One or more immutable borrows (count)
    Reading(I32),
    /// One mutable borrow
    Writing
}

/// A mutable memory location with dynamically checked borrow rules.
///
/// `RefCell` enforces TML's borrowing rules at runtime instead of compile time.
/// This allows mutation through shared references, at the cost of potential
/// runtime panics if the rules are violated.
///
/// # Borrow Rules
///
/// At any given time, you can have either:
/// - Any number of immutable borrows (`borrow()`)
/// - Exactly one mutable borrow (`borrow_mut()`)
///
/// Violating these rules causes a panic.
///
/// # Examples
///
/// ```tml
/// use core::cell::RefCell
///
/// let cell = RefCell::new(42)
///
/// // Multiple immutable borrows are OK
/// let r1 = cell.borrow()
/// let r2 = cell.borrow()
/// assert(r1.get() == r2.get())
/// // r1, r2 dropped here
///
/// // Now we can mutably borrow
/// let mut m = cell.borrow_mut()
/// m.get_mut() = 100
/// ```
///
/// # Panics
///
/// - `borrow()` panics if a mutable borrow is active
/// - `borrow_mut()` panics if any borrow is active
///
/// Use `try_borrow()` and `try_borrow_mut()` for non-panicking versions.
///
/// # Thread Safety
///
/// `RefCell` is not `Sync` - it cannot be shared between threads. For
/// thread-safe alternatives, use `Mutex` or `RwLock` from `std::sync`.
pub type RefCell[T] {
    value: T,
    borrow_state: BorrowState
}

impl[T] RefCell[T] {
    /// Creates a new `RefCell` containing the given value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(vec![1, 2, 3])
    /// ```
    pub func new(value: T) -> RefCell[T] {
        return RefCell[T] {
            value: value,
            borrow_state: BorrowState::Unused
        }
    }

    /// Immutably borrows the wrapped value.
    ///
    /// The borrow lasts until the returned [`Ref`] is dropped. Multiple
    /// immutable borrows can be active at once.
    ///
    /// # Panics
    ///
    /// Panics if the value is currently mutably borrowed.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    /// let borrowed = cell.borrow()
    /// assert(borrowed.get() == 42)
    /// ```
    pub func borrow(mut this) -> Ref[T] {
        when this.borrow_state {
            BorrowState::Unused => {
                this.borrow_state = BorrowState::Reading(1)
                return Ref[T] { cell: ref this }
            },
            BorrowState::Reading(count) => {
                this.borrow_state = BorrowState::Reading(count + 1)
                return Ref[T] { cell: ref this }
            },
            BorrowState::Writing => {
                panic("RefCell already mutably borrowed")
            }
        }
    }

    /// Mutably borrows the wrapped value.
    ///
    /// The borrow lasts until the returned [`RefMut`] is dropped.
    ///
    /// # Panics
    ///
    /// Panics if the value is currently borrowed (mutably or immutably).
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    /// {
    ///     let mut borrowed = cell.borrow_mut()
    ///     borrowed.get_mut() = 100
    /// }
    /// assert(cell.borrow().get() == 100)
    /// ```
    pub func borrow_mut(mut this) -> RefMut[T] {
        when this.borrow_state {
            BorrowState::Unused => {
                this.borrow_state = BorrowState::Writing
                return RefMut[T] { cell: mut ref this }
            },
            BorrowState::Reading(_) => {
                panic("RefCell already immutably borrowed")
            },
            BorrowState::Writing => {
                panic("RefCell already mutably borrowed")
            }
        }
    }

    /// Tries to immutably borrow the wrapped value.
    ///
    /// Returns `Nothing` if the value is currently mutably borrowed.
    /// This is the non-panicking version of [`borrow`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    ///
    /// when cell.try_borrow() {
    ///     Just(r) => println(r.get().to_string()),
    ///     Nothing => println("Could not borrow")
    /// }
    /// ```
    pub func try_borrow(mut this) -> Maybe[Ref[T]] {
        when this.borrow_state {
            BorrowState::Unused => {
                this.borrow_state = BorrowState::Reading(1)
                return Just(Ref[T] { cell: ref this })
            },
            BorrowState::Reading(count) => {
                this.borrow_state = BorrowState::Reading(count + 1)
                return Just(Ref[T] { cell: ref this })
            },
            BorrowState::Writing => {
                return Nothing
            }
        }
    }

    /// Tries to mutably borrow the wrapped value.
    ///
    /// Returns `Nothing` if the value is currently borrowed.
    /// This is the non-panicking version of [`borrow_mut`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    ///
    /// when cell.try_borrow_mut() {
    ///     Just(r) => r.get_mut() = 100,
    ///     Nothing => println("Could not borrow mutably")
    /// }
    /// ```
    pub func try_borrow_mut(mut this) -> Maybe[RefMut[T]] {
        when this.borrow_state {
            BorrowState::Unused => {
                this.borrow_state = BorrowState::Writing
                return Just(RefMut[T] { cell: mut ref this })
            },
            _ => {
                return Nothing
            }
        }
    }

    /// Replaces the wrapped value and returns the old value.
    ///
    /// # Panics
    ///
    /// Panics if the value is currently borrowed.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    /// let old = cell.replace(100)
    /// assert(old == 42)
    /// ```
    pub func replace(mut this, value: T) -> T {
        let mut_ref: RefMut[T] = this.borrow_mut()
        let old: T = mut_ref.replace(value)
        return old
    }

    /// Takes the value out of the RefCell, leaving `Default::default()` in its place.
    ///
    /// # Panics
    ///
    /// Panics if the value is currently borrowed.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = RefCell::new(42)
    /// let value = cell.take()
    /// assert(value == 42)
    /// assert(cell.borrow().get() == 0)
    /// ```
    pub func take(mut this) -> T where T: Default {
        return this.replace(T::default())
    }
}

impl[T: Default] Default for RefCell[T] {
    pub func default() -> RefCell[T] {
        return RefCell[T]::new(T::default())
    }
}

// ============================================================================
// Ref[T] - Immutable borrow wrapper
// ============================================================================

/// A wrapper type for an immutably borrowed value from a [`RefCell`].
///
/// This type is created by [`RefCell::borrow`] and implements [`Drop`] to
/// automatically release the borrow when it goes out of scope.
///
/// # Examples
///
/// ```tml
/// let cell = RefCell::new(42)
/// let borrowed: Ref[I32] = cell.borrow()
/// assert(borrowed.get() == 42)
/// // borrowed is dropped here, releasing the borrow
/// ```
pub type Ref[T] {
    cell: ref RefCell[T]
}

impl[T] Ref[T] {
    /// Returns a reference to the borrowed value.
    pub func get(this) -> ref T {
        return ref this.cell.value
    }
}

// When Ref is dropped, decrement the borrow count
impl[T] Drop for Ref[T] {
    pub func drop(mut this) {
        when this.cell.borrow_state {
            BorrowState::Reading(count) => {
                if count == 1 {
                    this.cell.borrow_state = BorrowState::Unused
                } else {
                    this.cell.borrow_state = BorrowState::Reading(count - 1)
                }
            },
            _ => {
                // Should not happen
            }
        }
    }
}

// ============================================================================
// RefMut[T] - Mutable borrow wrapper
// ============================================================================

/// A wrapper type for a mutably borrowed value from a [`RefCell`].
///
/// This type is created by [`RefCell::borrow_mut`] and implements [`Drop`] to
/// automatically release the borrow when it goes out of scope.
///
/// # Examples
///
/// ```tml
/// let cell = RefCell::new(42)
/// {
///     let mut borrowed: RefMut[I32] = cell.borrow_mut()
///     borrowed.get_mut() = 100
/// }
/// // borrowed is dropped here, allowing new borrows
/// assert(cell.borrow().get() == 100)
/// ```
pub type RefMut[T] {
    cell: mut ref RefCell[T]
}

impl[T] RefMut[T] {
    /// Returns a reference to the borrowed value.
    pub func get(this) -> ref T {
        return ref this.cell.value
    }

    /// Returns a mutable reference to the borrowed value.
    pub func get_mut(mut this) -> mut ref T {
        return mut ref this.cell.value
    }

    /// Replaces the borrowed value and returns the old value.
    pub func replace(mut this, value: T) -> T {
        let old: T = this.cell.value
        this.cell.value = value
        return old
    }
}

// When RefMut is dropped, release the mutable borrow
impl[T] Drop for RefMut[T] {
    pub func drop(mut this) {
        this.cell.borrow_state = BorrowState::Unused
    }
}

// ============================================================================
// OnceCell[T] - Write-once cell
// ============================================================================

/// A cell which can be written to only once.
///
/// `OnceCell` provides a way to initialize data lazily or only once. Unlike
/// [`Cell`] and [`RefCell`], `OnceCell` can only be set once, after which
/// it will always return the same value.
///
/// # Examples
///
/// ```tml
/// use core::cell::OnceCell
///
/// let cell: OnceCell[I32] = OnceCell::new()
///
/// assert(cell.get().is_nothing())
///
/// // First set succeeds
/// assert(cell.set(42).is_ok())
/// assert(cell.get() == Just(42))
///
/// // Second set fails - already initialized
/// assert(cell.set(100).is_err())
/// assert(cell.get() == Just(42))  // Still 42
/// ```
///
/// # Thread Safety
///
/// `OnceCell` is not thread-safe. For thread-safe lazy initialization,
/// use `OnceLock` from `std::sync`.
///
/// # Use Cases
///
/// - Lazy initialization of global/static data
/// - Caching expensive computations
/// - Implementing singletons
pub type OnceCell[T] {
    value: Maybe[T]
}

impl[T] OnceCell[T] {
    /// Creates a new empty `OnceCell`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    /// assert(cell.get().is_nothing())
    /// ```
    pub func new() -> OnceCell[T] {
        return OnceCell[T] { value: Nothing }
    }

    /// Creates a new `OnceCell` with the given value already set.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = OnceCell::with_value(42)
    /// assert(cell.get() == Just(42))
    /// ```
    pub func with_value(value: T) -> OnceCell[T] {
        return OnceCell[T] { value: Just(value) }
    }

    /// Gets the reference to the underlying value.
    ///
    /// Returns `Nothing` if the cell is empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    /// assert(cell.get().is_nothing())
    ///
    /// cell.set(42)
    /// assert(cell.get() == Just(42))
    /// ```
    pub func get(this) -> Maybe[ref T] {
        when this.value {
            Just(ref v) => return Just(v),
            Nothing => return Nothing
        }
    }

    /// Gets the mutable reference to the underlying value.
    ///
    /// Returns `Nothing` if the cell is empty.
    pub func get_mut(mut this) -> Maybe[mut ref T] {
        when this.value {
            Just(mut ref v) => return Just(v),
            Nothing => return Nothing
        }
    }

    /// Sets the contents of the cell to `value`.
    ///
    /// Returns `Ok(())` if the cell was empty and the value was set,
    /// or `Err(value)` if the cell was already initialized.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    ///
    /// assert(cell.set(42).is_ok())
    /// assert(cell.set(100).is_err())  // Already set
    /// ```
    pub func set(mut this, value: T) -> Outcome[Unit, T] {
        when this.value {
            Just(_) => return Err(value),
            Nothing => {
                this.value = Just(value)
                return Ok(())
            }
        }
    }

    /// Gets the contents of the cell, initializing it with `f` if empty.
    ///
    /// If the cell is empty, `f` is called and the result is stored in the cell.
    /// Returns a reference to the value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    ///
    /// let value = cell.get_or_init(do() 42)
    /// assert(*value == 42)
    ///
    /// // Second call returns same value, doesn't call the function
    /// let value2 = cell.get_or_init(do() 100)
    /// assert(*value2 == 42)
    /// ```
    pub func get_or_init(mut this, f: func() -> T) -> ref T {
        when this.value {
            Just(ref v) => return v,
            Nothing => {
                this.value = Just(f())
                when this.value {
                    Just(ref v) => return v,
                    Nothing => panic("OnceCell: impossible state")
                }
            }
        }
    }

    /// Takes the value out of the cell, leaving it empty.
    ///
    /// Returns `Nothing` if the cell was empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = OnceCell::with_value(42)
    /// assert(cell.take() == Just(42))
    /// assert(cell.get().is_nothing())
    /// ```
    pub func take(mut this) -> Maybe[T] {
        let old: Maybe[T] = this.value
        this.value = Nothing
        return old
    }

    /// Returns `true` if the cell is empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    /// assert(cell.is_empty())
    ///
    /// cell.set(42)
    /// assert(not cell.is_empty())
    /// ```
    pub func is_empty(this) -> Bool {
        return this.value.is_nothing()
    }

    /// Returns `true` if the cell contains a value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell: OnceCell[I32] = OnceCell::new()
    /// assert(not cell.is_initialized())
    ///
    /// cell.set(42)
    /// assert(cell.is_initialized())
    /// ```
    pub func is_initialized(this) -> Bool {
        return this.value.is_just()
    }

    /// Consumes the cell and returns the inner value.
    ///
    /// Returns `Nothing` if the cell was empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let cell = OnceCell::with_value(42)
    /// assert(cell.into_inner() == Just(42))
    /// ```
    pub func into_inner(this) -> Maybe[T] {
        return this.value
    }
}

impl[T: Default] Default for OnceCell[T] {
    pub func default() -> OnceCell[T] {
        return OnceCell[T]::new()
    }
}

// ============================================================================
// LazyCell[T] - Lazily initialized cell
// ============================================================================

/// A value which is initialized on first access.
///
/// `LazyCell` combines the lazy initialization of `OnceCell` with a closure
/// that provides the initialization value. The closure is called exactly
/// once, on first access.
///
/// # Examples
///
/// ```tml
/// use core::cell::LazyCell
///
/// let lazy = LazyCell::new(do() {
///     println("Initializing!")
///     expensive_computation()
/// })
///
/// // Nothing printed yet
///
/// let value = lazy.get()  // Prints "Initializing!"
/// let value2 = lazy.get() // Nothing printed - uses cached value
/// ```
///
/// # Thread Safety
///
/// `LazyCell` is not thread-safe. For thread-safe lazy initialization,
/// use `LazyLock` from `std::sync`.
pub type LazyCell[T, F] {
    cell: OnceCell[T],
    init: Maybe[F]
}

impl[T, F: Fn[] -> T] LazyCell[T, F] {
    /// Creates a new `LazyCell` with the given initialization function.
    ///
    /// The function will be called exactly once, when the value is first accessed.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let lazy = LazyCell::new(do() 42)
    /// ```
    pub func new(f: F) -> LazyCell[T, F] {
        return LazyCell[T, F] {
            cell: OnceCell::new(),
            init: Just(f)
        }
    }

    /// Forces evaluation of the lazy value and returns a reference to it.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let lazy = LazyCell::new(do() 42)
    /// assert(*lazy.get() == 42)
    /// ```
    pub func get(mut this) -> ref T {
        if this.cell.is_empty() {
            when this.init {
                Just(f) => {
                    let value: T = f()
                    this.cell.set(value)
                    this.init = Nothing
                },
                Nothing => panic("LazyCell: init function already consumed")
            }
        }
        when this.cell.get() {
            Just(v) => return v,
            Nothing => panic("LazyCell: impossible state")
        }
    }

    /// Returns `true` if the lazy value has been computed.
    pub func is_initialized(this) -> Bool {
        return this.cell.is_initialized()
    }
}
