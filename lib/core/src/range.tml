//! Range types for iteration and slicing.
//!
//! This module re-exports range types from `core::ops::range` and provides
//! concrete iterator implementations.
//!
//! # Range Types
//!
//! | Type | Description |
//! |------|-------------|
//! | `Range[T]` | Half-open range [start, end) |
//! | `RangeInclusive[T]` | Closed range [start, end] |
//! | `RangeFrom[T]` | Unbounded above [start, ..) |
//! | `RangeTo[T]` | Unbounded below (.., end) |
//! | `RangeFull` | Full range (..) |
//!
//! # Usage
//!
//! ```tml
//! use core::ops::range::*
//!
//! let r: Range[I64] = Range::new(0, 10)
//! let inclusive: RangeInclusive[I64] = RangeInclusive::new(1, 5)
//! ```

// Re-export all range types from core::ops::range
pub use core::ops::range::*

// Import Iterator for implementing concrete iterators
use core::iter::*

// ============================================================================
// Concrete Range Iterators (for I64)
// ============================================================================

/// Iterator for `Range[I64]`.
///
/// Produces values from `current` to `end - 1`.
///
/// # Examples
///
/// ```tml
/// let mut iter: RangeIterI64 = RangeIterI64 { current: 0, end: 3 }
/// assert(iter.next() == Just(0))
/// assert(iter.next() == Just(1))
/// assert(iter.next() == Just(2))
/// assert(iter.next() == Nothing)
/// ```
pub type RangeIterI64 {
    /// The current position in the iteration.
    current: I64,
    /// The exclusive upper bound.
    end: I64,
}

impl Iterator for RangeIterI64 {
    type Item = I64

    pub func next(mut this) -> Maybe[I64] {
        if this.current < this.end {
            let val: I64 = this.current
            this.current = this.current + 1
            return Just(val)
        }
        return Nothing
    }
}

/// Iterator for `RangeInclusive[I64]`.
///
/// Produces values from `current` to `end` (inclusive).
///
/// # Examples
///
/// ```tml
/// let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
///     current: 1,
///     end: 3,
///     exhausted: false
/// }
/// assert(iter.next() == Just(1))
/// assert(iter.next() == Just(2))
/// assert(iter.next() == Just(3))
/// assert(iter.next() == Nothing)
/// ```
pub type RangeInclusiveIterI64 {
    /// The current position in the iteration.
    current: I64,
    /// The inclusive upper bound.
    end: I64,
    /// Whether the iterator has been exhausted.
    exhausted: Bool,
}

impl Iterator for RangeInclusiveIterI64 {
    type Item = I64

    pub func next(mut this) -> Maybe[I64] {
        if this.exhausted {
            return Nothing
        }
        if this.current < this.end {
            let val: I64 = this.current
            this.current = this.current + 1
            return Just(val)
        }
        if this.current == this.end {
            this.exhausted = true
            return Just(this.current)
        }
        return Nothing
    }
}
