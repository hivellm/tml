//! Optional values.
//!
//! The [`Maybe[T]`] type represents an optional value: every `Maybe` is either
//! [`Just`] and contains a value, or [`Nothing`] and does not.
//!
//! `Maybe` is TML's equivalent of Rust's `Option` type, using more intuitive
//! variant names (`Just` instead of `Some`, `Nothing` instead of `None`).
//!
//! # Common Uses
//!
//! `Maybe` types are very common in TML code, as they have a number of uses:
//!
//! - Initial values
//! - Return values for functions that may not have a meaningful result
//! - Optional struct fields
//! - Optional function arguments
//! - Nullable pointers
//! - Returning from iteration early
//!
//! # Examples
//!
//! ## Basic Pattern Matching
//!
//! ```tml
//! func find_user(id: I64) -> Maybe[User] {
//!     when database.get(id) {
//!         Just(user) => return Just(user),
//!         Nothing => return Nothing
//!     }
//! }
//!
//! when find_user(42) {
//!     Just(user) => println("Found: " + user.name),
//!     Nothing => println("User not found")
//! }
//! ```
//!
//! ## Using Combinators
//!
//! `Maybe` provides many methods for working with optional values without
//! explicit pattern matching:
//!
//! ```tml
//! let name = get_config_value("username")
//!     .map(do(s) s.trim())
//!     .filter(do(s) not s.is_empty())
//!     .unwrap_or("anonymous")
//! ```
//!
//! ## Chaining Operations
//!
//! ```tml
//! let result = get_user(id)
//!     .and_then(do(u) get_address(u.address_id))
//!     .and_then(do(a) get_city(a.city_id))
//!     .map(do(c) c.name)
//! ```
//!
//! # The Question Mark Operator
//!
//! The `?` operator can be used to propagate `Nothing` values:
//!
//! ```tml
//! func get_user_city(id: I64) -> Maybe[Str] {
//!     let user = get_user(id)?
//!     let address = get_address(user.address_id)?
//!     let city = get_city(address.city_id)?
//!     return Just(city.name)
//! }
//! ```

use core::iter::*
// PartialEq is a builtin behavior - no import needed
use core::default::Default

// ============================================================================
// Maybe[T] Type (defined in std::types, enhanced here)
// ============================================================================

// The Maybe[T] type is defined as:
// pub type Maybe[T] {
//     Just(T),
//     Nothing,
// }

// ============================================================================
// Core Methods
// ============================================================================

impl[T] Maybe[T] {
    /// Returns `true` if the option is a [`Just`] value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// assert(x.is_just())
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(not y.is_just())
    /// ```
    pub func is_just(this) -> Bool {
        when this {
            Just(_) => return true,
            Nothing => return false
        }
    }

    /// Returns `true` if the option is [`Nothing`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// assert(not x.is_nothing())
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.is_nothing())
    /// ```
    pub func is_nothing(this) -> Bool {
        when this {
            Just(_) => return false,
            Nothing => return true
        }
    }

    /// Returns `true` if the option is a [`Just`] value containing the given value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// assert(x.contains(ref 42))
    /// assert(not x.contains(ref 0))
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(not y.contains(ref 42))
    /// ```
    pub func contains[U: PartialEq](this, value: ref U) -> Bool where T = U {
        when this {
            Just(v) => return v.eq(value),
            Nothing => return false
        }
    }
}

// ============================================================================
// Extracting Values
// ============================================================================

impl[T] Maybe[T] {
    /// Returns the contained [`Just`] value, consuming the `self` value.
    ///
    /// # Panics
    ///
    /// Panics if the value is [`Nothing`] with a generic panic message.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[Str] = Just("value")
    /// assert(x.unwrap() == "value")
    /// ```
    ///
    /// ```tml
    /// let x: Maybe[Str] = Nothing
    /// x.unwrap()  // Panics!
    /// ```
    pub func unwrap(this) -> T {
        when this {
            Just(val) => return val,
            Nothing => panic("called unwrap() on Nothing")
        }
    }

    /// Returns the contained [`Just`] value, consuming the `self` value.
    ///
    /// # Panics
    ///
    /// Panics if the value is [`Nothing`] with a custom panic message.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[Str] = Nothing
    /// x.expect("config file should exist")  // Panics with custom message
    /// ```
    pub func expect(this, msg: Str) -> T {
        when this {
            Just(val) => return val,
            Nothing => panic(msg)
        }
    }

    /// Returns the contained [`Just`] value or a provided default.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// assert(x.unwrap_or(0) == 42)
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.unwrap_or(0) == 0)
    /// ```
    pub func unwrap_or(this, default_val: T) -> T {
        when this {
            Just(val) => return val,
            Nothing => return default_val
        }
    }

    /// Returns the contained [`Just`] value or computes it from a closure.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let k = 10
    /// let x: Maybe[I64] = Just(4)
    /// assert(x.unwrap_or_else(do() k * 2) == 4)
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.unwrap_or_else(do() k * 2) == 20)
    /// ```
    pub func unwrap_or_else(this, f: func() -> T) -> T {
        when this {
            Just(val) => return val,
            Nothing => return f()
        }
    }

    /// Returns the contained [`Just`] value or a default for the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Nothing
    /// assert(x.unwrap_or_default() == 0)  // I64::default() is 0
    /// ```
    pub func unwrap_or_default(this) -> T where T: Default {
        when this {
            Just(val) => return val,
            Nothing => return T::default()
        }
    }
}

// ============================================================================
// Transforming Values
// ============================================================================

impl[T] Maybe[T] {
    /// Maps a `Maybe[T]` to `Maybe[U]` by applying a function to a contained value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let maybe_str: Maybe[Str] = Just("Hello")
    /// let maybe_len: Maybe[I64] = maybe_str.map(do(s) s.len())
    /// assert(maybe_len == Just(5))
    /// ```
    pub func map[U](this, f: func(T) -> U) -> Maybe[U] {
        when this {
            Just(val) => return Just(f(val)),
            Nothing => return Nothing
        }
    }

    /// Returns the provided default result (if [`Nothing`]), or applies a
    /// function to the contained value (if [`Just`]).
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[Str] = Just("hello")
    /// assert(x.map_or(42, do(s) s.len()) == 5)
    ///
    /// let y: Maybe[Str] = Nothing
    /// assert(y.map_or(42, do(s) s.len()) == 42)
    /// ```
    pub func map_or[U](this, default_val: U, f: func(T) -> U) -> U {
        when this {
            Just(val) => return f(val),
            Nothing => return default_val
        }
    }

    /// Computes a default function result (if [`Nothing`]), or applies a
    /// function to the contained value (if [`Just`]).
    ///
    /// # Examples
    ///
    /// ```tml
    /// let k = 21
    /// let x: Maybe[I64] = Just(2)
    /// assert(x.map_or_else(do() k * 2, do(v) v * k) == 42)
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.map_or_else(do() k * 2, do(v) v * k) == 42)
    /// ```
    pub func map_or_else[U](this, default_fn: func() -> U, f: func(T) -> U) -> U {
        when this {
            Just(val) => return f(val),
            Nothing => return default_fn()
        }
    }

    /// Calls a function with a reference to the contained value (if [`Just`]).
    ///
    /// Useful for debugging or logging without consuming the value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// let y = x.inspect(do(v) println("value: " + v.to_string()))
    ///           .map(do(v) v + 1)
    /// ```
    pub func inspect(this, f: func(ref T)) -> Maybe[T] {
        when this {
            Just(val) => {
                f(ref val)
                return Just(val)
            },
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Chaining Operations
// ============================================================================

impl[T] Maybe[T] {
    /// Returns [`Nothing`] if the option is [`Nothing`], otherwise calls `f`
    /// with the wrapped value and returns the result.
    ///
    /// This is also known as "flat map" or "bind".
    ///
    /// # Examples
    ///
    /// ```tml
    /// func square_if_positive(x: I64) -> Maybe[I64] {
    ///     if x > 0 { return Just(x * x) }
    ///     return Nothing
    /// }
    ///
    /// assert(Just(2).and_then(square_if_positive) == Just(4))
    /// assert(Just(-1).and_then(square_if_positive) == Nothing)
    /// assert(Nothing.and_then(square_if_positive) == Nothing)
    /// ```
    pub func and_then[U](this, f: func(T) -> Maybe[U]) -> Maybe[U] {
        when this {
            Just(val) => return f(val),
            Nothing => return Nothing
        }
    }

    /// Returns the option if it contains a value, otherwise returns `other`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(2)
    /// let y: Maybe[I64] = Nothing
    /// assert(x.alt(y) == Just(2))
    ///
    /// let x: Maybe[I64] = Nothing
    /// let y: Maybe[I64] = Just(100)
    /// assert(x.alt(y) == Just(100))
    /// ```
    pub func alt(this, other: Maybe[T]) -> Maybe[T] {
        when this {
            Just(val) => return Just(val),
            Nothing => return other
        }
    }

    /// Returns the option if it contains a value, otherwise calls `f` and
    /// returns the result.
    ///
    /// # Examples
    ///
    /// ```tml
    /// func get_backup() -> Maybe[I64] { return Just(42) }
    ///
    /// let x: Maybe[I64] = Just(2)
    /// assert(x.or_else(get_backup) == Just(2))
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.or_else(get_backup) == Just(42))
    /// ```
    pub func or_else(this, f: func() -> Maybe[T]) -> Maybe[T] {
        when this {
            Just(val) => return Just(val),
            Nothing => return f()
        }
    }

    /// Returns [`Just`] if exactly one of `self` or `other` is [`Just`],
    /// otherwise returns [`Nothing`].
    ///
    /// Named `one_of` instead of `xor` because `xor` is a reserved keyword.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(2)
    /// let y: Maybe[I64] = Nothing
    /// assert(x.one_of(y) == Just(2))
    ///
    /// let x: Maybe[I64] = Just(2)
    /// let y: Maybe[I64] = Just(3)
    /// assert(x.one_of(y) == Nothing)
    /// ```
    pub func one_of(this, other: Maybe[T]) -> Maybe[T] {
        when this {
            Just(val) => {
                when other {
                    Just(_) => return Nothing,
                    Nothing => return Just(val)
                }
            },
            Nothing => return other
        }
    }

    /// Returns [`Nothing`] if the option is [`Nothing`], otherwise returns `other`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(2)
    /// let y: Maybe[Str] = Nothing
    /// assert(x.also(y) == Nothing)
    ///
    /// let x: Maybe[I64] = Just(2)
    /// let y: Maybe[Str] = Just("hello")
    /// assert(x.also(y) == Just("hello"))
    /// ```
    pub func also[U](this, other: Maybe[U]) -> Maybe[U] {
        when this {
            Just(_) => return other,
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Filtering
// ============================================================================

impl[T] Maybe[T] {
    /// Returns [`Nothing`] if the option is [`Nothing`], otherwise calls
    /// `predicate` with the wrapped value and returns:
    ///
    /// - [`Just(t)`] if `predicate` returns `true`
    /// - [`Nothing`] if `predicate` returns `false`
    ///
    /// # Examples
    ///
    /// ```tml
    /// let is_even = do(n: ref I64) *n % 2 == 0
    ///
    /// assert(Just(4).filter(is_even) == Just(4))
    /// assert(Just(3).filter(is_even) == Nothing)
    /// assert(Nothing.filter(is_even) == Nothing)
    /// ```
    pub func filter(this, predicate: func(ref T) -> Bool) -> Maybe[T] {
        when this {
            Just(val) => {
                if predicate(ref val) {
                    return Just(val)
                }
                return Nothing
            },
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Converting to Other Types
// ============================================================================

impl[T] Maybe[T] {
    /// Transforms the `Maybe[T]` into an [`Outcome[T, E]`], mapping [`Just(v)`]
    /// to [`Ok(v)`] and [`Nothing`] to [`Err(err)`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(42)
    /// assert(x.ok_or("error") == Ok(42))
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.ok_or("error") == Err("error"))
    /// ```
    pub func ok_or[E](this, err: E) -> Outcome[T, E] {
        when this {
            Just(val) => return Ok(val),
            Nothing => return Err(err)
        }
    }

    /// Transforms the `Maybe[T]` into an [`Outcome[T, E]`], mapping [`Just(v)`]
    /// to [`Ok(v)`] and [`Nothing`] to [`Err(err())`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Nothing
    /// assert(x.ok_or_else(do() "not found") == Err("not found"))
    /// ```
    pub func ok_or_else[E](this, err_fn: func() -> E) -> Outcome[T, E] {
        when this {
            Just(val) => return Ok(val),
            Nothing => return Err(err_fn())
        }
    }

    /// Transposes a `Maybe` of an `Outcome` into an `Outcome` of a `Maybe`.
    ///
    /// [`Nothing`] will be mapped to [`Ok(Nothing)`].
    /// [`Just(Ok(x))`] will be mapped to [`Ok(Just(x))`].
    /// [`Just(Err(e))`] will be mapped to [`Err(e)`].
    pub func transpose[E](this) -> Outcome[Maybe[T], E] where T: Outcome[T, E] {
        when this {
            Just(result) => {
                when result {
                    Ok(val) => return Ok(Just(val)),
                    Err(e) => return Err(e)
                }
            },
            Nothing => return Ok(Nothing)
        }
    }
}

// ============================================================================
// Reference Operations
// ============================================================================

impl[T] Maybe[T] {
    /// Converts from `Maybe[T]` to `Maybe[ref T]`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[Str] = Just("hello")
    /// // Get a reference without consuming the original
    /// let ref_x: Maybe[ref Str] = x.as_ref()
    /// ```
    pub func as_ref(this) -> Maybe[ref T] {
        when this {
            Just(val) => return Just(ref val),
            Nothing => return Nothing
        }
    }

    /// Converts from `Maybe[T]` to `Maybe[mut ref T]`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut x: Maybe[Str] = Just("hello")
    /// when x.as_mut() {
    ///     Just(s) => *s = "world",
    ///     Nothing => {}
    /// }
    /// ```
    pub func as_mut(mut this) -> Maybe[mut ref T] {
        when this {
            Just(val) => return Just(mut ref val),
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Zipping
// ============================================================================

impl[T] Maybe[T] {
    /// Zips `self` with another `Maybe`.
    ///
    /// If `self` is [`Just(s)`] and `other` is [`Just(o)`], returns [`Just((s, o))`].
    /// Otherwise, returns [`Nothing`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(1)
    /// let y: Maybe[Str] = Just("hi")
    /// assert(x.zip(y) == Just((1, "hi")))
    ///
    /// let z: Maybe[Str] = Nothing
    /// assert(x.zip(z) == Nothing)
    /// ```
    pub func zip[U](this, other: Maybe[U]) -> Maybe[(T, U)] {
        when this {
            Just(a) => {
                when other {
                    Just(b) => return Just((a, b)),
                    Nothing => return Nothing
                }
            },
            Nothing => return Nothing
        }
    }

    /// Zips `self` and `other` with function `f`.
    ///
    /// If `self` is [`Just(s)`] and `other` is [`Just(o)`], returns [`Just(f(s, o))`].
    /// Otherwise, returns [`Nothing`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(10)
    /// let y: Maybe[I64] = Just(3)
    /// assert(x.zip_with(y, do(a, b) a + b) == Just(13))
    /// ```
    pub func zip_with[U, V](this, other: Maybe[U], f: func(T, U) -> V) -> Maybe[V] {
        when this {
            Just(a) => {
                when other {
                    Just(b) => return Just(f(a, b)),
                    Nothing => return Nothing
                }
            },
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Flattening
// ============================================================================

impl[T] Maybe[Maybe[T]] {
    /// Converts from `Maybe[Maybe[T]]` to `Maybe[T]`.
    ///
    /// Flattening only removes one level of nesting at a time.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[Maybe[I64]] = Just(Just(6))
    /// assert(x.flatten() == Just(6))
    ///
    /// let y: Maybe[Maybe[I64]] = Just(Nothing)
    /// assert(y.flatten() == Nothing)
    ///
    /// let z: Maybe[Maybe[I64]] = Nothing
    /// assert(z.flatten() == Nothing)
    /// ```
    pub func flatten(this) -> Maybe[T] {
        when this {
            Just(inner) => return inner,
            Nothing => return Nothing
        }
    }
}

// ============================================================================
// Iterator Support
// ============================================================================

impl[T] Maybe[T] {
    /// Returns an iterator over the possibly contained value.
    ///
    /// The iterator yields one value if the option is [`Just`], otherwise none.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: Maybe[I64] = Just(4)
    /// assert(x.iter().next() == Just(4))
    ///
    /// let y: Maybe[I64] = Nothing
    /// assert(y.iter().next() == Nothing)
    /// ```
    pub func iter(this) -> MaybeIter[T] {
        return MaybeIter { value: this }
    }
}

/// An iterator over the item contained in a [`Maybe`].
///
/// This iterator yields exactly one value if the `Maybe` is [`Just`],
/// or no values if it is [`Nothing`].
pub type MaybeIter[T] {
    value: Maybe[T]
}

impl[T] Iterator for MaybeIter[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        let result: Maybe[T] = this.value
        this.value = Nothing
        return result
    }
}
