//! Memory allocation APIs.
//!
//! This module provides the core memory allocation primitives for TML,
//! following Rust's `core::alloc` module structure.
//!
//! # Main Types
//!
//! - [`Layout`] - Describes memory layout requirements (size and alignment)
//! - [`LayoutError`] - Error for invalid layout parameters
//! - [`AllocError`] - Error indicating allocation failure
//!
//! # Smart Pointers
//!
//! - [`Heap[T]`] - Unique pointer to heap-allocated data (like Box[T] in Rust)
//! - [`Shared[T]`] - Reference-counted pointer for shared ownership (like Rc[T] in Rust)
//! - [`Sync[T]`] - Atomic reference-counted pointer for thread-safe shared ownership (like Arc[T] in Rust)
//!
//! # Behaviors (Traits)
//!
//! - [`Allocator`] - The main allocator interface for memory management
//! - [`GlobalAlloc`] - Interface for global/system allocators (in `global` submodule)
//!
//! # Module Structure
//!
//! - `layout` - Layout and LayoutError types
//! - `global` - GlobalAlloc behavior and utilities
//! - `heap` - Heap[T] smart pointer
//! - `shared` - Shared[T] reference-counted pointer
//! - `sync` - Sync[T] atomic reference-counted pointer

// Submodule declarations
pub mod layout
pub mod global
pub mod heap
pub mod shared
pub mod sync

// Re-export all from submodules
pub use layout::*
pub use global::*
pub use heap::*
pub use shared::*
pub use sync::*

// ============================================================================
// AllocError
// ============================================================================

/// The `AllocError` error indicates an allocation failure
/// that may be due to resource exhaustion or to something wrong
/// when combining the given input arguments with this allocator.
pub type AllocError {}

impl AllocError {
    /// Creates a new `AllocError`.
    pub func new() -> AllocError {
        return AllocError {}
    }

    /// Returns a string describing the error.
    pub func to_string(this) -> Str {
        return "memory allocation failed"
    }

    /// Returns a debug representation of the error.
    pub func debug_string(this) -> Str {
        return "AllocError"
    }
}

// ============================================================================
// Allocator Behavior
// ============================================================================

/// An implementation of `Allocator` can allocate, grow, shrink, and deallocate
/// arbitrary blocks of data described via `Layout`.
///
/// `Allocator` is designed to be implemented on ZSTs, references, or
/// smart pointers because having an allocator by value would be largely
/// useless: it wouldn't have any state.
///
/// Unlike `GlobalAlloc`, `Allocator` returns `Outcome` types instead of
/// raw pointers, making it safer to use.
///
/// # Safety
///
/// * Memory blocks returned from an allocator must point to valid memory and
///   retain their validity until the instance and all of its clones are dropped.
///
/// * Cloning or moving the allocator must not invalidate memory blocks returned
///   from this allocator. A cloned allocator must behave like the same allocator.
///
/// * Any pointer to a memory block which is currently allocated may be passed
///   to any other method of the allocator.
///
/// # Example
///
/// ```tml
/// use core::alloc::{Allocator, AllocError, Layout}
///
/// type BumpAllocator {
///     buffer: Ptr[U8],
///     offset: I64,
///     capacity: I64,
/// }
///
/// impl Allocator for BumpAllocator {
///     func allocate(ref this, layout: Layout) -> Outcome[Ptr[U8], AllocError] {
///         // ... bump allocation implementation
///     }
///
///     func deallocate(ref this, ptr: Ptr[U8], layout: Layout) {
///         // Bump allocators typically don't deallocate individual blocks
///     }
/// }
/// ```
pub behavior Allocator {
    /// Attempts to allocate a block of memory.
    ///
    /// On success, returns a `Ptr[U8]` meeting the size and alignment
    /// guarantees of `layout`.
    ///
    /// The returned block may or may not have its contents initialized.
    ///
    /// # Errors
    ///
    /// Returning `Err` indicates that either memory is exhausted
    /// or `layout` does not meet allocator's size or alignment constraints.
    func allocate(mut this, layout: Layout) -> Outcome[Ptr[U8], AllocError]

    /// Deallocates the memory referenced by `ptr`.
    ///
    /// # Safety
    ///
    /// * `ptr` must denote a block of memory currently allocated via this allocator.
    /// * `layout` must fit that block of memory.
    func deallocate(mut this, ptr: Ptr[U8], layout: Layout)

    /// Behaves like `allocate`, but also ensures that the returned memory
    /// is zero-initialized.
    ///
    /// # Errors
    ///
    /// Returning `Err` indicates that either memory is exhausted
    /// or `layout` does not meet allocator's size or alignment constraints.
    ///
    /// # Default Implementation
    ///
    /// This method has a default implementation that calls `allocate` and
    /// then zeroes the memory.
    func allocate_zeroed(mut this, layout: Layout) -> Outcome[Ptr[U8], AllocError]

    /// Attempts to extend the memory block.
    ///
    /// If this returns `Ok`, then ownership of the memory block referenced
    /// by `ptr` has been transferred to this allocator.
    ///
    /// # Safety
    ///
    /// * `ptr` must denote a block of memory currently allocated via this allocator.
    /// * `old_layout` must fit that block of memory.
    /// * `new_layout.size()` must be greater than or equal to `old_layout.size()`.
    ///
    /// # Errors
    ///
    /// Returns `Err` if the new layout does not meet the allocator's size
    /// and alignment constraints, or if growing otherwise fails.
    func grow(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError]

    /// Behaves like `grow`, but also ensures that the new contents are
    /// zero-initialized.
    ///
    /// The portion of memory that was already allocated will not be zeroed.
    func grow_zeroed(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError]

    /// Attempts to shrink the memory block.
    ///
    /// # Safety
    ///
    /// * `ptr` must denote a block of memory currently allocated via this allocator.
    /// * `old_layout` must fit that block of memory.
    /// * `new_layout.size()` must be smaller than or equal to `old_layout.size()`.
    ///
    /// # Errors
    ///
    /// Returns `Err` if the new layout does not meet the allocator's size
    /// and alignment constraints, or if shrinking otherwise fails.
    func shrink(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError]
}

// ============================================================================
// AllocatorRef - Wrapper for borrowing allocators
// ============================================================================

/// A wrapper type that allows using a reference to an allocator.
///
/// This is returned by `Allocator::by_ref()` and allows passing an allocator
/// by reference while still satisfying the `Allocator` bound.
///
/// # Example
///
/// ```tml
/// func use_allocator[A: Allocator](alloc: A) { ... }
///
/// let my_alloc: MyAllocator = MyAllocator::new()
/// // Instead of moving my_alloc, we can borrow it:
/// use_allocator(my_alloc.by_ref())
/// // my_alloc is still usable here
/// ```
pub type AllocatorRef[A] {
    /// Reference to the underlying allocator
    alloc: ref A
}

impl[A: Allocator] Allocator for AllocatorRef[A] {
    func allocate(mut this, layout: Layout) -> Outcome[Ptr[U8], AllocError] {
        return this.alloc.allocate(layout)
    }

    func deallocate(mut this, ptr: Ptr[U8], layout: Layout) {
        this.alloc.deallocate(ptr, layout)
    }

    func allocate_zeroed(mut this, layout: Layout) -> Outcome[Ptr[U8], AllocError] {
        return this.alloc.allocate_zeroed(layout)
    }

    func grow(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError] {
        return this.alloc.grow(ptr, old_layout, new_layout)
    }

    func grow_zeroed(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError] {
        return this.alloc.grow_zeroed(ptr, old_layout, new_layout)
    }

    func shrink(mut this, ptr: Ptr[U8], old_layout: Layout, new_layout: Layout) -> Outcome[Ptr[U8], AllocError] {
        return this.alloc.shrink(ptr, old_layout, new_layout)
    }
}

/// Creates an `AllocatorRef` that borrows from the given allocator.
///
/// This function allows using an allocator by reference in contexts
/// that require ownership.
pub func by_ref[A: Allocator](alloc: ref A) -> AllocatorRef[A] {
    return AllocatorRef { alloc: alloc }
}
