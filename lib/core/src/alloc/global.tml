//! Global memory allocator interface.
//!
//! This module provides the `GlobalAlloc` behavior for implementing
//! custom global allocators that can be registered with `@global_allocator`.

// Note: Layout and LayoutError are defined in layout.tml which is loaded
// together with this file as part of the core::alloc module.

// ============================================================================
// GlobalAlloc Behavior
// ============================================================================

/// A memory allocator that can be registered as the standard library's default
/// through the `@global_allocator` attribute.
///
/// Some of the methods require that a memory block be currently
/// allocated via an allocator. This means that:
///
/// * the starting address for that memory block was previously returned by
///   a call to `alloc` or `realloc`, and
///
/// * the memory block has not been subsequently deallocated.
///
/// # Safety
///
/// The `GlobalAlloc` trait is an unsafe trait for a number of reasons:
///
/// * Global allocators are typically implemented using `lowlevel` blocks.
///
/// * Implementors must ensure thread-safety.
///
/// * It is platform-dependent what happens when the first allocation request
///   is made before the allocator is initialized.
///
/// # Example
///
/// ```tml
/// type MyAllocator {}
///
/// impl GlobalAlloc for MyAllocator {
///     func alloc(ref this, layout: Layout) -> Ptr[U8] {
///         // ... implementation using lowlevel malloc
///     }
///
///     func dealloc(ref this, ptr: Ptr[U8], layout: Layout) {
///         // ... implementation using lowlevel free
///     }
/// }
///
/// @global_allocator
/// static GLOBAL: MyAllocator = MyAllocator {}
/// ```
pub behavior GlobalAlloc {
    /// Allocate memory as described by the given `layout`.
    ///
    /// Returns a pointer to newly-allocated memory,
    /// or null to indicate allocation failure.
    ///
    /// # Safety
    ///
    /// This function is unsafe because undefined behavior can result
    /// if the caller does not ensure that `layout` has non-zero size.
    ///
    /// The allocated block of memory may or may not be initialized.
    ///
    /// # Errors
    ///
    /// Returning a null pointer indicates that either memory is exhausted
    /// or `layout` does not meet allocator's size or alignment constraints.
    func alloc(mut this, layout: Layout) -> Ptr[U8]

    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.
    ///
    /// # Safety
    ///
    /// This function is unsafe because undefined behavior can result
    /// if the caller does not ensure all of the following:
    ///
    /// * `ptr` must denote a block of memory currently allocated via
    ///   this allocator,
    ///
    /// * `layout` must be the same layout that was used
    ///   to allocate that block of memory.
    func dealloc(mut this, ptr: Ptr[U8], layout: Layout)

    /// Behaves like `alloc`, but also ensures that the contents
    /// are set to zero before being returned.
    ///
    /// # Safety
    ///
    /// This function is unsafe for the same reasons that `alloc` is.
    /// Additionally, the behavior is undefined if zero-initializing
    /// the memory fails.
    ///
    /// # Default Implementation
    ///
    /// The default implementation calls `alloc` and then zeroes the
    /// memory using `write_bytes`. Implementors can override this
    /// for better performance (e.g., using `calloc`).
    func alloc_zeroed(mut this, layout: Layout) -> Ptr[U8]

    /// Shrink or grow a block of memory to the given `new_size` in bytes.
    /// The block is described by the given `ptr` pointer and `layout`.
    ///
    /// Returns a pointer to newly-allocated memory, or null if reallocation
    /// failed.
    ///
    /// If the reallocation is successful, the old pointer becomes invalid
    /// and should not be used.
    ///
    /// The contents of the returned memory will be unchanged up to the
    /// lesser of the new and old sizes.
    ///
    /// If `new_size` is greater than `layout.size()`, the contents of the
    /// new portion of the memory are undefined.
    ///
    /// # Safety
    ///
    /// This function is unsafe because undefined behavior can result
    /// if the caller does not ensure all of the following:
    ///
    /// * `ptr` must be currently allocated via this allocator,
    ///
    /// * `layout` must be the same layout that was used to allocate that block
    ///   of memory,
    ///
    /// * `new_size` must be greater than zero.
    ///
    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,
    ///   must not overflow (i.e., the rounded value must be less than or equal to
    ///   `I64::MAX`).
    ///
    /// # Default Implementation
    ///
    /// The default implementation allocates new memory, copies the old data,
    /// and deallocates the old memory. Implementors can override this for
    /// better performance (e.g., using system `realloc`).
    func realloc(mut this, ptr: Ptr[U8], layout: Layout, new_size: I64) -> Ptr[U8]
}

// ============================================================================
// Global Allocator Utilities
// ============================================================================

/// Handle allocation failure by calling the out-of-memory handler.
///
/// This function is called when a memory allocation fails and the allocator
/// cannot recover. The default behavior is to abort the program.
///
/// Note: This is a placeholder. The actual implementation would use
/// lowlevel code to handle OOM situations.
pub func handle_alloc_error(layout: Layout) {
    // In a real implementation, this would:
    // 1. Call the registered OOM handler
    // 2. If no handler, abort the program
    //
    // For now, we just print an error message and the program will continue.
    // A proper implementation would abort/panic here.
    println("memory allocation of " + layout.size().to_string() + " bytes failed")
}

/// The default alignment for general-purpose memory allocations.
///
/// This is typically the maximum alignment required by any fundamental type
/// on the platform (e.g., 16 bytes on x86-64 for SSE registers).
pub func default_alloc_align() -> I64 {
    return 16  // Suitable for most platforms
}

/// The minimum allocation size.
///
/// Allocations smaller than this may be rounded up by the allocator.
pub func min_alloc_size() -> I64 {
    return 16  // Common minimum for malloc implementations
}

// ============================================================================
// Layout Presets for Common Types
// ============================================================================

/// Creates a layout suitable for a single byte (U8/I8).
pub func layout_u8() -> Layout {
    return Layout::from_size_align_unchecked(1, 1)
}

/// Creates a layout suitable for a 16-bit value (U16/I16).
pub func layout_u16() -> Layout {
    return Layout::from_size_align_unchecked(2, 2)
}

/// Creates a layout suitable for a 32-bit value (U32/I32/F32).
pub func layout_u32() -> Layout {
    return Layout::from_size_align_unchecked(4, 4)
}

/// Creates a layout suitable for a 64-bit value (U64/I64/F64).
pub func layout_u64() -> Layout {
    return Layout::from_size_align_unchecked(8, 8)
}

/// Creates a layout suitable for a 128-bit value (U128/I128).
pub func layout_u128() -> Layout {
    return Layout::from_size_align_unchecked(16, 16)
}

/// Creates a layout suitable for a pointer-sized value.
pub func layout_ptr() -> Layout {
    // Assuming 64-bit platform
    return Layout::from_size_align_unchecked(8, 8)
}

/// Creates a layout for a byte array of the given size.
pub func layout_bytes(size: I64) -> Outcome[Layout, LayoutError] {
    return Layout::from_size_align(size, 1)
}

/// Creates a layout for an aligned byte array.
pub func layout_bytes_aligned(size: I64, align: I64) -> Outcome[Layout, LayoutError] {
    return Layout::from_size_align(size, align)
}

// ============================================================================
// Global Allocator Access
// ============================================================================

/// Allocates memory using the global allocator.
///
/// This is a convenience function that allocates memory using the
/// system's default allocator. The returned pointer must be freed
/// with `dealloc_global`.
///
/// # Example
///
/// ```tml
/// let ptr: Ptr[U8] = alloc_global(layout_u64())
/// if ptr != null {
///     // Use the memory...
///     dealloc_global(ptr, layout_u64())
/// }
/// ```
///
/// # Safety
///
/// The caller must ensure:
/// - The layout has non-zero size
/// - The returned pointer is eventually freed with `dealloc_global`
pub func alloc_global(layout: Layout) -> Ptr[U8] {
    // This is a placeholder - actual implementation would call
    // the registered global allocator or system malloc
    return alloc(layout.size())
}

/// Allocates zeroed memory using the global allocator.
///
/// Like `alloc_global`, but the memory is initialized to zero.
pub func alloc_global_zeroed(layout: Layout) -> Ptr[U8] {
    let ptr: Ptr[U8] = alloc_global(layout)
    if ptr != null {
        mem_zero(ptr, layout.size())
    }
    return ptr
}

/// Deallocates memory previously allocated with `alloc_global`.
///
/// # Safety
///
/// - `ptr` must have been allocated by `alloc_global` or `alloc_global_zeroed`
/// - `layout` must be the same layout used for allocation
/// - The memory must not be accessed after this call
pub func dealloc_global(ptr: Ptr[U8], layout: Layout) {
    // This is a placeholder - actual implementation would call
    // the registered global allocator or system free
    dealloc(ptr)
}

/// Reallocates memory previously allocated with `alloc_global`.
///
/// The contents of the returned memory will be unchanged up to the
/// lesser of the new and old sizes.
///
/// # Safety
///
/// - `ptr` must have been allocated by `alloc_global`
/// - `old_layout` must match the original allocation
/// - `new_size` must be greater than zero
pub func realloc_global(ptr: Ptr[U8], old_layout: Layout, new_size: I64) -> Ptr[U8] {
    // Allocate new memory
    let new_layout_result: Outcome[Layout, LayoutError] = Layout::from_size_align(new_size, old_layout.align())
    let new_layout: Layout = when new_layout_result {
        Ok(l) => l,
        Err(_) => return null
    }

    let new_ptr: Ptr[U8] = alloc_global(new_layout)
    if new_ptr == null {
        return null
    }

    // Copy old data
    let copy_size: I64 = if old_layout.size() < new_size { old_layout.size() } else { new_size }
    mem_copy(new_ptr, ptr, copy_size)

    // Free old memory
    dealloc_global(ptr, old_layout)

    return new_ptr
}

// ============================================================================
// Allocation Helpers
// ============================================================================

/// Allocates memory for a single value of the given size and alignment.
///
/// This is a convenience wrapper around `alloc_global` for single-value allocations.
pub func alloc_single(size: I64, align: I64) -> Ptr[U8] {
    let layout_result: Outcome[Layout, LayoutError] = Layout::from_size_align(size, align)
    when layout_result {
        Ok(layout) => return alloc_global(layout),
        Err(_) => return null
    }
}

/// Allocates memory for an array of `n` elements.
///
/// Each element has the given size and alignment.
pub func alloc_array(elem_size: I64, elem_align: I64, n: I64) -> Ptr[U8] {
    let layout_result: Outcome[Layout, LayoutError] = Layout::array(elem_size, elem_align, n)
    when layout_result {
        Ok(layout) => return alloc_global(layout),
        Err(_) => return null
    }
}

/// Allocates zeroed memory for an array of `n` elements.
pub func alloc_array_zeroed(elem_size: I64, elem_align: I64, n: I64) -> Ptr[U8] {
    let layout_result: Outcome[Layout, LayoutError] = Layout::array(elem_size, elem_align, n)
    when layout_result {
        Ok(layout) => return alloc_global_zeroed(layout),
        Err(_) => return null
    }
}

/// Frees memory for a single value.
pub func dealloc_single(ptr: Ptr[U8], size: I64, align: I64) {
    let layout_result: Outcome[Layout, LayoutError] = Layout::from_size_align(size, align)
    when layout_result {
        Ok(layout) => dealloc_global(ptr, layout),
        Err(_) => {}
    }
}

/// Frees memory for an array.
pub func dealloc_array(ptr: Ptr[U8], elem_size: I64, elem_align: I64, n: I64) {
    let layout_result: Outcome[Layout, LayoutError] = Layout::array(elem_size, elem_align, n)
    when layout_result {
        Ok(layout) => dealloc_global(ptr, layout),
        Err(_) => {}
    }
}
