//! Object Pool for efficient memory reuse.
//!
//! This module provides `Pool[T]`, a high-performance object pool that
//! reduces allocation overhead by reusing objects.
//!
//! # Overview
//!
//! Object pools are useful when:
//! - Objects are frequently allocated and deallocated
//! - Object construction is expensive
//! - Memory fragmentation is a concern
//!
//! # Example
//!
//! ```tml
//! use core::pool::{Pool, GrowthPolicy}
//!
//! // Create a pool with initial capacity of 16, doubling when exhausted
//! let pool: Pool[Connection] = Pool::new(16, GrowthPolicy::Doubling)
//!
//! // Acquire an object from the pool
//! let conn = pool.acquire()
//!
//! // Use the connection...
//! conn.send(data)
//!
//! // Return the object to the pool for reuse
//! pool.release(conn)
//! ```
//!
//! # Thread Safety
//!
//! The pool uses a lock-free free list for thread-safe acquire/release
//! operations with minimal contention.

use core::alloc::{Layout, AllocError}
use core::sync::{atomic_load, atomic_store, atomic_cas, atomic_cas_val, fence_acquire, fence_release}
use core::mem::size_of

// ============================================================================
// Growth Policy
// ============================================================================

/// Defines how the pool grows when all objects are in use.
pub type GrowthPolicy {
    /// Pool does not grow - acquire returns Nothing when exhausted
    Fixed,
    /// Pool capacity doubles when exhausted
    Doubling,
    /// Pool grows by a fixed amount
    Linear(I32),
}

impl GrowthPolicy {
    /// Calculate the new capacity based on current capacity.
    pub func next_capacity(this, current: I32) -> I32 {
        when this {
            Fixed => current
            Doubling => current * 2
            Linear(step) => current + step
        }
    }

    /// Returns true if this policy allows growth.
    pub func can_grow(this) -> Bool {
        when this {
            Fixed => false
            _ => true
        }
    }
}

// ============================================================================
// Pool Statistics
// ============================================================================

/// Statistics about pool usage.
pub type PoolStats {
    /// Number of objects currently in the pool (available)
    pub available: I32,
    /// Number of objects currently in use (acquired)
    pub in_use: I32,
    /// Total capacity of the pool
    pub capacity: I32,
    /// Number of times acquire() found an available object
    pub hits: I64,
    /// Number of times acquire() had to allocate new object
    pub misses: I64,
    /// Number of times the pool was grown
    pub grows: I32,
}

impl PoolStats {
    /// Creates empty statistics.
    pub func new() -> PoolStats {
        PoolStats {
            available: 0,
            in_use: 0,
            capacity: 0,
            hits: 0,
            misses: 0,
            grows: 0,
        }
    }

    /// Returns the hit rate as a percentage (0-100).
    pub func hit_rate(this) -> F64 {
        let total: I64 = this.hits + this.misses
        if total == 0 {
            return 100.0
        }
        return (this.hits as F64 / total as F64) * 100.0
    }
}

// ============================================================================
// PoolNode - Internal free list node
// ============================================================================

/// Internal node in the free list. Each node contains:
/// - A pointer to the next free node (or null)
/// - The object data follows after this header
type PoolNode {
    /// Pointer to the next free node, stored as I64 for atomic operations
    next: I64,
}

impl PoolNode {
    /// Create a node pointing to the given next node.
    func new(next_ptr: I64) -> PoolNode {
        PoolNode { next: next_ptr }
    }
}

// ============================================================================
// Pool[T] - The main pool type
// ============================================================================

/// A high-performance object pool for type T.
///
/// The pool maintains a lock-free free list of available objects.
/// When `acquire()` is called, it pops an object from the free list.
/// When `release()` is called, it pushes the object back onto the free list.
///
/// # Type Parameters
///
/// - `T`: The type of objects to pool. Should be a class type.
///
/// # Memory Layout
///
/// Each pooled object has a PoolNode header followed by the object data.
/// When in the free list, the node's `next` pointer points to the next free object.
/// When in use, the header is ignored and the object data follows immediately.
pub type Pool[T] {
    /// Head of the free list (pointer to first free PoolNode), as I64 for atomics
    free_list_head: I64,
    /// Growth policy
    policy: GrowthPolicy,
    /// Current statistics (not atomic - approximate under contention)
    stats: PoolStats,
    /// Size of each object including header
    object_size: I64,
    /// Alignment requirement
    alignment: I64,
    /// All allocated blocks (for cleanup)
    blocks: List[I64],
    /// Lock for block list modifications
    blocks_lock: I32,
}

impl[T] Pool[T] {
    /// Creates a new pool with the specified initial capacity and growth policy.
    ///
    /// # Arguments
    ///
    /// * `initial_capacity` - Number of objects to pre-allocate
    /// * `policy` - How the pool should grow when exhausted
    ///
    /// # Example
    ///
    /// ```tml
    /// let pool: Pool[MyClass] = Pool::new(32, GrowthPolicy::Doubling)
    /// ```
    pub func new(initial_capacity: I32, policy: GrowthPolicy) -> Pool[T] {
        // Calculate object size: PoolNode header + sizeof(T)
        let node_size: I64 = 8 // size of next pointer
        let obj_size: I64 = 8  // Placeholder - should use size_of[T]() when available
        let total_size: I64 = node_size + obj_size
        let align: I64 = 8 // Default alignment

        var pool: Pool[T] = Pool {
            free_list_head: 0, // null
            policy: policy,
            stats: PoolStats::new(),
            object_size: total_size,
            alignment: align,
            blocks: List[I64].default(),
            blocks_lock: 0,
        }

        // Pre-allocate initial capacity
        if initial_capacity > 0 {
            pool.grow_by(initial_capacity)
        }

        pool
    }

    /// Creates a pool with fixed capacity (no growth).
    pub func fixed(capacity: I32) -> Pool[T] {
        Pool::new(capacity, GrowthPolicy::Fixed)
    }

    /// Creates a pool with doubling growth policy.
    pub func with_doubling(initial_capacity: I32) -> Pool[T] {
        Pool::new(initial_capacity, GrowthPolicy::Doubling)
    }

    /// Acquires an object from the pool.
    ///
    /// If the pool has available objects, one is removed from the free list
    /// and returned. If the pool is exhausted, it may grow according to the
    /// growth policy.
    ///
    /// # Returns
    ///
    /// - `Just(ptr)` - A pointer to the acquired object
    /// - `Nothing` - Pool is exhausted and cannot grow
    ///
    /// # Thread Safety
    ///
    /// This operation is lock-free using compare-and-swap.
    pub func acquire(mut this) -> Maybe[Ptr[T]] {
        loop (true) {
            // Load current head
            let head: I64 = atomic_load(ref this.free_list_head as ref I32) as I64

            if head == 0 {
                // Free list is empty, try to grow
                if not this.policy.can_grow() {
                    this.stats.misses = this.stats.misses + 1
                    return Nothing
                }

                // Grow the pool
                let current_cap: I32 = this.stats.capacity
                let grow_amount: I32 = if current_cap == 0 { 8 } else {
                    this.policy.next_capacity(current_cap) - current_cap
                }
                this.grow_by(grow_amount)

                // Try again
                continue
            }

            // Try to pop from free list using CAS
            // Read the next pointer from the node at head
            let node_ptr: Ptr[PoolNode] = head as Ptr[PoolNode]
            let next: I64 = lowlevel { (*node_ptr).next }

            // CAS: if head hasn't changed, update to next
            let old: I32 = atomic_cas_val(
                mut ref this.free_list_head as mut ref I32,
                head as I32,
                next as I32
            )

            if old as I64 == head {
                // Success! We popped the node
                fence_acquire()
                this.stats.available = this.stats.available - 1
                this.stats.in_use = this.stats.in_use + 1
                this.stats.hits = this.stats.hits + 1

                // Return pointer to the object (after the node header)
                let obj_ptr: Ptr[T] = (head + 8) as Ptr[T]
                return Just(obj_ptr)
            }

            // CAS failed, another thread modified the list, retry
        }
    }

    /// Releases an object back to the pool for reuse.
    ///
    /// The object is pushed onto the free list and can be acquired again.
    ///
    /// # Arguments
    ///
    /// * `obj` - Pointer to the object to release
    ///
    /// # Safety
    ///
    /// The caller must ensure that:
    /// - The object was acquired from this pool
    /// - The object is not used after release
    ///
    /// # Thread Safety
    ///
    /// This operation is lock-free using compare-and-swap.
    pub func release(mut this, obj: Ptr[T]) {
        // Get the node header (8 bytes before the object)
        let node_ptr: Ptr[PoolNode] = ((obj as I64) - 8) as Ptr[PoolNode]

        fence_release()

        loop (true) {
            // Load current head
            let head: I64 = atomic_load(ref this.free_list_head as ref I32) as I64

            // Set node's next to current head
            lowlevel { (*node_ptr).next = head }

            // CAS: try to make this node the new head
            let old: I32 = atomic_cas_val(
                mut ref this.free_list_head as mut ref I32,
                head as I32,
                node_ptr as I64 as I32
            )

            if old as I64 == head {
                // Success!
                this.stats.available = this.stats.available + 1
                this.stats.in_use = this.stats.in_use - 1
                return
            }

            // CAS failed, retry
        }
    }

    /// Grows the pool by allocating additional objects.
    ///
    /// # Arguments
    ///
    /// * `count` - Number of objects to add
    pub func grow_by(mut this, count: I32) {
        if count <= 0 {
            return
        }

        // Allocate a block for all new objects
        let block_size: I64 = this.object_size * (count as I64)
        let block: I64 = alloc(block_size) as I64

        if block == 0 {
            return // Allocation failed
        }

        // Add block to our list for cleanup
        // Note: This part needs locking for thread safety
        spin_lock(mut ref this.blocks_lock)
        this.blocks.push(block)
        spin_unlock(mut ref this.blocks_lock)

        // Add all objects to the free list
        var i: I32 = 0
        loop (i < count) {
            let node_addr: I64 = block + (i as I64 * this.object_size)
            let node_ptr: Ptr[PoolNode] = node_addr as Ptr[PoolNode]

            // Push onto free list
            loop (true) {
                let head: I64 = atomic_load(ref this.free_list_head as ref I32) as I64
                lowlevel { (*node_ptr).next = head }

                let old: I32 = atomic_cas_val(
                    mut ref this.free_list_head as mut ref I32,
                    head as I32,
                    node_addr as I32
                )

                if old as I64 == head {
                    break
                }
            }

            i = i + 1
        }

        this.stats.capacity = this.stats.capacity + count
        this.stats.available = this.stats.available + count
        this.stats.grows = this.stats.grows + 1
    }

    /// Returns current pool statistics.
    pub func stats(this) -> PoolStats {
        this.stats
    }

    /// Returns the current capacity of the pool.
    pub func capacity(this) -> I32 {
        this.stats.capacity
    }

    /// Returns the number of available objects.
    pub func available(this) -> I32 {
        this.stats.available
    }

    /// Returns the number of objects currently in use.
    pub func in_use(this) -> I32 {
        this.stats.in_use
    }

    /// Clears the pool and releases all memory.
    ///
    /// All objects must be released before calling this.
    pub func clear(mut this) {
        // Free all allocated blocks
        spin_lock(mut ref this.blocks_lock)
        loop (true) {
            when this.blocks.pop() {
                Just(block) => dealloc(block as *Unit),
                Nothing => break
            }
        }
        spin_unlock(mut ref this.blocks_lock)

        this.free_list_head = 0
        this.stats = PoolStats::new()
    }
}

// ============================================================================
// Drop implementation
// ============================================================================

impl[T] Drop for Pool[T] {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// Helper functions for spinlock (using sync module)
// ============================================================================

func spin_lock(lock: mut ref I32) {
    loop (true) {
        let old: I32 = atomic_cas_val(lock, 0, 1)
        if old == 0 {
            fence_acquire()
            return
        }
        // Spin
    }
}

func spin_unlock(lock: mut ref I32) {
    fence_release()
    atomic_store(lock, 0)
}

// ============================================================================
// ThreadLocalPool[T] - Per-thread object pools
// ============================================================================

/// Thread-local object pools for high-performance allocation without contention.
///
/// `ThreadLocalPool[T]` provides each thread with its own pool instance,
/// eliminating all synchronization overhead for acquire/release operations.
///
/// # Performance
///
/// - No atomic operations for acquire/release (single-threaded per pool)
/// - No cache-line bouncing between cores
/// - Ideal for short-lived objects in request handling
///
/// # Example
///
/// ```tml
/// // Define thread-local pool storage
/// static var tls_pools: ThreadLocalPoolRegistry[Connection] = ThreadLocalPoolRegistry::new()
///
/// // Get the pool for current thread
/// let pool = tls_pools.get()
///
/// // Use the pool (no synchronization!)
/// let conn = pool.acquire()
/// // ... use connection ...
/// pool.release(conn)
/// ```
pub type ThreadLocalPool[T] {
    /// The underlying pool (no synchronization needed)
    objects: List[Ptr[T]],
    /// Allocated memory blocks
    blocks: List[I64],
    /// Current capacity
    capacity: I32,
    /// Available count
    available: I32,
    /// Statistics
    stats: PoolStats,
    /// Object size
    object_size: I64,
}

impl[T] ThreadLocalPool[T] {
    /// Creates a new thread-local pool.
    pub func new(initial_capacity: I32) -> ThreadLocalPool[T] {
        let obj_size: I64 = 8 // Placeholder for size_of[T]()

        var pool: ThreadLocalPool[T] = ThreadLocalPool {
            objects: List[Ptr[T]].default(),
            blocks: List[I64].default(),
            capacity: 0,
            available: 0,
            stats: PoolStats::new(),
            object_size: obj_size,
        }

        if initial_capacity > 0 {
            pool.grow_by(initial_capacity)
        }

        pool
    }

    /// Creates a thread-local pool with default capacity (32).
    pub func default() -> ThreadLocalPool[T] {
        ThreadLocalPool::new(32)
    }

    /// Acquires an object from the pool.
    ///
    /// This operation is extremely fast (no synchronization).
    ///
    /// # Returns
    ///
    /// - `Just(ptr)` - Pointer to acquired object
    /// - `Nothing` - Pool exhausted and cannot grow
    pub func acquire(mut this) -> Maybe[Ptr[T]] {
        if this.available == 0 {
            // Try to grow
            let grow_amount: I32 = if this.capacity == 0 { 32 } else { this.capacity }
            this.grow_by(grow_amount)

            if this.available == 0 {
                this.stats.misses = this.stats.misses + 1
                return Nothing
            }
        }

        // Pop from the list (fast path - no atomics!)
        when this.objects.pop() {
            Just(ptr) => {
                this.available = this.available - 1
                this.stats.in_use = this.stats.in_use + 1
                this.stats.hits = this.stats.hits + 1
                return Just(ptr)
            }
            Nothing => {
                this.stats.misses = this.stats.misses + 1
                return Nothing
            }
        }
    }

    /// Releases an object back to the pool.
    ///
    /// This operation is extremely fast (no synchronization).
    pub func release(mut this, obj: Ptr[T]) {
        this.objects.push(obj)
        this.available = this.available + 1
        this.stats.in_use = this.stats.in_use - 1
    }

    /// Grows the pool by allocating additional objects.
    pub func grow_by(mut this, count: I32) {
        if count <= 0 {
            return
        }

        // Allocate a block
        let block_size: I64 = this.object_size * (count as I64)
        let block: I64 = alloc(block_size) as I64

        if block == 0 {
            return
        }

        this.blocks.push(block)

        // Add all objects to the pool
        var i: I32 = 0
        loop (i < count) {
            let obj_addr: I64 = block + (i as I64 * this.object_size)
            this.objects.push(obj_addr as Ptr[T])
            i = i + 1
        }

        this.capacity = this.capacity + count
        this.available = this.available + count
        this.stats.capacity = this.capacity
        this.stats.available = this.available
        this.stats.grows = this.stats.grows + 1
    }

    /// Returns pool statistics.
    pub func stats(this) -> PoolStats {
        this.stats
    }

    /// Returns available object count.
    pub func available(this) -> I32 {
        this.available
    }

    /// Returns objects in use count.
    pub func in_use(this) -> I32 {
        this.stats.in_use
    }

    /// Clears the pool and frees all memory.
    pub func clear(mut this) {
        loop (true) {
            when this.blocks.pop() {
                Just(block) => dealloc(block as *Unit),
                Nothing => break
            }
        }
        this.objects.clear()
        this.capacity = 0
        this.available = 0
        this.stats = PoolStats::new()
    }
}

impl[T] Drop for ThreadLocalPool[T] {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// NOTE: ThreadLocalPoolRegistry[T] has been temporarily removed due to
// complex generic array initialization requirements. Use Pool[T] or
// ThreadLocalPool[T] directly for now.
// ============================================================================
// NOTE: Inline tests temporarily disabled due to codegen bug with Pool[T]
// generating as an unsized type in LLVM IR. The codegen needs to be fixed
// to properly calculate the size of generic structs with List[T] fields.
// ============================================================================
