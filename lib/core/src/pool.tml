//! Object Pool for efficient memory reuse.
//!
//! This module provides `Pool[T]`, a high-performance object pool that
//! reduces allocation overhead by reusing objects.
//!
//! # Overview
//!
//! Object pools are useful when:
//! - Objects are frequently allocated and deallocated
//! - Object construction is expensive
//! - Memory fragmentation is a concern
//!
//! # Example
//!
//! ```tml
//! use core::pool::{Pool, GrowthPolicy}
//!
//! // Create a pool with initial capacity of 16, doubling when exhausted
//! let pool: Pool[Connection] = Pool::new(16, GrowthPolicy::Doubling)
//!
//! // Acquire an object from the pool
//! let conn = pool.acquire()
//!
//! // Use the connection...
//! conn.send(data)
//!
//! // Return the object to the pool for reuse
//! pool.release(conn)
//! ```
//!
//! # Thread Safety
//!
//! The pool uses a lock-free free list for thread-safe acquire/release
//! operations with minimal contention.

use core::alloc::{Layout, AllocError}
use core::sync::{atomic_load, atomic_store, atomic_cas, atomic_cas_val, fence_acquire, fence_release}
use core::mem::size_of

// ============================================================================
// Growth Policy
// ============================================================================

/// Defines how the pool grows when all objects are in use.
pub type GrowthPolicy {
    /// Pool does not grow - acquire returns Nothing when exhausted
    Fixed,
    /// Pool capacity doubles when exhausted
    Doubling,
    /// Pool grows by a fixed amount
    Linear(I32),
}

impl GrowthPolicy {
    /// Calculate the new capacity based on current capacity.
    pub func next_capacity(this, current: I32) -> I32 {
        when this {
            Fixed => current
            Doubling => current * 2
            Linear(step) => current + step
        }
    }

    /// Returns true if this policy allows growth.
    pub func can_grow(this) -> Bool {
        when this {
            Fixed => false
            _ => true
        }
    }
}

// ============================================================================
// Pool Statistics
// ============================================================================

/// Statistics about pool usage.
pub type PoolStats {
    /// Number of objects currently in the pool (available)
    pub available: I32,
    /// Number of objects currently in use (acquired)
    pub in_use: I32,
    /// Total capacity of the pool
    pub capacity: I32,
    /// Number of times acquire() found an available object
    pub hits: I64,
    /// Number of times acquire() had to allocate new object
    pub misses: I64,
    /// Number of times the pool was grown
    pub grows: I32,
}

impl PoolStats {
    /// Creates empty statistics.
    pub func new() -> PoolStats {
        PoolStats {
            available: 0,
            in_use: 0,
            capacity: 0,
            hits: 0,
            misses: 0,
            grows: 0,
        }
    }

    /// Returns the hit rate as a percentage (0-100).
    pub func hit_rate(this) -> F64 {
        let total = this.hits + this.misses
        if total == 0 {
            return 100.0
        }
        (this.hits as F64 / total as F64) * 100.0
    }
}

// ============================================================================
// PoolNode - Internal free list node
// ============================================================================

/// Internal node in the free list. Each node contains:
/// - A pointer to the next free node (or null)
/// - The object data follows after this header
type PoolNode {
    /// Pointer to the next free node, stored as I64 for atomic operations
    next: I64,
}

impl PoolNode {
    /// Create a node pointing to the given next node.
    func new(next_ptr: I64) -> PoolNode {
        PoolNode { next: next_ptr }
    }
}

// ============================================================================
// Pool[T] - The main pool type
// ============================================================================

/// A high-performance object pool for type T.
///
/// The pool maintains a lock-free free list of available objects.
/// When `acquire()` is called, it pops an object from the free list.
/// When `release()` is called, it pushes the object back onto the free list.
///
/// # Type Parameters
///
/// - `T`: The type of objects to pool. Should be a class type.
///
/// # Memory Layout
///
/// Each pooled object has a PoolNode header followed by the object data.
/// When in the free list, the node's `next` pointer points to the next free object.
/// When in use, the header is ignored and the object data follows immediately.
pub type Pool[T] {
    /// Head of the free list (pointer to first free PoolNode), as I64 for atomics
    free_list_head: I64,
    /// Growth policy
    policy: GrowthPolicy,
    /// Current statistics (not atomic - approximate under contention)
    stats: PoolStats,
    /// Size of each object including header
    object_size: I64,
    /// Alignment requirement
    alignment: I64,
    /// All allocated blocks (for cleanup)
    blocks: List[I64],
    /// Lock for block list modifications
    blocks_lock: I32,
}

impl[T] Pool[T] {
    /// Creates a new pool with the specified initial capacity and growth policy.
    ///
    /// # Arguments
    ///
    /// * `initial_capacity` - Number of objects to pre-allocate
    /// * `policy` - How the pool should grow when exhausted
    ///
    /// # Example
    ///
    /// ```tml
    /// let pool: Pool[MyClass] = Pool::new(32, GrowthPolicy::Doubling)
    /// ```
    pub func new(initial_capacity: I32, policy: GrowthPolicy) -> Pool[T] {
        // Calculate object size: PoolNode header + sizeof(T)
        let node_size = 8 // size of next pointer
        let obj_size = 8  // Placeholder - should use size_of[T]() when available
        let total_size = node_size + obj_size
        let align = 8 // Default alignment

        var pool = Pool {
            free_list_head: 0, // null
            policy: policy,
            stats: PoolStats::new(),
            object_size: total_size,
            alignment: align,
            blocks: [],
            blocks_lock: 0,
        }

        // Pre-allocate initial capacity
        if initial_capacity > 0 {
            pool.grow_by(initial_capacity)
        }

        pool
    }

    /// Creates a pool with fixed capacity (no growth).
    pub func fixed(capacity: I32) -> Pool[T] {
        Pool::new(capacity, GrowthPolicy::Fixed)
    }

    /// Creates a pool with doubling growth policy.
    pub func with_doubling(initial_capacity: I32) -> Pool[T] {
        Pool::new(initial_capacity, GrowthPolicy::Doubling)
    }

    /// Acquires an object from the pool.
    ///
    /// If the pool has available objects, one is removed from the free list
    /// and returned. If the pool is exhausted, it may grow according to the
    /// growth policy.
    ///
    /// # Returns
    ///
    /// - `Just(ptr)` - A pointer to the acquired object
    /// - `Nothing` - Pool is exhausted and cannot grow
    ///
    /// # Thread Safety
    ///
    /// This operation is lock-free using compare-and-swap.
    pub func acquire(mut this) -> Maybe[Ptr[T]] {
        loop {
            // Load current head
            let head = atomic_load(ref this.free_list_head as ref I32) as I64

            if head == 0 {
                // Free list is empty, try to grow
                if not this.policy.can_grow() {
                    this.stats.misses = this.stats.misses + 1
                    return Nothing
                }

                // Grow the pool
                let current_cap = this.stats.capacity
                let grow_amount = if current_cap == 0 { 8 } else {
                    this.policy.next_capacity(current_cap) - current_cap
                }
                this.grow_by(grow_amount)

                // Try again
                continue
            }

            // Try to pop from free list using CAS
            // Read the next pointer from the node at head
            let node_ptr = head as Ptr[PoolNode]
            let next = lowlevel { (*node_ptr).next }

            // CAS: if head hasn't changed, update to next
            let old = atomic_cas_val(
                mut ref this.free_list_head as mut ref I32,
                head as I32,
                next as I32
            )

            if old as I64 == head {
                // Success! We popped the node
                fence_acquire()
                this.stats.available = this.stats.available - 1
                this.stats.in_use = this.stats.in_use + 1
                this.stats.hits = this.stats.hits + 1

                // Return pointer to the object (after the node header)
                let obj_ptr = (head + 8) as Ptr[T]
                return Just(obj_ptr)
            }

            // CAS failed, another thread modified the list, retry
        }
    }

    /// Releases an object back to the pool for reuse.
    ///
    /// The object is pushed onto the free list and can be acquired again.
    ///
    /// # Arguments
    ///
    /// * `obj` - Pointer to the object to release
    ///
    /// # Safety
    ///
    /// The caller must ensure that:
    /// - The object was acquired from this pool
    /// - The object is not used after release
    ///
    /// # Thread Safety
    ///
    /// This operation is lock-free using compare-and-swap.
    pub func release(mut this, obj: Ptr[T]) {
        // Get the node header (8 bytes before the object)
        let node_ptr = ((obj as I64) - 8) as Ptr[PoolNode]

        fence_release()

        loop {
            // Load current head
            let head = atomic_load(ref this.free_list_head as ref I32) as I64

            // Set node's next to current head
            lowlevel { (*node_ptr).next = head }

            // CAS: try to make this node the new head
            let old = atomic_cas_val(
                mut ref this.free_list_head as mut ref I32,
                head as I32,
                node_ptr as I64 as I32
            )

            if old as I64 == head {
                // Success!
                this.stats.available = this.stats.available + 1
                this.stats.in_use = this.stats.in_use - 1
                return
            }

            // CAS failed, retry
        }
    }

    /// Grows the pool by allocating additional objects.
    ///
    /// # Arguments
    ///
    /// * `count` - Number of objects to add
    func grow_by(mut this, count: I32) {
        if count <= 0 {
            return
        }

        // Allocate a block for all new objects
        let block_size = this.object_size * (count as I64)
        let block = lowlevel { malloc(block_size) } as I64

        if block == 0 {
            return // Allocation failed
        }

        // Add block to our list for cleanup
        // Note: This part needs locking for thread safety
        spin_lock(mut ref this.blocks_lock)
        this.blocks.push(block)
        spin_unlock(mut ref this.blocks_lock)

        // Add all objects to the free list
        var i = 0
        loop {
            if i >= count {
                break
            }

            let node_addr = block + (i as I64 * this.object_size)
            let node_ptr = node_addr as Ptr[PoolNode]

            // Push onto free list
            loop {
                let head = atomic_load(ref this.free_list_head as ref I32) as I64
                lowlevel { (*node_ptr).next = head }

                let old = atomic_cas_val(
                    mut ref this.free_list_head as mut ref I32,
                    head as I32,
                    node_addr as I32
                )

                if old as I64 == head {
                    break
                }
            }

            i = i + 1
        }

        this.stats.capacity = this.stats.capacity + count
        this.stats.available = this.stats.available + count
        this.stats.grows = this.stats.grows + 1
    }

    /// Returns current pool statistics.
    pub func stats(this) -> PoolStats {
        this.stats
    }

    /// Returns the current capacity of the pool.
    pub func capacity(this) -> I32 {
        this.stats.capacity
    }

    /// Returns the number of available objects.
    pub func available(this) -> I32 {
        this.stats.available
    }

    /// Returns the number of objects currently in use.
    pub func in_use(this) -> I32 {
        this.stats.in_use
    }

    /// Clears the pool and releases all memory.
    ///
    /// All objects must be released before calling this.
    pub func clear(mut this) {
        // Free all allocated blocks
        spin_lock(mut ref this.blocks_lock)
        loop {
            when this.blocks.pop() {
                Just(block) => lowlevel { free(block as Ptr[U8]) }
                Nothing => break
            }
        }
        spin_unlock(mut ref this.blocks_lock)

        this.free_list_head = 0
        this.stats = PoolStats::new()
    }
}

// ============================================================================
// Drop implementation
// ============================================================================

impl[T] Drop for Pool[T] {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// Helper functions for spinlock (using sync module)
// ============================================================================

func spin_lock(lock: mut ref I32) {
    loop {
        let old = atomic_cas_val(lock, 0, 1)
        if old == 0 {
            fence_acquire()
            return
        }
        // Spin
    }
}

func spin_unlock(lock: mut ref I32) {
    fence_release()
    atomic_store(lock, 0)
}

// ============================================================================
// ThreadLocalPool[T] - Per-thread object pools
// ============================================================================

/// Thread-local object pools for high-performance allocation without contention.
///
/// `ThreadLocalPool[T]` provides each thread with its own pool instance,
/// eliminating all synchronization overhead for acquire/release operations.
///
/// # Performance
///
/// - No atomic operations for acquire/release (single-threaded per pool)
/// - No cache-line bouncing between cores
/// - Ideal for short-lived objects in request handling
///
/// # Example
///
/// ```tml
/// // Define thread-local pool storage
/// static var tls_pools: ThreadLocalPoolRegistry[Connection] = ThreadLocalPoolRegistry::new()
///
/// // Get the pool for current thread
/// let pool = tls_pools.get()
///
/// // Use the pool (no synchronization!)
/// let conn = pool.acquire()
/// // ... use connection ...
/// pool.release(conn)
/// ```
pub type ThreadLocalPool[T] {
    /// The underlying pool (no synchronization needed)
    objects: List[Ptr[T]],
    /// Allocated memory blocks
    blocks: List[I64],
    /// Current capacity
    capacity: I32,
    /// Available count
    available: I32,
    /// Statistics
    stats: PoolStats,
    /// Object size
    object_size: I64,
}

impl[T] ThreadLocalPool[T] {
    /// Creates a new thread-local pool.
    pub func new(initial_capacity: I32) -> ThreadLocalPool[T] {
        let obj_size: I64 = 8 // Placeholder for size_of[T]()

        var pool = ThreadLocalPool {
            objects: [],
            blocks: [],
            capacity: 0,
            available: 0,
            stats: PoolStats::new(),
            object_size: obj_size,
        }

        if initial_capacity > 0 {
            pool.grow_by(initial_capacity)
        }

        pool
    }

    /// Creates a thread-local pool with default capacity (32).
    pub func default() -> ThreadLocalPool[T] {
        ThreadLocalPool::new(32)
    }

    /// Acquires an object from the pool.
    ///
    /// This operation is extremely fast (no synchronization).
    ///
    /// # Returns
    ///
    /// - `Just(ptr)` - Pointer to acquired object
    /// - `Nothing` - Pool exhausted and cannot grow
    pub func acquire(mut this) -> Maybe[Ptr[T]] {
        if this.available == 0 {
            // Try to grow
            let grow_amount = if this.capacity == 0 { 32 } else { this.capacity }
            this.grow_by(grow_amount)

            if this.available == 0 {
                this.stats.misses = this.stats.misses + 1
                return Nothing
            }
        }

        // Pop from the list (fast path - no atomics!)
        when this.objects.pop() {
            Just(ptr) => {
                this.available = this.available - 1
                this.stats.in_use = this.stats.in_use + 1
                this.stats.hits = this.stats.hits + 1
                return Just(ptr)
            }
            Nothing => {
                this.stats.misses = this.stats.misses + 1
                return Nothing
            }
        }
    }

    /// Releases an object back to the pool.
    ///
    /// This operation is extremely fast (no synchronization).
    pub func release(mut this, obj: Ptr[T]) {
        this.objects.push(obj)
        this.available = this.available + 1
        this.stats.in_use = this.stats.in_use - 1
    }

    /// Grows the pool by allocating additional objects.
    func grow_by(mut this, count: I32) {
        if count <= 0 {
            return
        }

        // Allocate a block
        let block_size = this.object_size * (count as I64)
        let block = lowlevel { malloc(block_size) } as I64

        if block == 0 {
            return
        }

        this.blocks.push(block)

        // Add all objects to the pool
        var i: I32 = 0
        loop {
            if i >= count { break }
            let obj_addr = block + (i as I64 * this.object_size)
            this.objects.push(obj_addr as Ptr[T])
            i = i + 1
        }

        this.capacity = this.capacity + count
        this.available = this.available + count
        this.stats.capacity = this.capacity
        this.stats.available = this.available
        this.stats.grows = this.stats.grows + 1
    }

    /// Returns pool statistics.
    pub func stats(this) -> PoolStats {
        this.stats
    }

    /// Returns available object count.
    pub func available(this) -> I32 {
        this.available
    }

    /// Returns objects in use count.
    pub func in_use(this) -> I32 {
        this.stats.in_use
    }

    /// Clears the pool and frees all memory.
    pub func clear(mut this) {
        loop {
            when this.blocks.pop() {
                Just(block) => lowlevel { free(block as Ptr[U8]) }
                Nothing => break
            }
        }
        this.objects.clear()
        this.capacity = 0
        this.available = 0
        this.stats = PoolStats::new()
    }
}

impl[T] Drop for ThreadLocalPool[T] {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// ThreadLocalPoolRegistry[T] - Registry of per-thread pools
// ============================================================================

/// Maximum number of thread-local pool slots.
const TLS_POOL_SLOTS: I64 = 64

/// Thread ID to pool slot mapping.
type TlsPoolSlot[T] {
    /// Thread ID that owns this slot
    thread_id: I64,
    /// The pool for this thread
    pool: ThreadLocalPool[T],
    /// Whether this slot is in use
    in_use: Bool,
}

/// Registry that manages thread-local pools.
///
/// Each thread gets its own pool instance for lock-free operations.
///
/// # Example
///
/// ```tml
/// static var pools: ThreadLocalPoolRegistry[Request] = ThreadLocalPoolRegistry::new()
///
/// func handle_request() {
///     let pool = pools.get()
///     let req = pool.acquire()
///     // ... handle request ...
///     pool.release(req)
/// }
/// ```
pub type ThreadLocalPoolRegistry[T] {
    /// Pool slots indexed by thread
    slots: [TlsPoolSlot[T]; 64],
    /// Number of slots in use
    slot_count: I32,
    /// Lock for slot allocation
    alloc_lock: I32,
    /// Default initial capacity for new pools
    default_capacity: I32,
}

impl[T] ThreadLocalPoolRegistry[T] {
    /// Creates a new thread-local pool registry.
    pub func new() -> ThreadLocalPoolRegistry[T] {
        ThreadLocalPoolRegistry {
            slots: default_array(),
            slot_count: 0,
            alloc_lock: 0,
            default_capacity: 32,
        }
    }

    /// Creates a registry with custom default pool capacity.
    pub func with_capacity(capacity: I32) -> ThreadLocalPoolRegistry[T] {
        ThreadLocalPoolRegistry {
            slots: default_array(),
            slot_count: 0,
            alloc_lock: 0,
            default_capacity: capacity,
        }
    }

    /// Gets the pool for the current thread, creating one if needed.
    ///
    /// # Returns
    ///
    /// Reference to this thread's pool.
    pub func get(mut this) -> mut ref ThreadLocalPool[T] {
        let thread_id = get_current_thread_id()

        // First, try to find existing slot (lock-free read)
        var i: I64 = 0
        loop {
            if i >= this.slot_count as I64 { break }
            if this.slots[i].in_use and this.slots[i].thread_id == thread_id {
                return mut ref this.slots[i].pool
            }
            i = i + 1
        }

        // Need to allocate a new slot (requires lock)
        spin_lock(mut ref this.alloc_lock)

        // Double-check after acquiring lock
        i = 0
        loop {
            if i >= this.slot_count as I64 { break }
            if this.slots[i].in_use and this.slots[i].thread_id == thread_id {
                spin_unlock(mut ref this.alloc_lock)
                return mut ref this.slots[i].pool
            }
            i = i + 1
        }

        // Allocate new slot
        let slot_idx = this.slot_count as I64
        if slot_idx < TLS_POOL_SLOTS {
            this.slots[slot_idx].thread_id = thread_id
            this.slots[slot_idx].pool = ThreadLocalPool::new(this.default_capacity)
            this.slots[slot_idx].in_use = true
            this.slot_count = this.slot_count + 1
        }

        spin_unlock(mut ref this.alloc_lock)

        return mut ref this.slots[slot_idx].pool
    }

    /// Returns the total number of pools across all threads.
    pub func pool_count(this) -> I32 {
        this.slot_count
    }

    /// Clears and releases the pool for the current thread.
    pub func release_current(mut this) {
        let thread_id = get_current_thread_id()

        spin_lock(mut ref this.alloc_lock)

        var i: I64 = 0
        loop {
            if i >= this.slot_count as I64 { break }
            if this.slots[i].in_use and this.slots[i].thread_id == thread_id {
                this.slots[i].pool.clear()
                this.slots[i].in_use = false
                break
            }
            i = i + 1
        }

        spin_unlock(mut ref this.alloc_lock)
    }

    /// Clears all pools in the registry.
    pub func clear_all(mut this) {
        spin_lock(mut ref this.alloc_lock)

        var i: I64 = 0
        loop {
            if i >= this.slot_count as I64 { break }
            if this.slots[i].in_use {
                this.slots[i].pool.clear()
                this.slots[i].in_use = false
            }
            i = i + 1
        }
        this.slot_count = 0

        spin_unlock(mut ref this.alloc_lock)
    }

    /// Returns aggregate statistics across all pools.
    pub func aggregate_stats(this) -> PoolStats {
        var total = PoolStats::new()

        var i: I64 = 0
        loop {
            if i >= this.slot_count as I64 { break }
            if this.slots[i].in_use {
                let s = this.slots[i].pool.stats()
                total.available = total.available + s.available
                total.in_use = total.in_use + s.in_use
                total.capacity = total.capacity + s.capacity
                total.hits = total.hits + s.hits
                total.misses = total.misses + s.misses
                total.grows = total.grows + s.grows
            }
            i = i + 1
        }

        total
    }
}

impl[T] Drop for ThreadLocalPoolRegistry[T] {
    func drop(mut this) {
        this.clear_all()
    }
}

// ============================================================================
// Helper: Get current thread ID
// ============================================================================

/// Returns the current thread's ID.
/// This is a platform-specific operation.
func get_current_thread_id() -> I64 {
    // Platform-specific thread ID retrieval
    #if WINDOWS
    lowlevel { GetCurrentThreadId() as I64 }
    #elif UNIX
    lowlevel { pthread_self() as I64 }
    #else
    // Fallback: return a unique value per call (not ideal)
    static var counter: I64 = 0
    counter = counter + 1
    counter
    #endif
}

/// Default array initializer helper.
func default_array[T, N]() -> [T; N] {
    lowlevel { zeroed() }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_pool_basic() {
    var pool: Pool[I64] = Pool::new(8, GrowthPolicy::Doubling)

    assert_eq(pool.capacity(), 8)
    assert_eq(pool.available(), 8)

    // Acquire an object
    let obj1 = pool.acquire()
    assert(obj1.is_just())
    assert_eq(pool.available(), 7)
    assert_eq(pool.in_use(), 1)

    // Release it back
    when obj1 {
        Just(ptr) => pool.release(ptr)
        Nothing => {}
    }
    assert_eq(pool.available(), 8)
    assert_eq(pool.in_use(), 0)
}

@test
func test_pool_growth() {
    var pool: Pool[I64] = Pool::new(2, GrowthPolicy::Doubling)

    // Acquire all objects
    let obj1 = pool.acquire()
    let obj2 = pool.acquire()
    assert_eq(pool.available(), 0)

    // Acquire more - should trigger growth
    let obj3 = pool.acquire()
    assert(obj3.is_just())
    assert(pool.stats().grows > 0)
}

@test
func test_pool_fixed() {
    var pool: Pool[I64] = Pool::fixed(2)

    let obj1 = pool.acquire()
    let obj2 = pool.acquire()
    let obj3 = pool.acquire() // Should fail - no growth

    assert(obj1.is_just())
    assert(obj2.is_just())
    assert(obj3.is_nothing())
}

@test
func test_thread_local_pool() {
    var pool: ThreadLocalPool[I64] = ThreadLocalPool::new(16)

    assert_eq(pool.capacity, 16)
    assert_eq(pool.available(), 16)

    // Fast acquire (no atomics)
    let obj1 = pool.acquire()
    assert(obj1.is_just())
    assert_eq(pool.available(), 15)

    // Fast release
    when obj1 {
        Just(ptr) => pool.release(ptr)
        Nothing => {}
    }
    assert_eq(pool.available(), 16)
}

@test
func test_thread_local_pool_stats() {
    var pool: ThreadLocalPool[I64] = ThreadLocalPool::new(8)

    let obj1 = pool.acquire()
    let obj2 = pool.acquire()
    let obj3 = pool.acquire()

    assert_eq(pool.stats().hits, 3)
    assert_eq(pool.in_use(), 3)

    when obj1 {
        Just(ptr) => pool.release(ptr)
        Nothing => {}
    }

    assert_eq(pool.in_use(), 2)
}
