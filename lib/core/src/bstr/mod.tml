//! Byte string utilities.
//!
//! This module provides utilities for working with byte slices that may
//! contain non-UTF-8 data.
//!
//! # Note
//!
//! The full ByteStr type requires `transmute` which is not yet implemented.
//! This module provides static utility functions as an alternative.
//!
//! # Examples
//!
//! ```tml
//! use core::bstr
//! use core::slice::Slice
//!
//! let data: [U8] = [72, 101, 108, 108, 111]  // "Hello"
//! let slice: Slice[U8] = data.as_slice()
//! assert(bstr::is_ascii(slice))
//! ```

use core::slice::Slice

// ============================================================================
// Byte String Utilities (operates on Slice[U8])
// ============================================================================

/// Returns `true` if all bytes are ASCII (0-127).
pub func is_ascii(bytes: Slice[U8]) -> Bool {
    var i: I64 = 0
    let len: I64 = bytes.len()
    loop (i < len) {
        let b: Maybe[ref U8] = bytes.get(i)
        when b {
            Just(byte_ref) => {
                if *byte_ref > 127 {
                    return false
                }
            },
            Nothing => { return false }
        }
        i = i + 1
    }
    return true
}

/// Checks if a byte slice starts with the given prefix.
pub func starts_with(bytes: Slice[U8], prefix: Slice[U8]) -> Bool {
    let prefix_len: I64 = prefix.len()
    if prefix_len > bytes.len() {
        return false
    }
    var i: I64 = 0
    loop (i < prefix_len) {
        let b1: Maybe[ref U8] = bytes.get(i)
        let b2: Maybe[ref U8] = prefix.get(i)
        when (b1, b2) {
            (Just(a), Just(b)) => {
                if *a != *b {
                    return false
                }
            },
            _ => { return false }
        }
        i = i + 1
    }
    return true
}

/// Checks if a byte slice ends with the given suffix.
pub func ends_with(bytes: Slice[U8], suffix: Slice[U8]) -> Bool {
    let suffix_len: I64 = suffix.len()
    let bytes_len: I64 = bytes.len()
    if suffix_len > bytes_len {
        return false
    }
    let start: I64 = bytes_len - suffix_len
    var i: I64 = 0
    loop (i < suffix_len) {
        let b1: Maybe[ref U8] = bytes.get(start + i)
        let b2: Maybe[ref U8] = suffix.get(i)
        when (b1, b2) {
            (Just(a), Just(b)) => {
                if *a != *b {
                    return false
                }
            },
            _ => { return false }
        }
        i = i + 1
    }
    return true
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Returns `true` if the byte is ASCII whitespace.
func is_ascii_whitespace(b: U8) -> Bool {
    return b == 32   // space
        or b == 9    // tab
        or b == 10   // newline
        or b == 13   // carriage return
        or b == 12   // form feed
}

/// Converts an ASCII uppercase letter to lowercase.
func to_ascii_lowercase_byte(b: U8) -> U8 {
    if b >= 65 and b <= 90 {  // 'A' to 'Z'
        return b + 32
    }
    return b
}
