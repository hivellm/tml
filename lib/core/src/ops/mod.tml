//! Overloadable operators.
//!
//! This module provides behaviors that enable operator overloading in TML.
//! When you implement these behaviors for your types, the corresponding
//! operators become available.
//!
//! # Module Organization
//!
//! The operators are organized into logical submodules:
//!
//! | Module | Contents |
//! |--------|----------|
//! | [`arith`] | Arithmetic: `+`, `-`, `*`, `/`, `%`, unary `-` |
//! | [`bit`] | Bitwise: `&`, `\|`, `^`, `not`, `<<`, `>>` |
//! | [`deref`] | Dereferencing: `*` (Deref, DerefMut) |
//! | [`index`] | Indexing: `[]` (Index, IndexMut) |
//! | [`function`] | Callable: FnOnce, FnMut, Fn |
//! | [`try_trait`] | Try operator: `?` |
//! | [`drop`] | Destructors: Drop, ManuallyDrop |
//! | [`range`] | Ranges: RangeBounds, Range, RangeInclusive, etc. |
//! | [`coroutine`] | Coroutines: Coroutine, Generator, CoroutineState |
//! | [`async_function`] | Async: AsyncFn, AsyncFnMut, AsyncFnOnce, IntoFuture |
//!
//! # Operator Behaviors Summary
//!
//! ## Arithmetic Operators
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`Add`] | `+` | `a + b` |
//! | [`Sub`] | `-` | `a - b` |
//! | [`Mul`] | `*` | `a * b` |
//! | [`Div`] | `/` | `a / b` |
//! | [`Rem`] | `%` | `a % b` |
//! | [`Neg`] | `-` (unary) | `-a` |
//!
//! ## Bitwise Operators
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`BitAnd`] | `&` | `a & b` |
//! | [`BitOr`] | `\|` | `a \| b` |
//! | [`BitXor`] | `^` | `a ^ b` |
//! | [`Not`] | `not` | `not a` |
//! | [`Shl`] | `<<` | `a << b` |
//! | [`Shr`] | `>>` | `a >> b` |
//!
//! ## Compound Assignment
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`AddAssign`] | `+=` | `a += b` |
//! | [`SubAssign`] | `-=` | `a -= b` |
//! | [`MulAssign`] | `*=` | `a *= b` |
//! | [`DivAssign`] | `/=` | `a /= b` |
//! | [`RemAssign`] | `%=` | `a %= b` |
//! | [`BitAndAssign`] | `&=` | `a &= b` |
//! | [`BitOrAssign`] | `\|=` | `a \|= b` |
//! | [`BitXorAssign`] | `^=` | `a ^= b` |
//! | [`ShlAssign`] | `<<=` | `a <<= b` |
//! | [`ShrAssign`] | `>>=` | `a >>= b` |
//!
//! # Examples
//!
//! ## Implementing Add for a Custom Type
//!
//! ```tml
//! use core::ops::Add
//!
//! pub type Point { x: F64, y: F64 }
//!
//! impl Add for Point {
//!     type Output = Point
//!
//!     pub func add(this, rhs: Point) -> Point {
//!         return Point {
//!             x: this.x + rhs.x,
//!             y: this.y + rhs.y
//!         }
//!     }
//! }
//!
//! let p1 = Point { x: 1.0, y: 2.0 }
//! let p2 = Point { x: 3.0, y: 4.0 }
//! let p3 = p1 + p2  // Point { x: 4.0, y: 6.0 }
//! ```
//!
//! ## Mixed-Type Operations
//!
//! ```tml
//! use core::ops::Mul
//!
//! impl Mul[F64] for Point {
//!     type Output = Point
//!
//!     pub func mul(this, scalar: F64) -> Point {
//!         return Point {
//!             x: this.x * scalar,
//!             y: this.y * scalar
//!         }
//!     }
//! }
//!
//! let p = Point { x: 1.0, y: 2.0 }
//! let scaled = p * 2.5  // Point { x: 2.5, y: 5.0 }
//! ```

// Declare submodules
pub mod arith
pub mod bit
pub mod deref
pub mod index
pub mod function
pub mod try_trait
pub mod drop
pub mod range
pub mod coroutine
pub mod async_function

// Re-export all public items from submodules
pub use arith::*
pub use bit::*
pub use deref::*
pub use index::*
pub use function::*
pub use try_trait::*
pub use drop::*
pub use range::*
pub use coroutine::*
pub use async_function::*
