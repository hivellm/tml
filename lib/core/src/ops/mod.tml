//! Overloadable operators.
//!
//! This module provides behaviors that enable operator overloading in TML.
//! When you implement these behaviors for your types, the corresponding
//! operators become available.
//!
//! # Operator Behaviors
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`Add`] | `+` | `a + b` |
//! | [`Sub`] | `-` | `a - b` |
//! | [`Mul`] | `*` | `a * b` |
//! | [`Div`] | `/` | `a / b` |
//! | [`Rem`] | `%` | `a % b` |
//! | [`Neg`] | `-` (unary) | `-a` |
//! | [`Not`] | `not` | `not a` |
//! | [`BitAnd`] | `&` | `a & b` |
//! | [`BitOr`] | `\|` | `a \| b` |
//! | [`BitXor`] | `^` | `a ^ b` |
//! | [`Shl`] | `<<` | `a << b` |
//! | [`Shr`] | `>>` | `a >> b` |
//! | [`Index`] | `[]` | `a[i]` |
//! | [`IndexMut`] | `[]` | `a[i] = x` |
//!
//! # Compound Assignment
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`AddAssign`] | `+=` | `a += b` |
//! | [`SubAssign`] | `-=` | `a -= b` |
//! | [`MulAssign`] | `*=` | `a *= b` |
//! | [`DivAssign`] | `/=` | `a /= b` |
//! | [`RemAssign`] | `%=` | `a %= b` |
//! | [`BitAndAssign`] | `&=` | `a &= b` |
//! | [`BitOrAssign`] | `\|=` | `a \|= b` |
//! | [`BitXorAssign`] | `^=` | `a ^= b` |
//! | [`ShlAssign`] | `<<=` | `a <<= b` |
//! | [`ShrAssign`] | `>>=` | `a >>= b` |
//!
//! # Examples
//!
//! ## Implementing Add for a Custom Type
//!
//! ```tml
//! use core::ops::Add
//!
//! pub type Point {
//!     x: F64,
//!     y: F64
//! }
//!
//! impl Add for Point {
//!     type Output = Point
//!
//!     pub func add(this, rhs: Point) -> Point {
//!         return Point {
//!             x: this.x + rhs.x,
//!             y: this.y + rhs.y
//!         }
//!     }
//! }
//!
//! let p1 = Point { x: 1.0, y: 2.0 }
//! let p2 = Point { x: 3.0, y: 4.0 }
//! let p3 = p1 + p2  // Point { x: 4.0, y: 6.0 }
//! ```
//!
//! ## Implementing Index for a Custom Container
//!
//! ```tml
//! use core::ops::Index
//!
//! pub type Matrix {
//!     data: List[F64],
//!     rows: I64,
//!     cols: I64
//! }
//!
//! impl Index[(I64, I64)] for Matrix {
//!     type Output = F64
//!
//!     pub func index(this, idx: (I64, I64)) -> ref F64 {
//!         let (row, col) = idx
//!         return ref this.data.get(row * this.cols + col)
//!     }
//! }
//!
//! let m = Matrix { ... }
//! let value = m[(1, 2)]  // Access row 1, column 2
//! ```
//!
//! ## Mixed-Type Operations
//!
//! You can implement operators with different right-hand side types:
//!
//! ```tml
//! use core::ops::Mul
//!
//! impl Mul[F64] for Point {
//!     type Output = Point
//!
//!     pub func mul(this, scalar: F64) -> Point {
//!         return Point {
//!             x: this.x * scalar,
//!             y: this.y * scalar
//!         }
//!     }
//! }
//!
//! let p = Point { x: 1.0, y: 2.0 }
//! let scaled = p * 2.5  // Point { x: 2.5, y: 5.0 }
//! ```

// ============================================================================
// Arithmetic Operators
// ============================================================================

/// The addition operator `+`.
///
/// Types implementing `Add` can be added using the `+` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Add
///
/// pub type Complex {
///     real: F64,
///     imag: F64
/// }
///
/// impl Add for Complex {
///     type Output = Complex
///
///     pub func add(this, rhs: Complex) -> Complex {
///         return Complex {
///             real: this.real + rhs.real,
///             imag: this.imag + rhs.imag
///         }
///     }
/// }
///
/// let a = Complex { real: 1.0, imag: 2.0 }
/// let b = Complex { real: 3.0, imag: 4.0 }
/// let c = a + b  // Complex { real: 4.0, imag: 6.0 }
/// ```
///
/// # Default Rhs
///
/// The `Rhs` type parameter defaults to `Self`, meaning by default you
/// implement addition between two values of the same type.
pub behavior Add[Rhs = Self] {
    /// The resulting type after applying `+`.
    type Output

    /// Performs the `+` operation.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let sum = a.add(b)  // Equivalent to: a + b
    /// ```
    func add(this, rhs: Rhs) -> This::Output
}

/// The subtraction operator `-`.
///
/// Types implementing `Sub` can be subtracted using the `-` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Sub
///
/// impl Sub for Point {
///     type Output = Point
///
///     pub func sub(this, rhs: Point) -> Point {
///         return Point {
///             x: this.x - rhs.x,
///             y: this.y - rhs.y
///         }
///     }
/// }
///
/// let p1 = Point { x: 5.0, y: 3.0 }
/// let p2 = Point { x: 2.0, y: 1.0 }
/// let diff = p1 - p2  // Point { x: 3.0, y: 2.0 }
/// ```
pub behavior Sub[Rhs = Self] {
    /// The resulting type after applying `-`.
    type Output

    /// Performs the `-` operation.
    func sub(this, rhs: Rhs) -> This::Output
}

/// The multiplication operator `*`.
///
/// Types implementing `Mul` can be multiplied using the `*` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Mul
///
/// impl Mul for Complex {
///     type Output = Complex
///
///     pub func mul(this, rhs: Complex) -> Complex {
///         return Complex {
///             real: this.real * rhs.real - this.imag * rhs.imag,
///             imag: this.real * rhs.imag + this.imag * rhs.real
///         }
///     }
/// }
/// ```
pub behavior Mul[Rhs = Self] {
    /// The resulting type after applying `*`.
    type Output

    /// Performs the `*` operation.
    func mul(this, rhs: Rhs) -> This::Output
}

/// The division operator `/`.
///
/// Types implementing `Div` can be divided using the `/` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Div
///
/// pub type Fraction {
///     num: I64,
///     den: I64
/// }
///
/// impl Div for Fraction {
///     type Output = Fraction
///
///     pub func div(this, rhs: Fraction) -> Fraction {
///         return Fraction {
///             num: this.num * rhs.den,
///             den: this.den * rhs.num
///         }
///     }
/// }
/// ```
///
/// # Panics
///
/// Division by zero behavior depends on the implementation. Primitive
/// integer division by zero will panic.
pub behavior Div[Rhs = Self] {
    /// The resulting type after applying `/`.
    type Output

    /// Performs the `/` operation.
    func div(this, rhs: Rhs) -> This::Output
}

/// The remainder operator `%`.
///
/// Types implementing `Rem` can compute the remainder using the `%` operator.
///
/// For integers, this is the remainder after division (modulo operation).
///
/// # Examples
///
/// ```tml
/// let remainder = 17 % 5  // 2
/// ```
///
/// # Note
///
/// The behavior of `%` for negative numbers follows the same convention
/// as the underlying platform (typically truncated division remainder).
pub behavior Rem[Rhs = Self] {
    /// The resulting type after applying `%`.
    type Output

    /// Performs the `%` operation.
    func rem(this, rhs: Rhs) -> This::Output
}

// ============================================================================
// Unary Operators
// ============================================================================

/// The unary negation operator `-`.
///
/// Types implementing `Neg` can be negated using the unary `-` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Neg
///
/// impl Neg for Point {
///     type Output = Point
///
///     pub func neg(this) -> Point {
///         return Point { x: -this.x, y: -this.y }
///     }
/// }
///
/// let p = Point { x: 1.0, y: 2.0 }
/// let neg_p = -p  // Point { x: -1.0, y: -2.0 }
/// ```
pub behavior Neg {
    /// The resulting type after applying unary `-`.
    type Output

    /// Performs the unary `-` operation.
    func neg(this) -> This::Output
}

/// The logical negation operator `not`.
///
/// Types implementing `Not` can be logically negated using the `not` operator.
///
/// # Examples
///
/// ```tml
/// let a = true
/// let b = not a  // false
/// ```
///
/// # Note
///
/// For bitwise NOT on integers, use the `BitNot` behavior (not yet implemented).
pub behavior Not {
    /// The resulting type after applying `not`.
    type Output

    /// Performs the `not` operation.
    func negate(this) -> This::Output
}

// ============================================================================
// Bitwise Operators
// ============================================================================

/// The bitwise AND operator `&`.
///
/// Types implementing `BitAnd` can perform bitwise AND using the `&` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a & b  // 0b1000
/// ```
pub behavior BitAnd[Rhs = Self] {
    /// The resulting type after applying `&`.
    type Output

    /// Performs the `&` operation.
    func bitand(this, rhs: Rhs) -> This::Output
}

/// The bitwise OR operator `|`.
///
/// Types implementing `BitOr` can perform bitwise OR using the `|` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a | b  // 0b1110
/// ```
pub behavior BitOr[Rhs = Self] {
    /// The resulting type after applying `|`.
    type Output

    /// Performs the `|` operation.
    func bitor(this, rhs: Rhs) -> This::Output
}

/// The bitwise XOR operator `^`.
///
/// Types implementing `BitXor` can perform bitwise XOR using the `^` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a ^ b  // 0b0110
/// ```
pub behavior BitXor[Rhs = Self] {
    /// The resulting type after applying `^`.
    type Output

    /// Performs the `^` operation.
    func bitxor(this, rhs: Rhs) -> This::Output
}

/// The left shift operator `<<`.
///
/// Types implementing `Shl` can be left-shifted using the `<<` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b0001
/// let b = a << 3  // 0b1000
/// ```
///
/// # Note
///
/// The default `Rhs` is `I32`, representing the shift amount.
pub behavior Shl[Rhs = I32] {
    /// The resulting type after applying `<<`.
    type Output

    /// Performs the `<<` operation.
    func shift_left(this, rhs: Rhs) -> This::Output
}

/// The right shift operator `>>`.
///
/// Types implementing `Shr` can be right-shifted using the `>>` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1000
/// let b = a >> 3  // 0b0001
/// ```
///
/// # Note
///
/// For signed integers, this is typically an arithmetic right shift
/// (sign-extending). For unsigned integers, it's a logical right shift
/// (zero-filling).
pub behavior Shr[Rhs = I32] {
    /// The resulting type after applying `>>`.
    type Output

    /// Performs the `>>` operation.
    func shift_right(this, rhs: Rhs) -> This::Output
}

// ============================================================================
// Indexing Operators
// ============================================================================
// NOTE: Index and IndexMut are compiler builtins, not defined here.
// See compiler/src/types/builtins for the definitions.

// ============================================================================
// Assignment Operators (Compound)
// ============================================================================

/// The addition assignment operator `+=`.
///
/// Types implementing `AddAssign` can use the `+=` operator for in-place addition.
///
/// # Examples
///
/// ```tml
/// use core::ops::AddAssign
///
/// impl AddAssign for Point {
///     pub func add_assign(mut this, rhs: Point) {
///         this.x = this.x + rhs.x
///         this.y = this.y + rhs.y
///     }
/// }
///
/// let mut p = Point { x: 1.0, y: 2.0 }
/// p += Point { x: 3.0, y: 4.0 }
/// // p is now Point { x: 4.0, y: 6.0 }
/// ```
pub behavior AddAssign[Rhs = Self] {
    /// Performs the `+=` operation.
    func add_assign(mut this, rhs: Rhs)
}

/// The subtraction assignment operator `-=`.
///
/// Types implementing `SubAssign` can use the `-=` operator for in-place subtraction.
///
/// # Examples
///
/// ```tml
/// let mut x = 10
/// x -= 3  // x is now 7
/// ```
pub behavior SubAssign[Rhs = Self] {
    /// Performs the `-=` operation.
    func sub_assign(mut this, rhs: Rhs)
}

/// The multiplication assignment operator `*=`.
///
/// Types implementing `MulAssign` can use the `*=` operator for in-place multiplication.
///
/// # Examples
///
/// ```tml
/// let mut x = 5
/// x *= 3  // x is now 15
/// ```
pub behavior MulAssign[Rhs = Self] {
    /// Performs the `*=` operation.
    func mul_assign(mut this, rhs: Rhs)
}

/// The division assignment operator `/=`.
///
/// Types implementing `DivAssign` can use the `/=` operator for in-place division.
///
/// # Examples
///
/// ```tml
/// let mut x = 20
/// x /= 4  // x is now 5
/// ```
pub behavior DivAssign[Rhs = Self] {
    /// Performs the `/=` operation.
    func div_assign(mut this, rhs: Rhs)
}

/// The remainder assignment operator `%=`.
///
/// Types implementing `RemAssign` can use the `%=` operator for in-place remainder.
///
/// # Examples
///
/// ```tml
/// let mut x = 17
/// x %= 5  // x is now 2
/// ```
pub behavior RemAssign[Rhs = Self] {
    /// Performs the `%=` operation.
    func rem_assign(mut this, rhs: Rhs)
}

// ============================================================================
// Bitwise Assignment Operators
// ============================================================================

/// The bitwise AND assignment operator `&=`.
///
/// Types implementing `BitAndAssign` can use the `&=` operator for in-place bitwise AND.
///
/// # Examples
///
/// ```tml
/// let mut x: U8 = 0b1111
/// x &= 0b1010  // x is now 0b1010
/// ```
pub behavior BitAndAssign[Rhs = Self] {
    /// Performs the `&=` operation.
    func bitand_assign(mut this, rhs: Rhs)
}

/// The bitwise OR assignment operator `|=`.
///
/// Types implementing `BitOrAssign` can use the `|=` operator for in-place bitwise OR.
///
/// # Examples
///
/// ```tml
/// let mut x: U8 = 0b1010
/// x |= 0b0101  // x is now 0b1111
/// ```
pub behavior BitOrAssign[Rhs = Self] {
    /// Performs the `|=` operation.
    func bitor_assign(mut this, rhs: Rhs)
}

/// The bitwise XOR assignment operator `^=`.
///
/// Types implementing `BitXorAssign` can use the `^=` operator for in-place bitwise XOR.
///
/// # Examples
///
/// ```tml
/// let mut x: U8 = 0b1111
/// x ^= 0b1010  // x is now 0b0101
/// ```
pub behavior BitXorAssign[Rhs = Self] {
    /// Performs the `^=` operation.
    func bitxor_assign(mut this, rhs: Rhs)
}

/// The left shift assignment operator `<<=`.
///
/// Types implementing `ShlAssign` can use the `<<=` operator for in-place left shift.
///
/// # Examples
///
/// ```tml
/// let mut x: U8 = 0b0001
/// x <<= 3  // x is now 0b1000
/// ```
pub behavior ShlAssign[Rhs = I32] {
    /// Performs the `<<=` operation.
    func shl_assign(mut this, rhs: Rhs)
}

/// The right shift assignment operator `>>=`.
///
/// Types implementing `ShrAssign` can use the `>>=` operator for in-place right shift.
///
/// # Examples
///
/// ```tml
/// let mut x: U8 = 0b1000
/// x >>= 3  // x is now 0b0001
/// ```
///
/// # Note
///
/// For signed integers, this is typically an arithmetic right shift
/// (sign-extending). For unsigned integers, it's a logical right shift
/// (zero-filling).
pub behavior ShrAssign[Rhs = I32] {
    /// Performs the `>>=` operation.
    func shr_assign(mut this, rhs: Rhs)
}

// ============================================================================
// Add implementations for primitives
// ============================================================================

/// `Add` implementation for `I8`.
impl Add for I8 {
    type Output = I8
    pub func add(this, rhs: I8) -> I8 { return this + rhs }
}

/// `Add` implementation for `I16`.
impl Add for I16 {
    type Output = I16
    pub func add(this, rhs: I16) -> I16 { return this + rhs }
}

/// `Add` implementation for `I32`.
impl Add for I32 {
    type Output = I32
    pub func add(this, rhs: I32) -> I32 { return this + rhs }
}

/// `Add` implementation for `I64`.
impl Add for I64 {
    type Output = I64
    pub func add(this, rhs: I64) -> I64 { return this + rhs }
}

/// `Add` implementation for `U8`.
impl Add for U8 {
    type Output = U8
    pub func add(this, rhs: U8) -> U8 { return this + rhs }
}

/// `Add` implementation for `U16`.
impl Add for U16 {
    type Output = U16
    pub func add(this, rhs: U16) -> U16 { return this + rhs }
}

/// `Add` implementation for `U32`.
impl Add for U32 {
    type Output = U32
    pub func add(this, rhs: U32) -> U32 { return this + rhs }
}

/// `Add` implementation for `U64`.
impl Add for U64 {
    type Output = U64
    pub func add(this, rhs: U64) -> U64 { return this + rhs }
}

/// `Add` implementation for `F32`.
impl Add for F32 {
    type Output = F32
    pub func add(this, rhs: F32) -> F32 { return this + rhs }
}

/// `Add` implementation for `F64`.
impl Add for F64 {
    type Output = F64
    pub func add(this, rhs: F64) -> F64 { return this + rhs }
}

// ============================================================================
// Sub implementations for primitives
// ============================================================================

/// `Sub` implementation for `I32`.
impl Sub for I32 {
    type Output = I32
    pub func sub(this, rhs: I32) -> I32 { return this - rhs }
}

/// `Sub` implementation for `I64`.
impl Sub for I64 {
    type Output = I64
    pub func sub(this, rhs: I64) -> I64 { return this - rhs }
}

/// `Sub` implementation for `F32`.
impl Sub for F32 {
    type Output = F32
    pub func sub(this, rhs: F32) -> F32 { return this - rhs }
}

/// `Sub` implementation for `F64`.
impl Sub for F64 {
    type Output = F64
    pub func sub(this, rhs: F64) -> F64 { return this - rhs }
}

// ============================================================================
// Mul implementations for primitives
// ============================================================================

/// `Mul` implementation for `I32`.
impl Mul for I32 {
    type Output = I32
    pub func mul(this, rhs: I32) -> I32 { return this * rhs }
}

/// `Mul` implementation for `I64`.
impl Mul for I64 {
    type Output = I64
    pub func mul(this, rhs: I64) -> I64 { return this * rhs }
}

/// `Mul` implementation for `F32`.
impl Mul for F32 {
    type Output = F32
    pub func mul(this, rhs: F32) -> F32 { return this * rhs }
}

/// `Mul` implementation for `F64`.
impl Mul for F64 {
    type Output = F64
    pub func mul(this, rhs: F64) -> F64 { return this * rhs }
}

// ============================================================================
// Div implementations for primitives
// ============================================================================

/// `Div` implementation for `I32`.
impl Div for I32 {
    type Output = I32
    pub func div(this, rhs: I32) -> I32 { return this / rhs }
}

/// `Div` implementation for `I64`.
impl Div for I64 {
    type Output = I64
    pub func div(this, rhs: I64) -> I64 { return this / rhs }
}

/// `Div` implementation for `F32`.
impl Div for F32 {
    type Output = F32
    pub func div(this, rhs: F32) -> F32 { return this / rhs }
}

/// `Div` implementation for `F64`.
impl Div for F64 {
    type Output = F64
    pub func div(this, rhs: F64) -> F64 { return this / rhs }
}

// ============================================================================
// Rem implementations for primitives
// ============================================================================

/// `Rem` implementation for `I32`.
impl Rem for I32 {
    type Output = I32
    pub func rem(this, rhs: I32) -> I32 { return this % rhs }
}

/// `Rem` implementation for `I64`.
impl Rem for I64 {
    type Output = I64
    pub func rem(this, rhs: I64) -> I64 { return this % rhs }
}

// ============================================================================
// Neg implementations for primitives
// ============================================================================

/// `Neg` implementation for `I32`.
impl Neg for I32 {
    type Output = I32
    pub func neg(this) -> I32 { return 0 - this }
}

/// `Neg` implementation for `I64`.
impl Neg for I64 {
    type Output = I64
    pub func neg(this) -> I64 { return 0 - this }
}

/// `Neg` implementation for `F32`.
impl Neg for F32 {
    type Output = F32
    pub func neg(this) -> F32 { return 0.0 - this }
}

/// `Neg` implementation for `F64`.
impl Neg for F64 {
    type Output = F64
    pub func neg(this) -> F64 { return 0.0 - this }
}

// ============================================================================
// Not implementation for Bool
// ============================================================================

/// `Not` implementation for `Bool`.
///
/// Enables `not true` -> `false` and `not false` -> `true`.
impl Not for Bool {
    type Output = Bool
    pub func negate(this) -> Bool { return not this }
}

// ============================================================================
// Index for List[T]
// ============================================================================
// Note: This requires the List type from std::collections

// impl[T] Index[I64] for List[T] {
//     type Output = T
//     pub func index(this, idx: I64) -> ref T {
//         return ref this.get(idx)
//     }
// }

// ============================================================================
// Index for Str (character access)
// ============================================================================
// Note: Str indexing returns a character code (I32)

// impl Index[I64] for Str {
//     type Output = I32
//     pub func index(this, idx: I64) -> ref I32 {
//         return ref lowlevel { str_char_at(this, idx) }
//     }
// }

// ============================================================================
// Drop Behavior (RAII)
// ============================================================================
// NOTE: Drop is a compiler builtin, not defined here.
// See compiler/src/types/builtins for the definition.

// ============================================================================
// BitAndAssign implementations for integers
// ============================================================================

/// `BitAndAssign` implementation for `I8`.
impl BitAndAssign for I8 {
    pub func bitand_assign(mut this, rhs: I8) { this = this & rhs }
}

/// `BitAndAssign` implementation for `I16`.
impl BitAndAssign for I16 {
    pub func bitand_assign(mut this, rhs: I16) { this = this & rhs }
}

/// `BitAndAssign` implementation for `I32`.
impl BitAndAssign for I32 {
    pub func bitand_assign(mut this, rhs: I32) { this = this & rhs }
}

/// `BitAndAssign` implementation for `I64`.
impl BitAndAssign for I64 {
    pub func bitand_assign(mut this, rhs: I64) { this = this & rhs }
}

/// `BitAndAssign` implementation for `U8`.
impl BitAndAssign for U8 {
    pub func bitand_assign(mut this, rhs: U8) { this = this & rhs }
}

/// `BitAndAssign` implementation for `U16`.
impl BitAndAssign for U16 {
    pub func bitand_assign(mut this, rhs: U16) { this = this & rhs }
}

/// `BitAndAssign` implementation for `U32`.
impl BitAndAssign for U32 {
    pub func bitand_assign(mut this, rhs: U32) { this = this & rhs }
}

/// `BitAndAssign` implementation for `U64`.
impl BitAndAssign for U64 {
    pub func bitand_assign(mut this, rhs: U64) { this = this & rhs }
}

// ============================================================================
// BitOrAssign implementations for integers
// ============================================================================

/// `BitOrAssign` implementation for `I8`.
impl BitOrAssign for I8 {
    pub func bitor_assign(mut this, rhs: I8) { this = this | rhs }
}

/// `BitOrAssign` implementation for `I16`.
impl BitOrAssign for I16 {
    pub func bitor_assign(mut this, rhs: I16) { this = this | rhs }
}

/// `BitOrAssign` implementation for `I32`.
impl BitOrAssign for I32 {
    pub func bitor_assign(mut this, rhs: I32) { this = this | rhs }
}

/// `BitOrAssign` implementation for `I64`.
impl BitOrAssign for I64 {
    pub func bitor_assign(mut this, rhs: I64) { this = this | rhs }
}

/// `BitOrAssign` implementation for `U8`.
impl BitOrAssign for U8 {
    pub func bitor_assign(mut this, rhs: U8) { this = this | rhs }
}

/// `BitOrAssign` implementation for `U16`.
impl BitOrAssign for U16 {
    pub func bitor_assign(mut this, rhs: U16) { this = this | rhs }
}

/// `BitOrAssign` implementation for `U32`.
impl BitOrAssign for U32 {
    pub func bitor_assign(mut this, rhs: U32) { this = this | rhs }
}

/// `BitOrAssign` implementation for `U64`.
impl BitOrAssign for U64 {
    pub func bitor_assign(mut this, rhs: U64) { this = this | rhs }
}

// ============================================================================
// BitXorAssign implementations for integers
// ============================================================================

/// `BitXorAssign` implementation for `I8`.
impl BitXorAssign for I8 {
    pub func bitxor_assign(mut this, rhs: I8) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `I16`.
impl BitXorAssign for I16 {
    pub func bitxor_assign(mut this, rhs: I16) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `I32`.
impl BitXorAssign for I32 {
    pub func bitxor_assign(mut this, rhs: I32) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `I64`.
impl BitXorAssign for I64 {
    pub func bitxor_assign(mut this, rhs: I64) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `U8`.
impl BitXorAssign for U8 {
    pub func bitxor_assign(mut this, rhs: U8) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `U16`.
impl BitXorAssign for U16 {
    pub func bitxor_assign(mut this, rhs: U16) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `U32`.
impl BitXorAssign for U32 {
    pub func bitxor_assign(mut this, rhs: U32) { this = this ^ rhs }
}

/// `BitXorAssign` implementation for `U64`.
impl BitXorAssign for U64 {
    pub func bitxor_assign(mut this, rhs: U64) { this = this ^ rhs }
}

// ============================================================================
// ShlAssign implementations for integers
// ============================================================================

/// `ShlAssign` implementation for `I8`.
impl ShlAssign for I8 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `I16`.
impl ShlAssign for I16 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `I32`.
impl ShlAssign for I32 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `I64`.
impl ShlAssign for I64 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `U8`.
impl ShlAssign for U8 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `U16`.
impl ShlAssign for U16 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `U32`.
impl ShlAssign for U32 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

/// `ShlAssign` implementation for `U64`.
impl ShlAssign for U64 {
    pub func shl_assign(mut this, rhs: I32) { this = this << rhs }
}

// ============================================================================
// ShrAssign implementations for integers
// ============================================================================

/// `ShrAssign` implementation for `I8`.
impl ShrAssign for I8 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `I16`.
impl ShrAssign for I16 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `I32`.
impl ShrAssign for I32 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `I64`.
impl ShrAssign for I64 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `U8`.
impl ShrAssign for U8 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `U16`.
impl ShrAssign for U16 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `U32`.
impl ShrAssign for U32 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

/// `ShrAssign` implementation for `U64`.
impl ShrAssign for U64 {
    pub func shr_assign(mut this, rhs: I32) { this = this >> rhs }
}

// ============================================================================
// Deref/DerefMut Behaviors
// ============================================================================

/// Used for immutable dereferencing operations.
///
/// The `Deref` behavior is used to implement the dereference operator `*` for
/// immutable access. Types implementing `Deref` can be treated as a reference
/// to their `Target` type.
///
/// # Deref Coercion
///
/// When a type `T` implements `Deref[Target=U]`, values of type `ref T` will
/// automatically coerce to `ref U` in contexts where `ref U` is expected.
/// This is called "deref coercion".
///
/// # Examples
///
/// ```tml
/// use core::ops::Deref
///
/// pub type SmartPtr[T] {
///     value: T
/// }
///
/// impl[T] Deref for SmartPtr[T] {
///     type Target = T
///
///     pub func deref(this) -> ref T {
///         return ref this.value
///     }
/// }
///
/// let ptr = SmartPtr { value: 42 }
/// let val: I32 = *ptr  // Dereference to get 42
/// ```
///
/// # Relationship with DerefMut
///
/// If you implement `Deref`, you often also want to implement `DerefMut`
/// for mutable dereferencing. `DerefMut` requires `Deref`.
///
/// # Use Cases
///
/// - Smart pointers (`Heap[T]`, `Shared[T]`, `Sync[T]`)
/// - Wrapper types that want to transparently expose their inner value
/// - Types that want to support deref coercion
///
/// # See Also
///
/// - [`DerefMut`]: Mutable dereferencing
pub behavior Deref {
    /// The resulting type after dereferencing.
    type Target

    /// Dereferences the value.
    ///
    /// Returns a reference to the target type.
    func deref(this) -> ref This::Target
}

/// Used for mutable dereferencing operations.
///
/// The `DerefMut` behavior is used to implement the dereference operator `*`
/// for mutable access. Types implementing `DerefMut` can be treated as a
/// mutable reference to their `Target` type.
///
/// # Mutable Deref Coercion
///
/// When a type `T` implements `DerefMut`, values of type `mut ref T` will
/// automatically coerce to `mut ref T::Target` in contexts where mutable
/// access is needed.
///
/// # Examples
///
/// ```tml
/// use core::ops::{Deref, DerefMut}
///
/// pub type SmartPtr[T] {
///     value: T
/// }
///
/// impl[T] Deref for SmartPtr[T] {
///     type Target = T
///     pub func deref(this) -> ref T { return ref this.value }
/// }
///
/// impl[T] DerefMut for SmartPtr[T] {
///     pub func deref_mut(mut this) -> mut ref T {
///         return mut ref this.value
///     }
/// }
///
/// let mut ptr = SmartPtr { value: 42 }
/// *ptr = 100  // Modify through the smart pointer
/// ```
///
/// # Prerequisite
///
/// `DerefMut` requires `Deref` to be implemented (same `Target` type).
///
/// # See Also
///
/// - [`Deref`]: Immutable dereferencing
pub behavior DerefMut: Deref {
    /// Mutably dereferences the value.
    ///
    /// Returns a mutable reference to the target type.
    func deref_mut(mut this) -> mut ref This::Target
}

// ============================================================================
// Function Traits Submodule
// ============================================================================

/// Function traits for callable types (FnOnce, FnMut, Fn).
///
/// See the [`function`] module for details.
pub mod function
