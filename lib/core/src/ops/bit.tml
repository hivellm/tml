//! Bitwise operator behaviors and implementations.
//!
//! This module defines the behaviors for bitwise operators (`&`, `|`, `^`,
//! `~`, `<<`, `>>`) and their compound assignment counterparts (`&=`, `|=`,
//! `^=`, `<<=`, `>>=`).
//!
//! Each behavior is implemented for all integer primitive types
//! (I8, I16, I32, I64, U8, U16, U32, U64). `Not` is also implemented for `Bool`.
//!
//! # Examples
//!
//! ```tml
//! let a: U8 = 0b1100
//! let b: U8 = 0b1010
//! let and_result: U8 = a & b    // 0b1000 (BitAnd)
//! let or_result: U8 = a | b     // 0b1110 (BitOr)
//! let xor_result: U8 = a ^ b    // 0b0110 (BitXor)
//! let shifted: U8 = a << 2      // 0b110000 (Shl)
//! let flag: Bool = not true      // false (Not)
//! ```

// ============================================================================
// Bitwise Behaviors
// ============================================================================

/// The bitwise AND operator `&`.
///
/// # Examples
///
/// ```tml
/// let x: U8 = 0b1111 & 0b1010  // 0b1010
/// ```
pub behavior BitAnd[Rhs] {
    /// Performs the `&` operation.
    func bitand(this, rhs: Rhs) -> This::Output
}

/// The bitwise OR operator `|`.
///
/// # Examples
///
/// ```tml
/// let x: U8 = 0b1100 | 0b0011  // 0b1111
/// ```
pub behavior BitOr[Rhs] {
    /// Performs the `|` operation.
    func bitor(this, rhs: Rhs) -> This::Output
}

/// The bitwise XOR operator `^`.
///
/// # Examples
///
/// ```tml
/// let x: U8 = 0b1100 ^ 0b1010  // 0b0110
/// ```
pub behavior BitXor[Rhs] {
    /// Performs the `^` operation.
    func bitxor(this, rhs: Rhs) -> This::Output
}

/// The bitwise NOT (complement) operator `not` / `~`.
///
/// For `Bool`, this is logical negation. For integers, this is bitwise complement.
///
/// # Examples
///
/// ```tml
/// let x: Bool = not true  // false
/// ```
pub behavior Not {
    /// Performs the `not` / `~` operation.
    func negate(this) -> This::Output
}

/// The left shift operator `<<`.
///
/// Shifts bits to the left, filling with zeros on the right.
/// The shift amount is always `I32`.
///
/// # Examples
///
/// ```tml
/// let x: U8 = 1 << 3  // 8
/// ```
pub behavior Shl[Rhs] {
    /// Performs the `<<` operation.
    func shift_left(this, rhs: Rhs) -> This::Output
}

/// The right shift operator `>>`.
///
/// For unsigned types, this is a logical shift (fills with zeros).
/// For signed types, this is an arithmetic shift (fills with sign bit).
/// The shift amount is always `I32`.
///
/// # Examples
///
/// ```tml
/// let x: U8 = 8 >> 2  // 2
/// ```
pub behavior Shr[Rhs] {
    /// Performs the `>>` operation.
    func shift_right(this, rhs: Rhs) -> This::Output
}

// ============================================================================
// Compound Assignment Behaviors
// ============================================================================

/// The bitwise AND assignment operator `&=`.
pub behavior BitAndAssign[Rhs] {
    /// Performs the `&=` operation.
    func bitand_assign(mut this, rhs: Rhs)
}

/// The bitwise OR assignment operator `|=`.
pub behavior BitOrAssign[Rhs] {
    /// Performs the `|=` operation.
    func bitor_assign(mut this, rhs: Rhs)
}

/// The bitwise XOR assignment operator `^=`.
pub behavior BitXorAssign[Rhs] {
    /// Performs the `^=` operation.
    func bitxor_assign(mut this, rhs: Rhs)
}

/// The left shift assignment operator `<<=`.
pub behavior ShlAssign[Rhs] {
    /// Performs the `<<=` operation.
    func shl_assign(mut this, rhs: Rhs)
}

/// The right shift assignment operator `>>=`.
pub behavior ShrAssign[Rhs] {
    /// Performs the `>>=` operation.
    func shr_assign(mut this, rhs: Rhs)
}

// ============================================================================
// Not implementation for Bool
// ============================================================================

/// Logical negation for `Bool`.
impl Not for Bool {
    pub func negate(this) -> Bool {
        return not this
    }
}

// ============================================================================
// BitAnd implementations for all integer types
// ============================================================================

/// `I8 & I8 -> I8`
impl BitAnd for I8 {
    pub func bitand(this, rhs: I8) -> I8 {
        return this & rhs
    }
}

/// `I16 & I16 -> I16`
impl BitAnd for I16 {
    pub func bitand(this, rhs: I16) -> I16 {
        return this & rhs
    }
}

/// `I32 & I32 -> I32`
impl BitAnd for I32 {
    pub func bitand(this, rhs: I32) -> I32 {
        return this & rhs
    }
}

/// `I64 & I64 -> I64`
impl BitAnd for I64 {
    pub func bitand(this, rhs: I64) -> I64 {
        return this & rhs
    }
}

/// `U8 & U8 -> U8`
impl BitAnd for U8 {
    pub func bitand(this, rhs: U8) -> U8 {
        return this & rhs
    }
}

/// `U16 & U16 -> U16`
impl BitAnd for U16 {
    pub func bitand(this, rhs: U16) -> U16 {
        return this & rhs
    }
}

/// `U32 & U32 -> U32`
impl BitAnd for U32 {
    pub func bitand(this, rhs: U32) -> U32 {
        return this & rhs
    }
}

/// `U64 & U64 -> U64`
impl BitAnd for U64 {
    pub func bitand(this, rhs: U64) -> U64 {
        return this & rhs
    }
}

// ============================================================================
// BitOr implementations for all integer types
// ============================================================================

/// `I8 | I8 -> I8`
impl BitOr for I8 {
    pub func bitor(this, rhs: I8) -> I8 {
        return this | rhs
    }
}

/// `I16 | I16 -> I16`
impl BitOr for I16 {
    pub func bitor(this, rhs: I16) -> I16 {
        return this | rhs
    }
}

/// `I32 | I32 -> I32`
impl BitOr for I32 {
    pub func bitor(this, rhs: I32) -> I32 {
        return this | rhs
    }
}

/// `I64 | I64 -> I64`
impl BitOr for I64 {
    pub func bitor(this, rhs: I64) -> I64 {
        return this | rhs
    }
}

/// `U8 | U8 -> U8`
impl BitOr for U8 {
    pub func bitor(this, rhs: U8) -> U8 {
        return this | rhs
    }
}

/// `U16 | U16 -> U16`
impl BitOr for U16 {
    pub func bitor(this, rhs: U16) -> U16 {
        return this | rhs
    }
}

/// `U32 | U32 -> U32`
impl BitOr for U32 {
    pub func bitor(this, rhs: U32) -> U32 {
        return this | rhs
    }
}

/// `U64 | U64 -> U64`
impl BitOr for U64 {
    pub func bitor(this, rhs: U64) -> U64 {
        return this | rhs
    }
}

// ============================================================================
// BitXor implementations for all integer types
// ============================================================================

/// `I8 ^ I8 -> I8`
impl BitXor for I8 {
    pub func bitxor(this, rhs: I8) -> I8 {
        return this ^ rhs
    }
}

/// `I16 ^ I16 -> I16`
impl BitXor for I16 {
    pub func bitxor(this, rhs: I16) -> I16 {
        return this ^ rhs
    }
}

/// `I32 ^ I32 -> I32`
impl BitXor for I32 {
    pub func bitxor(this, rhs: I32) -> I32 {
        return this ^ rhs
    }
}

/// `I64 ^ I64 -> I64`
impl BitXor for I64 {
    pub func bitxor(this, rhs: I64) -> I64 {
        return this ^ rhs
    }
}

/// `U8 ^ U8 -> U8`
impl BitXor for U8 {
    pub func bitxor(this, rhs: U8) -> U8 {
        return this ^ rhs
    }
}

/// `U16 ^ U16 -> U16`
impl BitXor for U16 {
    pub func bitxor(this, rhs: U16) -> U16 {
        return this ^ rhs
    }
}

/// `U32 ^ U32 -> U32`
impl BitXor for U32 {
    pub func bitxor(this, rhs: U32) -> U32 {
        return this ^ rhs
    }
}

/// `U64 ^ U64 -> U64`
impl BitXor for U64 {
    pub func bitxor(this, rhs: U64) -> U64 {
        return this ^ rhs
    }
}

// ============================================================================
// Shl implementations for all integer types
// ============================================================================

/// `I8 << I32 -> I8`
impl Shl for I8 {
    pub func shift_left(this, rhs: I32) -> I8 {
        return this << rhs
    }
}

/// `I16 << I32 -> I16`
impl Shl for I16 {
    pub func shift_left(this, rhs: I32) -> I16 {
        return this << rhs
    }
}

/// `I32 << I32 -> I32`
impl Shl for I32 {
    pub func shift_left(this, rhs: I32) -> I32 {
        return this << rhs
    }
}

/// `I64 << I32 -> I64`
impl Shl for I64 {
    pub func shift_left(this, rhs: I32) -> I64 {
        return this << rhs
    }
}

/// `U8 << I32 -> U8`
impl Shl for U8 {
    pub func shift_left(this, rhs: I32) -> U8 {
        return this << rhs
    }
}

/// `U16 << I32 -> U16`
impl Shl for U16 {
    pub func shift_left(this, rhs: I32) -> U16 {
        return this << rhs
    }
}

/// `U32 << I32 -> U32`
impl Shl for U32 {
    pub func shift_left(this, rhs: I32) -> U32 {
        return this << rhs
    }
}

/// `U64 << I32 -> U64`
impl Shl for U64 {
    pub func shift_left(this, rhs: I32) -> U64 {
        return this << rhs
    }
}

// ============================================================================
// Shr implementations for all integer types
// ============================================================================

/// `I8 >> I32 -> I8` (arithmetic shift)
impl Shr for I8 {
    pub func shift_right(this, rhs: I32) -> I8 {
        return this >> rhs
    }
}

/// `I16 >> I32 -> I16` (arithmetic shift)
impl Shr for I16 {
    pub func shift_right(this, rhs: I32) -> I16 {
        return this >> rhs
    }
}

/// `I32 >> I32 -> I32` (arithmetic shift)
impl Shr for I32 {
    pub func shift_right(this, rhs: I32) -> I32 {
        return this >> rhs
    }
}

/// `I64 >> I32 -> I64` (arithmetic shift)
impl Shr for I64 {
    pub func shift_right(this, rhs: I32) -> I64 {
        return this >> rhs
    }
}

/// `U8 >> I32 -> U8` (logical shift)
impl Shr for U8 {
    pub func shift_right(this, rhs: I32) -> U8 {
        return this >> rhs
    }
}

/// `U16 >> I32 -> U16` (logical shift)
impl Shr for U16 {
    pub func shift_right(this, rhs: I32) -> U16 {
        return this >> rhs
    }
}

/// `U32 >> I32 -> U32` (logical shift)
impl Shr for U32 {
    pub func shift_right(this, rhs: I32) -> U32 {
        return this >> rhs
    }
}

/// `U64 >> I32 -> U64` (logical shift)
impl Shr for U64 {
    pub func shift_right(this, rhs: I32) -> U64 {
        return this >> rhs
    }
}

// ============================================================================
// BitAndAssign implementations for all integer types
// ============================================================================

/// `I8 &= I8`
impl BitAndAssign for I8 {
    pub func bitand_assign(mut this, rhs: I8) {
        this = this & rhs
    }
}

/// `I16 &= I16`
impl BitAndAssign for I16 {
    pub func bitand_assign(mut this, rhs: I16) {
        this = this & rhs
    }
}

/// `I32 &= I32`
impl BitAndAssign for I32 {
    pub func bitand_assign(mut this, rhs: I32) {
        this = this & rhs
    }
}

/// `I64 &= I64`
impl BitAndAssign for I64 {
    pub func bitand_assign(mut this, rhs: I64) {
        this = this & rhs
    }
}

/// `U8 &= U8`
impl BitAndAssign for U8 {
    pub func bitand_assign(mut this, rhs: U8) {
        this = this & rhs
    }
}

/// `U16 &= U16`
impl BitAndAssign for U16 {
    pub func bitand_assign(mut this, rhs: U16) {
        this = this & rhs
    }
}

/// `U32 &= U32`
impl BitAndAssign for U32 {
    pub func bitand_assign(mut this, rhs: U32) {
        this = this & rhs
    }
}

/// `U64 &= U64`
impl BitAndAssign for U64 {
    pub func bitand_assign(mut this, rhs: U64) {
        this = this & rhs
    }
}

// ============================================================================
// BitOrAssign implementations for all integer types
// ============================================================================

/// `I8 |= I8`
impl BitOrAssign for I8 {
    pub func bitor_assign(mut this, rhs: I8) {
        this = this | rhs
    }
}

/// `I16 |= I16`
impl BitOrAssign for I16 {
    pub func bitor_assign(mut this, rhs: I16) {
        this = this | rhs
    }
}

/// `I32 |= I32`
impl BitOrAssign for I32 {
    pub func bitor_assign(mut this, rhs: I32) {
        this = this | rhs
    }
}

/// `I64 |= I64`
impl BitOrAssign for I64 {
    pub func bitor_assign(mut this, rhs: I64) {
        this = this | rhs
    }
}

/// `U8 |= U8`
impl BitOrAssign for U8 {
    pub func bitor_assign(mut this, rhs: U8) {
        this = this | rhs
    }
}

/// `U16 |= U16`
impl BitOrAssign for U16 {
    pub func bitor_assign(mut this, rhs: U16) {
        this = this | rhs
    }
}

/// `U32 |= U32`
impl BitOrAssign for U32 {
    pub func bitor_assign(mut this, rhs: U32) {
        this = this | rhs
    }
}

/// `U64 |= U64`
impl BitOrAssign for U64 {
    pub func bitor_assign(mut this, rhs: U64) {
        this = this | rhs
    }
}

// ============================================================================
// BitXorAssign implementations for all integer types
// ============================================================================

/// `I8 ^= I8`
impl BitXorAssign for I8 {
    pub func bitxor_assign(mut this, rhs: I8) {
        this = this ^ rhs
    }
}

/// `I16 ^= I16`
impl BitXorAssign for I16 {
    pub func bitxor_assign(mut this, rhs: I16) {
        this = this ^ rhs
    }
}

/// `I32 ^= I32`
impl BitXorAssign for I32 {
    pub func bitxor_assign(mut this, rhs: I32) {
        this = this ^ rhs
    }
}

/// `I64 ^= I64`
impl BitXorAssign for I64 {
    pub func bitxor_assign(mut this, rhs: I64) {
        this = this ^ rhs
    }
}

/// `U8 ^= U8`
impl BitXorAssign for U8 {
    pub func bitxor_assign(mut this, rhs: U8) {
        this = this ^ rhs
    }
}

/// `U16 ^= U16`
impl BitXorAssign for U16 {
    pub func bitxor_assign(mut this, rhs: U16) {
        this = this ^ rhs
    }
}

/// `U32 ^= U32`
impl BitXorAssign for U32 {
    pub func bitxor_assign(mut this, rhs: U32) {
        this = this ^ rhs
    }
}

/// `U64 ^= U64`
impl BitXorAssign for U64 {
    pub func bitxor_assign(mut this, rhs: U64) {
        this = this ^ rhs
    }
}

// ============================================================================
// ShlAssign implementations for all integer types
// ============================================================================

/// `I8 <<= I32`
impl ShlAssign for I8 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `I16 <<= I32`
impl ShlAssign for I16 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `I32 <<= I32`
impl ShlAssign for I32 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `I64 <<= I32`
impl ShlAssign for I64 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `U8 <<= I32`
impl ShlAssign for U8 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `U16 <<= I32`
impl ShlAssign for U16 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `U32 <<= I32`
impl ShlAssign for U32 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

/// `U64 <<= I32`
impl ShlAssign for U64 {
    pub func shl_assign(mut this, rhs: I32) {
        this = this << rhs
    }
}

// ============================================================================
// ShrAssign implementations for all integer types
// ============================================================================

/// `I8 >>= I32`
impl ShrAssign for I8 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `I16 >>= I32`
impl ShrAssign for I16 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `I32 >>= I32`
impl ShrAssign for I32 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `I64 >>= I32`
impl ShrAssign for I64 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `U8 >>= I32`
impl ShrAssign for U8 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `U16 >>= I32`
impl ShrAssign for U16 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `U32 >>= I32`
impl ShrAssign for U32 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}

/// `U64 >>= I32`
impl ShrAssign for U64 {
    pub func shr_assign(mut this, rhs: I32) {
        this = this >> rhs
    }
}
