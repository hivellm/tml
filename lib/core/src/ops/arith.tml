//! Arithmetic operator behaviors and implementations.
//!
//! This module defines the behaviors for arithmetic operators (`+`, `-`, `*`,
//! `/`, `%`) and their compound assignment counterparts (`+=`, `-=`, `*=`,
//! `/=`, `%=`), plus the unary negation operator.
//!
//! Each behavior is implemented for all numeric primitive types
//! (I8, I16, I32, I64, U8, U16, U32, U64, F32, F64).
//!
//! # Examples
//!
//! ```tml
//! let a: I32 = 10
//! let b: I32 = 3
//! let sum: I32 = a + b       // uses Add::add -> 13
//! let diff: I32 = a - b      // uses Sub::sub -> 7
//! let prod: I32 = a * b      // uses Mul::mul -> 30
//! let quot: I32 = a / b      // uses Div::div -> 3
//! let rem: I32 = a % b       // uses Rem::rem -> 1
//! let neg: I32 = -a           // uses Neg::neg -> -10
//! ```

// ============================================================================
// Arithmetic Behaviors
// ============================================================================

/// The addition operator `+`.
///
/// Types implementing `Add` can be used with the `+` operator.
/// The output type is determined by the associated `Output` type.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 5 + 3  // 8
/// let y: F64 = 1.5 + 2.5  // 4.0
/// ```
pub behavior Add[Rhs] {
    /// Performs the `+` operation.
    func add(this, rhs: Rhs) -> This::Output
}

/// The subtraction operator `-`.
///
/// Types implementing `Sub` can be used with the `-` operator.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 10 - 3  // 7
/// ```
pub behavior Sub[Rhs] {
    /// Performs the `-` operation.
    func sub(this, rhs: Rhs) -> This::Output
}

/// The multiplication operator `*`.
///
/// Types implementing `Mul` can be used with the `*` operator.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 4 * 5  // 20
/// ```
pub behavior Mul[Rhs] {
    /// Performs the `*` operation.
    func mul(this, rhs: Rhs) -> This::Output
}

/// The division operator `/`.
///
/// Types implementing `Div` can be used with the `/` operator.
/// Integer division truncates toward zero.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 10 / 3  // 3
/// let y: F64 = 10.0 / 3.0  // 3.333...
/// ```
pub behavior Div[Rhs] {
    /// Performs the `/` operation.
    func div(this, rhs: Rhs) -> This::Output
}

/// The remainder operator `%`.
///
/// Types implementing `Rem` can be used with the `%` operator.
/// For integers, the result has the same sign as the dividend.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 10 % 3  // 1
/// let y: I32 = -10 % 3  // -1
/// ```
pub behavior Rem[Rhs] {
    /// Performs the `%` operation.
    func rem(this, rhs: Rhs) -> This::Output
}

/// The unary negation operator `-`.
///
/// Types implementing `Neg` can be used with the unary `-` prefix operator.
/// Only signed types implement this behavior.
///
/// # Examples
///
/// ```tml
/// let x: I32 = 5
/// let y: I32 = -x  // -5
/// ```
pub behavior Neg {
    /// Performs the unary `-` operation.
    func neg(this) -> This::Output
}

// ============================================================================
// Add implementations for all numeric types
// ============================================================================

/// `I8 + I8 -> I8`
impl Add for I8 {
    pub func add(this, rhs: I8) -> I8 {
        return this + rhs
    }
}

/// `I16 + I16 -> I16`
impl Add for I16 {
    pub func add(this, rhs: I16) -> I16 {
        return this + rhs
    }
}

/// `I32 + I32 -> I32`
impl Add for I32 {
    pub func add(this, rhs: I32) -> I32 {
        return this + rhs
    }
}

/// `I64 + I64 -> I64`
impl Add for I64 {
    pub func add(this, rhs: I64) -> I64 {
        return this + rhs
    }
}

/// `U8 + U8 -> U8`
impl Add for U8 {
    pub func add(this, rhs: U8) -> U8 {
        return this + rhs
    }
}

/// `U16 + U16 -> U16`
impl Add for U16 {
    pub func add(this, rhs: U16) -> U16 {
        return this + rhs
    }
}

/// `U32 + U32 -> U32`
impl Add for U32 {
    pub func add(this, rhs: U32) -> U32 {
        return this + rhs
    }
}

/// `U64 + U64 -> U64`
impl Add for U64 {
    pub func add(this, rhs: U64) -> U64 {
        return this + rhs
    }
}

/// `F32 + F32 -> F32`
impl Add for F32 {
    pub func add(this, rhs: F32) -> F32 {
        return this + rhs
    }
}

/// `F64 + F64 -> F64`
impl Add for F64 {
    pub func add(this, rhs: F64) -> F64 {
        return this + rhs
    }
}

// ============================================================================
// Sub implementations for all numeric types
// ============================================================================

/// `I8 - I8 -> I8`
impl Sub for I8 {
    pub func sub(this, rhs: I8) -> I8 {
        return this - rhs
    }
}

/// `I16 - I16 -> I16`
impl Sub for I16 {
    pub func sub(this, rhs: I16) -> I16 {
        return this - rhs
    }
}

/// `I32 - I32 -> I32`
impl Sub for I32 {
    pub func sub(this, rhs: I32) -> I32 {
        return this - rhs
    }
}

/// `I64 - I64 -> I64`
impl Sub for I64 {
    pub func sub(this, rhs: I64) -> I64 {
        return this - rhs
    }
}

/// `U8 - U8 -> U8`
impl Sub for U8 {
    pub func sub(this, rhs: U8) -> U8 {
        return this - rhs
    }
}

/// `U16 - U16 -> U16`
impl Sub for U16 {
    pub func sub(this, rhs: U16) -> U16 {
        return this - rhs
    }
}

/// `U32 - U32 -> U32`
impl Sub for U32 {
    pub func sub(this, rhs: U32) -> U32 {
        return this - rhs
    }
}

/// `U64 - U64 -> U64`
impl Sub for U64 {
    pub func sub(this, rhs: U64) -> U64 {
        return this - rhs
    }
}

/// `F32 - F32 -> F32`
impl Sub for F32 {
    pub func sub(this, rhs: F32) -> F32 {
        return this - rhs
    }
}

/// `F64 - F64 -> F64`
impl Sub for F64 {
    pub func sub(this, rhs: F64) -> F64 {
        return this - rhs
    }
}

// ============================================================================
// Mul implementations for all numeric types
// ============================================================================

/// `I8 * I8 -> I8`
impl Mul for I8 {
    pub func mul(this, rhs: I8) -> I8 {
        return this * rhs
    }
}

/// `I16 * I16 -> I16`
impl Mul for I16 {
    pub func mul(this, rhs: I16) -> I16 {
        return this * rhs
    }
}

/// `I32 * I32 -> I32`
impl Mul for I32 {
    pub func mul(this, rhs: I32) -> I32 {
        return this * rhs
    }
}

/// `I64 * I64 -> I64`
impl Mul for I64 {
    pub func mul(this, rhs: I64) -> I64 {
        return this * rhs
    }
}

/// `U8 * U8 -> U8`
impl Mul for U8 {
    pub func mul(this, rhs: U8) -> U8 {
        return this * rhs
    }
}

/// `U16 * U16 -> U16`
impl Mul for U16 {
    pub func mul(this, rhs: U16) -> U16 {
        return this * rhs
    }
}

/// `U32 * U32 -> U32`
impl Mul for U32 {
    pub func mul(this, rhs: U32) -> U32 {
        return this * rhs
    }
}

/// `U64 * U64 -> U64`
impl Mul for U64 {
    pub func mul(this, rhs: U64) -> U64 {
        return this * rhs
    }
}

/// `F32 * F32 -> F32`
impl Mul for F32 {
    pub func mul(this, rhs: F32) -> F32 {
        return this * rhs
    }
}

/// `F64 * F64 -> F64`
impl Mul for F64 {
    pub func mul(this, rhs: F64) -> F64 {
        return this * rhs
    }
}

// ============================================================================
// Div implementations for all numeric types
// ============================================================================

/// `I8 / I8 -> I8` (truncating division)
impl Div for I8 {
    pub func div(this, rhs: I8) -> I8 {
        return this / rhs
    }
}

/// `I16 / I16 -> I16` (truncating division)
impl Div for I16 {
    pub func div(this, rhs: I16) -> I16 {
        return this / rhs
    }
}

/// `I32 / I32 -> I32` (truncating division)
impl Div for I32 {
    pub func div(this, rhs: I32) -> I32 {
        return this / rhs
    }
}

/// `I64 / I64 -> I64` (truncating division)
impl Div for I64 {
    pub func div(this, rhs: I64) -> I64 {
        return this / rhs
    }
}

/// `U8 / U8 -> U8`
impl Div for U8 {
    pub func div(this, rhs: U8) -> U8 {
        return this / rhs
    }
}

/// `U16 / U16 -> U16`
impl Div for U16 {
    pub func div(this, rhs: U16) -> U16 {
        return this / rhs
    }
}

/// `U32 / U32 -> U32`
impl Div for U32 {
    pub func div(this, rhs: U32) -> U32 {
        return this / rhs
    }
}

/// `U64 / U64 -> U64`
impl Div for U64 {
    pub func div(this, rhs: U64) -> U64 {
        return this / rhs
    }
}

/// `F32 / F32 -> F32`
impl Div for F32 {
    pub func div(this, rhs: F32) -> F32 {
        return this / rhs
    }
}

/// `F64 / F64 -> F64`
impl Div for F64 {
    pub func div(this, rhs: F64) -> F64 {
        return this / rhs
    }
}

// ============================================================================
// Rem implementations for integer types
// ============================================================================

/// `I8 % I8 -> I8`
impl Rem for I8 {
    pub func rem(this, rhs: I8) -> I8 {
        return this % rhs
    }
}

/// `I16 % I16 -> I16`
impl Rem for I16 {
    pub func rem(this, rhs: I16) -> I16 {
        return this % rhs
    }
}

/// `I32 % I32 -> I32`
impl Rem for I32 {
    pub func rem(this, rhs: I32) -> I32 {
        return this % rhs
    }
}

/// `I64 % I64 -> I64`
impl Rem for I64 {
    pub func rem(this, rhs: I64) -> I64 {
        return this % rhs
    }
}

/// `U8 % U8 -> U8`
impl Rem for U8 {
    pub func rem(this, rhs: U8) -> U8 {
        return this % rhs
    }
}

/// `U16 % U16 -> U16`
impl Rem for U16 {
    pub func rem(this, rhs: U16) -> U16 {
        return this % rhs
    }
}

/// `U32 % U32 -> U32`
impl Rem for U32 {
    pub func rem(this, rhs: U32) -> U32 {
        return this % rhs
    }
}

/// `U64 % U64 -> U64`
impl Rem for U64 {
    pub func rem(this, rhs: U64) -> U64 {
        return this % rhs
    }
}

// ============================================================================
// Neg implementations for signed types
// ============================================================================

/// `-I8 -> I8`
impl Neg for I8 {
    pub func neg(this) -> I8 {
        return 0 as I8 - this
    }
}

/// `-I16 -> I16`
impl Neg for I16 {
    pub func neg(this) -> I16 {
        return 0 as I16 - this
    }
}

/// `-I32 -> I32`
impl Neg for I32 {
    pub func neg(this) -> I32 {
        return 0 - this
    }
}

/// `-I64 -> I64`
impl Neg for I64 {
    pub func neg(this) -> I64 {
        return 0 - this
    }
}

/// `-F32 -> F32`
impl Neg for F32 {
    pub func neg(this) -> F32 {
        return 0.0 as F32 - this
    }
}

/// `-F64 -> F64`
impl Neg for F64 {
    pub func neg(this) -> F64 {
        return 0.0 - this
    }
}

// ============================================================================
// Compound Assignment Behaviors
// ============================================================================

/// The addition assignment operator `+=`.
///
/// # Examples
///
/// ```tml
/// var x: I32 = 5
/// x += 3  // x is now 8
/// ```
pub behavior AddAssign[Rhs] {
    /// Performs the `+=` operation.
    func add_assign(mut this, rhs: Rhs)
}

/// The subtraction assignment operator `-=`.
///
/// # Examples
///
/// ```tml
/// var x: I32 = 10
/// x -= 3  // x is now 7
/// ```
pub behavior SubAssign[Rhs] {
    /// Performs the `-=` operation.
    func sub_assign(mut this, rhs: Rhs)
}

/// The multiplication assignment operator `*=`.
///
/// # Examples
///
/// ```tml
/// var x: I32 = 4
/// x *= 3  // x is now 12
/// ```
pub behavior MulAssign[Rhs] {
    /// Performs the `*=` operation.
    func mul_assign(mut this, rhs: Rhs)
}

/// The division assignment operator `/=`.
///
/// # Examples
///
/// ```tml
/// var x: I32 = 12
/// x /= 4  // x is now 3
/// ```
pub behavior DivAssign[Rhs] {
    /// Performs the `/=` operation.
    func div_assign(mut this, rhs: Rhs)
}

/// The remainder assignment operator `%=`.
///
/// # Examples
///
/// ```tml
/// var x: I32 = 10
/// x %= 3  // x is now 1
/// ```
pub behavior RemAssign[Rhs] {
    /// Performs the `%=` operation.
    func rem_assign(mut this, rhs: Rhs)
}

// ============================================================================
// AddAssign implementations for all numeric types
// ============================================================================

/// `I8 += I8`
impl AddAssign for I8 {
    pub func add_assign(mut this, rhs: I8) {
        this = this + rhs
    }
}

/// `I16 += I16`
impl AddAssign for I16 {
    pub func add_assign(mut this, rhs: I16) {
        this = this + rhs
    }
}

/// `I32 += I32`
impl AddAssign for I32 {
    pub func add_assign(mut this, rhs: I32) {
        this = this + rhs
    }
}

/// `I64 += I64`
impl AddAssign for I64 {
    pub func add_assign(mut this, rhs: I64) {
        this = this + rhs
    }
}

/// `U8 += U8`
impl AddAssign for U8 {
    pub func add_assign(mut this, rhs: U8) {
        this = this + rhs
    }
}

/// `U16 += U16`
impl AddAssign for U16 {
    pub func add_assign(mut this, rhs: U16) {
        this = this + rhs
    }
}

/// `U32 += U32`
impl AddAssign for U32 {
    pub func add_assign(mut this, rhs: U32) {
        this = this + rhs
    }
}

/// `U64 += U64`
impl AddAssign for U64 {
    pub func add_assign(mut this, rhs: U64) {
        this = this + rhs
    }
}

/// `F32 += F32`
impl AddAssign for F32 {
    pub func add_assign(mut this, rhs: F32) {
        this = this + rhs
    }
}

/// `F64 += F64`
impl AddAssign for F64 {
    pub func add_assign(mut this, rhs: F64) {
        this = this + rhs
    }
}

// ============================================================================
// SubAssign implementations for all numeric types
// ============================================================================

/// `I8 -= I8`
impl SubAssign for I8 {
    pub func sub_assign(mut this, rhs: I8) {
        this = this - rhs
    }
}

/// `I16 -= I16`
impl SubAssign for I16 {
    pub func sub_assign(mut this, rhs: I16) {
        this = this - rhs
    }
}

/// `I32 -= I32`
impl SubAssign for I32 {
    pub func sub_assign(mut this, rhs: I32) {
        this = this - rhs
    }
}

/// `I64 -= I64`
impl SubAssign for I64 {
    pub func sub_assign(mut this, rhs: I64) {
        this = this - rhs
    }
}

/// `U8 -= U8`
impl SubAssign for U8 {
    pub func sub_assign(mut this, rhs: U8) {
        this = this - rhs
    }
}

/// `U16 -= U16`
impl SubAssign for U16 {
    pub func sub_assign(mut this, rhs: U16) {
        this = this - rhs
    }
}

/// `U32 -= U32`
impl SubAssign for U32 {
    pub func sub_assign(mut this, rhs: U32) {
        this = this - rhs
    }
}

/// `U64 -= U64`
impl SubAssign for U64 {
    pub func sub_assign(mut this, rhs: U64) {
        this = this - rhs
    }
}

/// `F32 -= F32`
impl SubAssign for F32 {
    pub func sub_assign(mut this, rhs: F32) {
        this = this - rhs
    }
}

/// `F64 -= F64`
impl SubAssign for F64 {
    pub func sub_assign(mut this, rhs: F64) {
        this = this - rhs
    }
}

// ============================================================================
// MulAssign implementations for all numeric types
// ============================================================================

/// `I8 *= I8`
impl MulAssign for I8 {
    pub func mul_assign(mut this, rhs: I8) {
        this = this * rhs
    }
}

/// `I16 *= I16`
impl MulAssign for I16 {
    pub func mul_assign(mut this, rhs: I16) {
        this = this * rhs
    }
}

/// `I32 *= I32`
impl MulAssign for I32 {
    pub func mul_assign(mut this, rhs: I32) {
        this = this * rhs
    }
}

/// `I64 *= I64`
impl MulAssign for I64 {
    pub func mul_assign(mut this, rhs: I64) {
        this = this * rhs
    }
}

/// `U8 *= U8`
impl MulAssign for U8 {
    pub func mul_assign(mut this, rhs: U8) {
        this = this * rhs
    }
}

/// `U16 *= U16`
impl MulAssign for U16 {
    pub func mul_assign(mut this, rhs: U16) {
        this = this * rhs
    }
}

/// `U32 *= U32`
impl MulAssign for U32 {
    pub func mul_assign(mut this, rhs: U32) {
        this = this * rhs
    }
}

/// `U64 *= U64`
impl MulAssign for U64 {
    pub func mul_assign(mut this, rhs: U64) {
        this = this * rhs
    }
}

/// `F32 *= F32`
impl MulAssign for F32 {
    pub func mul_assign(mut this, rhs: F32) {
        this = this * rhs
    }
}

/// `F64 *= F64`
impl MulAssign for F64 {
    pub func mul_assign(mut this, rhs: F64) {
        this = this * rhs
    }
}

// ============================================================================
// DivAssign implementations for all numeric types
// ============================================================================

/// `I8 /= I8`
impl DivAssign for I8 {
    pub func div_assign(mut this, rhs: I8) {
        this = this / rhs
    }
}

/// `I16 /= I16`
impl DivAssign for I16 {
    pub func div_assign(mut this, rhs: I16) {
        this = this / rhs
    }
}

/// `I32 /= I32`
impl DivAssign for I32 {
    pub func div_assign(mut this, rhs: I32) {
        this = this / rhs
    }
}

/// `I64 /= I64`
impl DivAssign for I64 {
    pub func div_assign(mut this, rhs: I64) {
        this = this / rhs
    }
}

/// `U8 /= U8`
impl DivAssign for U8 {
    pub func div_assign(mut this, rhs: U8) {
        this = this / rhs
    }
}

/// `U16 /= U16`
impl DivAssign for U16 {
    pub func div_assign(mut this, rhs: U16) {
        this = this / rhs
    }
}

/// `U32 /= U32`
impl DivAssign for U32 {
    pub func div_assign(mut this, rhs: U32) {
        this = this / rhs
    }
}

/// `U64 /= U64`
impl DivAssign for U64 {
    pub func div_assign(mut this, rhs: U64) {
        this = this / rhs
    }
}

/// `F32 /= F32`
impl DivAssign for F32 {
    pub func div_assign(mut this, rhs: F32) {
        this = this / rhs
    }
}

/// `F64 /= F64`
impl DivAssign for F64 {
    pub func div_assign(mut this, rhs: F64) {
        this = this / rhs
    }
}

// ============================================================================
// RemAssign implementations for integer types
// ============================================================================

/// `I8 %= I8`
impl RemAssign for I8 {
    pub func rem_assign(mut this, rhs: I8) {
        this = this % rhs
    }
}

/// `I16 %= I16`
impl RemAssign for I16 {
    pub func rem_assign(mut this, rhs: I16) {
        this = this % rhs
    }
}

/// `I32 %= I32`
impl RemAssign for I32 {
    pub func rem_assign(mut this, rhs: I32) {
        this = this % rhs
    }
}

/// `I64 %= I64`
impl RemAssign for I64 {
    pub func rem_assign(mut this, rhs: I64) {
        this = this % rhs
    }
}

/// `U8 %= U8`
impl RemAssign for U8 {
    pub func rem_assign(mut this, rhs: U8) {
        this = this % rhs
    }
}

/// `U16 %= U16`
impl RemAssign for U16 {
    pub func rem_assign(mut this, rhs: U16) {
        this = this % rhs
    }
}

/// `U32 %= U32`
impl RemAssign for U32 {
    pub func rem_assign(mut this, rhs: U32) {
        this = this % rhs
    }
}

/// `U64 %= U64`
impl RemAssign for U64 {
    pub func rem_assign(mut this, rhs: U64) {
        this = this % rhs
    }
}
