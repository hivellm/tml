//! Hashing support for types.
//!
//! This module provides the [`Hash`] behavior for computing hash values,
//! which is essential for using types as keys in hash-based collections
//! like `HashMap` and `HashSet`.
//!
//! # The Hash Contract
//!
//! Types that implement both `Hash` and [`Eq`] must satisfy:
//!
//! ```text
//! k1 == k2 implies hash(k1) == hash(k2)
//! ```
//!
//! In other words, if two values are equal, they must have the same hash.
//! The converse is not required: different values may have the same hash
//! (this is called a "collision").
//!
//! # Implementing Hash
//!
//! For most types, you should hash all fields that participate in equality:
//!
//! ```tml
//! use core::hash::{Hash, combine_hashes}
//!
//! pub type Point {
//!     x: I64,
//!     y: I64
//! }
//!
//! impl Hash for Point {
//!     pub func hash(this) -> I64 {
//!         return combine_hashes(this.x.hash(), this.y.hash())
//!     }
//! }
//! ```
//!
//! # Using Hash
//!
//! The primary use of `Hash` is with hash-based collections:
//!
//! ```tml
//! use std::collections::HashMap
//!
//! let mut map: HashMap[Str, I64] = HashMap::new()
//! map.insert("one", 1)
//! map.insert("two", 2)
//!
//! // Str implements Hash, so it can be used as a key
//! let value = map.get("one")  // Just(1)
//! ```
//!
//! # Hash Quality
//!
//! A good hash function distributes values uniformly across the output space.
//! For most uses, the provided [`combine_hashes`] function is sufficient.

// ============================================================================
// Hash Behavior
// ============================================================================

/// A behavior for computing hash values.
///
/// Types implementing `Hash` can be used as keys in hash-based collections
/// like `HashMap` and `HashSet`.
///
/// # Contract
///
/// If your type implements both `Hash` and [`Eq`], you must ensure:
///
/// - `k1 == k2` implies `k1.hash() == k2.hash()`
///
/// Violating this contract will cause hash-based collections to malfunction.
///
/// # Examples
///
/// ```tml
/// use core::hash::Hash
///
/// let x: I64 = 42
/// let h: I64 = x.hash()
/// ```
pub behavior Hash {
    /// Computes a hash value for this value.
    ///
    /// The returned value should be deterministic: calling `hash()` multiple
    /// times on the same value must return the same result.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = "hello"
    /// let b = "hello"
    /// assert(a.hash() == b.hash())  // Equal values, equal hashes
    /// ```
    func hash(this) -> I64
}

// ============================================================================
// Hash implementations for primitives
// ============================================================================

/// `Hash` for `I8` - extends to `I64` for the hash value.
impl Hash for I8 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `I16` - extends to `I64` for the hash value.
impl Hash for I16 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `I32` - extends to `I64` for the hash value.
impl Hash for I32 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `I64` - the value is its own hash.
impl Hash for I64 {
    pub func hash(this) -> I64 {
        return this
    }
}

/// `Hash` for `U8` - extends to `I64` for the hash value.
impl Hash for U8 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `U16` - extends to `I64` for the hash value.
impl Hash for U16 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `U32` - extends to `I64` for the hash value.
impl Hash for U32 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `U64` - converts to `I64` for the hash value.
impl Hash for U64 {
    pub func hash(this) -> I64 {
        return this as I64
    }
}

/// `Hash` for `Bool` - `true` hashes to `1`, `false` to `0`.
impl Hash for Bool {
    pub func hash(this) -> I64 {
        if this {
            return 1
        }
        return 0
    }
}

/// `Hash` for `Str` - computes a hash of the string contents using FNV-1a.
///
/// Equal strings always produce equal hashes.
impl Hash for Str {
    pub func hash(this) -> I64 {
        // FNV-1a hash over string bytes (pure TML, no C runtime)
        let addr: I64 = this as I64
        if addr == 0 {
            return 0
        }
        var state: U64 = FNV_OFFSET_BASIS
        var i: I64 = 0
        loop (true) {
            let p: *U8 = (addr + i) as *U8
            let byte: U8 = lowlevel { ptr_read[U8](p) }
            if byte == (0 as U8) {
                return state as I64
            }
            state = state ^ (byte as U64)
            state = state.wrapping_mul(FNV_PRIME)
            i = i + 1
        }
        return state as I64
    }
}

// ============================================================================
// Hash for Maybe[T]
// ============================================================================

/// `Hash` for `Maybe[T]` where `T: Hash`.
///
/// - `Nothing` hashes to `0`
/// - `Just(v)` combines `v.hash()` with a discriminant to avoid collisions
impl[T: Hash] Hash for Maybe[T] {
    pub func hash(this) -> I64 {
        when this {
            Just(val) => {
                // Combine discriminant (1) with value hash
                let h: I64 = val.hash()
                return h * 31 + 1
            },
            Nothing => {
                // Use 0 for Nothing
                return 0
            },
        }
    }
}

// ============================================================================
// Hash for Outcome[T, E]
// ============================================================================

/// `Hash` for `Outcome[T, E]` where both `T` and `E` implement `Hash`.
///
/// - `Ok(v)` combines `v.hash()` with discriminant 1
/// - `Err(e)` combines `e.hash()` with discriminant 2
impl[T: Hash, E: Hash] Hash for Outcome[T, E] {
    pub func hash(this) -> I64 {
        when this {
            Ok(val) => {
                // Combine discriminant (1) with value hash
                let h: I64 = val.hash()
                return h * 31 + 1
            },
            Err(e) => {
                // Combine discriminant (2) with error hash
                let h: I64 = e.hash()
                return h * 31 + 2
            },
        }
    }
}

// ============================================================================
// Hasher Interface (for advanced hashing)
// ============================================================================

/// A stateful hasher that can be fed data incrementally.
///
/// This behavior is useful for hashing composite types or when you need
/// more control over the hashing process. Unlike [`Hash::hash`] which
/// returns a final hash value directly, `Hasher` allows you to feed
/// data piece by piece.
///
/// # Examples
///
/// ```tml
/// impl Hash for MyStruct {
///     pub func hash(this) -> I64 {
///         let mut hasher = DefaultHasher::new()
///         hasher.write_i64(this.field1)
///         hasher.write_i64(this.field2)
///         return hasher.finish()
///     }
/// }
/// ```
pub behavior Hasher {
    /// Writes a slice of bytes into this hasher.
    func write(mut this, bytes: ref [U8])

    /// Writes a single byte into this hasher.
    func write_u8(mut this, value: U8)

    /// Writes an `I32` into this hasher.
    func write_i32(mut this, value: I32)

    /// Writes an `I64` into this hasher.
    func write_i64(mut this, value: I64)

    /// Returns the hash value computed from all data written so far.
    ///
    /// This method does not reset the hasher's state. Calling `finish`
    /// multiple times without writing more data will return the same value.
    func finish(this) -> I64
}

// ============================================================================
// Helper functions
// ============================================================================

/// Combines two hash values into a single hash.
///
/// This is useful when implementing `Hash` for composite types. It ensures
/// that the order of fields matters: `combine_hashes(a, b) != combine_hashes(b, a)`.
///
/// # Examples
///
/// ```tml
/// use core::hash::{Hash, combine_hashes}
///
/// impl Hash for Point {
///     pub func hash(this) -> I64 {
///         return combine_hashes(this.x.hash(), this.y.hash())
///     }
/// }
/// ```
///
/// # Algorithm
///
/// Uses the formula `h1 * 31 + h2`, similar to Java's hash combination
/// and boost::hash_combine.
pub func combine_hashes(h1: I64, h2: I64) -> I64 {
    // Use a simple combination formula similar to boost::hash_combine
    return h1 * 31 + h2
}

// ============================================================================
// BuildHasher Behavior
// ============================================================================

/// A behavior for creating `Hasher` instances.
///
/// Types implementing `BuildHasher` can produce new `Hasher` instances on
/// demand. This is used by `HashMap` and `HashSet` to allow customizable
/// hashing strategies.
///
/// # Examples
///
/// ```tml
/// use core::hash::{BuildHasher, RandomState}
///
/// let build_hasher = RandomState::new()
/// let hasher1 = build_hasher.build_hasher()
/// let hasher2 = build_hasher.build_hasher()
/// // hasher1 and hasher2 will produce the same hashes for the same inputs
/// ```
///
/// # Usage with HashMap
///
/// ```tml
/// use std::collections::HashMap
/// use core::hash::RandomState
///
/// // HashMap uses RandomState by default
/// let map: HashMap[Str, I64] = HashMap::new()
///
/// // Or use a custom hasher
/// let map: HashMap[Str, I64, MyHasher] = HashMap::with_hasher(MyHasher::new())
/// ```
pub behavior BuildHasher {
    /// The type of hasher this builder creates.
    type Hasher: Hasher

    /// Creates a new hasher.
    ///
    /// Each call may return a new hasher instance, but all hashers created
    /// by the same `BuildHasher` must produce identical hash values for
    /// identical input sequences.
    func build_hasher(this) -> This::Hasher
}

// ============================================================================
// DefaultHasher Type
// ============================================================================

/// A simple hasher implementation using FNV-1a algorithm.
///
/// `DefaultHasher` provides a fast, general-purpose hash function. It's not
/// cryptographically secure, but suitable for hash tables.
///
/// # Examples
///
/// ```tml
/// use core::hash::DefaultHasher
///
/// let mut hasher = DefaultHasher::new()
/// hasher.write_i64(42)
/// hasher.write_i64(100)
/// let hash = hasher.finish()
/// ```
///
/// # Algorithm
///
/// Uses a variant of FNV-1a (Fowler-Noll-Vo) hashing, which is fast and
/// has good distribution properties.
pub type DefaultHasher {
    state: U64
}

// FNV-1a constants
const FNV_OFFSET_BASIS: U64 = 14695981039346656037 as U64
const FNV_PRIME: U64 = 1099511628211 as U64

impl DefaultHasher {
    /// Creates a new `DefaultHasher` with default state.
    pub func new() -> DefaultHasher {
        return DefaultHasher { state: FNV_OFFSET_BASIS }
    }

    /// Creates a new `DefaultHasher` with the given seed.
    ///
    /// Different seeds produce different hash sequences.
    pub func with_seed(seed: U64) -> DefaultHasher {
        return DefaultHasher { state: FNV_OFFSET_BASIS ^ seed }
    }
}

impl Hasher for DefaultHasher {
    pub func write(mut this, bytes: ref [U8]) {
        var i: I64 = 0
        let len: I64 = bytes.len()
        loop (i < len) {
            this.state = this.state ^ (bytes[i] as U64)
            this.state = this.state.wrapping_mul(FNV_PRIME)
            i = i + 1
        }
    }

    pub func write_u8(mut this, value: U8) {
        this.state = this.state ^ (value as U64)
        this.state = this.state.wrapping_mul(FNV_PRIME)
    }

    pub func write_i32(mut this, value: I32) {
        // Write each byte of the I32
        let v: U32 = value as U32
        this.write_u8((v & 0xFF) as U8)
        this.write_u8(((v >> 8) & 0xFF) as U8)
        this.write_u8(((v >> 16) & 0xFF) as U8)
        this.write_u8(((v >> 24) & 0xFF) as U8)
    }

    pub func write_i64(mut this, value: I64) {
        // Write each byte of the I64
        let v: U64 = value as U64
        this.write_u8((v & 0xFF) as U8)
        this.write_u8(((v >> 8) & 0xFF) as U8)
        this.write_u8(((v >> 16) & 0xFF) as U8)
        this.write_u8(((v >> 24) & 0xFF) as U8)
        this.write_u8(((v >> 32) & 0xFF) as U8)
        this.write_u8(((v >> 40) & 0xFF) as U8)
        this.write_u8(((v >> 48) & 0xFF) as U8)
        this.write_u8(((v >> 56) & 0xFF) as U8)
    }

    pub func finish(this) -> I64 {
        return this.state as I64
    }
}

impl Default for DefaultHasher {
    pub func default() -> DefaultHasher {
        return DefaultHasher { state: FNV_OFFSET_BASIS }
    }
}

impl Duplicate for DefaultHasher {
    pub func duplicate(this) -> DefaultHasher {
        return DefaultHasher { state: this.state }
    }
}

// ============================================================================
// RandomState Type
// ============================================================================

/// A hasher builder that produces hashers with random seeds.
///
/// `RandomState` is the default hasher builder for `HashMap` and `HashSet`.
/// It provides some protection against HashDoS attacks by using random
/// keys to seed the hasher.
///
/// # Examples
///
/// ```tml
/// use core::hash::RandomState
///
/// let state = RandomState::new()
/// let hasher = state.build_hasher()
/// ```
///
/// # Thread Safety
///
/// Each `RandomState` instance is initialized with random keys. Different
/// instances will produce different hash values for the same input.
pub type RandomState {
    k0: U64,
    k1: U64
}

impl RandomState {
    /// Creates a new `RandomState` with random keys.
    ///
    /// The randomness is derived from a runtime counter that provides
    /// unique values across multiple calls.
    pub func new() -> RandomState {
        // Get unique seeds from the runtime using the global counter
        let seed: U64 = lowlevel { tml_random_seed() }
        let seed2: U64 = lowlevel { tml_random_seed() }
        return RandomState {
            k0: seed,
            k1: seed2
        }
    }

    /// Creates a new `RandomState` with the given keys.
    ///
    /// This is useful for reproducible hashing in tests.
    pub func with_keys(k0: U64, k1: U64) -> RandomState {
        return RandomState { k0: k0, k1: k1 }
    }
}

impl BuildHasher for RandomState {
    type Hasher = DefaultHasher

    pub func build_hasher(this) -> DefaultHasher {
        return DefaultHasher::with_seed(this.k0 ^ this.k1)
    }
}

impl Default for RandomState {
    pub func default() -> RandomState {
        return RandomState::new()
    }
}

impl Duplicate for RandomState {
    pub func duplicate(this) -> RandomState {
        return RandomState { k0: this.k0, k1: this.k1 }
    }
}

// ============================================================================
// Imports
// ============================================================================

use core::default::Default
use core::clone::Duplicate
