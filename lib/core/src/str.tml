//! String manipulation utilities.
//!
//! This module provides functions for working with strings. All functions
//! operate on TML's `Str` type, which is a UTF-8 encoded string.
//!
//! # Categories
//!
//! ## Length and Emptiness
//! - [`len`] - Get string length in bytes
//! - [`is_empty`] - Check if string is empty
//!
//! ## Character Access
//! - [`char_at`] - Get character at byte index
//! - [`first_char`] / [`last_char`] - Get first/last character
//!
//! ## Substrings
//! - [`substring`] - Extract a portion of the string
//! - [`substring_from`] / [`substring_to`] - Partial extraction
//!
//! ## Trimming
//! - [`trim`] - Remove leading and trailing whitespace
//! - [`trim_start`] / [`trim_end`] - Trim one side
//!
//! ## Case Conversion
//! - [`to_uppercase`] / [`to_lowercase`] - Convert case
//!
//! ## Searching
//! - [`contains`] - Check if substring exists
//! - [`starts_with`] / [`ends_with`] - Check prefix/suffix
//! - [`find`] / [`rfind`] - Find substring position
//!
//! ## Splitting
//! - [`split`] - Split by delimiter
//! - [`split_whitespace`] - Split by whitespace
//! - [`lines`] - Split into lines
//!
//! ## Replacement
//! - [`replace`] - Replace all occurrences
//! - [`replace_first`] - Replace first occurrence
//!
//! ## Building
//! - [`repeat`] - Repeat string N times
//! - [`pad_left`] / [`pad_right`] - Add padding
//! - [`join`] - Join strings with separator
//! - [`concat`] / [`concat_all`] - Concatenate strings
//!
//! ## Parsing
//! - [`parse_i32`] / [`parse_i64`] / [`parse_f64`] - Parse numbers
//! - [`parse_bool`] - Parse boolean
//!
//! # Examples
//!
//! ```tml
//! use core::str::*
//!
//! let s = "  Hello, World!  "
//!
//! // Trimming
//! assert(trim(s) == "Hello, World!")
//!
//! // Searching
//! assert(contains(s, "World"))
//! assert(find(s, "World") == Just(9))
//!
//! // Splitting
//! let words = split(trim(s), ", ")
//! assert(words.len() == 2)
//!
//! // Case conversion
//! assert(to_uppercase("hello") == "HELLO")
//! ```

// ============================================================================
// String Length and Emptiness
// ============================================================================

/// Returns the length of a string in bytes.
///
/// Note: This returns the byte length, not the character count. For UTF-8
/// strings with multi-byte characters, this may differ from the visible
/// character count.
///
/// # Examples
///
/// ```tml
/// assert(len("hello") == 5)
/// assert(len("") == 0)
/// ```
pub func len(s: Str) -> I64 {
    return lowlevel { str_len(s) }
}

/// Returns `true` if the string is empty.
///
/// # Examples
///
/// ```tml
/// assert(is_empty("") == true)
/// assert(is_empty("hello") == false)
/// ```
pub func is_empty(s: Str) -> Bool {
    return len(s) == 0
}

// ============================================================================
// Character Access
// ============================================================================

/// Returns the character at the given byte index.
///
/// # Panics
///
/// Panics if the index is out of bounds.
///
/// # Examples
///
/// ```tml
/// assert(char_at("hello", 0) == 'h')
/// assert(char_at("hello", 4) == 'o')
/// ```
pub func char_at(s: Str, index: I64) -> I32 {
    let idx32: I32 = index as I32
    return lowlevel { str_char_at(s, idx32) }
}

/// Returns the first character of the string, or `Nothing` if empty.
///
/// # Examples
///
/// ```tml
/// assert(first_char("hello") == Just('h'))
/// assert(first_char("") == Nothing)
/// ```
pub func first_char(s: Str) -> Maybe[I32] {
    if is_empty(s) {
        return Nothing
    }
    return Just(char_at(s, 0))
}

/// Returns the last character of the string, or `Nothing` if empty.
///
/// # Examples
///
/// ```tml
/// assert(last_char("hello") == Just('o'))
/// assert(last_char("") == Nothing)
/// ```
pub func last_char(s: Str) -> Maybe[I32] {
    let length: I64 = len(s)
    if length == 0 {
        return Nothing
    }
    return Just(char_at(s, length - 1))
}

// ============================================================================
// Substring Operations
// ============================================================================

/// Returns a substring from `start` to `end` (exclusive).
///
/// # Arguments
///
/// * `s` - The source string
/// * `start` - Starting byte index (inclusive)
/// * `end` - Ending byte index (exclusive)
///
/// # Examples
///
/// ```tml
/// assert(substring("hello", 1, 4) == "ell")
/// assert(substring("hello", 0, 5) == "hello")
/// ```
pub func substring(s: Str, start: I64, end: I64) -> Str {
    let start32: I32 = start as I32
    let end32: I32 = end as I32
    return lowlevel { str_substring(s, start32, end32) }
}

/// Returns a substring from `start` to the end of the string.
///
/// # Examples
///
/// ```tml
/// assert(substring_from("hello", 2) == "llo")
/// ```
pub func substring_from(s: Str, start: I64) -> Str {
    return substring(s, start, len(s))
}

/// Returns a substring from the beginning to `end` (exclusive).
///
/// # Examples
///
/// ```tml
/// assert(substring_to("hello", 3) == "hel")
/// ```
pub func substring_to(s: Str, end: I64) -> Str {
    return substring(s, 0, end)
}

// ============================================================================
// Trimming
// ============================================================================

/// Removes leading and trailing whitespace from a string.
///
/// # Examples
///
/// ```tml
/// assert(trim("  hello  ") == "hello")
/// assert(trim("\n\thello\t\n") == "hello")
/// ```
pub func trim(s: Str) -> Str {
    return lowlevel { str_trim(s) }
}

/// Removes leading whitespace from a string.
///
/// # Examples
///
/// ```tml
/// assert(trim_start("  hello  ") == "hello  ")
/// ```
pub func trim_start(s: Str) -> Str {
    return lowlevel { str_trim_start(s) }
}

/// Removes trailing whitespace from a string.
///
/// # Examples
///
/// ```tml
/// assert(trim_end("  hello  ") == "  hello")
/// ```
pub func trim_end(s: Str) -> Str {
    return lowlevel { str_trim_end(s) }
}

// ============================================================================
// Case Conversion
// ============================================================================

/// Converts all characters to uppercase.
///
/// # Examples
///
/// ```tml
/// assert(to_uppercase("hello") == "HELLO")
/// assert(to_uppercase("Hello World") == "HELLO WORLD")
/// ```
pub func to_uppercase(s: Str) -> Str {
    return lowlevel { str_to_uppercase(s) }
}

/// Converts all characters to lowercase.
///
/// # Examples
///
/// ```tml
/// assert(to_lowercase("HELLO") == "hello")
/// assert(to_lowercase("Hello World") == "hello world")
/// ```
pub func to_lowercase(s: Str) -> Str {
    return lowlevel { str_to_lowercase(s) }
}

// ============================================================================
// Search Operations
// ============================================================================

/// Returns `true` if the string contains the given substring.
///
/// # Examples
///
/// ```tml
/// assert(contains("hello world", "world") == true)
/// assert(contains("hello", "xyz") == false)
/// ```
pub func contains(s: Str, pattern: Str) -> Bool {
    return lowlevel { str_contains(s, pattern) }
}

/// Returns `true` if the string starts with the given prefix.
///
/// # Examples
///
/// ```tml
/// assert(starts_with("hello", "hel") == true)
/// assert(starts_with("hello", "lo") == false)
/// ```
pub func starts_with(s: Str, prefix: Str) -> Bool {
    return lowlevel { str_starts_with(s, prefix) }
}

/// Returns `true` if the string ends with the given suffix.
///
/// # Examples
///
/// ```tml
/// assert(ends_with("hello", "lo") == true)
/// assert(ends_with("hello", "hel") == false)
/// ```
pub func ends_with(s: Str, suffix: Str) -> Bool {
    return lowlevel { str_ends_with(s, suffix) }
}

/// Returns the byte index of the first occurrence of the pattern.
///
/// Returns `Nothing` if the pattern is not found.
///
/// # Examples
///
/// ```tml
/// assert(find("hello", "ll") == Just(2))
/// assert(find("hello", "xyz") == Nothing)
/// ```
pub func find(s: Str, pattern: Str) -> Maybe[I64] {
    let idx: I64 = lowlevel { str_find(s, pattern) }
    if idx < 0 {
        return Nothing
    }
    return Just(idx)
}

/// Returns the byte index of the last occurrence of the pattern.
///
/// Returns `Nothing` if the pattern is not found.
///
/// # Examples
///
/// ```tml
/// assert(rfind("hello hello", "hello") == Just(6))
/// assert(rfind("hello", "xyz") == Nothing)
/// ```
pub func rfind(s: Str, pattern: Str) -> Maybe[I64] {
    let idx: I64 = lowlevel { str_rfind(s, pattern) }
    if idx < 0 {
        return Nothing
    }
    return Just(idx)
}

// ============================================================================
// Splitting
// ============================================================================

/// Splits a string by the given delimiter.
///
/// Returns a list of substrings. Empty strings are included if there are
/// consecutive delimiters.
///
/// # Examples
///
/// ```tml
/// let parts = split("a,b,c", ",")
/// assert(parts.len() == 3)
/// assert(parts[0] == "a")
///
/// let parts2 = split("a::b", "::")
/// assert(parts2.len() == 2)
/// ```
pub func split(s: Str, delimiter: Str) -> List[Str] {
    return lowlevel { str_split(s, delimiter) }
}

/// Splits a string by whitespace.
///
/// Multiple consecutive whitespace characters are treated as a single
/// delimiter. Leading and trailing whitespace is ignored.
///
/// # Examples
///
/// ```tml
/// let words = split_whitespace("  hello   world  ")
/// assert(words.len() == 2)
/// assert(words[0] == "hello")
/// assert(words[1] == "world")
/// ```
pub func split_whitespace(s: Str) -> List[Str] {
    return lowlevel { str_split_whitespace(s) }
}

/// Splits a string into lines.
///
/// Handles both `\n` and `\r\n` line endings.
///
/// # Examples
///
/// ```tml
/// let lns = lines("line1\nline2\nline3")
/// assert(lns.len() == 3)
/// ```
pub func lines(s: Str) -> List[Str] {
    return lowlevel { str_lines(s) }
}

// ============================================================================
// Replacement
// ============================================================================

/// Replaces all occurrences of a substring with another string.
///
/// # Arguments
///
/// * `s` - The source string
/// * `from` - The pattern to search for
/// * `to` - The replacement string
///
/// # Examples
///
/// ```tml
/// assert(replace("hello world", "world", "TML") == "hello TML")
/// assert(replace("aaa", "a", "b") == "bbb")
/// assert(replace("hello", "x", "y") == "hello")  // No match
/// ```
pub func replace(s: Str, pattern: Str, replacement: Str) -> Str {
    return lowlevel { str_replace(s, pattern, replacement) }
}

/// Replaces only the first occurrence of a substring.
///
/// # Arguments
///
/// * `s` - The source string
/// * `from` - The pattern to search for
/// * `to` - The replacement string
///
/// # Examples
///
/// ```tml
/// assert(replace_first("aaa", "a", "b") == "baa")
/// assert(replace_first("hello hello", "hello", "hi") == "hi hello")
/// ```
pub func replace_first(s: Str, pattern: Str, replacement: Str) -> Str {
    return lowlevel { str_replace_first(s, pattern, replacement) }
}

// ============================================================================
// Repetition and Padding
// ============================================================================

/// Repeats the string `n` times.
///
/// # Arguments
///
/// * `s` - The string to repeat
/// * `n` - Number of times to repeat (must be non-negative)
///
/// # Examples
///
/// ```tml
/// assert(repeat("ab", 3) == "ababab")
/// assert(repeat("x", 5) == "xxxxx")
/// assert(repeat("hello", 0) == "")
/// ```
pub func repeat(s: Str, n: I64) -> Str {
    let n32: I32 = n as I32
    return lowlevel { str_repeat(s, n32) }
}

/// Pads the string on the left to reach the given width.
///
/// If the string is already at least `width` bytes long, it is returned
/// unchanged.
///
/// # Arguments
///
/// * `s` - The string to pad
/// * `width` - The target width in bytes
/// * `pad_char` - The padding string (typically a single character)
///
/// # Examples
///
/// ```tml
/// assert(pad_left("42", 5, "0") == "00042")
/// assert(pad_left("hello", 10, " ") == "     hello")
/// assert(pad_left("long", 2, "x") == "long")  // Already long enough
/// ```
pub func pad_left(s: Str, width: I64, pad_char: Str) -> Str {
    let current_len: I64 = len(s)
    if current_len >= width {
        return s
    }
    let padding: Str = repeat(pad_char, width - current_len)
    return padding + s
}

/// Pads the string on the right to reach the given width.
///
/// If the string is already at least `width` bytes long, it is returned
/// unchanged.
///
/// # Arguments
///
/// * `s` - The string to pad
/// * `width` - The target width in bytes
/// * `pad_char` - The padding string (typically a single character)
///
/// # Examples
///
/// ```tml
/// assert(pad_right("42", 5, "0") == "42000")
/// assert(pad_right("hello", 10, " ") == "hello     ")
/// assert(pad_right("long", 2, "x") == "long")  // Already long enough
/// ```
pub func pad_right(s: Str, width: I64, pad_char: Str) -> Str {
    let current_len: I64 = len(s)
    if current_len >= width {
        return s
    }
    let padding: Str = repeat(pad_char, width - current_len)
    return s + padding
}

// ============================================================================
// Parsing
// ============================================================================

/// Parses a string as a 32-bit signed integer.
///
/// Attempts to parse the entire string as an integer. Leading and trailing
/// whitespace should be trimmed before calling.
///
/// # Examples
///
/// ```tml
/// assert(parse_i32("42") == Just(42))
/// assert(parse_i32("-17") == Just(-17))
/// assert(parse_i32("0") == Just(0))
/// ```
///
/// # Note
///
/// Currently always returns `Just(result)`. Proper error detection is
/// pending implementation.
pub func parse_i32(s: Str) -> Maybe[I32] {
    let result: I32 = lowlevel { str_parse_i32(s) }
    // Check for parse error (returns 0 on error, need sentinel)
    return Just(result)
}

/// Parses a string as a 64-bit signed integer.
///
/// Attempts to parse the entire string as an integer. Leading and trailing
/// whitespace should be trimmed before calling.
///
/// # Examples
///
/// ```tml
/// assert(parse_i64("9223372036854775807") == Just(9223372036854775807))
/// assert(parse_i64("-42") == Just(-42))
/// ```
///
/// # Note
///
/// Currently always returns `Just(result)`. Proper error detection is
/// pending implementation.
pub func parse_i64(s: Str) -> Maybe[I64] {
    let result: I64 = lowlevel { str_parse_i64(s) }
    return Just(result)
}

/// Parses a string as a 64-bit floating point number.
///
/// Accepts standard decimal notation and scientific notation.
///
/// # Examples
///
/// ```tml
/// assert(parse_f64("3.14") == Just(3.14))
/// assert(parse_f64("-0.5") == Just(-0.5))
/// assert(parse_f64("1e10") == Just(1e10))
/// ```
///
/// # Note
///
/// Currently always returns `Just(result)`. Proper error detection is
/// pending implementation.
pub func parse_f64(s: Str) -> Maybe[F64] {
    let result: F64 = lowlevel { str_parse_f64(s) }
    return Just(result)
}

/// Parses a string as a boolean value.
///
/// Accepts the following values (case insensitive):
/// - `"true"` or `"1"` → `Just(true)`
/// - `"false"` or `"0"` → `Just(false)`
/// - Any other value → `Nothing`
///
/// # Examples
///
/// ```tml
/// assert(parse_bool("true") == Just(true))
/// assert(parse_bool("FALSE") == Just(false))
/// assert(parse_bool("1") == Just(true))
/// assert(parse_bool("yes") == Nothing)
/// ```
pub func parse_bool(s: Str) -> Maybe[Bool] {
    let lower: Str = to_lowercase(s)
    if lower == "true" or lower == "1" {
        return Just(true)
    }
    if lower == "false" or lower == "0" {
        return Just(false)
    }
    return Nothing
}

// ============================================================================
// Joining
// ============================================================================

/// Joins a list of strings with the given separator.
///
/// Creates a single string by concatenating all elements with the separator
/// between each pair of adjacent elements.
///
/// # Arguments
///
/// * `parts` - The list of strings to join
/// * `separator` - The string to insert between elements
///
/// # Examples
///
/// ```tml
/// let words = ["hello", "world"]
/// assert(join(words, " ") == "hello world")
///
/// let nums = ["1", "2", "3"]
/// assert(join(nums, ", ") == "1, 2, 3")
///
/// let empty: List[Str] = []
/// assert(join(empty, ",") == "")
/// ```
pub func join(parts: List[Str], separator: Str) -> Str {
    return lowlevel { str_join(parts, separator) }
}

// ============================================================================
// Concatenation
// ============================================================================

/// Concatenates two strings.
///
/// This is equivalent to using the `+` operator on strings.
///
/// # Examples
///
/// ```tml
/// assert(concat("Hello, ", "World!") == "Hello, World!")
/// assert(concat("", "x") == "x")
/// ```
pub func concat(a: Str, b: Str) -> Str {
    return a + b
}

/// Concatenates multiple strings without a separator.
///
/// This is equivalent to `join(parts, "")`.
///
/// # Examples
///
/// ```tml
/// let parts = ["a", "b", "c"]
/// assert(concat_all(parts) == "abc")
///
/// let words = ["Hello", " ", "World"]
/// assert(concat_all(words) == "Hello World")
/// ```
pub func concat_all(parts: List[Str]) -> Str {
    return join(parts, "")
}

// ============================================================================
// Str Methods
// ============================================================================

impl Str {
    /// Returns the length of this string in bytes.
    ///
    /// Note: This returns the byte length, not the character count. For UTF-8
    /// strings with multi-byte characters, this may differ from the visible
    /// character count.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let s = "hello"
    /// assert(s.len() == 5)
    /// ```
    pub func len(this) -> I64 {
        return lowlevel { str_len(this) }
    }

    /// Returns `true` if this string is empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// assert("".is_empty())
    /// assert(not "hello".is_empty())
    /// ```
    pub func is_empty(this) -> Bool {
        return this.len() == 0
    }

    /// Returns the underlying bytes of this string as a byte slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let s = "abc"
    /// let bytes: ref [U8] = s.as_bytes()
    /// assert(bytes[0] == 97)  // 'a'
    /// ```
    pub func as_bytes(this) -> ref [U8] {
        return lowlevel { str_as_bytes(this) }
    }

    /// Returns the character at the given byte index.
    pub func char_at(this, index: I64) -> I32 {
        let idx32: I32 = index as I32
        return lowlevel { str_char_at(this, idx32) }
    }

    /// Returns a substring from `start` to `end` (exclusive).
    pub func slice_str(this, start: I64, end: I64) -> Str {
        let start32: I32 = start as I32
        let end32: I32 = end as I32
        return lowlevel { str_substring(this, start32, end32) }
    }

    /// Alias for slice_str
    pub func slice(this, start: I64, end: I64) -> Str {
        let start32: I32 = start as I32
        let end32: I32 = end as I32
        return lowlevel { str_substring(this, start32, end32) }
    }

    /// Converts all characters to uppercase.
    pub func to_uppercase(this) -> Str {
        return lowlevel { str_to_uppercase(this) }
    }

    /// Converts all characters to lowercase.
    pub func to_lowercase(this) -> Str {
        return lowlevel { str_to_lowercase(this) }
    }

    /// Returns `true` if this string starts with the given prefix.
    pub func starts_with(this, prefix: Str) -> Bool {
        return lowlevel { str_starts_with(this, prefix) }
    }

    /// Returns `true` if this string ends with the given suffix.
    pub func ends_with(this, suffix: Str) -> Bool {
        return lowlevel { str_ends_with(this, suffix) }
    }

    /// Returns `true` if this string contains the given substring.
    pub func contains(this, pattern: Str) -> Bool {
        return lowlevel { str_contains(this, pattern) }
    }

    /// Returns the byte index of the first occurrence of the pattern.
    /// Returns -1 if not found.
    pub func find(this, pattern: Str) -> I64 {
        return lowlevel { str_find(this, pattern) }
    }

    /// Returns the byte index of the last occurrence of the pattern.
    /// Returns -1 if not found.
    pub func rfind(this, pattern: Str) -> I64 {
        return lowlevel { str_rfind(this, pattern) }
    }

    /// Splits this string by the given delimiter.
    pub func split(this, delimiter: Str) -> List[Str] {
        return lowlevel { str_split(this, delimiter) }
    }

    /// Returns an iterator over the characters of this string.
    pub func chars(this) -> List[I32] {
        return lowlevel { str_chars(this) }
    }

    /// Removes leading and trailing whitespace.
    pub func trim(this) -> Str {
        return lowlevel { str_trim(this) }
    }

    /// Removes leading whitespace.
    pub func trim_start(this) -> Str {
        return lowlevel { str_trim_start(this) }
    }

    /// Removes trailing whitespace.
    pub func trim_end(this) -> Str {
        return lowlevel { str_trim_end(this) }
    }

    /// Parses this string as an I64.
    pub func parse_i64(this) -> Maybe[I64] {
        let result: I64 = lowlevel { str_parse_i64(this) }
        return Just(result)
    }

    /// Parses this string as a U16.
    pub func parse_u16(this) -> Maybe[U16] {
        let result: I64 = lowlevel { str_parse_i64(this) }
        return Just(result as U16)
    }

    /// Replaces all occurrences of a substring.
    pub func replace(this, pattern: Str, replacement: Str) -> Str {
        return lowlevel { str_replace(this, pattern, replacement) }
    }
}
