//! Percent-encoding (URL encoding) per RFC 3986.
//!
//! Encodes characters that are not unreserved (A-Z, a-z, 0-9, `-`, `_`, `.`, `~`)
//! into `%XX` form where XX is the uppercase hexadecimal value of the byte.
//!
//! # Examples
//!
//! ```tml
//! use core::encoding::percent
//!
//! assert(percent::encode("hello world") == "hello%20world")
//! assert(percent::decode("hello%20world") == Ok("hello world"))
//! ```

use core::str
use core::encoding::hex

/// Returns true if the byte is an unreserved character per RFC 3986.
/// Unreserved: A-Z, a-z, 0-9, '-', '.', '_', '~'
func is_unreserved(b: I32) -> Bool {
    if b >= 65 and b <= 90 { return true }   // A-Z
    if b >= 97 and b <= 122 { return true }  // a-z
    if b >= 48 and b <= 57 { return true }   // 0-9
    if b == 45 { return true }               // -
    if b == 46 { return true }               // .
    if b == 95 { return true }               // _
    if b == 126 { return true }              // ~
    return false
}

/// Percent-encode a string for use in URLs.
///
/// Encodes all characters except unreserved: A-Z a-z 0-9 - _ . ~
///
/// # Examples
///
/// ```tml
/// assert(encode("hello world") == "hello%20world")
/// assert(encode("a+b=c") == "a%2Bb%3Dc")
/// ```
pub func encode(input: Str) -> Str {
    let in_len: I64 = str::len(input)
    if in_len == 0 {
        return ""
    }
    // Worst case: every byte needs %XX encoding -> 3x length
    let max_len: I64 = in_len * 3
    let buf: *Unit = lowlevel { mem_alloc(max_len + 1) }
    let src: I64 = input as I64
    let dst: I64 = buf as I64
    var si: I64 = 0
    var di: I64 = 0

    loop (si < in_len) {
        let byte: U8 = lowlevel { ptr_read[U8]((src + si) as *U8) }
        let b: I32 = byte as I32
        if is_unreserved(b) {
            lowlevel { ptr_write[U8]((dst + di) as *U8, byte) }
            di = di + 1
        } else {
            lowlevel { ptr_write[U8]((dst + di) as *U8, 37 as U8) }        // '%'
            lowlevel { ptr_write[U8]((dst + di + 1) as *U8, hex::nibble_to_upper(b / 16)) }
            lowlevel { ptr_write[U8]((dst + di + 2) as *U8, hex::nibble_to_upper(b % 16)) }
            di = di + 3
        }
        si = si + 1
    }

    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
    return buf as Str
}

/// Percent-encode for form data (application/x-www-form-urlencoded).
///
/// Same as `encode` but spaces become '+' instead of '%20'.
pub func encode_form(input: Str) -> Str {
    let in_len: I64 = str::len(input)
    if in_len == 0 {
        return ""
    }
    let max_len: I64 = in_len * 3
    let buf: *Unit = lowlevel { mem_alloc(max_len + 1) }
    let src: I64 = input as I64
    let dst: I64 = buf as I64
    var si: I64 = 0
    var di: I64 = 0

    loop (si < in_len) {
        let byte: U8 = lowlevel { ptr_read[U8]((src + si) as *U8) }
        let b: I32 = byte as I32
        if b == 32 {
            // Space -> '+'
            lowlevel { ptr_write[U8]((dst + di) as *U8, 43 as U8) }
            di = di + 1
        } else if is_unreserved(b) {
            lowlevel { ptr_write[U8]((dst + di) as *U8, byte) }
            di = di + 1
        } else {
            lowlevel { ptr_write[U8]((dst + di) as *U8, 37 as U8) }
            lowlevel { ptr_write[U8]((dst + di + 1) as *U8, hex::nibble_to_upper(b / 16)) }
            lowlevel { ptr_write[U8]((dst + di + 2) as *U8, hex::nibble_to_upper(b % 16)) }
            di = di + 3
        }
        si = si + 1
    }

    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
    return buf as Str
}

/// Decode a percent-encoded string.
///
/// # Examples
///
/// ```tml
/// assert(decode("hello%20world") == Ok("hello world"))
/// ```
pub func decode(input: Str) -> Outcome[Str, Str] {
    let in_len: I64 = str::len(input)
    if in_len == 0 {
        return Ok("")
    }
    // Output is at most in_len bytes
    let buf: *Unit = lowlevel { mem_alloc(in_len + 1) }
    let src: I64 = input as I64
    let dst: I64 = buf as I64
    var si: I64 = 0
    var di: I64 = 0

    loop (si < in_len) {
        let byte: U8 = lowlevel { ptr_read[U8]((src + si) as *U8) }
        let b: I32 = byte as I32
        if b == 37 {
            // '%' â€” next two chars are hex
            if si + 2 >= in_len {
                lowlevel { mem_free(buf) }
                return Err("percent: incomplete escape sequence")
            }
            let hi_byte: U8 = lowlevel { ptr_read[U8]((src + si + 1) as *U8) }
            let lo_byte: U8 = lowlevel { ptr_read[U8]((src + si + 2) as *U8) }
            let hi: I32 = hex::char_to_nibble(hi_byte as I32)
            let lo: I32 = hex::char_to_nibble(lo_byte as I32)
            if hi == -1 or lo == -1 {
                lowlevel { mem_free(buf) }
                return Err("percent: invalid hex digit in escape")
            }
            let decoded: U8 = (hi * 16 + lo) as U8
            lowlevel { ptr_write[U8]((dst + di) as *U8, decoded) }
            di = di + 1
            si = si + 3
        } else {
            lowlevel { ptr_write[U8]((dst + di) as *U8, byte) }
            di = di + 1
            si = si + 1
        }
    }

    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
    return Ok(buf as Str)
}

/// Decode form-encoded string ('+' treated as space).
pub func decode_form(input: Str) -> Outcome[Str, Str] {
    let in_len: I64 = str::len(input)
    if in_len == 0 {
        return Ok("")
    }
    let buf: *Unit = lowlevel { mem_alloc(in_len + 1) }
    let src: I64 = input as I64
    let dst: I64 = buf as I64
    var si: I64 = 0
    var di: I64 = 0

    loop (si < in_len) {
        let byte: U8 = lowlevel { ptr_read[U8]((src + si) as *U8) }
        let b: I32 = byte as I32
        if b == 43 {
            // '+' -> space
            lowlevel { ptr_write[U8]((dst + di) as *U8, 32 as U8) }
            di = di + 1
            si = si + 1
        } else if b == 37 {
            if si + 2 >= in_len {
                lowlevel { mem_free(buf) }
                return Err("percent: incomplete escape sequence")
            }
            let hi_byte: U8 = lowlevel { ptr_read[U8]((src + si + 1) as *U8) }
            let lo_byte: U8 = lowlevel { ptr_read[U8]((src + si + 2) as *U8) }
            let hi: I32 = hex::char_to_nibble(hi_byte as I32)
            let lo: I32 = hex::char_to_nibble(lo_byte as I32)
            if hi == -1 or lo == -1 {
                lowlevel { mem_free(buf) }
                return Err("percent: invalid hex digit in escape")
            }
            let decoded: U8 = (hi * 16 + lo) as U8
            lowlevel { ptr_write[U8]((dst + di) as *U8, decoded) }
            di = di + 1
            si = si + 3
        } else {
            lowlevel { ptr_write[U8]((dst + di) as *U8, byte) }
            di = di + 1
            si = si + 1
        }
    }

    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
    return Ok(buf as Str)
}
