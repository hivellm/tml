//! ASCII85 (Base85) encoding and decoding.
//!
//! Uses the standard Ascii85 encoding where 4 bytes map to 5 characters
//! in the range '!' (33) to 'u' (117). The special 'z' character represents
//! four zero bytes. Output is wrapped in `<~` and `~>` delimiters.
//!
//! # Examples
//!
//! ```tml
//! use core::encoding::ascii85
//!
//! assert(ascii85::encode("Hello") == "<~87cURD]i~>")
//! assert(ascii85::decode("<~87cURD]i~>") == Ok("Hello"))
//! ```

use core::str

/// Encode a string's bytes as Ascii85 with `<~` ... `~>` delimiters.
///
/// Processes 4 bytes at a time into 5 Ascii85 characters.
/// All-zero groups are encoded as 'z'.
pub func encode(input: Str) -> Str {
    let in_len: I64 = str::len(input)
    if in_len == 0 {
        return "<~~>"
    }

    let src: I64 = input as I64
    let full_groups: I64 = in_len / 4
    let remainder: I64 = in_len % 4

    // Worst case output: full_groups * 5 + (remainder+1) + 4 (delimiters) + 1 (null)
    // z-compression could make it smaller, but we allocate for worst case
    let max_out: I64 = full_groups * 5 + (if remainder > 0 { remainder + 1 } else { 0 }) + 5
    let buf: *Unit = lowlevel { mem_alloc(max_out) }
    let dst: I64 = buf as I64

    // Write opening delimiter
    lowlevel { ptr_write[U8]((dst) as *U8, 60 as U8) }       // '<'
    lowlevel { ptr_write[U8]((dst + 1) as *U8, 126 as U8) }  // '~'
    var di: I64 = 2
    var si: I64 = 0

    // Process full 4-byte groups
    loop (si + 4 <= in_len) {
        let b0: I64 = lowlevel { ptr_read[U8]((src + si) as *U8) } as I64
        let b1: I64 = lowlevel { ptr_read[U8]((src + si + 1) as *U8) } as I64
        let b2: I64 = lowlevel { ptr_read[U8]((src + si + 2) as *U8) } as I64
        let b3: I64 = lowlevel { ptr_read[U8]((src + si + 3) as *U8) } as I64
        let val: I64 = b0 * 16777216 + b1 * 65536 + b2 * 256 + b3

        if val == 0 {
            // z-compression for all-zero groups
            lowlevel { ptr_write[U8]((dst + di) as *U8, 122 as U8) }  // 'z'
            di = di + 1
        } else {
            // Encode 4 bytes as 5 characters (base 85, big-endian)
            let c4: I64 = val % 85
            let r4: I64 = val / 85
            let c3: I64 = r4 % 85
            let r3: I64 = r4 / 85
            let c2: I64 = r3 % 85
            let r2: I64 = r3 / 85
            let c1: I64 = r2 % 85
            let c0: I64 = r2 / 85
            lowlevel { ptr_write[U8]((dst + di) as *U8, (c0 + 33) as U8) }
            lowlevel { ptr_write[U8]((dst + di + 1) as *U8, (c1 + 33) as U8) }
            lowlevel { ptr_write[U8]((dst + di + 2) as *U8, (c2 + 33) as U8) }
            lowlevel { ptr_write[U8]((dst + di + 3) as *U8, (c3 + 33) as U8) }
            lowlevel { ptr_write[U8]((dst + di + 4) as *U8, (c4 + 33) as U8) }
            di = di + 5
        }
        si = si + 4
    }

    // Handle remainder (1-3 bytes)
    if remainder > 0 {
        // Pad with zeros to make 4 bytes, encode, then take remainder+1 chars
        var padded: I64 = 0
        if remainder >= 1 {
            let b0: I64 = lowlevel { ptr_read[U8]((src + si) as *U8) } as I64
            padded = b0 * 16777216
        }
        if remainder >= 2 {
            let b1: I64 = lowlevel { ptr_read[U8]((src + si + 1) as *U8) } as I64
            padded = padded + b1 * 65536
        }
        if remainder >= 3 {
            let b2: I64 = lowlevel { ptr_read[U8]((src + si + 2) as *U8) } as I64
            padded = padded + b2 * 256
        }

        let c4: I64 = padded % 85
        let r4: I64 = padded / 85
        let c3: I64 = r4 % 85
        let r3: I64 = r4 / 85
        let c2: I64 = r3 % 85
        let r2: I64 = r3 / 85
        let c1: I64 = r2 % 85
        let c0: I64 = r2 / 85

        // Write remainder+1 characters
        lowlevel { ptr_write[U8]((dst + di) as *U8, (c0 + 33) as U8) }
        di = di + 1
        if remainder >= 1 {
            lowlevel { ptr_write[U8]((dst + di) as *U8, (c1 + 33) as U8) }
            di = di + 1
        }
        if remainder >= 2 {
            lowlevel { ptr_write[U8]((dst + di) as *U8, (c2 + 33) as U8) }
            di = di + 1
        }
        if remainder >= 3 {
            lowlevel { ptr_write[U8]((dst + di) as *U8, (c3 + 33) as U8) }
            di = di + 1
        }
    }

    // Write closing delimiter
    lowlevel { ptr_write[U8]((dst + di) as *U8, 126 as U8) }      // '~'
    lowlevel { ptr_write[U8]((dst + di + 1) as *U8, 62 as U8) }   // '>'
    di = di + 2
    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
    return buf as Str
}

/// Decode an Ascii85 string (with `<~` `~>` delimiters) back to bytes.
pub func decode(a85: Str) -> Outcome[Str, Str] {
    let in_len: I64 = str::len(a85)
    if in_len < 4 {
        return Err("ascii85: input too short")
    }

    let src: I64 = a85 as I64

    // Check for <~ prefix
    let p0: U8 = lowlevel { ptr_read[U8]((src) as *U8) }
    let p1: U8 = lowlevel { ptr_read[U8]((src + 1) as *U8) }
    if p0 != (60 as U8) or p1 != (126 as U8) {
        return Err("ascii85: missing <~ prefix")
    }

    // Check for ~> suffix
    let s0: U8 = lowlevel { ptr_read[U8]((src + in_len - 2) as *U8) }
    let s1: U8 = lowlevel { ptr_read[U8]((src + in_len - 1) as *U8) }
    if s0 != (126 as U8) or s1 != (62 as U8) {
        return Err("ascii85: missing ~> suffix")
    }

    // Payload is between delimiters
    let payload_start: I64 = 2
    let payload_end: I64 = in_len - 2
    let payload_len: I64 = payload_end - payload_start

    if payload_len == 0 {
        return Ok("")
    }

    // First pass: count output bytes (need to handle 'z' compression)
    // Max output is payload_len bytes (each 'z' = 4 bytes, each group of 5 chars = 4 bytes)
    let max_out: I64 = payload_len * 4
    let buf: *Unit = lowlevel { mem_alloc(max_out + 1) }
    let dst: I64 = buf as I64
    var di: I64 = 0
    var si: I64 = payload_start

    loop (si < payload_end) {
        let c: I32 = lowlevel { ptr_read[U8]((src + si) as *U8) } as I32

        // Skip whitespace
        if c == 32 or c == 10 or c == 13 or c == 9 {
            si = si + 1
        } else if c == 122 {
            // 'z' = four zero bytes
            lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }
            lowlevel { ptr_write[U8]((dst + di + 1) as *U8, 0 as U8) }
            lowlevel { ptr_write[U8]((dst + di + 2) as *U8, 0 as U8) }
            lowlevel { ptr_write[U8]((dst + di + 3) as *U8, 0 as U8) }
            di = di + 4
            si = si + 1
        } else if c >= 33 and c <= 117 {
            // Collect up to 5 characters for a group
            var group_chars: I64 = 0
            var val: I64 = 0
            var gi: I64 = si
            loop (gi < payload_end and group_chars < 5) {
                let gc: I32 = lowlevel { ptr_read[U8]((src + gi) as *U8) } as I32
                // Skip whitespace within group
                if gc == 32 or gc == 10 or gc == 13 or gc == 9 {
                    gi = gi + 1
                } else if gc >= 33 and gc <= 117 {
                    val = val * 85 + (gc - 33) as I64
                    group_chars = group_chars + 1
                    gi = gi + 1
                } else {
                    // Invalid char, will be caught below
                    group_chars = 5  // force exit
                    gi = gi + 1
                }
            }

            if group_chars == 5 {
                // Full group -> 4 bytes
                lowlevel { ptr_write[U8]((dst + di) as *U8, ((val >> 24) & (255 as I64)) as U8) }
                lowlevel { ptr_write[U8]((dst + di + 1) as *U8, ((val >> 16) & (255 as I64)) as U8) }
                lowlevel { ptr_write[U8]((dst + di + 2) as *U8, ((val >> 8) & (255 as I64)) as U8) }
                lowlevel { ptr_write[U8]((dst + di + 3) as *U8, (val & (255 as I64)) as U8) }
                di = di + 4
            } else if group_chars >= 2 {
                // Partial group: pad with 'u' (84) and take group_chars-1 bytes
                var pad_count: I64 = 5 - group_chars
                loop (pad_count > 0) {
                    val = val * 85 + 84
                    pad_count = pad_count - 1
                }
                let out_bytes: I64 = group_chars - 1
                if out_bytes >= 1 {
                    lowlevel { ptr_write[U8]((dst + di) as *U8, ((val >> 24) & (255 as I64)) as U8) }
                }
                if out_bytes >= 2 {
                    lowlevel { ptr_write[U8]((dst + di + 1) as *U8, ((val >> 16) & (255 as I64)) as U8) }
                }
                if out_bytes >= 3 {
                    lowlevel { ptr_write[U8]((dst + di + 2) as *U8, ((val >> 8) & (255 as I64)) as U8) }
                }
                di = di + out_bytes
            } else {
                lowlevel { mem_free(buf) }
                return Err("ascii85: incomplete group")
            }
            si = gi
        } else {
            lowlevel { mem_free(buf) }
            return Err("ascii85: invalid character")
        }
    }

    lowlevel { ptr_write[U8]((dst + di) as *U8, 0 as U8) }

    // Copy to exact-size buffer
    let result: *Unit = lowlevel { mem_alloc(di + 1) }
    let result_addr: I64 = result as I64
    var ci: I64 = 0
    loop (ci <= di) {
        let b: U8 = lowlevel { ptr_read[U8]((dst + ci) as *U8) }
        lowlevel { ptr_write[U8]((result_addr + ci) as *U8, b) }
        ci = ci + 1
    }
    lowlevel { mem_free(buf) }
    return Ok(result as Str)
}
