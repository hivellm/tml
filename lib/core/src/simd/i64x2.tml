//! 2-lane I64 SIMD vector type.

use core::simd::mask::Mask2
use core::intrinsics::{
    simd_load, simd_store, simd_extract, simd_insert, simd_splat,
    llvm_add, llvm_sub, llvm_mul, llvm_div,
    llvm_and, llvm_or, llvm_xor
}

/// A 2-lane vector of I64 values (128 bits total).
@simd
pub type I64x2 {
    e0: I64,
    e1: I64
}

impl I64x2 {
    /// Construct from two lane values.
    pub func new(e0: I64, e1: I64) -> I64x2 {
        return I64x2 { e0: e0, e1: e1 }
    }

    /// Broadcast a single value to all lanes.
    pub func splat(v: I64) -> I64x2 {
        return I64x2 { e0: v, e1: v }
    }

    /// All lanes zero.
    pub func zero() -> I64x2 {
        return I64x2 { e0: 0 as I64, e1: 0 as I64 }
    }

    /// Get lane by index (0-1). Returns 0 for out-of-bounds.
    pub func get(this, idx: I32) -> I64 {
        if idx < 0 or idx > 1 { return 0 as I64 }
        lowlevel {
            let v = simd_load[I64x2](ref this)
            return simd_extract[I64x2, I64](v, idx)
        }
    }

    /// Return a new vector with lane `idx` replaced by `val`.
    pub func set(this, idx: I32, val: I64) -> I64x2 {
        lowlevel {
            let v = simd_load[I64x2](ref this)
            let w = simd_insert[I64x2, I64](v, val, idx)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, w)
            return result
        }
    }

    // -- Arithmetic --

    pub func add(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_add(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func sub(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_sub(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func mul(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_mul(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func div(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_div(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func neg(this) -> I64x2 {
        lowlevel {
            let z = simd_splat[I64x2, I64](0 as I64)
            let a = simd_load[I64x2](ref this)
            let r = llvm_sub(z, a)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    // -- Comparison (scalar â€” returns Mask2) --

    pub func eq(this, other: I64x2) -> Mask2 {
        return Mask2 { m0: this.e0 == other.e0, m1: this.e1 == other.e1 }
    }

    pub func ne(this, other: I64x2) -> Mask2 {
        return Mask2 { m0: this.e0 != other.e0, m1: this.e1 != other.e1 }
    }

    pub func lt(this, other: I64x2) -> Mask2 {
        return Mask2 { m0: this.e0 < other.e0, m1: this.e1 < other.e1 }
    }

    pub func gt(this, other: I64x2) -> Mask2 {
        return Mask2 { m0: this.e0 > other.e0, m1: this.e1 > other.e1 }
    }

    // -- Bitwise --

    pub func band(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_and(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func bor(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_or(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    pub func bxor(this, other: I64x2) -> I64x2 {
        lowlevel {
            let a = simd_load[I64x2](ref this)
            let b = simd_load[I64x2](ref other)
            let r = llvm_xor(a, b)
            var result: I64x2 = I64x2::zero()
            simd_store[I64x2](mut ref result, r)
            return result
        }
    }

    // -- Horizontal --

    pub func sum(this) -> I64 {
        lowlevel {
            let v = simd_load[I64x2](ref this)
            let e0 = simd_extract[I64x2, I64](v, 0)
            let e1 = simd_extract[I64x2, I64](v, 1)
            return e0 + e1
        }
    }

    pub func hmin(this) -> I64 {
        lowlevel {
            let v = simd_load[I64x2](ref this)
            let e0 = simd_extract[I64x2, I64](v, 0)
            let e1 = simd_extract[I64x2, I64](v, 1)
            if e1 < e0 { return e1 }
            return e0
        }
    }

    pub func hmax(this) -> I64 {
        lowlevel {
            let v = simd_load[I64x2](ref this)
            let e0 = simd_extract[I64x2, I64](v, 0)
            let e1 = simd_extract[I64x2, I64](v, 1)
            if e1 > e0 { return e1 }
            return e0
        }
    }

    pub func min(this, other: I64x2) -> I64x2 {
        var r0: I64 = this.e0; if other.e0 < r0 { r0 = other.e0 }
        var r1: I64 = this.e1; if other.e1 < r1 { r1 = other.e1 }
        return I64x2 { e0: r0, e1: r1 }
    }

    pub func max(this, other: I64x2) -> I64x2 {
        var r0: I64 = this.e0; if other.e0 > r0 { r0 = other.e0 }
        var r1: I64 = this.e1; if other.e1 > r1 { r1 = other.e1 }
        return I64x2 { e0: r0, e1: r1 }
    }
}

/// Select lanes from `if_true` or `if_false` based on mask.
pub func select(mask: Mask2, if_true: I64x2, if_false: I64x2) -> I64x2 {
    var r0: I64 = if_false.e0; if mask.m0 { r0 = if_true.e0 }
    var r1: I64 = if_false.e1; if mask.m1 { r1 = if_true.e1 }
    return I64x2 { e0: r0, e1: r1 }
}
