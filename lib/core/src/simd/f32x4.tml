//! 4-lane F32 SIMD vector type.

use core::simd::mask::Mask4
use core::intrinsics::{
    simd_load, simd_store, simd_extract, simd_insert, simd_splat,
    llvm_add, llvm_sub, llvm_mul, llvm_div
}

/// A 4-lane vector of F32 values (128 bits total).
@simd
pub type F32x4 {
    e0: F32,
    e1: F32,
    e2: F32,
    e3: F32
}

impl F32x4 {
    pub func new(e0: F32, e1: F32, e2: F32, e3: F32) -> F32x4 {
        return F32x4 { e0: e0, e1: e1, e2: e2, e3: e3 }
    }

    pub func splat(v: F32) -> F32x4 {
        return F32x4 { e0: v, e1: v, e2: v, e3: v }
    }

    pub func zero() -> F32x4 {
        return F32x4 { e0: 0.0 as F32, e1: 0.0 as F32, e2: 0.0 as F32, e3: 0.0 as F32 }
    }

    pub func get(this, idx: I32) -> F32 {
        if idx < 0 or idx > 3 { return 0.0 as F32 }
        lowlevel {
            let v = simd_load[F32x4](ref this)
            return simd_extract[F32x4, F32](v, idx)
        }
    }

    pub func set(this, idx: I32, val: F32) -> F32x4 {
        lowlevel {
            let v = simd_load[F32x4](ref this)
            let w = simd_insert[F32x4, F32](v, val, idx)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, w)
            return result
        }
    }

    // -- Arithmetic --

    pub func add(this, other: F32x4) -> F32x4 {
        lowlevel {
            let a = simd_load[F32x4](ref this)
            let b = simd_load[F32x4](ref other)
            let r = llvm_add(a, b)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, r)
            return result
        }
    }

    pub func sub(this, other: F32x4) -> F32x4 {
        lowlevel {
            let a = simd_load[F32x4](ref this)
            let b = simd_load[F32x4](ref other)
            let r = llvm_sub(a, b)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, r)
            return result
        }
    }

    pub func mul(this, other: F32x4) -> F32x4 {
        lowlevel {
            let a = simd_load[F32x4](ref this)
            let b = simd_load[F32x4](ref other)
            let r = llvm_mul(a, b)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, r)
            return result
        }
    }

    pub func div(this, other: F32x4) -> F32x4 {
        lowlevel {
            let a = simd_load[F32x4](ref this)
            let b = simd_load[F32x4](ref other)
            let r = llvm_div(a, b)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, r)
            return result
        }
    }

    pub func neg(this) -> F32x4 {
        lowlevel {
            let z = simd_splat[F32x4, F32](0.0 as F32)
            let a = simd_load[F32x4](ref this)
            let r = llvm_sub(z, a)
            var result: F32x4 = F32x4::zero()
            simd_store[F32x4](mut ref result, r)
            return result
        }
    }

    // -- Comparison (scalar â€” returns Mask4) --

    pub func eq(this, other: F32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 == other.e0, m1: this.e1 == other.e1,
            m2: this.e2 == other.e2, m3: this.e3 == other.e3
        }
    }

    pub func ne(this, other: F32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 != other.e0, m1: this.e1 != other.e1,
            m2: this.e2 != other.e2, m3: this.e3 != other.e3
        }
    }

    pub func lt(this, other: F32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 < other.e0, m1: this.e1 < other.e1,
            m2: this.e2 < other.e2, m3: this.e3 < other.e3
        }
    }

    pub func gt(this, other: F32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 > other.e0, m1: this.e1 > other.e1,
            m2: this.e2 > other.e2, m3: this.e3 > other.e3
        }
    }

    // -- Horizontal --

    pub func sum(this) -> F32 {
        lowlevel {
            let v = simd_load[F32x4](ref this)
            let e0 = simd_extract[F32x4, F32](v, 0)
            let e1 = simd_extract[F32x4, F32](v, 1)
            let e2 = simd_extract[F32x4, F32](v, 2)
            let e3 = simd_extract[F32x4, F32](v, 3)
            return e0 + e1 + e2 + e3
        }
    }

    pub func hmin(this) -> F32 {
        lowlevel {
            let v = simd_load[F32x4](ref this)
            var m: F32 = simd_extract[F32x4, F32](v, 0)
            let e1 = simd_extract[F32x4, F32](v, 1)
            let e2 = simd_extract[F32x4, F32](v, 2)
            let e3 = simd_extract[F32x4, F32](v, 3)
            if e1 < m { m = e1 }
            if e2 < m { m = e2 }
            if e3 < m { m = e3 }
            return m
        }
    }

    pub func hmax(this) -> F32 {
        lowlevel {
            let v = simd_load[F32x4](ref this)
            var m: F32 = simd_extract[F32x4, F32](v, 0)
            let e1 = simd_extract[F32x4, F32](v, 1)
            let e2 = simd_extract[F32x4, F32](v, 2)
            let e3 = simd_extract[F32x4, F32](v, 3)
            if e1 > m { m = e1 }
            if e2 > m { m = e2 }
            if e3 > m { m = e3 }
            return m
        }
    }

    pub func min(this, other: F32x4) -> F32x4 {
        var r0: F32 = this.e0; if other.e0 < r0 { r0 = other.e0 }
        var r1: F32 = this.e1; if other.e1 < r1 { r1 = other.e1 }
        var r2: F32 = this.e2; if other.e2 < r2 { r2 = other.e2 }
        var r3: F32 = this.e3; if other.e3 < r3 { r3 = other.e3 }
        return F32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
    }

    pub func max(this, other: F32x4) -> F32x4 {
        var r0: F32 = this.e0; if other.e0 > r0 { r0 = other.e0 }
        var r1: F32 = this.e1; if other.e1 > r1 { r1 = other.e1 }
        var r2: F32 = this.e2; if other.e2 > r2 { r2 = other.e2 }
        var r3: F32 = this.e3; if other.e3 > r3 { r3 = other.e3 }
        return F32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
    }

    // -- Math --

    pub func abs(this) -> F32x4 {
        var r0: F32 = this.e0; if r0 < (0.0 as F32) { r0 = (0.0 as F32) - r0 }
        var r1: F32 = this.e1; if r1 < (0.0 as F32) { r1 = (0.0 as F32) - r1 }
        var r2: F32 = this.e2; if r2 < (0.0 as F32) { r2 = (0.0 as F32) - r2 }
        var r3: F32 = this.e3; if r3 < (0.0 as F32) { r3 = (0.0 as F32) - r3 }
        return F32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
    }
}

/// Select lanes from `if_true` or `if_false` based on mask.
pub func select(mask: Mask4, if_true: F32x4, if_false: F32x4) -> F32x4 {
    var r0: F32 = if_false.e0; if mask.m0 { r0 = if_true.e0 }
    var r1: F32 = if_false.e1; if mask.m1 { r1 = if_true.e1 }
    var r2: F32 = if_false.e2; if mask.m2 { r2 = if_true.e2 }
    var r3: F32 = if_false.e3; if mask.m3 { r3 = if_true.e3 }
    return F32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
}
