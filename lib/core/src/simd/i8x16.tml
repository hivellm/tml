//! 16-lane I8 SIMD vector type.

use core::simd::mask::Mask16
use core::intrinsics::{
    simd_load, simd_store, simd_extract, simd_insert,
    llvm_add, llvm_sub
}

/// A 16-lane vector of I8 values (128 bits total).
@simd
pub type I8x16 {
    e0: I8, e1: I8, e2: I8, e3: I8,
    e4: I8, e5: I8, e6: I8, e7: I8,
    e8: I8, e9: I8, e10: I8, e11: I8,
    e12: I8, e13: I8, e14: I8, e15: I8
}

impl I8x16 {
    /// Construct from 16 lane values.
    pub func new(
        e0: I8, e1: I8, e2: I8, e3: I8,
        e4: I8, e5: I8, e6: I8, e7: I8,
        e8: I8, e9: I8, e10: I8, e11: I8,
        e12: I8, e13: I8, e14: I8, e15: I8
    ) -> I8x16 {
        return I8x16 {
            e0: e0, e1: e1, e2: e2, e3: e3,
            e4: e4, e5: e5, e6: e6, e7: e7,
            e8: e8, e9: e9, e10: e10, e11: e11,
            e12: e12, e13: e13, e14: e14, e15: e15
        }
    }

    /// Broadcast a single value to all lanes.
    pub func splat(v: I8) -> I8x16 {
        return I8x16 {
            e0: v, e1: v, e2: v, e3: v,
            e4: v, e5: v, e6: v, e7: v,
            e8: v, e9: v, e10: v, e11: v,
            e12: v, e13: v, e14: v, e15: v
        }
    }

    /// All lanes zero.
    pub func zero() -> I8x16 {
        return I8x16::splat(0 as I8)
    }

    /// Get lane by index (0-15). Returns 0 for out-of-bounds.
    pub func get(this, idx: I32) -> I8 {
        if idx < 0 or idx > 15 { return 0 as I8 }
        lowlevel {
            let v = simd_load[I8x16](ref this)
            return simd_extract[I8x16, I8](v, idx)
        }
    }

    // -- Arithmetic --

    pub func add(this, other: I8x16) -> I8x16 {
        lowlevel {
            let a = simd_load[I8x16](ref this)
            let b = simd_load[I8x16](ref other)
            let r = llvm_add(a, b)
            var result: I8x16 = I8x16::zero()
            simd_store[I8x16](mut ref result, r)
            return result
        }
    }

    pub func sub(this, other: I8x16) -> I8x16 {
        lowlevel {
            let a = simd_load[I8x16](ref this)
            let b = simd_load[I8x16](ref other)
            let r = llvm_sub(a, b)
            var result: I8x16 = I8x16::zero()
            simd_store[I8x16](mut ref result, r)
            return result
        }
    }

    // -- Comparison (scalar â€” returns Mask16) --

    pub func eq(this, other: I8x16) -> Mask16 {
        return Mask16 {
            m0: this.e0 == other.e0, m1: this.e1 == other.e1,
            m2: this.e2 == other.e2, m3: this.e3 == other.e3,
            m4: this.e4 == other.e4, m5: this.e5 == other.e5,
            m6: this.e6 == other.e6, m7: this.e7 == other.e7,
            m8: this.e8 == other.e8, m9: this.e9 == other.e9,
            m10: this.e10 == other.e10, m11: this.e11 == other.e11,
            m12: this.e12 == other.e12, m13: this.e13 == other.e13,
            m14: this.e14 == other.e14, m15: this.e15 == other.e15
        }
    }

    pub func ne(this, other: I8x16) -> Mask16 {
        return Mask16 {
            m0: this.e0 != other.e0, m1: this.e1 != other.e1,
            m2: this.e2 != other.e2, m3: this.e3 != other.e3,
            m4: this.e4 != other.e4, m5: this.e5 != other.e5,
            m6: this.e6 != other.e6, m7: this.e7 != other.e7,
            m8: this.e8 != other.e8, m9: this.e9 != other.e9,
            m10: this.e10 != other.e10, m11: this.e11 != other.e11,
            m12: this.e12 != other.e12, m13: this.e13 != other.e13,
            m14: this.e14 != other.e14, m15: this.e15 != other.e15
        }
    }

    // -- Horizontal --

    pub func sum(this) -> I8 {
        lowlevel {
            let v = simd_load[I8x16](ref this)
            let e0 = simd_extract[I8x16, I8](v, 0)
            let e1 = simd_extract[I8x16, I8](v, 1)
            let e2 = simd_extract[I8x16, I8](v, 2)
            let e3 = simd_extract[I8x16, I8](v, 3)
            let e4 = simd_extract[I8x16, I8](v, 4)
            let e5 = simd_extract[I8x16, I8](v, 5)
            let e6 = simd_extract[I8x16, I8](v, 6)
            let e7 = simd_extract[I8x16, I8](v, 7)
            let e8 = simd_extract[I8x16, I8](v, 8)
            let e9 = simd_extract[I8x16, I8](v, 9)
            let e10 = simd_extract[I8x16, I8](v, 10)
            let e11 = simd_extract[I8x16, I8](v, 11)
            let e12 = simd_extract[I8x16, I8](v, 12)
            let e13 = simd_extract[I8x16, I8](v, 13)
            let e14 = simd_extract[I8x16, I8](v, 14)
            let e15 = simd_extract[I8x16, I8](v, 15)
            return e0 + e1 + e2 + e3 + e4 + e5 + e6 + e7
                 + e8 + e9 + e10 + e11 + e12 + e13 + e14 + e15
        }
    }
}

/// Select lanes from `if_true` or `if_false` based on mask.
pub func select(mask: Mask16, if_true: I8x16, if_false: I8x16) -> I8x16 {
    var r0: I8 = if_false.e0; if mask.m0 { r0 = if_true.e0 }
    var r1: I8 = if_false.e1; if mask.m1 { r1 = if_true.e1 }
    var r2: I8 = if_false.e2; if mask.m2 { r2 = if_true.e2 }
    var r3: I8 = if_false.e3; if mask.m3 { r3 = if_true.e3 }
    var r4: I8 = if_false.e4; if mask.m4 { r4 = if_true.e4 }
    var r5: I8 = if_false.e5; if mask.m5 { r5 = if_true.e5 }
    var r6: I8 = if_false.e6; if mask.m6 { r6 = if_true.e6 }
    var r7: I8 = if_false.e7; if mask.m7 { r7 = if_true.e7 }
    var r8: I8 = if_false.e8; if mask.m8 { r8 = if_true.e8 }
    var r9: I8 = if_false.e9; if mask.m9 { r9 = if_true.e9 }
    var r10: I8 = if_false.e10; if mask.m10 { r10 = if_true.e10 }
    var r11: I8 = if_false.e11; if mask.m11 { r11 = if_true.e11 }
    var r12: I8 = if_false.e12; if mask.m12 { r12 = if_true.e12 }
    var r13: I8 = if_false.e13; if mask.m13 { r13 = if_true.e13 }
    var r14: I8 = if_false.e14; if mask.m14 { r14 = if_true.e14 }
    var r15: I8 = if_false.e15; if mask.m15 { r15 = if_true.e15 }
    return I8x16 {
        e0: r0, e1: r1, e2: r2, e3: r3,
        e4: r4, e5: r5, e6: r6, e7: r7,
        e8: r8, e9: r9, e10: r10, e11: r11,
        e12: r12, e13: r13, e14: r14, e15: r15
    }
}
