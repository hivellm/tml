//! 4-lane I32 SIMD vector type.

use core::simd::mask::Mask4

/// A 4-lane vector of I32 values (128 bits total).
@simd
pub type I32x4 {
    e0: I32,
    e1: I32,
    e2: I32,
    e3: I32
}

impl I32x4 {
    /// Construct from four lane values.
    pub func new(e0: I32, e1: I32, e2: I32, e3: I32) -> I32x4 {
        return I32x4 { e0: e0, e1: e1, e2: e2, e3: e3 }
    }

    /// Broadcast a single value to all lanes.
    pub func splat(v: I32) -> I32x4 {
        return I32x4 { e0: v, e1: v, e2: v, e3: v }
    }

    /// All lanes zero.
    pub func zero() -> I32x4 {
        return I32x4 { e0: 0, e1: 0, e2: 0, e3: 0 }
    }

    /// Get lane by index (0-3). Returns 0 for out-of-bounds.
    pub func get(this, idx: I32) -> I32 {
        if idx == 0 { return this.e0 }
        if idx == 1 { return this.e1 }
        if idx == 2 { return this.e2 }
        if idx == 3 { return this.e3 }
        return 0
    }

    /// Return a new vector with lane `idx` replaced by `val`.
    pub func set(this, idx: I32, val: I32) -> I32x4 {
        var r: I32x4 = I32x4 { e0: this.e0, e1: this.e1, e2: this.e2, e3: this.e3 }
        if idx == 0 { r.e0 = val }
        if idx == 1 { r.e1 = val }
        if idx == 2 { r.e2 = val }
        if idx == 3 { r.e3 = val }
        return r
    }

    // -- Arithmetic --

    /// Element-wise addition.
    pub func add(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 + other.e0, e1: this.e1 + other.e1,
            e2: this.e2 + other.e2, e3: this.e3 + other.e3
        }
    }

    /// Element-wise subtraction.
    pub func sub(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 - other.e0, e1: this.e1 - other.e1,
            e2: this.e2 - other.e2, e3: this.e3 - other.e3
        }
    }

    /// Element-wise multiplication.
    pub func mul(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 * other.e0, e1: this.e1 * other.e1,
            e2: this.e2 * other.e2, e3: this.e3 * other.e3
        }
    }

    /// Element-wise division.
    pub func div(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 / other.e0, e1: this.e1 / other.e1,
            e2: this.e2 / other.e2, e3: this.e3 / other.e3
        }
    }

    /// Element-wise negation.
    pub func neg(this) -> I32x4 {
        return I32x4 {
            e0: 0 - this.e0, e1: 0 - this.e1,
            e2: 0 - this.e2, e3: 0 - this.e3
        }
    }

    // -- Comparison --

    /// Element-wise equality.
    pub func eq(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 == other.e0, m1: this.e1 == other.e1,
            m2: this.e2 == other.e2, m3: this.e3 == other.e3
        }
    }

    /// Element-wise inequality.
    pub func ne(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 != other.e0, m1: this.e1 != other.e1,
            m2: this.e2 != other.e2, m3: this.e3 != other.e3
        }
    }

    /// Element-wise less-than.
    pub func lt(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 < other.e0, m1: this.e1 < other.e1,
            m2: this.e2 < other.e2, m3: this.e3 < other.e3
        }
    }

    /// Element-wise less-or-equal.
    pub func le(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 <= other.e0, m1: this.e1 <= other.e1,
            m2: this.e2 <= other.e2, m3: this.e3 <= other.e3
        }
    }

    /// Element-wise greater-than.
    pub func gt(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 > other.e0, m1: this.e1 > other.e1,
            m2: this.e2 > other.e2, m3: this.e3 > other.e3
        }
    }

    /// Element-wise greater-or-equal.
    pub func ge(this, other: I32x4) -> Mask4 {
        return Mask4 {
            m0: this.e0 >= other.e0, m1: this.e1 >= other.e1,
            m2: this.e2 >= other.e2, m3: this.e3 >= other.e3
        }
    }

    // -- Bitwise --

    /// Element-wise bitwise AND.
    pub func band(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 & other.e0, e1: this.e1 & other.e1,
            e2: this.e2 & other.e2, e3: this.e3 & other.e3
        }
    }

    /// Element-wise bitwise OR.
    pub func bor(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 | other.e0, e1: this.e1 | other.e1,
            e2: this.e2 | other.e2, e3: this.e3 | other.e3
        }
    }

    /// Element-wise bitwise XOR.
    pub func bxor(this, other: I32x4) -> I32x4 {
        return I32x4 {
            e0: this.e0 ^ other.e0, e1: this.e1 ^ other.e1,
            e2: this.e2 ^ other.e2, e3: this.e3 ^ other.e3
        }
    }

    /// Element-wise left shift.
    pub func shift_left(this, n: I32) -> I32x4 {
        return I32x4 {
            e0: this.e0 << n, e1: this.e1 << n,
            e2: this.e2 << n, e3: this.e3 << n
        }
    }

    /// Element-wise arithmetic right shift.
    pub func shift_right(this, n: I32) -> I32x4 {
        return I32x4 {
            e0: this.e0 >> n, e1: this.e1 >> n,
            e2: this.e2 >> n, e3: this.e3 >> n
        }
    }

    // -- Horizontal reductions --

    /// Sum of all lanes.
    pub func sum(this) -> I32 {
        return this.e0 + this.e1 + this.e2 + this.e3
    }

    /// Product of all lanes.
    pub func product(this) -> I32 {
        return this.e0 * this.e1 * this.e2 * this.e3
    }

    /// Minimum lane value.
    pub func hmin(this) -> I32 {
        var m: I32 = this.e0
        if this.e1 < m { m = this.e1 }
        if this.e2 < m { m = this.e2 }
        if this.e3 < m { m = this.e3 }
        return m
    }

    /// Maximum lane value.
    pub func hmax(this) -> I32 {
        var m: I32 = this.e0
        if this.e1 > m { m = this.e1 }
        if this.e2 > m { m = this.e2 }
        if this.e3 > m { m = this.e3 }
        return m
    }

    /// Element-wise minimum.
    pub func min(this, other: I32x4) -> I32x4 {
        var r0: I32 = this.e0; if other.e0 < r0 { r0 = other.e0 }
        var r1: I32 = this.e1; if other.e1 < r1 { r1 = other.e1 }
        var r2: I32 = this.e2; if other.e2 < r2 { r2 = other.e2 }
        var r3: I32 = this.e3; if other.e3 < r3 { r3 = other.e3 }
        return I32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
    }

    /// Element-wise maximum.
    pub func max(this, other: I32x4) -> I32x4 {
        var r0: I32 = this.e0; if other.e0 > r0 { r0 = other.e0 }
        var r1: I32 = this.e1; if other.e1 > r1 { r1 = other.e1 }
        var r2: I32 = this.e2; if other.e2 > r2 { r2 = other.e2 }
        var r3: I32 = this.e3; if other.e3 > r3 { r3 = other.e3 }
        return I32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
    }
}

/// Select lanes from `if_true` or `if_false` based on mask.
pub func select(mask: Mask4, if_true: I32x4, if_false: I32x4) -> I32x4 {
    var r0: I32 = if_false.e0; if mask.m0 { r0 = if_true.e0 }
    var r1: I32 = if_false.e1; if mask.m1 { r1 = if_true.e1 }
    var r2: I32 = if_false.e2; if mask.m2 { r2 = if_true.e2 }
    var r3: I32 = if_false.e3; if mask.m3 { r3 = if_true.e3 }
    return I32x4 { e0: r0, e1: r1, e2: r2, e3: r3 }
}
