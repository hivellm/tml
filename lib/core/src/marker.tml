//! Marker behaviors for compile-time type properties.
//!
//! This module provides "marker" behaviors - behaviors that have no methods
//! but convey information about type properties to the compiler. These are
//! used to enforce safety invariants at compile time.
//!
//! # Available Markers
//!
//! | Marker | Description |
//! |--------|-------------|
//! | [`Send`] | Types that can be transferred across thread boundaries |
//! | [`Sync`] | Types that can be shared between threads via references |
//! | [`Sized`] | Types with a known size at compile time |
//! | [`Unpin`] | Types that can be safely moved after being pinned (re-exported from `core::pin`) |
//! | [`PhantomData`] | Zero-sized type for marking unused type parameters |
//! | [`PhantomPinned`] | Marker type that opts out of Unpin |
//!
//! # Thread Safety: Send and Sync
//!
//! [`Send`] and [`Sync`] are the foundation of TML's thread safety guarantees:
//!
//! - **`Send`**: A type is `Send` if it can be safely moved to another thread.
//!   Most types are `Send`. Notable exceptions include `Rc[T]` (use `Arc[T]`
//!   for thread-safe reference counting).
//!
//! - **`Sync`**: A type is `Sync` if `ref T` is `Send` - that is, if shared
//!   references can be safely used from multiple threads. Types with interior
//!   mutability like `Cell[T]` and `RefCell[T]` are not `Sync` because their
//!   mutation isn't synchronized.
//!
//! ```tml
//! // Most primitives are both Send and Sync
//! let x: I64 = 42  // Send + Sync
//!
//! // Cell provides interior mutability but is NOT Sync
//! let cell = Cell::new(42)  // Send, but NOT Sync
//! ```
//!
//! # Sized Types
//!
//! [`Sized`] marks types whose size is known at compile time. Almost all types
//! are `Sized`. The main exceptions are:
//!
//! - Trait objects (`dyn Trait`)
//! - Slices (`[T]` without a length)
//!
//! Most generic bounds implicitly require `Sized` unless you write `T: ?Sized`.
//!
//! # Unpin
//!
//! [`Unpin`] indicates that a type can be safely moved even after being pinned.
//! Most types are `Unpin`. The main exception is self-referential types used
//! in async code. The `Unpin` behavior is defined in `core::pin` and re-exported
//! here for convenience.

// ============================================================================
// Send Behavior (Marker)
// ============================================================================

/// Marker behavior for types that can be safely sent between threads.
///
/// Types implementing `Send` can have their ownership transferred to another
/// thread. This is fundamental for message passing and thread spawning.
///
/// # Automatic Implementation
///
/// Most types are automatically `Send`. A type is `Send` if all of its
/// components are `Send`.
///
/// # Types That Are NOT Send
///
/// - `Rc[T]` - Use `Arc[T]` for thread-safe reference counting
/// - Types containing raw pointers (unless explicitly marked)
/// - Types with thread-local state
///
/// # Examples
///
/// ```tml
/// // Primitives are Send
/// let x: I64 = 42
/// spawn(do() { use_value(x) })  // OK: I64 is Send
///
/// // Rc is NOT Send
/// let rc = Rc::new(42)
/// spawn(do() { use_rc(rc) })  // ERROR: Rc is not Send
/// ```
pub behavior Send {
    // No methods - this is a marker behavior
}

// ============================================================================
// Sync Behavior (Marker)
// ============================================================================

/// Marker behavior for types that can be safely shared between threads.
///
/// Types implementing `Sync` can have shared references (`ref T`) used by
/// multiple threads concurrently. This is the foundation for safe concurrent
/// read access.
///
/// # Key Property
///
/// If `T: Sync`, then `ref T: Send` - a reference to `T` can be sent to
/// another thread.
///
/// # Automatic Implementation
///
/// Most types are automatically `Sync`. A type is `Sync` if all of its
/// components are `Sync`.
///
/// # Types That Are NOT Sync
///
/// - `Cell[T]` - Interior mutability without synchronization
/// - `RefCell[T]` - Runtime borrow checking, not thread-safe
/// - `Rc[T]` - Non-atomic reference counting
///
/// For thread-safe alternatives, use:
/// - `Mutex[T]` or `RwLock[T]` for synchronized access
/// - `Arc[T]` for thread-safe reference counting
///
/// # Examples
///
/// ```tml
/// // Primitives are Sync - can be shared via references
/// let x: I64 = 42
/// let r: ref I64 = ref x
/// // r can be used from multiple threads
///
/// // Cell is NOT Sync
/// let cell = Cell::new(42)
/// // Cannot share &cell between threads
/// ```
pub behavior Sync {
    // No methods - this is a marker behavior
}

// ============================================================================
// Sized Behavior (Marker)
// ============================================================================

/// Marker behavior for types with a known size at compile time.
///
/// Types implementing `Sized` have a size that can be determined at compile
/// time. This is required for stack allocation, struct fields, and most
/// generic type parameters.
///
/// # Automatic Implementation
///
/// Almost all types are `Sized`. The exceptions are:
///
/// - **Slices** (`[T]`) - Size depends on runtime length
/// - **Trait objects** (`dyn Trait`) - Size depends on concrete type
/// - **Str** (as a slice type) - Size depends on string length
///
/// # Implicit Bound
///
/// All generic type parameters have an implicit `Sized` bound. To accept
/// unsized types, use `?Sized`:
///
/// ```tml
/// // This function only accepts Sized types
/// func foo[T](x: T) { ... }
///
/// // This function accepts both Sized and unsized types
/// func bar[T: ?Sized](x: ref T) { ... }
/// ```
///
/// Note that unsized types can only be used behind a pointer or reference.
pub behavior Sized {
    // No methods - this is a marker behavior
}

// Note: Unpin behavior is defined in core::pin along with the Pin type.
// Re-export it here for convenience.
pub use core::pin::Unpin

// ============================================================================
// Send implementations for primitives
// ============================================================================

impl Send for I8 {}
impl Send for I16 {}
impl Send for I32 {}
impl Send for I64 {}
impl Send for U8 {}
impl Send for U16 {}
impl Send for U32 {}
impl Send for U64 {}
impl Send for F32 {}
impl Send for F64 {}
impl Send for Bool {}
impl Send for Str {}

// ============================================================================
// Sync implementations for primitives
// ============================================================================

impl Sync for I8 {}
impl Sync for I16 {}
impl Sync for I32 {}
impl Sync for I64 {}
impl Sync for U8 {}
impl Sync for U16 {}
impl Sync for U32 {}
impl Sync for U64 {}
impl Sync for F32 {}
impl Sync for F64 {}
impl Sync for Bool {}
impl Sync for Str {}

// ============================================================================
// Sized implementations for primitives
// ============================================================================

impl Sized for I8 {}
impl Sized for I16 {}
impl Sized for I32 {}
impl Sized for I64 {}
impl Sized for U8 {}
impl Sized for U16 {}
impl Sized for U32 {}
impl Sized for U64 {}
impl Sized for F32 {}
impl Sized for F64 {}
impl Sized for Bool {}
impl Sized for Str {}

// Note: Unpin implementations for primitives are in core::pin

// ============================================================================
// Send/Sync for Maybe[T] and Outcome[T, E]
// ============================================================================

impl[T: Send] Send for Maybe[T] {}
impl[T: Sync] Sync for Maybe[T] {}
impl[T: Sized] Sized for Maybe[T] {}
// Note: Unpin impl for Maybe is in core::pin

impl[T: Send, E: Send] Send for Outcome[T, E] {}
impl[T: Sync, E: Sync] Sync for Outcome[T, E] {}
impl[T: Sized, E: Sized] Sized for Outcome[T, E] {}
// Note: Unpin impl for Outcome is in core::pin

// ============================================================================
// PhantomData - Zero-sized type for marking unused type parameters
// ============================================================================

/// Zero-sized type used to mark types that "logically" own or reference data
/// of type `T`, even though they don't physically contain it.
///
/// # Use Cases
///
/// ## 1. Unused Type Parameters
///
/// When a type has a type parameter that isn't used in any field:
///
/// ```tml
/// use core::marker::PhantomData
///
/// // TypeId is parameterized by T but doesn't store T
/// pub type TypeId[T] {
///     id: U64,
///     _marker: PhantomData[T]
/// }
/// ```
///
/// ## 2. Indicating Ownership
///
/// When a type owns data through a raw pointer:
///
/// ```tml
/// pub type RawVec[T] {
///     ptr: RawPtr[T],      // Doesn't express ownership
///     cap: I64,
///     _marker: PhantomData[T]  // Indicates we logically own T
/// }
/// ```
///
/// ## 3. Variance and Lifetime Markers
///
/// PhantomData affects how a type relates to its type parameter for the
/// purposes of variance and drop checking.
///
/// # Thread Safety
///
/// PhantomData inherits the Send/Sync properties of its type parameter:
/// - `PhantomData[T]: Send` if `T: Send`
/// - `PhantomData[T]: Sync` if `T: Sync`
///
/// # Memory Layout
///
/// PhantomData has zero size and zero alignment requirements. Adding a
/// `PhantomData[T]` field to a struct doesn't change its size.
///
/// # Examples
///
/// ```tml
/// use core::marker::PhantomData
///
/// // A handle that's parameterized by a resource type
/// pub type Handle[R] {
///     id: I64,
///     _phantom: PhantomData[R]
/// }
///
/// impl[R] Handle[R] {
///     pub func new(id: I64) -> Handle[R] {
///         return Handle {
///             id: id,
///             _phantom: PhantomData
///         }
///     }
/// }
///
/// // Different handle types are incompatible
/// type FileResource {}
/// type NetworkResource {}
///
/// let file_handle: Handle[FileResource] = Handle::new(1)
/// let net_handle: Handle[NetworkResource] = Handle::new(2)
/// // file_handle and net_handle are different types!
/// ```
pub type PhantomData[T] {
    // Zero-sized - no fields needed
    // The compiler treats this specially
}

impl[T] PhantomData[T] {
    /// Creates a new PhantomData instance.
    ///
    /// This is a zero-cost operation since PhantomData has no data.
    pub func new() -> PhantomData[T] {
        return PhantomData[T] {}
    }
}

impl[T] Default for PhantomData[T] {
    /// Returns the default value of PhantomData.
    ///
    /// Since PhantomData has no data, this simply creates an instance.
    pub func default() -> PhantomData[T] {
        return PhantomData[T] {}
    }
}

impl[T] Duplicate for PhantomData[T] {
    /// Creates a duplicate of this PhantomData.
    ///
    /// Since PhantomData has no data, this is a no-op.
    pub func duplicate(this) -> PhantomData[T] {
        return PhantomData[T] {}
    }
}

impl[T] Copy for PhantomData[T] {}

// PhantomData inherits marker traits from T
impl[T: Send] Send for PhantomData[T] {}
impl[T: Sync] Sync for PhantomData[T] {}
impl[T] Sized for PhantomData[T] {}
// Note: Unpin impl for PhantomData is in core::pin

// ============================================================================
// PhantomPinned - Marker type that opts out of Unpin
// ============================================================================

/// A marker type which does not implement `Unpin`.
///
/// If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.
/// This is useful for creating self-referential structs that must not be moved
/// in memory once pinned.
///
/// # Use Cases
///
/// ## 1. Self-Referential Structures
///
/// When you have a struct that contains pointers to itself:
///
/// ```tml
/// use core::marker::PhantomPinned
///
/// pub type SelfRef {
///     data: I64,
///     ptr: RawPtr[I64],  // Points to `data`
///     _pinned: PhantomPinned
/// }
/// ```
///
/// ## 2. Async Futures
///
/// Futures that hold references across `.await` points need to be pinned:
///
/// ```tml
/// pub type MyFuture {
///     state: I32,
///     // Internal state may contain self-references
///     _pinned: PhantomPinned
/// }
/// ```
///
/// # Important
///
/// - Types containing `PhantomPinned` cannot be moved after being pinned
/// - Use `Pin[Heap[T]]` to create a pinned, heap-allocated instance
/// - Stack pinning requires care with lifetimes and drop guarantees
///
/// # Thread Safety
///
/// `PhantomPinned` is both `Send` and `Sync` since it contains no data.
/// However, the type containing it may not be, depending on its other fields.
///
/// # See Also
///
/// - [`Pin`](core::pin::Pin): The pinning wrapper type
/// - [`Unpin`]: The trait that `PhantomPinned` deliberately does not implement
pub type PhantomPinned {
    // Empty - this is a marker type
}

impl PhantomPinned {
    /// Creates a new `PhantomPinned` instance.
    pub func new() -> PhantomPinned {
        return PhantomPinned {}
    }
}

impl Default for PhantomPinned {
    /// Returns the default value of PhantomPinned.
    pub func default() -> PhantomPinned {
        return PhantomPinned {}
    }
}

impl Duplicate for PhantomPinned {
    /// Creates a duplicate of this PhantomPinned.
    ///
    /// Since PhantomPinned has no data, this is a no-op.
    pub func duplicate(this) -> PhantomPinned {
        return PhantomPinned {}
    }
}

impl Copy for PhantomPinned {}

// PhantomPinned is Send and Sync (no data)
impl Send for PhantomPinned {}
impl Sync for PhantomPinned {}
impl Sized for PhantomPinned {}

impl Display for PhantomPinned {
    pub func to_string(this) -> Str {
        return "PhantomPinned"
    }
}

impl Debug for PhantomPinned {
    pub func debug_string(this) -> Str {
        return "PhantomPinned"
    }
}

// NOTE: PhantomPinned explicitly does NOT implement Unpin
// This is intentional - it's the whole purpose of this type
