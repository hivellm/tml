//! Internal helper functions for formatting.
//!
//! This module provides helper functions used by the formatting implementations.
//! These are internal utilities and should not be used directly.

// ============================================================================
// Binary conversion helpers
// ============================================================================

/// Converts a U8 to its binary string representation (without prefix).
pub func u8_to_binary_str(n: U8) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U8 = n
    loop {
        if val == 0 { return result }
        if val % 2 == 1 {
            result = "1" + result
        } else {
            result = "0" + result
        }
        val = val / 2
    }
}

/// Converts a U16 to its binary string representation (without prefix).
pub func u16_to_binary_str(n: U16) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U16 = n
    loop {
        if val == 0 { return result }
        if val % 2 == 1 {
            result = "1" + result
        } else {
            result = "0" + result
        }
        val = val / 2
    }
}

/// Converts a U32 to its binary string representation (without prefix).
pub func u32_to_binary_str(n: U32) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U32 = n
    loop {
        if val == 0 { return result }
        if val % 2 == 1 {
            result = "1" + result
        } else {
            result = "0" + result
        }
        val = val / 2
    }
}

/// Converts a U64 to its binary string representation (without prefix).
pub func u64_to_binary_str(n: U64) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop {
        if val == 0 { return result }
        if val % 2 == 1 {
            result = "1" + result
        } else {
            result = "0" + result
        }
        val = val / 2
    }
}

/// Converts an I8 to its binary string representation (two's complement).
pub func i8_to_binary_str(n: I8) -> Str {
    return u8_to_binary_str(n as U8)
}

/// Converts an I16 to its binary string representation (two's complement).
pub func i16_to_binary_str(n: I16) -> Str {
    return u16_to_binary_str(n as U16)
}

/// Converts an I32 to its binary string representation (two's complement).
pub func i32_to_binary_str(n: I32) -> Str {
    return u32_to_binary_str(n as U32)
}

/// Converts an I64 to its binary string representation (two's complement).
pub func i64_to_binary_str(n: I64) -> Str {
    return u64_to_binary_str(n as U64)
}

// ============================================================================
// Octal conversion helpers
// ============================================================================

/// Converts a U64 to its octal string representation (without prefix).
pub func u64_to_octal_str(n: U64) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop {
        if val == 0 { return result }
        let digit: U64 = val % 8
        result = digit_to_char(digit as I32) + result
        val = val / 8
    }
}

// ============================================================================
// Hexadecimal conversion helpers
// ============================================================================

/// Converts a U64 to its hexadecimal string representation (without prefix).
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
pub func u64_to_hex_str(n: U64, upper: Bool) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop {
        if val == 0 { return result }
        let digit: U64 = val % 16
        result = hex_digit(digit as I32, upper) + result
        val = val / 16
    }
}

// ============================================================================
// Character conversion helpers
// ============================================================================

/// Converts a decimal digit (0-9) to its character representation.
pub func digit_to_char(d: I32) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        _ => return "?"
    }
}

/// Converts a hexadecimal digit (0-15) to its character representation.
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
pub func hex_digit(d: I32, upper: Bool) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        10 => { if upper { return "A" } else { return "a" } },
        11 => { if upper { return "B" } else { return "b" } },
        12 => { if upper { return "C" } else { return "c" } },
        13 => { if upper { return "D" } else { return "d" } },
        14 => { if upper { return "E" } else { return "e" } },
        15 => { if upper { return "F" } else { return "f" } },
        _ => return "?"
    }
}

// ============================================================================
// String utilities
// ============================================================================

/// Returns the length of a string.
pub func string_len(s: Str) -> I64 {
    return lowlevel { str_len(s) }
}

/// Converts a character to a string.
pub func char_to_str(c: Char) -> Str {
    return lowlevel { char_to_string(c) }
}

/// Repeats a string n times.
pub func repeat_string(s: Str, n: I64) -> Str {
    if n <= 0 {
        return ""
    }
    var result: Str = ""
    var i: I64 = 0
    loop {
        if i >= n {
            return result
        }
        result = result + s
        i = i + 1
    }
}

/// Returns a slice of a string from start to end (exclusive).
pub func string_slice(s: Str, start: I64, end: I64) -> Str {
    return lowlevel { str_slice(s, start, end) }
}

/// Pads a string on the left to reach the specified width.
pub func pad_left(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return repeat_string(fill, pad_count) + s
}

/// Pads a string on the right to reach the specified width.
pub func pad_right(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return s + repeat_string(fill, pad_count)
}

/// Pads a string on both sides to center it within the specified width.
pub func pad_center(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_total: I64 = width - len
    let left_pad: I64 = pad_total / 2
    let right_pad: I64 = pad_total - left_pad
    return repeat_string(fill, left_pad) + s + repeat_string(fill, right_pad)
}

// ============================================================================
// Number formatting utilities
// ============================================================================

/// Formats an integer with a sign prefix based on sign mode.
/// sign_mode: 0 = minus only, 1 = plus/minus, 2 = space/minus
pub func format_with_sign(value: I64, sign_mode: I32) -> Str {
    let is_negative: Bool = value < 0
    let abs_value: I64 = if is_negative { 0 - value } else { value }
    let num_str: Str = lowlevel { i64_to_string(abs_value) }

    when sign_mode {
        0 => {
            // Minus only
            if is_negative {
                return "-" + num_str
            } else {
                return num_str
            }
        },
        1 => {
            // Always show sign
            if is_negative {
                return "-" + num_str
            } else {
                return "+" + num_str
            }
        },
        2 => {
            // Space for positive
            if is_negative {
                return "-" + num_str
            } else {
                return " " + num_str
            }
        },
        _ => return num_str
    }
}

/// Escapes special characters in a string for debug output.
pub func escape_string(s: Str) -> Str {
    // For now, just return the string as-is
    // A full implementation would escape \n, \t, \r, \\, \", etc.
    return s
}

/// Escapes a single character for debug output.
pub func escape_char(c: Char) -> Str {
    // For now, just convert to string
    // A full implementation would escape special characters
    return lowlevel { char_to_string(c) }
}
