//! Internal helper functions for formatting.
//!
//! This module provides helper functions used by the formatting implementations.
//! These are internal utilities and should not be used directly.

// ============================================================================
// Integer to string conversion (pure TML)
// ============================================================================

/// Converts an I64 to its decimal string representation.
/// Pure TML: extracts digits via % 10 and builds string with concatenation.
pub func i64_to_str(value: I64) -> Str {
    if value == 0 {
        return "0"
    }

    let is_negative: Bool = value < 0
    var v: I64 = value
    let min_i64: I64 = -9223372036854775807 - 1

    // Handle MIN_VALUE specially: can't negate it
    if is_negative and v == min_i64 {
        // -9223372036854775808 = "-9223372036854775808"
        return "-9223372036854775808"
    }

    if is_negative {
        v = 0 - v
    }

    // Extract digits and build string (digits come out reversed)
    var result: Str = ""
    loop (v > 0) {
        let digit: I64 = v % 10
        v = v / 10
        result = i64_digit_char(digit) + result
    }

    if is_negative {
        result = "-" + result
    }
    return result
}

/// Converts a U64 to its decimal string representation.
pub func u64_to_str(value: U64) -> Str {
    if value == 0 {
        return "0"
    }

    var result: Str = ""
    var v: U64 = value
    loop (v > 0) {
        let digit: U64 = v % 10
        v = v / 10
        result = u64_digit_char(digit) + result
    }
    return result
}

// Internal: convert a digit 0-9 (as I64) to its string character
func i64_digit_char(d: I64) -> Str {
    return digit_to_char(d as I32)
}

// Internal: convert a digit 0-9 (as U64) to its string character
func u64_digit_char(d: U64) -> Str {
    return digit_to_char(d as I32)
}

/// Converts an I8 to string (widen to I64, then convert).
pub func i8_to_str(value: I8) -> Str {
    return i64_to_str(value as I64)
}

/// Converts an I16 to string.
pub func i16_to_str(value: I16) -> Str {
    return i64_to_str(value as I64)
}

/// Converts an I32 to string.
pub func i32_to_str(value: I32) -> Str {
    return i64_to_str(value as I64)
}

/// Converts a U8 to string.
pub func u8_to_str(value: U8) -> Str {
    return u64_to_str(value as U64)
}

/// Converts a U16 to string.
pub func u16_to_str(value: U16) -> Str {
    return u64_to_str(value as U64)
}

/// Converts a U32 to string.
pub func u32_to_str(value: U32) -> Str {
    return u64_to_str(value as U64)
}

// ============================================================================
// Binary conversion helpers
// ============================================================================

/// Converts a U8 to its binary string representation (without prefix).
pub func u8_to_binary_str(n: U8) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U16 to its binary string representation (without prefix).
pub func u16_to_binary_str(n: U16) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U32 to its binary string representation (without prefix).
pub func u32_to_binary_str(n: U32) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U64 to its binary string representation (without prefix).
pub func u64_to_binary_str(n: U64) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop (val != 0) {
        if val % 2 == 1 {
            result = "1" + result
        } else {
            result = "0" + result
        }
        val = val / 2
    }
    return result
}

/// Converts an I8 to its binary string representation (two's complement).
pub func i8_to_binary_str(n: I8) -> Str {
    return u8_to_binary_str(n as U8)
}

/// Converts an I16 to its binary string representation (two's complement).
pub func i16_to_binary_str(n: I16) -> Str {
    return u16_to_binary_str(n as U16)
}

/// Converts an I32 to its binary string representation (two's complement).
pub func i32_to_binary_str(n: I32) -> Str {
    return u32_to_binary_str(n as U32)
}

/// Converts an I64 to its binary string representation (two's complement).
pub func i64_to_binary_str(n: I64) -> Str {
    return u64_to_binary_str(n as U64)
}

// ============================================================================
// Octal conversion helpers
// ============================================================================

/// Converts a U64 to its octal string representation (without prefix).
pub func u64_to_octal_str(n: U64) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop (val != 0) {
        let digit: U64 = val % 8
        result = digit_to_char(digit as I32) + result
        val = val / 8
    }
    return result
}

// ============================================================================
// Hexadecimal conversion helpers
// ============================================================================

/// Converts a U64 to its hexadecimal string representation (without prefix).
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
pub func u64_to_hex_str(n: U64, upper: Bool) -> Str {
    if n == 0 { return "0" }
    var result: Str = ""
    var val: U64 = n
    loop (val != 0) {
        let digit: U64 = val % 16
        result = hex_digit(digit as I32, upper) + result
        val = val / 16
    }
    return result
}

// ============================================================================
// Character conversion helpers
// ============================================================================

/// Converts a decimal digit (0-9) to its character representation.
pub func digit_to_char(d: I32) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        _ => return "?"
    }
}

/// Converts a hexadecimal digit (0-15) to its character representation.
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
pub func hex_digit(d: I32, upper: Bool) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        10 => { if upper { return "A" } else { return "a" } },
        11 => { if upper { return "B" } else { return "b" } },
        12 => { if upper { return "C" } else { return "c" } },
        13 => { if upper { return "D" } else { return "d" } },
        14 => { if upper { return "E" } else { return "e" } },
        15 => { if upper { return "F" } else { return "f" } },
        _ => return "?"
    }
}

use core::str

// ============================================================================
// String utilities
// ============================================================================

/// Returns the length of a string.
pub func string_len(s: Str) -> I64 {
    return str::len(s)
}

/// Converts a character (byte value) to a single-character string (pure TML).
pub func char_to_str(c: Char) -> Str {
    let code: U32 = c as U32
    let byte: U8 = code as U8
    let buf: *Unit = lowlevel { mem_alloc(2) }
    let p0: *U8 = buf as *U8
    lowlevel { ptr_write[U8](p0, byte) }
    let p1: *U8 = (buf as I64 + 1) as *U8
    lowlevel { ptr_write[U8](p1, 0 as U8) }
    return buf as Str
}

/// Repeats a string n times.
pub func repeat_string(s: Str, n: I64) -> Str {
    if n <= 0 {
        return ""
    }
    var result: Str = ""
    var i: I64 = 0
    loop (i < n) {
        result = result + s
        i = i + 1
    }
    return result
}

/// Returns a slice of a string from start to end (exclusive).
pub func string_slice(s: Str, start: I64, end: I64) -> Str {
    return str::substring(s, start, end)
}

/// Pads a string on the left to reach the specified width.
pub func pad_left(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return repeat_string(fill, pad_count) + s
}

/// Pads a string on the right to reach the specified width.
pub func pad_right(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return s + repeat_string(fill, pad_count)
}

/// Pads a string on both sides to center it within the specified width.
pub func pad_center(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_total: I64 = width - len
    let left_pad: I64 = pad_total / 2
    let right_pad: I64 = pad_total - left_pad
    return repeat_string(fill, left_pad) + s + repeat_string(fill, right_pad)
}

// ============================================================================
// Number formatting utilities
// ============================================================================

/// Formats an integer with a sign prefix based on sign mode.
/// sign_mode: 0 = minus only, 1 = plus/minus, 2 = space/minus
pub func format_with_sign(value: I64, sign_mode: I32) -> Str {
    let is_negative: Bool = value < 0
    let abs_value: I64 = if is_negative { 0 - value } else { value }
    let num_str: Str = i64_to_str(abs_value)

    when sign_mode {
        0 => {
            // Minus only
            if is_negative {
                return "-" + num_str
            } else {
                return num_str
            }
        },
        1 => {
            // Always show sign
            if is_negative {
                return "-" + num_str
            } else {
                return "+" + num_str
            }
        },
        2 => {
            // Space for positive
            if is_negative {
                return "-" + num_str
            } else {
                return " " + num_str
            }
        },
        _ => return num_str
    }
}

/// Escapes special characters in a string for debug output.
pub func escape_string(s: Str) -> Str {
    // For now, just return the string as-is
    // A full implementation would escape \n, \t, \r, \\, \", etc.
    return s
}

/// Escapes a single character for debug output.
pub func escape_char(c: Char) -> Str {
    // For now, just convert to string
    // A full implementation would escape special characters
    return char_to_str(c)
}
