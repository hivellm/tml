//! Internal helper functions for formatting.
//!
//! This module provides helper functions used by the formatting implementations.
//! These are internal utilities and should not be used directly.

// ============================================================================
// Integer to string conversion (pure TML)
// ============================================================================

/// Converts an I64 to its decimal string representation.
/// Uses a single heap allocation by counting digits first.
@allocates
pub func i64_to_str(value: I64) -> Str {
    if value == 0 {
        return "0"
    }

    let is_negative: Bool = value < 0
    var v: I64 = value
    let min_i64: I64 = -9223372036854775807 - 1

    // Handle MIN_VALUE specially: can't negate it
    if is_negative and v == min_i64 {
        return "-9223372036854775808"
    }

    if is_negative {
        v = 0 - v
    }

    // Count digits first to allocate exactly once
    var num_digits: I64 = 0
    var tmp: I64 = v
    loop (tmp > 0) {
        num_digits = num_digits + 1
        tmp = tmp / 10
    }

    let total_len: I64 = if is_negative { num_digits + 1 } else { num_digits }
    let buf: *U8 = lowlevel { mem_alloc(total_len + 1) } as *U8
    let buf_addr: I64 = buf as I64

    // Write null terminator
    lowlevel { ptr_write[U8]((buf_addr + total_len) as *U8, 0 as U8) }

    // Write digits backwards from the end
    var pos: I64 = total_len - 1
    loop (v > 0) {
        let digit: U8 = (v % 10) as U8 + (48 as U8)
        lowlevel { ptr_write[U8]((buf_addr + pos) as *U8, digit) }
        v = v / 10
        pos = pos - 1
    }

    // Write sign if negative
    if is_negative {
        lowlevel { ptr_write[U8](buf, 45 as U8) }
    }

    return buf as Str
}

/// Converts a U64 to its decimal string representation.
/// Uses a single heap allocation by counting digits first.
@allocates
pub func u64_to_str(value: U64) -> Str {
    if value == 0 {
        return "0"
    }

    // Count digits first
    var num_digits: I64 = 0
    var tmp: U64 = value
    loop (tmp > 0) {
        num_digits = num_digits + 1
        tmp = tmp / 10
    }

    let buf: *U8 = lowlevel { mem_alloc(num_digits + 1) } as *U8
    let buf_addr: I64 = buf as I64

    // Write null terminator
    lowlevel { ptr_write[U8]((buf_addr + num_digits) as *U8, 0 as U8) }

    // Write digits backwards
    var pos: I64 = num_digits - 1
    var v: U64 = value
    loop (v > 0) {
        let digit: U8 = (v % 10) as U8 + (48 as U8)
        lowlevel { ptr_write[U8]((buf_addr + pos) as *U8, digit) }
        v = v / 10
        pos = pos - 1
    }

    return buf as Str
}

// Internal: convert a digit 0-9 (as I64) to its string character
func i64_digit_char(d: I64) -> Str {
    return digit_to_char(d as I32)
}

// Internal: convert a digit 0-9 (as U64) to its string character
func u64_digit_char(d: U64) -> Str {
    return digit_to_char(d as I32)
}

/// Converts an I8 to string (widen to I64, then convert).
@allocates
pub func i8_to_str(value: I8) -> Str {
    return i64_to_str(value as I64)
}

/// Converts an I16 to string.
@allocates
pub func i16_to_str(value: I16) -> Str {
    return i64_to_str(value as I64)
}

/// Converts an I32 to string.
@allocates
pub func i32_to_str(value: I32) -> Str {
    return i64_to_str(value as I64)
}

/// Converts a U8 to string.
@allocates
pub func u8_to_str(value: U8) -> Str {
    return u64_to_str(value as U64)
}

/// Converts a U16 to string.
@allocates
pub func u16_to_str(value: U16) -> Str {
    return u64_to_str(value as U64)
}

/// Converts a U32 to string.
@allocates
pub func u32_to_str(value: U32) -> Str {
    return u64_to_str(value as U64)
}

// ============================================================================
// Binary conversion helpers
// ============================================================================

/// Converts a U8 to its binary string representation (without prefix).
@allocates
pub func u8_to_binary_str(n: U8) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U16 to its binary string representation (without prefix).
@allocates
pub func u16_to_binary_str(n: U16) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U32 to its binary string representation (without prefix).
@allocates
pub func u32_to_binary_str(n: U32) -> Str {
    return u64_to_binary_str(n as U64)
}

/// Converts a U64 to its binary string representation (without prefix).
/// Uses a single allocation with backwards digit writing.
@allocates
pub func u64_to_binary_str(n: U64) -> Str {
    if n == 0 { return "0" }

    // Count bits needed (max 64)
    var num_bits: I64 = 0
    var tmp: U64 = n
    loop (tmp != 0) {
        num_bits = num_bits + 1
        tmp = tmp >> 1
    }

    let buf: *U8 = lowlevel { mem_alloc(num_bits + 1) } as *U8
    let buf_addr: I64 = buf as I64

    // Write null terminator
    lowlevel { ptr_write[U8]((buf_addr + num_bits) as *U8, 0 as U8) }

    // Write digits backwards
    var pos: I64 = num_bits - 1
    var val: U64 = n
    loop (val != 0) {
        let digit: U8 = ((val & 1) as U8) + (48 as U8)  // '0' = 48
        lowlevel { ptr_write[U8]((buf_addr + pos) as *U8, digit) }
        val = val >> 1
        pos = pos - 1
    }

    return buf as Str
}

/// Converts an I8 to its binary string representation (two's complement).
@allocates
pub func i8_to_binary_str(n: I8) -> Str {
    return u8_to_binary_str(n as U8)
}

/// Converts an I16 to its binary string representation (two's complement).
@allocates
pub func i16_to_binary_str(n: I16) -> Str {
    return u16_to_binary_str(n as U16)
}

/// Converts an I32 to its binary string representation (two's complement).
@allocates
pub func i32_to_binary_str(n: I32) -> Str {
    return u32_to_binary_str(n as U32)
}

/// Converts an I64 to its binary string representation (two's complement).
@allocates
pub func i64_to_binary_str(n: I64) -> Str {
    return u64_to_binary_str(n as U64)
}

// ============================================================================
// Octal conversion helpers
// ============================================================================

/// Converts a U64 to its octal string representation (without prefix).
/// Uses a single allocation with backwards digit writing.
@allocates
pub func u64_to_octal_str(n: U64) -> Str {
    if n == 0 { return "0" }

    // Count digits needed (max 22 for U64)
    var num_digits: I64 = 0
    var tmp: U64 = n
    loop (tmp != 0) {
        num_digits = num_digits + 1
        tmp = tmp >> 3
    }

    let buf: *U8 = lowlevel { mem_alloc(num_digits + 1) } as *U8
    let buf_addr: I64 = buf as I64

    // Write null terminator
    lowlevel { ptr_write[U8]((buf_addr + num_digits) as *U8, 0 as U8) }

    // Write digits backwards
    var pos: I64 = num_digits - 1
    var val: U64 = n
    loop (val != 0) {
        let digit: U8 = ((val & 7) as U8) + (48 as U8)  // '0' = 48
        lowlevel { ptr_write[U8]((buf_addr + pos) as *U8, digit) }
        val = val >> 3
        pos = pos - 1
    }

    return buf as Str
}

// ============================================================================
// Hexadecimal conversion helpers
// ============================================================================

/// Converts a U64 to its hexadecimal string representation (without prefix).
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
/// Uses a single allocation with backwards digit writing and lookup table.
@allocates
pub func u64_to_hex_str(n: U64, upper: Bool) -> Str {
    if n == 0 { return "0" }

    let table: Str = if upper { "0123456789ABCDEF" } else { "0123456789abcdef" }
    let table_addr: I64 = table as I64

    // Count digits needed (max 16 for U64)
    var num_digits: I64 = 0
    var tmp: U64 = n
    loop (tmp != 0) {
        num_digits = num_digits + 1
        tmp = tmp >> 4
    }

    let buf: *U8 = lowlevel { mem_alloc(num_digits + 1) } as *U8
    let buf_addr: I64 = buf as I64

    // Write null terminator
    lowlevel { ptr_write[U8]((buf_addr + num_digits) as *U8, 0 as U8) }

    // Write digits backwards using lookup table
    var pos: I64 = num_digits - 1
    var val: U64 = n
    loop (val != 0) {
        let digit: U8 = lowlevel { ptr_read[U8]((table_addr + (val & 15) as I64) as *U8) }
        lowlevel { ptr_write[U8]((buf_addr + pos) as *U8, digit) }
        val = val >> 4
        pos = pos - 1
    }

    return buf as Str
}

// ============================================================================
// Character conversion helpers
// ============================================================================

/// Converts a decimal digit (0-9) to its character representation.
@allocates
pub func digit_to_char(d: I32) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        _ => return "?"
    }
}

/// Converts a hexadecimal digit (0-15) to its character representation.
/// If `upper` is true, uses uppercase letters (A-F), otherwise lowercase (a-f).
@allocates
pub func hex_digit(d: I32, upper: Bool) -> Str {
    when d {
        0 => return "0",
        1 => return "1",
        2 => return "2",
        3 => return "3",
        4 => return "4",
        5 => return "5",
        6 => return "6",
        7 => return "7",
        8 => return "8",
        9 => return "9",
        10 => { if upper { return "A" } else { return "a" } },
        11 => { if upper { return "B" } else { return "b" } },
        12 => { if upper { return "C" } else { return "c" } },
        13 => { if upper { return "D" } else { return "d" } },
        14 => { if upper { return "E" } else { return "e" } },
        15 => { if upper { return "F" } else { return "f" } },
        _ => return "?"
    }
}

use core::str

// ============================================================================
// String utilities
// ============================================================================

/// Returns the length of a string.
pub func string_len(s: Str) -> I64 {
    return str::len(s)
}

/// Converts a character (byte value) to a single-character string (pure TML).
@allocates
pub func char_to_str(c: Char) -> Str {
    let code: U32 = c as U32
    let byte: U8 = code as U8
    let buf: *Unit = lowlevel { mem_alloc(2) }
    let p0: *U8 = buf as *U8
    lowlevel { ptr_write[U8](p0, byte) }
    let p1: *U8 = (buf as I64 + 1) as *U8
    lowlevel { ptr_write[U8](p1, 0 as U8) }
    return buf as Str
}

/// Repeats a string n times.
@allocates
pub func repeat_string(s: Str, n: I64) -> Str {
    if n <= 0 {
        return ""
    }
    var result: Str = ""
    var i: I64 = 0
    loop (i < n) {
        result = result + s
        i = i + 1
    }
    return result
}

/// Returns a slice of a string from start to end (exclusive).
@allocates
pub func string_slice(s: Str, start: I64, end: I64) -> Str {
    return str::substring(s, start, end)
}

/// Pads a string on the left to reach the specified width.
@allocates
pub func pad_left(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return repeat_string(fill, pad_count) + s
}

/// Pads a string on the right to reach the specified width.
@allocates
pub func pad_right(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_count: I64 = width - len
    return s + repeat_string(fill, pad_count)
}

/// Pads a string on both sides to center it within the specified width.
@allocates
pub func pad_center(s: Str, width: I64, fill: Str) -> Str {
    let len: I64 = string_len(s)
    if len >= width {
        return s
    }
    let pad_total: I64 = width - len
    let left_pad: I64 = pad_total / 2
    let right_pad: I64 = pad_total - left_pad
    return repeat_string(fill, left_pad) + s + repeat_string(fill, right_pad)
}

// ============================================================================
// Number formatting utilities
// ============================================================================

/// Formats an integer with a sign prefix based on sign mode.
/// sign_mode: 0 = minus only, 1 = plus/minus, 2 = space/minus
@allocates
pub func format_with_sign(value: I64, sign_mode: I32) -> Str {
    let is_negative: Bool = value < 0
    let abs_value: I64 = if is_negative { 0 - value } else { value }
    let num_str: Str = i64_to_str(abs_value)

    when sign_mode {
        0 => {
            // Minus only
            if is_negative {
                return "-" + num_str
            } else {
                return num_str
            }
        },
        1 => {
            // Always show sign
            if is_negative {
                return "-" + num_str
            } else {
                return "+" + num_str
            }
        },
        2 => {
            // Space for positive
            if is_negative {
                return "-" + num_str
            } else {
                return " " + num_str
            }
        },
        _ => return num_str
    }
}

/// Escapes special characters in a string for debug output.
@allocates
pub func escape_string(s: Str) -> Str {
    // For now, just return the string as-is
    // A full implementation would escape \n, \t, \r, \\, \", etc.
    return s
}

/// Escapes a single character for debug output.
@allocates
pub func escape_char(c: Char) -> Str {
    // For now, just convert to string
    // A full implementation would escape special characters
    return char_to_str(c)
}
