//! Compiler intrinsics.
//!
//! This module exposes low-level operations that are implemented directly
//! by the compiler. These are the primitive building blocks used to implement
//! higher-level operations in the standard library.
//!
//! **WARNING**: These functions are highly unsafe and should generally not be
//! used directly. Use the safe wrappers in other modules instead.
//!
//! # Categories
//!
//! ## Arithmetic Operations
//! - [`llvm_add`], [`llvm_sub`], [`llvm_mul`], [`llvm_div`], [`llvm_rem`]
//! - [`llvm_neg`] (unary negation)
//!
//! ## Comparison Operations
//! - [`llvm_eq`], [`llvm_ne`], [`llvm_lt`], [`llvm_le`], [`llvm_gt`], [`llvm_ge`]
//!
//! ## Bitwise Operations
//! - [`llvm_and`], [`llvm_or`], [`llvm_xor`], [`llvm_not`]
//! - [`llvm_shl`], [`llvm_shr`]
//!
//! ## Memory Operations
//! - [`ptr_read`], [`ptr_write`], [`ptr_offset`]
//! - [`copy_nonoverlapping`], [`copy`]
//!
//! ## Type Information
//! - [`size_of`], [`align_of`], [`type_id`]
//!
//! ## Unsafe Conversions
//! - [`transmute`]
//!
//! # Example (Internal Use Only)
//!
//! ```tml
//! // Inside core::ops - implementing Add for I32
//! impl Add for I32 {
//!     pub func add(this, other: I32) -> I32 {
//!         return lowlevel { llvm_add(this, other) }
//!     }
//! }
//! ```

// ============================================================================
// Arithmetic Intrinsics
// ============================================================================

/// Adds two values. Maps to LLVM `add` instruction.
/// For integers: wrapping addition (no overflow check).
/// For floats: IEEE 754 addition.
@intrinsic
pub func llvm_add[T](a: T, b: T) -> T

/// Subtracts b from a. Maps to LLVM `sub` instruction.
@intrinsic
pub func llvm_sub[T](a: T, b: T) -> T

/// Multiplies two values. Maps to LLVM `mul` instruction.
@intrinsic
pub func llvm_mul[T](a: T, b: T) -> T

/// Divides a by b. Maps to LLVM `sdiv`/`udiv`/`fdiv` instruction.
/// For integers: truncating division.
/// For floats: IEEE 754 division.
/// **WARNING**: Division by zero is undefined behavior.
@intrinsic
pub func llvm_div[T](a: T, b: T) -> T

/// Computes remainder of a divided by b. Maps to LLVM `srem`/`urem`/`frem`.
/// **WARNING**: Division by zero is undefined behavior.
@intrinsic
pub func llvm_rem[T](a: T, b: T) -> T

/// Negates a value. Maps to LLVM `sub 0, x` or `fneg`.
@intrinsic
pub func llvm_neg[T](a: T) -> T

// ============================================================================
// Comparison Intrinsics
// ============================================================================

/// Equality comparison. Maps to LLVM `icmp eq` or `fcmp oeq`.
@intrinsic
pub func llvm_eq[T](a: T, b: T) -> Bool

/// Inequality comparison. Maps to LLVM `icmp ne` or `fcmp one`.
@intrinsic
pub func llvm_ne[T](a: T, b: T) -> Bool

/// Less than comparison. Maps to LLVM `icmp slt/ult` or `fcmp olt`.
@intrinsic
pub func llvm_lt[T](a: T, b: T) -> Bool

/// Less than or equal. Maps to LLVM `icmp sle/ule` or `fcmp ole`.
@intrinsic
pub func llvm_le[T](a: T, b: T) -> Bool

/// Greater than comparison. Maps to LLVM `icmp sgt/ugt` or `fcmp ogt`.
@intrinsic
pub func llvm_gt[T](a: T, b: T) -> Bool

/// Greater than or equal. Maps to LLVM `icmp sge/uge` or `fcmp oge`.
@intrinsic
pub func llvm_ge[T](a: T, b: T) -> Bool

// ============================================================================
// Bitwise Intrinsics
// ============================================================================

/// Bitwise AND. Maps to LLVM `and` instruction.
@intrinsic
pub func llvm_and[T](a: T, b: T) -> T

/// Bitwise OR. Maps to LLVM `or` instruction.
@intrinsic
pub func llvm_or[T](a: T, b: T) -> T

/// Bitwise XOR. Maps to LLVM `xor` instruction.
@intrinsic
pub func llvm_xor[T](a: T, b: T) -> T

/// Bitwise NOT. Maps to LLVM `xor x, -1`.
@intrinsic
pub func llvm_not[T](a: T) -> T

/// Shift left. Maps to LLVM `shl` instruction.
@intrinsic
pub func llvm_shl[T](a: T, b: T) -> T

/// Shift right. Maps to LLVM `ashr` (signed) or `lshr` (unsigned).
@intrinsic
pub func llvm_shr[T](a: T, b: T) -> T

// ============================================================================
// Checked Arithmetic (returns Maybe[T])
// ============================================================================

/// Add with overflow check. Returns Nothing on overflow.
@intrinsic
pub func checked_add[T](a: T, b: T) -> Maybe[T]

/// Subtract with overflow check. Returns Nothing on overflow.
@intrinsic
pub func checked_sub[T](a: T, b: T) -> Maybe[T]

/// Multiply with overflow check. Returns Nothing on overflow.
@intrinsic
pub func checked_mul[T](a: T, b: T) -> Maybe[T]

/// Divide with zero check. Returns Nothing on division by zero.
@intrinsic
pub func checked_div[T](a: T, b: T) -> Maybe[T]

// ============================================================================
// Saturating Arithmetic
// ============================================================================

/// Add with saturation. Clamps to min/max on overflow.
@intrinsic
pub func saturating_add[T](a: T, b: T) -> T

/// Subtract with saturation. Clamps to min/max on overflow.
@intrinsic
pub func saturating_sub[T](a: T, b: T) -> T

/// Multiply with saturation. Clamps to min/max on overflow.
@intrinsic
pub func saturating_mul[T](a: T, b: T) -> T

// ============================================================================
// Slice Intrinsics (for use in lowlevel blocks)
// ============================================================================

/// Gets a reference to an element at index in a slice.
/// **UNSAFE**: Caller must ensure index is in bounds.
@intrinsic
pub func slice_get[T](data: ref T, index: I64) -> ref T

/// Gets a mutable reference to an element at index in a slice.
/// **UNSAFE**: Caller must ensure index is in bounds.
@intrinsic
pub func slice_get_mut[T](data: mut ref T, index: I64) -> mut ref T

/// Sets an element at index in a slice.
/// **UNSAFE**: Caller must ensure index is in bounds.
@intrinsic
pub func slice_set[T](data: mut ref T, index: I64, value: T)

/// Computes an offset pointer for slice splitting.
/// **UNSAFE**: Result must stay within allocated object or one past end.
@intrinsic
pub func slice_offset[T](data: ref T, count: I64) -> ref T

/// Swaps two elements in a slice.
/// **UNSAFE**: Caller must ensure both indices are in bounds.
@intrinsic
pub func slice_swap[T](data: mut ref T, a: I64, b: I64)

// ============================================================================
// Array Intrinsics (for use in lowlevel blocks)
// ============================================================================

/// Gets a pointer to the first element of an array.
/// Used by Array::as_slice() to create a slice view.
/// **UNSAFE**: Caller must ensure the array is valid.
@intrinsic
pub func array_as_ptr[T](data: T) -> ref T

/// Gets a mutable pointer to the first element of an array.
/// Used by Array::as_mut_slice() to create a mutable slice view.
/// **UNSAFE**: Caller must ensure the array is valid.
@intrinsic
pub func array_as_mut_ptr[T](data: T) -> mut ref T

/// Computes an offset pointer within an array.
/// Used for slice iteration and range operations.
/// **UNSAFE**: Result must stay within allocated object or one past end.
@intrinsic
pub func array_offset_ptr[T](data: ref T, count: I64) -> ref T

/// Computes a mutable offset pointer within an array.
/// **UNSAFE**: Result must stay within allocated object or one past end.
@intrinsic
pub func array_offset_mut_ptr[T](data: mut ref T, count: I64) -> mut ref T

// ============================================================================
// Memory Intrinsics
// ============================================================================

/// Reads the value at a raw pointer.
/// **UNSAFE**: Pointer must be valid and properly aligned.
@intrinsic
pub func ptr_read[T](ptr: Ptr[T]) -> T

/// Writes a value to a raw pointer.
/// **UNSAFE**: Pointer must be valid and properly aligned.
@intrinsic
pub func ptr_write[T](ptr: Ptr[T], val: T)

/// Computes an offset from a pointer.
/// **UNSAFE**: Result must stay within allocated object or one past end.
@intrinsic
pub func ptr_offset[T](ptr: Ptr[T], count: I64) -> Ptr[T]

/// Copies bytes from src to dst. Regions must not overlap.
/// **UNSAFE**: Pointers must be valid. Use `copy` for overlapping regions.
@intrinsic
pub func copy_nonoverlapping[T](src: Ptr[T], dst: Ptr[T], count: I64)

/// Copies bytes from src to dst. Safe for overlapping regions.
/// **UNSAFE**: Pointers must be valid.
@intrinsic
pub func copy[T](src: Ptr[T], dst: Ptr[T], count: I64)

/// Sets count bytes at dst to val.
/// **UNSAFE**: Pointer must be valid.
@intrinsic
pub func write_bytes[T](dst: Ptr[T], val: U8, count: I64)

// ============================================================================
// Type Information Intrinsics
// ============================================================================

/// Returns the size of type T in bytes.
@intrinsic
pub func size_of[T]() -> I64

/// Returns the minimum alignment of type T in bytes.
@intrinsic
pub func align_of[T]() -> I64

/// Returns a unique identifier for type T.
@intrinsic
pub func type_id[T]() -> U64

/// Returns the name of type T as a string (for debugging).
@intrinsic
pub func type_name[T]() -> Str

// ============================================================================
// Unsafe Conversions
// ============================================================================

/// Reinterprets the bits of one type as another type.
/// **EXTREMELY UNSAFE**: Types must have same size. No validation performed.
@intrinsic
pub func transmute[T, U](val: T) -> U

/// Converts between numeric types (zero-extend, sign-extend, truncate).
/// For integer-to-float or float-to-integer conversions.
@intrinsic
pub func cast[T, U](val: T) -> U

// ============================================================================
// Volatile Memory Operations (for memory-mapped I/O)
// ============================================================================

/// Volatile read. Compiler cannot optimize away or reorder.
@intrinsic
pub func volatile_read[T](ptr: Ptr[T]) -> T

/// Volatile write. Compiler cannot optimize away or reorder.
@intrinsic
pub func volatile_write[T](ptr: Ptr[T], val: T)

// ============================================================================
// Atomic Operations
// ============================================================================

/// Atomic load with sequential consistency.
@intrinsic
pub func atomic_load[T](ptr: Ptr[T]) -> T

/// Atomic store with sequential consistency.
@intrinsic
pub func atomic_store[T](ptr: Ptr[T], val: T)

/// Atomic compare-and-swap. Returns (success, old_value).
@intrinsic
pub func atomic_cmpxchg[T](ptr: Ptr[T], expected: T, desired: T) -> (Bool, T)

/// Atomic fetch-and-add. Returns old value.
@intrinsic
pub func atomic_add[T](ptr: Ptr[T], val: T) -> T

/// Atomic fetch-and-sub. Returns old value.
@intrinsic
pub func atomic_sub[T](ptr: Ptr[T], val: T) -> T

/// Atomic fetch-and-and. Returns old value.
@intrinsic
pub func atomic_and[T](ptr: Ptr[T], val: T) -> T

/// Atomic fetch-and-or. Returns old value.
@intrinsic
pub func atomic_or[T](ptr: Ptr[T], val: T) -> T

/// Atomic fetch-and-xor. Returns old value.
@intrinsic
pub func atomic_xor[T](ptr: Ptr[T], val: T) -> T

// ============================================================================
// Compiler Hints
// ============================================================================

/// Indicates that this code path is unreachable.
/// **UNSAFE**: If reached, behavior is undefined.
/// Note: Returns Unit but never actually returns (diverges).
@intrinsic
pub func unreachable() -> Unit

/// Assumes the condition is true. Enables optimizations.
/// **UNSAFE**: If condition is false, behavior is undefined.
@intrinsic
pub func assume(cond: Bool)

/// Hints to the compiler that this branch is likely to be taken.
@intrinsic
pub func likely(cond: Bool) -> Bool

/// Hints to the compiler that this branch is unlikely to be taken.
@intrinsic
pub func unlikely(cond: Bool) -> Bool

/// Memory fence for synchronization.
@intrinsic
pub func fence()

// ============================================================================
// Bit Manipulation
// ============================================================================

/// Count leading zeros.
@intrinsic
pub func ctlz[T](val: T) -> T

/// Count trailing zeros.
@intrinsic
pub func cttz[T](val: T) -> T

/// Population count (number of 1 bits).
@intrinsic
pub func ctpop[T](val: T) -> T

/// Byte swap (for endianness conversion).
@intrinsic
pub func bswap[T](val: T) -> T

/// Bit reverse.
@intrinsic
pub func bitreverse[T](val: T) -> T

// ============================================================================
// Math Intrinsics
// ============================================================================

/// Square root. Maps to LLVM `llvm.sqrt`.
@intrinsic
pub func sqrt[T](val: T) -> T

/// Sine. Maps to LLVM `llvm.sin`.
@intrinsic
pub func sin[T](val: T) -> T

/// Cosine. Maps to LLVM `llvm.cos`.
@intrinsic
pub func cos[T](val: T) -> T

/// Natural logarithm. Maps to LLVM `llvm.log`.
@intrinsic
pub func log[T](val: T) -> T

/// Exponential (e^x). Maps to LLVM `llvm.exp`.
@intrinsic
pub func exp[T](val: T) -> T

/// Power (x^y). Maps to LLVM `llvm.pow`.
@intrinsic
pub func pow[T](x: T, exp: T) -> T

/// Floor (round down).
@intrinsic
pub func floor[T](val: T) -> T

/// Ceiling (round up).
@intrinsic
pub func ceil[T](val: T) -> T

/// Round to nearest integer.
@intrinsic
pub func round[T](val: T) -> T

/// Truncate toward zero.
@intrinsic
pub func trunc[T](val: T) -> T

/// Fused multiply-add: (a * b) + c with single rounding.
@intrinsic
pub func fma[T](a: T, b: T, c: T) -> T

/// Minimum of two values.
@intrinsic
pub func minnum[T](a: T, b: T) -> T

/// Maximum of two values.
@intrinsic
pub func maxnum[T](a: T, b: T) -> T

/// Absolute value.
@intrinsic
pub func fabs[T](val: T) -> T

/// Copy sign from b to a.
@intrinsic
pub func copysign[T](a: T, b: T) -> T

// ============================================================================
// Reflection Intrinsics
// ============================================================================

/// Returns the number of fields in a struct type.
/// Returns 0 for primitives and enums without data fields.
@intrinsic
pub func field_count[T]() -> I64

/// Returns the number of variants in an enum type.
/// Returns 0 for structs and primitives.
@intrinsic
pub func variant_count[T]() -> I64

/// Returns the name of the field at the given index.
/// Index must be a compile-time constant less than field_count[T]().
@intrinsic
pub func field_name[T](index: I64) -> Str

/// Returns the type ID of the field at the given index.
/// Index must be a compile-time constant less than field_count[T]().
@intrinsic
pub func field_type_id[T](index: I64) -> U64

/// Returns the byte offset of the field at the given index.
/// Index must be a compile-time constant less than field_count[T]().
@intrinsic
pub func field_offset[T](index: I64) -> I64

// ============================================================================
// SIMD Vector Intrinsics
// ============================================================================

/// Load an entire @simd vector as a raw LLVM vector value.
/// V must be a @simd type. The result is the LLVM vector (e.g., <4 x i32>).
@intrinsic
pub func simd_load[V](ptr: ref V) -> V

/// Store a raw LLVM vector value back to a @simd struct.
@intrinsic
pub func simd_store[V](ptr: mut ref V, val: V)

/// Extract a single element from a SIMD vector by lane index.
/// V is the @simd type, T is its element type.
@intrinsic
pub func simd_extract[V, T](vec: V, idx: I32) -> T

/// Insert a single element into a SIMD vector at lane index. Returns new vector.
@intrinsic
pub func simd_insert[V, T](vec: V, elem: T, idx: I32) -> V

/// Broadcast a scalar value to all lanes of a SIMD vector.
@intrinsic
pub func simd_splat[V, T](val: T) -> V

/// Load a SIMD vector from a raw pointer (unaligned, align 1).
/// V must be a @simd type. The pointer does not need alignment.
@intrinsic
pub func simd_load_ptr[V](ptr: *Unit) -> V

/// Convert a vector boolean mask (<N x i1>) to an integer bitmask.
/// Bit i of the result is 1 if lane i of the mask is true.
@intrinsic
pub func simd_bitmask[V](mask: V) -> I32

// ============================================================================
// Native SSE2 Intrinsics (x86-64 only)
// ============================================================================

#if X86_64

/// Byte-wise equality comparison of two 16-byte SIMD vectors.
/// Returns 0xFF for matching bytes, 0x00 for non-matching.
/// Compiles to PCMPEQB on x86.
@intrinsic
pub func sse2_cmpeq_epi8[V](a: V, b: V) -> V

/// Extract the most significant bit of each byte into a 16-bit integer mask.
/// Bit i of the result is 1 if the sign bit of byte i is set.
/// Compiles to PMOVMSKB on x86.
@intrinsic
pub func sse2_movemask_epi8[V](v: V) -> I32

#endif
