//! Small Object Optimization (SOO) types.
//!
//! This module provides types that store small objects inline, avoiding heap
//! allocation for common cases.

// ============================================================================
// SmallVec8 - Fixed-capacity inline vector for I64
// ============================================================================

/// A fixed-capacity vector that stores up to 8 I64 elements inline.
pub type SmallVec8 {
    /// Current number of elements
    len: I64,
    /// Inline storage for elements
    e0: I64,
    e1: I64,
    e2: I64,
    e3: I64,
    e4: I64,
    e5: I64,
    e6: I64,
    e7: I64,
}

impl SmallVec8 {
    /// Creates a new empty SmallVec8.
    pub func new() -> SmallVec8 {
        return SmallVec8 {
            len: 0,
            e0: 0, e1: 0, e2: 0, e3: 0,
            e4: 0, e5: 0, e6: 0, e7: 0,
        }
    }

    /// Returns the number of elements.
    pub func len(this) -> I64 {
        return this.len
    }

    /// Returns true if empty.
    pub func is_empty(this) -> Bool {
        return this.len == (0 as I64)
    }

    /// Returns capacity (always 8).
    pub func capacity(this) -> I64 {
        return 8
    }

    /// Returns true (always inline storage).
    pub func is_inline(this) -> Bool {
        return true
    }

    /// Returns true if the vector is full.
    pub func is_full(this) -> Bool {
        return this.len >= (8 as I64)
    }

    /// Gets element at index from inline storage.
    pub func get_at(this, index: I64) -> I64 {
        if index == (0 as I64) { return this.e0 }
        if index == (1 as I64) { return this.e1 }
        if index == (2 as I64) { return this.e2 }
        if index == (3 as I64) { return this.e3 }
        if index == (4 as I64) { return this.e4 }
        if index == (5 as I64) { return this.e5 }
        if index == (6 as I64) { return this.e6 }
        if index == (7 as I64) { return this.e7 }
        return 0
    }

    /// Sets element at index in inline storage.
    pub func set_at(mut this, index: I64, value: I64) {
        if index == (0 as I64) { this.e0 = value; return }
        if index == (1 as I64) { this.e1 = value; return }
        if index == (2 as I64) { this.e2 = value; return }
        if index == (3 as I64) { this.e3 = value; return }
        if index == (4 as I64) { this.e4 = value; return }
        if index == (5 as I64) { this.e5 = value; return }
        if index == (6 as I64) { this.e6 = value; return }
        if index == (7 as I64) { this.e7 = value; return }
    }

    /// Pushes an element to the back. Returns false if full.
    pub func push(mut this, value: I64) -> Bool {
        if this.len >= (8 as I64) {
            return false
        }
        this.set_at(this.len, value)
        this.len = this.len + 1
        return true
    }

    /// Pops an element from the back.
    pub func pop(mut this) -> Maybe[I64] {
        if this.len == (0 as I64) {
            return Nothing
        }
        let idx: I64 = this.len - 1
        this.len = idx
        var value: I64 = 0
        if idx == (0 as I64) { value = this.e0 }
        if idx == (1 as I64) { value = this.e1 }
        if idx == (2 as I64) { value = this.e2 }
        if idx == (3 as I64) { value = this.e3 }
        if idx == (4 as I64) { value = this.e4 }
        if idx == (5 as I64) { value = this.e5 }
        if idx == (6 as I64) { value = this.e6 }
        if idx == (7 as I64) { value = this.e7 }
        return Just(value)
    }

    /// Gets element at index without bounds checking.
    pub func get_unchecked(this, index: I64) -> I64 {
        return this.get_at(index)
    }

    /// Gets element at index.
    pub func get(this, index: I64) -> Maybe[I64] {
        if index < (0 as I64) or index >= this.len {
            return Nothing
        }
        return Just(this.get_at(index))
    }

    /// Sets element at index.
    pub func set(mut this, index: I64, value: I64) {
        if index < (0 as I64) or index >= this.len {
            return
        }
        this.set_at(index, value)
    }

    /// Clears all elements.
    pub func clear(mut this) {
        this.len = 0
    }
}

// ============================================================================
// Tests
// ============================================================================

use test

@test
func test_small_vec_basic() -> I32 {
    var vec: SmallVec8 = SmallVec8::new()

    assert(vec.is_inline(), "should be inline")
    assert_eq(vec.len(), 0 as I64, "should have 0 length")

    vec.push(1)
    vec.push(2)
    vec.push(3)

    assert_eq(vec.len(), 3 as I64, "should have 3 elements")
    assert_eq(vec.get_unchecked(0), 1 as I64, "first element")
    assert_eq(vec.get_unchecked(1), 2 as I64, "second element")
    assert_eq(vec.get_unchecked(2), 3 as I64, "third element")
    return 0
}

@test
func test_small_vec_full() -> I32 {
    var vec: SmallVec8 = SmallVec8::new()

    // Fill to capacity
    var i: I64 = 0
    loop (i < 8) {
        let pushed: Bool = vec.push(i * 10)
        assert(pushed, "push should succeed")
        i = i + 1
    }

    assert(vec.is_full(), "should be full")
    assert_eq(vec.len(), 8 as I64, "should have 8 elements")

    // Try to push one more - should fail
    let overflow: Bool = vec.push(100)
    assert(not overflow, "push to full vec should fail")
    assert_eq(vec.len(), 8 as I64, "length should still be 8")
    return 0
}

@test
func test_small_vec_pop() -> I32 {
    var vec: SmallVec8 = SmallVec8::new()

    vec.push(10)
    vec.push(20)
    vec.push(30)

    let v1: Maybe[I64] = vec.pop()
    assert(v1 == Just(30 as I64), "pop should return 30")

    let v2: Maybe[I64] = vec.pop()
    assert(v2 == Just(20 as I64), "pop should return 20")

    assert_eq(vec.len(), 1 as I64, "should have 1 element")

    let v3: Maybe[I64] = vec.pop()
    assert(v3 == Just(10 as I64), "pop should return 10")

    let v4: Maybe[I64] = vec.pop()
    assert(v4 == Nothing, "pop on empty should return Nothing")
    return 0
}

@test
func test_small_vec_get_set() -> I32 {
    var vec: SmallVec8 = SmallVec8::new()

    vec.push(100)
    vec.push(200)
    vec.push(300)

    // Get
    let v: Maybe[I64] = vec.get(1)
    assert(v == Just(200 as I64), "get(1) should return 200")

    // Out of bounds get
    let oob: Maybe[I64] = vec.get(10)
    assert(oob == Nothing, "get(10) should return Nothing")

    // Set
    vec.set(1, 999)
    assert_eq(vec.get_unchecked(1), 999 as I64, "after set, get(1) should return 999")
    return 0
}

@test
func test_small_vec_clear() -> I32 {
    var vec: SmallVec8 = SmallVec8::new()

    vec.push(1)
    vec.push(2)
    vec.push(3)
    assert_eq(vec.len(), 3 as I64, "should have 3 elements")

    vec.clear()
    assert_eq(vec.len(), 0 as I64, "should be empty after clear")
    assert(vec.is_empty(), "is_empty should return true")
    return 0
}
