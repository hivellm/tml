//! The `Char` type for representing ASCII characters.
//!
//! This module defines the core ASCII character type, equivalent to Rust's
//! `ascii::Char` (AsciiChar).

use core::cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering}
use core::clone::{Duplicate, Copy}
use core::hash::Hash
use core::default::Default
use core::fmt::{Display, Debug}
use core::option::Maybe

// ============================================================================
// ASCII Character Type
// ============================================================================

/// An ASCII character.
///
/// This type represents a single ASCII character (byte value 0-127).
/// It provides a type-safe way to work with ASCII data, guaranteeing
/// that the contained value is always a valid ASCII byte.
///
/// # Representation
///
/// `Char` is represented as a single `U8` byte with value in range 0-127.
/// This is equivalent to Rust's `ascii::Char`.
///
/// Unlike Rust which uses an enum with 128 named variants, TML uses a
/// newtype wrapper for simplicity and LLM-friendliness.
///
/// # Examples
///
/// ```tml
/// use core::ascii::Char
///
/// // Create from a known-valid byte
/// let a = Char::from_u8(65).unwrap()  // 'A'
/// assert_eq(a.to_u8(), 65)
///
/// // Check character properties
/// assert(a.is_uppercase())
/// assert(a.is_alphabetic())
///
/// // Case conversion
/// let lower = a.to_lowercase()
/// assert_eq(lower.to_u8(), 97)  // 'a'
/// ```
pub type Char {
    value: U8
}

// ============================================================================
// Constants
// ============================================================================

impl Char {
    // Minimum and Maximum
    /// The smallest ASCII character: Null (0x00).
    pub const MIN: Char = Char { value: 0 }
    /// The largest ASCII character: Delete (0x7F = 127).
    pub const MAX: Char = Char { value: 127 }

    // Control Characters (0x00 - 0x1F)
    /// Null character (NUL, 0x00)
    pub const Null: Char = Char { value: 0 }
    /// Start of Heading (SOH, 0x01)
    pub const StartOfHeading: Char = Char { value: 1 }
    /// Start of Text (STX, 0x02)
    pub const StartOfText: Char = Char { value: 2 }
    /// End of Text (ETX, 0x03)
    pub const EndOfText: Char = Char { value: 3 }
    /// End of Transmission (EOT, 0x04)
    pub const EndOfTransmission: Char = Char { value: 4 }
    /// Enquiry (ENQ, 0x05)
    pub const Enquiry: Char = Char { value: 5 }
    /// Acknowledge (ACK, 0x06)
    pub const Acknowledge: Char = Char { value: 6 }
    /// Bell (BEL, 0x07)
    pub const Bell: Char = Char { value: 7 }
    /// Backspace (BS, 0x08)
    pub const Backspace: Char = Char { value: 8 }
    /// Horizontal Tab (HT, 0x09)
    pub const Tab: Char = Char { value: 9 }
    /// Line Feed (LF, 0x0A)
    pub const LineFeed: Char = Char { value: 10 }
    /// Vertical Tab (VT, 0x0B)
    pub const VerticalTab: Char = Char { value: 11 }
    /// Form Feed (FF, 0x0C)
    pub const FormFeed: Char = Char { value: 12 }
    /// Carriage Return (CR, 0x0D)
    pub const CarriageReturn: Char = Char { value: 13 }
    /// Shift Out (SO, 0x0E)
    pub const ShiftOut: Char = Char { value: 14 }
    /// Shift In (SI, 0x0F)
    pub const ShiftIn: Char = Char { value: 15 }
    /// Data Link Escape (DLE, 0x10)
    pub const DataLinkEscape: Char = Char { value: 16 }
    /// Device Control 1 / XON (DC1, 0x11)
    pub const DeviceControl1: Char = Char { value: 17 }
    /// Device Control 2 (DC2, 0x12)
    pub const DeviceControl2: Char = Char { value: 18 }
    /// Device Control 3 / XOFF (DC3, 0x13)
    pub const DeviceControl3: Char = Char { value: 19 }
    /// Device Control 4 (DC4, 0x14)
    pub const DeviceControl4: Char = Char { value: 20 }
    /// Negative Acknowledge (NAK, 0x15)
    pub const NegativeAcknowledge: Char = Char { value: 21 }
    /// Synchronous Idle (SYN, 0x16)
    pub const SynchronousIdle: Char = Char { value: 22 }
    /// End of Transmission Block (ETB, 0x17)
    pub const EndOfTransmissionBlock: Char = Char { value: 23 }
    /// Cancel (CAN, 0x18)
    pub const Cancel: Char = Char { value: 24 }
    /// End of Medium (EM, 0x19)
    pub const EndOfMedium: Char = Char { value: 25 }
    /// Substitute (SUB, 0x1A)
    pub const Substitute: Char = Char { value: 26 }
    /// Escape (ESC, 0x1B)
    pub const Escape: Char = Char { value: 27 }
    /// File Separator (FS, 0x1C)
    pub const FileSeparator: Char = Char { value: 28 }
    /// Group Separator (GS, 0x1D)
    pub const GroupSeparator: Char = Char { value: 29 }
    /// Record Separator (RS, 0x1E)
    pub const RecordSeparator: Char = Char { value: 30 }
    /// Unit Separator (US, 0x1F)
    pub const UnitSeparator: Char = Char { value: 31 }

    // Printable Characters
    /// Space (SP, 0x20)
    pub const Space: Char = Char { value: 32 }
    /// Delete (DEL, 0x7F)
    pub const Delete: Char = Char { value: 127 }

    // Digit Characters (0x30 - 0x39)
    pub const Digit0: Char = Char { value: 48 }
    pub const Digit1: Char = Char { value: 49 }
    pub const Digit2: Char = Char { value: 50 }
    pub const Digit3: Char = Char { value: 51 }
    pub const Digit4: Char = Char { value: 52 }
    pub const Digit5: Char = Char { value: 53 }
    pub const Digit6: Char = Char { value: 54 }
    pub const Digit7: Char = Char { value: 55 }
    pub const Digit8: Char = Char { value: 56 }
    pub const Digit9: Char = Char { value: 57 }

    // Capital Letters (0x41 - 0x5A)
    pub const CapitalA: Char = Char { value: 65 }
    pub const CapitalB: Char = Char { value: 66 }
    pub const CapitalC: Char = Char { value: 67 }
    pub const CapitalD: Char = Char { value: 68 }
    pub const CapitalE: Char = Char { value: 69 }
    pub const CapitalF: Char = Char { value: 70 }
    pub const CapitalG: Char = Char { value: 71 }
    pub const CapitalH: Char = Char { value: 72 }
    pub const CapitalI: Char = Char { value: 73 }
    pub const CapitalJ: Char = Char { value: 74 }
    pub const CapitalK: Char = Char { value: 75 }
    pub const CapitalL: Char = Char { value: 76 }
    pub const CapitalM: Char = Char { value: 77 }
    pub const CapitalN: Char = Char { value: 78 }
    pub const CapitalO: Char = Char { value: 79 }
    pub const CapitalP: Char = Char { value: 80 }
    pub const CapitalQ: Char = Char { value: 81 }
    pub const CapitalR: Char = Char { value: 82 }
    pub const CapitalS: Char = Char { value: 83 }
    pub const CapitalT: Char = Char { value: 84 }
    pub const CapitalU: Char = Char { value: 85 }
    pub const CapitalV: Char = Char { value: 86 }
    pub const CapitalW: Char = Char { value: 87 }
    pub const CapitalX: Char = Char { value: 88 }
    pub const CapitalY: Char = Char { value: 89 }
    pub const CapitalZ: Char = Char { value: 90 }

    // Small Letters (0x61 - 0x7A)
    pub const SmallA: Char = Char { value: 97 }
    pub const SmallB: Char = Char { value: 98 }
    pub const SmallC: Char = Char { value: 99 }
    pub const SmallD: Char = Char { value: 100 }
    pub const SmallE: Char = Char { value: 101 }
    pub const SmallF: Char = Char { value: 102 }
    pub const SmallG: Char = Char { value: 103 }
    pub const SmallH: Char = Char { value: 104 }
    pub const SmallI: Char = Char { value: 105 }
    pub const SmallJ: Char = Char { value: 106 }
    pub const SmallK: Char = Char { value: 107 }
    pub const SmallL: Char = Char { value: 108 }
    pub const SmallM: Char = Char { value: 109 }
    pub const SmallN: Char = Char { value: 110 }
    pub const SmallO: Char = Char { value: 111 }
    pub const SmallP: Char = Char { value: 112 }
    pub const SmallQ: Char = Char { value: 113 }
    pub const SmallR: Char = Char { value: 114 }
    pub const SmallS: Char = Char { value: 115 }
    pub const SmallT: Char = Char { value: 116 }
    pub const SmallU: Char = Char { value: 117 }
    pub const SmallV: Char = Char { value: 118 }
    pub const SmallW: Char = Char { value: 119 }
    pub const SmallX: Char = Char { value: 120 }
    pub const SmallY: Char = Char { value: 121 }
    pub const SmallZ: Char = Char { value: 122 }

    // Punctuation
    pub const ExclamationMark: Char = Char { value: 33 }
    pub const QuotationMark: Char = Char { value: 34 }
    pub const NumberSign: Char = Char { value: 35 }
    pub const DollarSign: Char = Char { value: 36 }
    pub const PercentSign: Char = Char { value: 37 }
    pub const Ampersand: Char = Char { value: 38 }
    pub const Apostrophe: Char = Char { value: 39 }
    pub const LeftParenthesis: Char = Char { value: 40 }
    pub const RightParenthesis: Char = Char { value: 41 }
    pub const Asterisk: Char = Char { value: 42 }
    pub const PlusSign: Char = Char { value: 43 }
    pub const Comma: Char = Char { value: 44 }
    pub const HyphenMinus: Char = Char { value: 45 }
    pub const FullStop: Char = Char { value: 46 }
    pub const Solidus: Char = Char { value: 47 }
    pub const Colon: Char = Char { value: 58 }
    pub const Semicolon: Char = Char { value: 59 }
    pub const LessThanSign: Char = Char { value: 60 }
    pub const EqualsSign: Char = Char { value: 61 }
    pub const GreaterThanSign: Char = Char { value: 62 }
    pub const QuestionMark: Char = Char { value: 63 }
    pub const CommercialAt: Char = Char { value: 64 }
    pub const LeftSquareBracket: Char = Char { value: 91 }
    pub const ReverseSolidus: Char = Char { value: 92 }
    pub const RightSquareBracket: Char = Char { value: 93 }
    pub const CircumflexAccent: Char = Char { value: 94 }
    pub const LowLine: Char = Char { value: 95 }
    pub const GraveAccent: Char = Char { value: 96 }
    pub const LeftCurlyBracket: Char = Char { value: 123 }
    pub const VerticalLine: Char = Char { value: 124 }
    pub const RightCurlyBracket: Char = Char { value: 125 }
    pub const Tilde: Char = Char { value: 126 }
}

// ============================================================================
// Construction
// ============================================================================

impl Char {
    /// Creates an ASCII character from a byte.
    ///
    /// Returns `Nothing` if the byte is not a valid ASCII value (> 127).
    ///
    /// This is the primary safe constructor for ASCII characters.
    ///
    /// # Examples
    ///
    /// ```tml
    /// assert(Char::from_u8(65).is_just())   // 'A' is valid
    /// assert(Char::from_u8(127).is_just())  // DEL is valid
    /// assert(Char::from_u8(128).is_nothing()) // Invalid
    /// ```
    pub func from_u8(byte: U8) -> Maybe[Char] {
        if byte > 127 {
            return Nothing
        }
        return Just(Char { value: byte })
    }

    /// Creates an ASCII character from a byte without checking validity.
    ///
    /// # Safety (lowlevel)
    ///
    /// The caller must ensure the byte is a valid ASCII value (0-127).
    /// Passing a value > 127 violates the type invariant.
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Only use when you're certain the value is valid ASCII
    /// let ch = lowlevel { Char::from_u8_unchecked(65) }
    /// ```
    pub func from_u8_unchecked(byte: U8) -> Char {
        return Char { value: byte }
    }

    /// Creates an ASCII digit from a decimal number 0-9.
    ///
    /// Returns `Nothing` if the value is > 9.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let five = Char::digit(5).unwrap()
    /// assert_eq(five.to_u8(), 53)  // '5'
    /// assert(Char::digit(10).is_nothing())
    /// ```
    pub func digit(n: U8) -> Maybe[Char] {
        if n > 9 {
            return Nothing
        }
        return Just(Char { value: n + 48 })  // '0' = 48
    }

    /// Creates an ASCII digit from a decimal number 0-9 without bounds checking.
    ///
    /// # Safety (lowlevel)
    ///
    /// The caller must ensure n is in range 0-9.
    pub func digit_unchecked(n: U8) -> Char {
        return Char { value: n + 48 }
    }
}

// ============================================================================
// Conversion Methods
// ============================================================================

impl Char {
    /// Returns the byte value of this ASCII character.
    ///
    /// This is always a value in range 0-127.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = Char::from_u8(65).unwrap()
    /// assert_eq(a.to_u8(), 65)
    /// ```
    pub func to_u8(this) -> U8 {
        return this.value
    }

    /// Converts this ASCII character to a Unicode scalar value.
    ///
    /// ASCII characters map directly to Unicode code points 0-127.
    pub func to_char(this) -> U32 {
        return this.value as U32
    }

    /// Returns a string containing just this ASCII character.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = Char::from_u8(65).unwrap()
    /// assert_eq(a.as_str(), "A")
    /// ```
    pub func as_str(this) -> Str {
        return lowlevel { char_to_string(this.value) }
    }
}

// ============================================================================
// Character Classification
// ============================================================================

impl Char {
    /// Returns `true` if this is an ASCII alphabetic character: A-Z or a-z.
    pub func is_alphabetic(this) -> Bool {
        return (this.value >= 65 and this.value <= 90) or  // A-Z
               (this.value >= 97 and this.value <= 122)     // a-z
    }

    /// Returns `true` if this is an ASCII lowercase letter: a-z.
    pub func is_lowercase(this) -> Bool {
        return this.value >= 97 and this.value <= 122
    }

    /// Returns `true` if this is an ASCII uppercase letter: A-Z.
    pub func is_uppercase(this) -> Bool {
        return this.value >= 65 and this.value <= 90
    }

    /// Returns `true` if this is an ASCII decimal digit: 0-9.
    pub func is_digit(this) -> Bool {
        return this.value >= 48 and this.value <= 57
    }

    /// Returns `true` if this is an ASCII octal digit: 0-7.
    pub func is_octdigit(this) -> Bool {
        return this.value >= 48 and this.value <= 55
    }

    /// Returns `true` if this is an ASCII hexadecimal digit: 0-9, A-F, or a-f.
    pub func is_hexdigit(this) -> Bool {
        return this.is_digit() or
               (this.value >= 65 and this.value <= 70) or   // A-F
               (this.value >= 97 and this.value <= 102)     // a-f
    }

    /// Returns `true` if this is an ASCII alphanumeric character: A-Z, a-z, or 0-9.
    pub func is_alphanumeric(this) -> Bool {
        return this.is_alphabetic() or this.is_digit()
    }

    /// Returns `true` if this is an ASCII whitespace character.
    ///
    /// ASCII whitespace characters are:
    /// - Space (0x20)
    /// - Horizontal tab (0x09)
    /// - Line feed (0x0A)
    /// - Form feed (0x0C)
    /// - Carriage return (0x0D)
    /// - Vertical tab (0x0B)
    pub func is_whitespace(this) -> Bool {
        return this.value == 32 or   // space
               this.value == 9 or    // horizontal tab
               this.value == 10 or   // line feed
               this.value == 12 or   // form feed
               this.value == 13 or   // carriage return
               this.value == 11      // vertical tab
    }

    /// Returns `true` if this is a "blank" ASCII character: space or tab.
    pub func is_blank(this) -> Bool {
        return this.value == 32 or this.value == 9
    }

    /// Returns `true` if this is a printable ASCII character (0x20-0x7E).
    ///
    /// Printable characters are space through tilde, excluding control characters.
    pub func is_printable(this) -> Bool {
        return this.value >= 32 and this.value <= 126
    }

    /// Returns `true` if this is a "graphic" ASCII character (0x21-0x7E).
    ///
    /// Graphic characters are printable characters excluding space.
    pub func is_graphic(this) -> Bool {
        return this.value >= 33 and this.value <= 126
    }

    /// Returns `true` if this is an ASCII control character (0x00-0x1F or 0x7F).
    pub func is_control(this) -> Bool {
        return this.value < 32 or this.value == 127
    }

    /// Returns `true` if this is an ASCII punctuation character.
    pub func is_punctuation(this) -> Bool {
        return (this.value >= 33 and this.value <= 47) or
               (this.value >= 58 and this.value <= 64) or
               (this.value >= 91 and this.value <= 96) or
               (this.value >= 123 and this.value <= 126)
    }
}

// ============================================================================
// Case Conversion
// ============================================================================

impl Char {
    /// Converts this ASCII character to lowercase.
    ///
    /// If this is an uppercase letter (A-Z), returns the lowercase equivalent (a-z).
    /// Otherwise, returns the character unchanged.
    pub func to_lowercase(this) -> Char {
        if this.is_uppercase() {
            return Char { value: this.value + 32 }
        }
        return this
    }

    /// Converts this ASCII character to uppercase.
    ///
    /// If this is a lowercase letter (a-z), returns the uppercase equivalent (A-Z).
    /// Otherwise, returns the character unchanged.
    pub func to_uppercase(this) -> Char {
        if this.is_lowercase() {
            return Char { value: this.value - 32 }
        }
        return this
    }

    /// Converts this ASCII character to lowercase in place.
    pub func make_lowercase(mut this) {
        if this.is_uppercase() {
            this.value = this.value + 32
        }
    }

    /// Converts this ASCII character to uppercase in place.
    pub func make_uppercase(mut this) {
        if this.is_lowercase() {
            this.value = this.value - 32
        }
    }

    /// Compares this character with another, ignoring ASCII case.
    pub func eq_ignore_case(this, other: Char) -> Bool {
        return this.to_lowercase().value == other.to_lowercase().value
    }
}

// ============================================================================
// Digit Conversion
// ============================================================================

impl Char {
    /// Converts this ASCII digit to its numeric value.
    ///
    /// Returns `Nothing` if this is not a digit (0-9).
    pub func to_digit(this) -> Maybe[U8] {
        if this.is_digit() {
            return Just(this.value - 48)
        }
        return Nothing
    }

    /// Converts this ASCII hex digit to its numeric value (0-15).
    ///
    /// Returns `Nothing` if this is not a hex digit (0-9, A-F, a-f).
    pub func to_hexdigit(this) -> Maybe[U8] {
        if this.is_digit() {
            return Just(this.value - 48)
        } else if this.value >= 65 and this.value <= 70 {
            return Just(this.value - 55)  // A=10, B=11, ...
        } else if this.value >= 97 and this.value <= 102 {
            return Just(this.value - 87)  // a=10, b=11, ...
        }
        return Nothing
    }
}

// ============================================================================
// Behavior Implementations
// ============================================================================

impl PartialEq for Char {
    pub func eq(this, other: ref Char) -> Bool {
        return this.value == other.value
    }
}

impl Eq for Char {}

impl PartialOrd for Char {
    pub func partial_cmp(this, other: ref Char) -> Maybe[Ordering] {
        return Just(this.cmp(other))
    }
}

impl Ord for Char {
    pub func cmp(this, other: ref Char) -> Ordering {
        if this.value < other.value {
            return Less
        } else if this.value > other.value {
            return Greater
        } else {
            return Equal
        }
    }
}

impl Duplicate for Char {
    pub func duplicate(this) -> Char {
        return Char { value: this.value }
    }
}

impl Copy for Char {}

impl Hash for Char {
    pub func hash(this) -> I64 {
        return this.value as I64
    }
}

impl Default for Char {
    /// Returns the NUL character (0x00).
    pub func default() -> Char {
        return Char::Null
    }
}

impl Display for Char {
    pub func to_string(this) -> Str {
        return this.as_str()
    }
}

impl Debug for Char {
    pub func debug_string(this) -> Str {
        if this.is_printable() {
            return "'" + this.as_str() + "'"
        } else {
            return "'\\x" + hex_byte(this.value) + "'"
        }
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

func hex_byte(b: U8) -> Str {
    let high: U8 = b / 16
    let low: U8 = b % 16
    return hex_nibble(high) + hex_nibble(low)
}

func hex_nibble(n: U8) -> Str {
    if n < 10 {
        return lowlevel { char_to_string(n + 48) }  // '0' + n
    } else {
        return lowlevel { char_to_string(n + 87) }  // 'a' + (n - 10)
    }
}
