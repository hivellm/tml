//! The Iterator behavior.

// Ordering is a builtin - no import needed

/// The core iterator behavior that all iterators implement.
///
/// `Iterator` provides a way to iterate over a sequence of elements. The
/// [`next`] method is the only required method - all other iterator methods
/// have default implementations based on `next`.
pub behavior Iterator {
    /// The type of elements being iterated over.
    type Item

    /// Advances the iterator and returns the next value.
    pub func next(mut this) -> Maybe[This::Item]

    /// Consumes the iterator, counting the number of iterations.
    pub func count(mut this) -> I64 {
        let mut n: I64 = 0
        loop {
            when this.next() {
                Just(_) => n = n + 1,
                Nothing => return n
            }
        }
    }

    /// Consumes the iterator, returning the last element.
    pub func last(mut this) -> Maybe[This::Item] {
        let mut result: Maybe[This::Item] = Nothing
        loop {
            when this.next() {
                Just(x) => result = Just(x),
                Nothing => return result
            }
        }
    }

    /// Returns the nth element of the iterator.
    pub func nth(mut this, n: I64) -> Maybe[This::Item] {
        let mut i: I64 = 0
        loop {
            when this.next() {
                Just(x) => {
                    if i == n {
                        return Just(x)
                    }
                    i = i + 1
                },
                Nothing => return Nothing
            }
        }
    }

    /// Tests if every element of the iterator matches a predicate.
    pub func all(mut this, pred: func(This::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(x) => {
                    if not pred(x) {
                        return false
                    }
                },
                Nothing => return true
            }
        }
    }

    /// Tests if any element of the iterator matches a predicate.
    pub func any(mut this, pred: func(This::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return true
                    }
                },
                Nothing => return false
            }
        }
    }

    /// Searches for an element that satisfies a predicate.
    pub func find(mut this, pred: func(This::Item) -> Bool) -> Maybe[This::Item] {
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return Just(x)
                    }
                },
                Nothing => return Nothing
            }
        }
    }

    /// Returns the position of the first element matching a predicate.
    pub func position(mut this, pred: func(This::Item) -> Bool) -> Maybe[I64] {
        let mut i: I64 = 0
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return Just(i)
                    }
                    i = i + 1
                },
                Nothing => return Nothing
            }
        }
    }

    /// Applies a function to each element of the iterator.
    pub func for_each(mut this, f: func(This::Item)) {
        loop {
            when this.next() {
                Just(x) => f(x),
                Nothing => return
            }
        }
    }

    /// Folds every element into an accumulator by applying an operation.
    pub func fold[B](mut this, init: B, f: func(B, This::Item) -> B) -> B {
        let mut acc: B = init
        loop {
            when this.next() {
                Just(x) => acc = f(acc, x),
                Nothing => return acc
            }
        }
    }

    /// Returns the bounds on the remaining length of the iterator.
    pub func size_hint(this) -> (I64, Maybe[I64]) {
        return (0, Nothing)
    }

    /// Advances the iterator by `n` elements.
    pub func advance_by(mut this, n: I64) -> Outcome[Unit, I64] {
        let mut i: I64 = 0
        loop {
            if i >= n {
                return Ok(())
            }
            when this.next() {
                Just(_) => i = i + 1,
                Nothing => return Err(n - i)
            }
        }
    }

    /// Reduces the elements to a single one by repeatedly applying a reducing operation.
    pub func reduce(mut this, f: func(This::Item, This::Item) -> This::Item) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut acc: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => acc = f(acc, x),
                        Nothing => return Just(acc)
                    }
                }
            }
        }
    }

    /// Folds with early termination on error.
    pub func try_fold[B, E](mut this, init: B, f: func(B, This::Item) -> Outcome[B, E]) -> Outcome[B, E] {
        let mut acc: B = init
        loop {
            when this.next() {
                Just(x) => {
                    when f(acc, x) {
                        Ok(new_acc) => acc = new_acc,
                        Err(e) => return Err(e)
                    }
                },
                Nothing => return Ok(acc)
            }
        }
    }

    /// Applies function to elements and returns first Some result.
    pub func find_map[B](mut this, f: func(This::Item) -> Maybe[B]) -> Maybe[B] {
        loop {
            when this.next() {
                Just(x) => {
                    when f(x) {
                        Just(result) => return Just(result),
                        Nothing => {}
                    }
                },
                Nothing => return Nothing
            }
        }
    }

    /// Returns the maximum element using a comparison function.
    pub func max_by(mut this, compare: func(ref This::Item, ref This::Item) -> Ordering) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut max_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when compare(ref x, ref max_val) {
                                Ordering::Greater => max_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(max_val)
                    }
                }
            }
        }
    }

    /// Returns the minimum element using a comparison function.
    pub func min_by(mut this, compare: func(ref This::Item, ref This::Item) -> Ordering) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut min_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when compare(ref x, ref min_val) {
                                Ordering::Less => min_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(min_val)
                    }
                }
            }
        }
    }

    /// Determines if the elements of this iterator are equal to those of another.
    pub func eq[I: Iterator](mut this, mut other: I) -> Bool where This::Item: PartialEq, I::Item = This::Item {
        loop {
            when this.next() {
                Just(a) => {
                    when other.next() {
                        Just(b) => {
                            if not a.eq(ref b) {
                                return false
                            }
                        },
                        Nothing => return false
                    }
                },
                Nothing => {
                    when other.next() {
                        Just(_) => return false,
                        Nothing => return true
                    }
                }
            }
        }
    }

    /// Lexicographically compares the elements of this iterator with those of another.
    pub func cmp[I: Iterator](mut this, mut other: I) -> Ordering where This::Item: Ord, I::Item = This::Item {
        loop {
            when this.next() {
                Just(a) => {
                    when other.next() {
                        Just(b) => {
                            when a.cmp(ref b) {
                                Ordering::Equal => {},
                                ord => return ord
                            }
                        },
                        Nothing => return Ordering::Greater
                    }
                },
                Nothing => {
                    when other.next() {
                        Just(_) => return Ordering::Less,
                        Nothing => return Ordering::Equal
                    }
                }
            }
        }
    }
}
