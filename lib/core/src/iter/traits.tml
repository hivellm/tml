//! Core iterator behaviors.
//!
//! This module defines the fundamental behaviors that form the foundation of
//! TML's iterator system:
//!
//! - [`Iterator`] - The core behavior all iterators implement
//! - [`IntoIterator`] - Conversion into an iterator
//! - [`FromIterator`] - Building collections from iterators
//! - [`DoubleEndedIterator`] - Iterators that can iterate from both ends
//! - [`ExactSizeIterator`] - Iterators that know their exact length
//!
//! # The Iterator Behavior
//!
//! The [`Iterator`] behavior is the heart of TML's iteration system. Any type
//! that implements `Iterator` can be used in `for` loops and with iterator
//! adapters.
//!
//! ```tml
//! use core::iter::Iterator
//!
//! // Custom counter iterator
//! pub type Counter {
//!     current: I64,
//!     max: I64
//! }
//!
//! impl Iterator for Counter {
//!     type Item = I64
//!
//!     pub func next(mut this) -> Maybe[I64] {
//!         if this.current >= this.max {
//!             return Nothing
//!         }
//!         let val = this.current
//!         this.current = this.current + 1
//!         return Just(val)
//!     }
//! }
//!
//! // Use in a for loop
//! let counter = Counter { current: 0, max: 5 }
//! for n in counter {
//!     println(n.to_string())  // 0, 1, 2, 3, 4
//! }
//! ```
//!
//! # IntoIterator
//!
//! The [`IntoIterator`] behavior enables a type to be used in `for` loops.
//! Collections like `Vec` and `Array` implement this.
//!
//! ```tml
//! // Arrays implement IntoIterator
//! for x in [1, 2, 3] {
//!     println(x.to_string())
//! }
//! ```
//!
//! # FromIterator
//!
//! The [`FromIterator`] behavior enables building collections from iterators:
//!
//! ```tml
//! // Collect iterator results into a Vec
//! let doubled: Vec[I64] = (1 to 5).map(do(x) x * 2).collect()
//! ```

use core::cmp::Ordering

// ============================================================================
// Core Iterator Behavior
// ============================================================================

/// The core iterator behavior that all iterators implement.
///
/// `Iterator` provides a way to iterate over a sequence of elements. The
/// [`next`] method is the only required method - all other iterator methods
/// have default implementations based on `next`.
///
/// # Implementing Iterator
///
/// To implement `Iterator`, you need:
/// 1. An associated `Item` type for what the iterator yields
/// 2. A `next` method that returns `Just(item)` or `Nothing`
///
/// ```tml
/// pub type Range {
///     start: I64,
///     end: I64
/// }
///
/// impl Iterator for Range {
///     type Item = I64
///
///     pub func next(mut this) -> Maybe[I64] {
///         if this.start >= this.end {
///             return Nothing
///         }
///         let val = this.start
///         this.start = this.start + 1
///         return Just(val)
///     }
/// }
/// ```
///
/// # Laziness
///
/// Iterators are lazy - they do nothing until consumed. Calling methods like
/// `map` or `filter` just creates a new iterator; no work happens until you
/// call `next`, `collect`, `for_each`, etc.
///
/// ```tml
/// let iter = (1 to 1000000)
///     .map(do(x) expensive_computation(x))
///     .filter(do(x) x > 100)
///     .take(5)
///
/// // No computation has happened yet!
/// // Only when we consume the iterator:
/// for x in iter {
///     println(x.to_string())  // Now computation happens
/// }
/// ```
pub behavior Iterator {
    /// The type of elements being iterated over.
    type Item

    /// Advances the iterator and returns the next value.
    ///
    /// Returns `Just(item)` while there are elements, and `Nothing` once
    /// the iterator is exhausted.
    pub func next(mut this) -> Maybe[This::Item]

    /// Consumes the iterator, counting the number of iterations.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let count = (1 to 6).count()
    /// assert_eq(count, 5)
    /// ```
    pub func count(mut this) -> I64 {
        let mut n: I64 = 0
        loop {
            when this.next() {
                Just(_) => n = n + 1,
                Nothing => return n
            }
        }
    }

    /// Consumes the iterator, returning the last element.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let last = (1 to 6).last()
    /// assert_eq(last, Just(5))
    /// ```
    pub func last(mut this) -> Maybe[This::Item] {
        let mut result: Maybe[This::Item] = Nothing
        loop {
            when this.next() {
                Just(x) => result = Just(x),
                Nothing => return result
            }
        }
    }

    /// Returns the nth element of the iterator.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let third = (1 to 10).nth(2)
    /// assert_eq(third, Just(3))
    /// ```
    pub func nth(mut this, n: I64) -> Maybe[This::Item] {
        let mut i: I64 = 0
        loop {
            when this.next() {
                Just(x) => {
                    if i == n {
                        return Just(x)
                    }
                    i = i + 1
                },
                Nothing => return Nothing
            }
        }
    }

    /// Tests if every element of the iterator matches a predicate.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let all_positive = [1, 2, 3].into_iter().all(do(x) x > 0)
    /// assert_eq(all_positive, true)
    /// ```
    pub func all(mut this, pred: func(This::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(x) => {
                    if not pred(x) {
                        return false
                    }
                },
                Nothing => return true
            }
        }
    }

    /// Tests if any element of the iterator matches a predicate.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let has_even = [1, 2, 3].into_iter().any(do(x) x % 2 == 0)
    /// assert_eq(has_even, true)
    /// ```
    pub func any(mut this, pred: func(This::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return true
                    }
                },
                Nothing => return false
            }
        }
    }

    /// Searches for an element that satisfies a predicate.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let first_even = [1, 2, 3, 4].into_iter().find(do(x) x % 2 == 0)
    /// assert_eq(first_even, Just(2))
    /// ```
    pub func find(mut this, pred: func(This::Item) -> Bool) -> Maybe[This::Item] {
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return Just(x)
                    }
                },
                Nothing => return Nothing
            }
        }
    }

    /// Returns the position of the first element matching a predicate.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let pos = [1, 2, 3].into_iter().position(do(x) x == 2)
    /// assert_eq(pos, Just(1))
    /// ```
    pub func position(mut this, pred: func(This::Item) -> Bool) -> Maybe[I64] {
        let mut i: I64 = 0
        loop {
            when this.next() {
                Just(x) => {
                    if pred(x) {
                        return Just(i)
                    }
                    i = i + 1
                },
                Nothing => return Nothing
            }
        }
    }

    /// Applies a function to each element of the iterator.
    ///
    /// # Examples
    ///
    /// ```tml
    /// [1, 2, 3].into_iter().for_each(do(x) println(x.to_string()))
    /// ```
    pub func for_each(mut this, f: func(This::Item)) {
        loop {
            when this.next() {
                Just(x) => f(x),
                Nothing => return
            }
        }
    }

    /// Folds every element into an accumulator by applying an operation.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let sum = [1, 2, 3].into_iter().fold(0, do(acc, x) acc + x)
    /// assert_eq(sum, 6)
    /// ```
    pub func fold[B](mut this, init: B, f: func(B, This::Item) -> B) -> B {
        let mut acc: B = init
        loop {
            when this.next() {
                Just(x) => acc = f(acc, x),
                Nothing => return acc
            }
        }
    }

    /// Returns the bounds on the remaining length of the iterator.
    ///
    /// The first element is the lower bound, the second is the upper bound.
    /// If the upper bound is `Nothing`, the iterator may have infinite length.
    ///
    /// # Default Implementation
    ///
    /// The default returns `(0, Nothing)` which is always valid but not useful.
    /// Iterators should override this when they know their length bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let arr = [1, 2, 3]
    /// let iter = arr.into_iter()
    /// let (lower, upper) = iter.size_hint()
    /// assert_eq(lower, 3)
    /// assert_eq(upper, Just(3))
    /// ```
    pub func size_hint(this) -> (I64, Maybe[I64]) {
        return (0, Nothing)
    }

    /// Advances the iterator by `n` elements.
    ///
    /// Returns `Ok(())` if the iterator was successfully advanced, or
    /// `Err(k)` where `k` is the number of elements remaining when
    /// the iterator was exhausted (i.e., how many more we needed).
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut iter = (1 to 10).into_iter()
    /// iter.advance_by(3)  // Skip first 3 elements
    /// assert_eq(iter.next(), Just(4))
    /// ```
    pub func advance_by(mut this, n: I64) -> Outcome[Unit, I64] {
        let mut i: I64 = 0
        loop {
            if i >= n {
                return Ok(())
            }
            when this.next() {
                Just(_) => i = i + 1,
                Nothing => return Err(n - i)
            }
        }
    }

    /// Reduces the elements to a single one by repeatedly applying a reducing operation.
    ///
    /// Returns `Nothing` if the iterator is empty.
    ///
    /// This is similar to `fold`, but uses the first element as the initial
    /// accumulator value instead of requiring an explicit initial value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let max = [1, 5, 3, 4, 2].into_iter().reduce(do(a, b) if a > b { a } else { b })
    /// assert_eq(max, Just(5))
    ///
    /// let sum = [1, 2, 3].into_iter().reduce(do(a, b) a + b)
    /// assert_eq(sum, Just(6))
    /// ```
    pub func reduce(mut this, f: func(This::Item, This::Item) -> This::Item) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut acc: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => acc = f(acc, x),
                        Nothing => return Just(acc)
                    }
                }
            }
        }
    }

    /// Creates an iterator that skips the first `n` elements.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let iter = [1, 2, 3, 4, 5].into_iter().skip(2)
    /// assert_eq(iter.collect(), [3, 4, 5])
    /// ```
    pub func skip(mut this, n: I64) -> This {
        let _result: Outcome[Unit, I64] = this.advance_by(n)
        return this
    }

    /// Folds with early termination on error.
    ///
    /// Similar to `fold`, but the folding function returns `Outcome[B, E]`.
    /// On error, folding stops immediately and the error is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let result = [1, 2, 3].into_iter().try_fold(0, do(acc, x) {
    ///     if x > 2 { Err("too big") } else { Ok(acc + x) }
    /// })
    /// assert_eq(result, Err("too big"))
    /// ```
    pub func try_fold[B, E](mut this, init: B, f: func(B, This::Item) -> Outcome[B, E]) -> Outcome[B, E] {
        let mut acc: B = init
        loop {
            when this.next() {
                Just(x) => {
                    when f(acc, x) {
                        Ok(new_acc) => acc = new_acc,
                        Err(e) => return Err(e)
                    }
                },
                Nothing => return Ok(acc)
            }
        }
    }

    /// Applies function to elements and returns first Some result.
    ///
    /// `find_map` is useful when you want to both find and transform an element.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let first_even_doubled = [1, 3, 4, 5].into_iter().find_map(do(x) {
    ///     if x % 2 == 0 { Just(x * 2) } else { Nothing }
    /// })
    /// assert_eq(first_even_doubled, Just(8))
    /// ```
    pub func find_map[B](mut this, f: func(This::Item) -> Maybe[B]) -> Maybe[B] {
        loop {
            when this.next() {
                Just(x) => {
                    when f(x) {
                        Just(result) => return Just(result),
                        Nothing => {}
                    }
                },
                Nothing => return Nothing
            }
        }
    }

    /// Returns the maximum element of an iterator.
    ///
    /// Uses the provided comparison function to determine ordering.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let max = [3, 1, 4, 1, 5].into_iter().max_by(do(a, b) a.cmp(b))
    /// assert_eq(max, Just(5))
    /// ```
    pub func max_by(mut this, compare: func(ref This::Item, ref This::Item) -> Ordering) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut max_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when compare(ref x, ref max_val) {
                                Ordering::Greater => max_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(max_val)
                    }
                }
            }
        }
    }

    /// Returns the minimum element of an iterator.
    ///
    /// Uses the provided comparison function to determine ordering.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let min = [3, 1, 4, 1, 5].into_iter().min_by(do(a, b) a.cmp(b))
    /// assert_eq(min, Just(1))
    /// ```
    pub func min_by(mut this, compare: func(ref This::Item, ref This::Item) -> Ordering) -> Maybe[This::Item] {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut min_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when compare(ref x, ref min_val) {
                                Ordering::Less => min_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(min_val)
                    }
                }
            }
        }
    }

    /// Returns the maximum element of an iterator.
    ///
    /// The elements must implement `Ord` for natural ordering comparison.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let max = [3, 1, 4, 1, 5].into_iter().max()
    /// assert_eq(max, Just(5))
    ///
    /// let empty: [I32; 0] = []
    /// assert_eq(empty.into_iter().max(), Nothing)
    /// ```
    pub func max(mut this) -> Maybe[This::Item] where This::Item: Ord {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut max_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when x.cmp(ref max_val) {
                                Ordering::Greater => max_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(max_val)
                    }
                }
            }
        }
    }

    /// Returns the minimum element of an iterator.
    ///
    /// The elements must implement `Ord` for natural ordering comparison.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let min = [3, 1, 4, 1, 5].into_iter().min()
    /// assert_eq(min, Just(1))
    ///
    /// let empty: [I32; 0] = []
    /// assert_eq(empty.into_iter().min(), Nothing)
    /// ```
    pub func min(mut this) -> Maybe[This::Item] where This::Item: Ord {
        when this.next() {
            Nothing => return Nothing,
            Just(first) => {
                let mut min_val: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => {
                            when x.cmp(ref min_val) {
                                Ordering::Less => min_val = x,
                                _ => {}
                            }
                        },
                        Nothing => return Just(min_val)
                    }
                }
            }
        }
    }

    /// Sums the elements of an iterator.
    ///
    /// Takes each element, adds them together, and returns the result.
    /// Returns `Default::default()` for an empty iterator.
    ///
    /// # Panics
    ///
    /// May panic if the result overflows the type bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let sum = [1, 2, 3, 4, 5].into_iter().sum()
    /// assert_eq(sum, 15)
    ///
    /// let empty: [I32; 0] = []
    /// assert_eq(empty.into_iter().sum(), 0)
    /// ```
    pub func sum(mut this) -> This::Item where This::Item: Add + Default {
        let mut total: This::Item = Default::default()
        loop {
            when this.next() {
                Just(x) => total = total.add(x),
                Nothing => return total
            }
        }
    }

    /// Takes the product of all elements of an iterator.
    ///
    /// Takes each element, multiplies them together, and returns the result.
    /// Returns `Default::default()` (typically 1) for an empty iterator.
    ///
    /// # Panics
    ///
    /// May panic if the result overflows the type bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let product = [1, 2, 3, 4, 5].into_iter().product()
    /// assert_eq(product, 120)
    ///
    /// let empty: [I32; 0] = []
    /// assert_eq(empty.into_iter().product(), 1)
    /// ```
    pub func product(mut this) -> This::Item where This::Item: Mul + Default {
        let mut total: This::Item = Default::default()
        // For product, default should be 1, but Default for I32 is 0
        // This needs careful handling - typically product uses One trait
        // For now, we'll use fold pattern
        when this.next() {
            Nothing => return total,  // Return default (0) for empty - not ideal
            Just(first) => {
                let mut result: This::Item = first
                loop {
                    when this.next() {
                        Just(x) => result = result.mul(x),
                        Nothing => return result
                    }
                }
            }
        }
    }

    /// Determines if the elements of this iterator are equal to those of another.
    ///
    /// Both iterators must yield the same elements in the same order.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let b = [1, 2, 3]
    /// assert(a.into_iter().eq(b.into_iter()))
    ///
    /// let c = [1, 2, 4]
    /// assert(not a.into_iter().eq(c.into_iter()))
    /// ```
    pub func eq[I: Iterator](mut this, mut other: I) -> Bool where This::Item: PartialEq, I::Item = This::Item {
        loop {
            when this.next() {
                Just(a) => {
                    when other.next() {
                        Just(b) => {
                            if not a.eq(ref b) {
                                return false
                            }
                        },
                        Nothing => return false  // this has more elements
                    }
                },
                Nothing => {
                    when other.next() {
                        Just(_) => return false,  // other has more elements
                        Nothing => return true    // both exhausted
                    }
                }
            }
        }
    }

    /// Lexicographically compares the elements of this iterator with those of another.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let b = [1, 2, 4]
    /// assert_eq(a.into_iter().cmp(b.into_iter()), Ordering::Less)
    ///
    /// let c = [1, 2, 3]
    /// assert_eq(a.into_iter().cmp(c.into_iter()), Ordering::Equal)
    /// ```
    pub func cmp[I: Iterator](mut this, mut other: I) -> Ordering where This::Item: Ord, I::Item = This::Item {
        loop {
            when this.next() {
                Just(a) => {
                    when other.next() {
                        Just(b) => {
                            when a.cmp(ref b) {
                                Ordering::Equal => {},  // continue comparing
                                ord => return ord
                            }
                        },
                        Nothing => return Ordering::Greater  // this has more elements
                    }
                },
                Nothing => {
                    when other.next() {
                        Just(_) => return Ordering::Less,  // other has more elements
                        Nothing => return Ordering::Equal  // both exhausted
                    }
                }
            }
        }
    }

    // NOTE: collect[C: FromIterator[This::Item]](this) -> C is blocked
    // The parser doesn't support parameterized behavior bounds like `C: FromIterator[This::Item]`
    // This would require syntax support for: generic_param: Behavior[AssociatedType]
    // For now, use FromIterator::from_iter(iterator) directly to collect.
    //
    // Example workaround:
    // ```tml
    // let list: List[I64] = List::from_iter((1 to 5).into_iter())
    // ```

    // NOTE: partition is similarly blocked due to complex trait bounds
    // partition[C: FromIterator[This::Item] + Default + Extend[This::Item]](...)
}

// ============================================================================
// IntoIterator Behavior
// ============================================================================

/// Conversion into an [`Iterator`].
///
/// Types implementing this behavior can be converted into iterators.
pub behavior IntoIterator {
    /// The type of elements being iterated over.
    type Item

    /// The iterator type returned.
    type IntoIter: Iterator

    /// Creates an iterator from a value.
    pub func into_iter(this) -> This::IntoIter
}

// ============================================================================
// FromIterator Behavior
// ============================================================================

/// Conversion from an [`Iterator`].
///
/// Types implementing this behavior can be built from iterators.
pub behavior FromIterator[T] {
    /// Creates a value from an iterator.
    pub func from_iter[I: Iterator](iter: I) -> This where I::Item = T
}

// ============================================================================
// Extend Behavior
// ============================================================================

/// Extend a collection with the contents of an iterator.
pub behavior Extend[T] {
    /// Extends the collection with elements from the iterator.
    pub func extend[I: Iterator](mut this, iter: I) where I::Item = T

    /// Extends the collection with exactly one element.
    ///
    /// This is useful for adding elements one at a time without creating
    /// an iterator.
    ///
    /// # Default Implementation
    ///
    /// The default implementation creates a single-element iterator and
    /// calls `extend`. Implementors should override this for better performance.
    // pub func extend_one(mut this, item: T)  // TODO: blocked on partition implementation
}

// ============================================================================
// DoubleEndedIterator Behavior
// ============================================================================

/// An iterator that can iterate from both ends.
pub behavior DoubleEndedIterator: Iterator {
    /// Removes and returns an element from the end of the iterator.
    pub func next_back(mut this) -> Maybe[This::Item]
}

// ============================================================================
// ExactSizeIterator Behavior
// ============================================================================

/// An iterator that knows its exact length.
pub behavior ExactSizeIterator: Iterator {
    /// Returns the exact number of remaining elements.
    pub func len(this) -> I64

    /// Returns whether the iterator is empty.
    pub func is_empty(this) -> Bool {
        return this.len() == 0
    }
}

// ============================================================================
// FusedIterator Behavior (marker)
// ============================================================================

/// An iterator that always returns `Nothing` after returning `Nothing` once.
///
/// This is a marker behavior - implementing it indicates that once the
/// iterator returns `Nothing`, it will continue to return `Nothing` forever.
pub behavior FusedIterator: Iterator {
}

// ============================================================================
// TrustedLen Behavior (marker)
// ============================================================================

/// An iterator that reports an accurate length using `size_hint`.
///
/// This is a marker behavior that indicates the iterator's reported length
/// (via `ExactSizeIterator::len` or the upper bound of `size_hint`) is
/// guaranteed to be accurate. This allows certain optimizations like
/// pre-allocating exact capacity.
///
/// # Safety (lowlevel)
///
/// Implementing this incorrectly can lead to memory unsafety if consumers
/// rely on the reported length for allocation.
///
/// # Examples
///
/// ```tml
/// // ArrayIter implements TrustedLen because the array size is known
/// // at compile time and cannot change.
/// let arr = [1, 2, 3]
/// let iter = arr.into_iter()  // TrustedLen iterator
/// ```
pub behavior TrustedLen: Iterator {
}
