//! Core iterator behaviors.
//!
//! This module defines the fundamental behaviors that form the foundation of
//! TML's iterator system:
//!
//! - [`Iterator`] - The core behavior all iterators implement
//! - [`IntoIterator`] - Conversion into an iterator
//! - [`FromIterator`] - Building collections from iterators
//! - [`DoubleEndedIterator`] - Iterators that can iterate from both ends
//! - [`ExactSizeIterator`] - Iterators that know their exact length
//!
//! # The Iterator Behavior
//!
//! The [`Iterator`] behavior is the heart of TML's iteration system. Any type
//! that implements `Iterator` can be used in `for` loops and with iterator
//! adapters.
//!
//! ```tml
//! use core::iter::Iterator
//!
//! // Custom counter iterator
//! pub type Counter {
//!     current: I64,
//!     max: I64
//! }
//!
//! impl Iterator for Counter {
//!     type Item = I64
//!
//!     pub func next(mut this) -> Maybe[I64] {
//!         if this.current >= this.max {
//!             return Nothing
//!         }
//!         let val = this.current
//!         this.current = this.current + 1
//!         return Just(val)
//!     }
//! }
//!
//! // Use in a for loop
//! let counter = Counter { current: 0, max: 5 }
//! for n in counter {
//!     println(n.to_string())  // 0, 1, 2, 3, 4
//! }
//! ```
//!
//! # IntoIterator
//!
//! The [`IntoIterator`] behavior enables a type to be used in `for` loops.
//! Collections like `Vec` and `Array` implement this.
//!
//! ```tml
//! // Arrays implement IntoIterator
//! for x in [1, 2, 3] {
//!     println(x.to_string())
//! }
//! ```
//!
//! # FromIterator
//!
//! The [`FromIterator`] behavior enables building collections from iterators:
//!
//! ```tml
//! // Collect iterator results into a Vec
//! let doubled: Vec[I64] = (1 to 5).map(do(x) x * 2).collect()
//! ```

use core::cmp::Ordering

// ============================================================================
// Core Iterator Behavior
// ============================================================================

/// The core iterator behavior that all iterators implement.
///
/// `Iterator` provides a way to iterate over a sequence of elements. The
/// [`next`] method is the only required method - all other iterator methods
/// have default implementations based on `next`.
///
/// # Implementing Iterator
///
/// To implement `Iterator`, you need:
/// 1. An associated `Item` type for what the iterator yields
/// 2. A `next` method that returns `Just(item)` or `Nothing`
///
/// ```tml
/// pub type Range {
///     start: I64,
///     end: I64
/// }
///
/// impl Iterator for Range {
///     type Item = I64
///
///     pub func next(mut this) -> Maybe[I64] {
///         if this.start >= this.end {
///             return Nothing
///         }
///         let val = this.start
///         this.start = this.start + 1
///         return Just(val)
///     }
/// }
/// ```
///
/// # Laziness
///
/// Iterators are lazy - they do nothing until consumed. Calling methods like
/// `map` or `filter` just creates a new iterator; no work happens until you
/// call `next`, `collect`, `for_each`, etc.
///
/// ```tml
/// let iter = (1 to 1000000)
///     .map(do(x) expensive_computation(x))
///     .filter(do(x) x > 100)
///     .take(5)
///
/// // No computation has happened yet!
/// // Only when we consume the iterator:
/// for x in iter {
///     println(x.to_string())  // Now computation happens
/// }
/// ```
pub behavior Iterator {
    /// The type of elements being iterated over.
    type Item

    /// Advances the iterator and returns the next value.
    ///
    /// Returns `Just(item)` while there are elements, and `Nothing` once
    /// the iterator is exhausted.
    pub func next(mut this) -> Maybe[This::Item]
}

// ============================================================================
// IntoIterator Behavior
// ============================================================================

/// Conversion into an [`Iterator`].
///
/// Types implementing this behavior can be converted into iterators.
pub behavior IntoIterator {
    /// The type of elements being iterated over.
    type Item

    /// The iterator type returned.
    type IntoIter: Iterator

    /// Creates an iterator from a value.
    pub func into_iter(this) -> This::IntoIter
}

// ============================================================================
// FromIterator Behavior
// ============================================================================

/// Conversion from an [`Iterator`].
///
/// Types implementing this behavior can be built from iterators.
pub behavior FromIterator[T] {
    /// Creates a value from an iterator.
    pub func from_iter[I: Iterator](iter: I) -> This where I::Item = T
}

// ============================================================================
// Extend Behavior
// ============================================================================

/// Extend a collection with the contents of an iterator.
pub behavior Extend[T] {
    /// Extends the collection with elements from the iterator.
    pub func extend[I: Iterator](mut this, iter: I) where I::Item = T
}

// ============================================================================
// DoubleEndedIterator Behavior
// ============================================================================

/// An iterator that can iterate from both ends.
pub behavior DoubleEndedIterator: Iterator {
    /// Removes and returns an element from the end of the iterator.
    pub func next_back(mut this) -> Maybe[This::Item]
}

// ============================================================================
// ExactSizeIterator Behavior
// ============================================================================

/// An iterator that knows its exact length.
pub behavior ExactSizeIterator: Iterator {
    /// Returns the exact number of remaining elements.
    pub func len(this) -> I64

    /// Returns whether the iterator is empty.
    pub func is_empty(this) -> Bool {
        return this.len() == 0
    }
}

// ============================================================================
// FusedIterator Behavior (marker)
// ============================================================================

/// An iterator that always returns `Nothing` after returning `Nothing` once.
///
/// This is a marker behavior - implementing it indicates that once the
/// iterator returns `Nothing`, it will continue to return `Nothing` forever.
pub behavior FusedIterator: Iterator {
}

// ============================================================================
// TrustedLen Behavior (marker)
// ============================================================================

/// An iterator that reports an accurate length using `size_hint`.
///
/// This is a marker behavior that indicates the iterator's reported length
/// (via `ExactSizeIterator::len` or the upper bound of `size_hint`) is
/// guaranteed to be accurate. This allows certain optimizations like
/// pre-allocating exact capacity.
///
/// # Safety (lowlevel)
///
/// Implementing this incorrectly can lead to memory unsafety if consumers
/// rely on the reported length for allocation.
///
/// # Examples
///
/// ```tml
/// // ArrayIter implements TrustedLen because the array size is known
/// // at compile time and cannot change.
/// let arr = [1, 2, 3]
/// let iter = arr.into_iter()  // TrustedLen iterator
/// ```
pub behavior TrustedLen: Iterator {
}
