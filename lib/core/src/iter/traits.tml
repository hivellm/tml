//! Core iterator traits.
//!
//! This module defines the fundamental `Iterator` behavior that all iterators implement.

use core::cmp::Ordering

// ============================================================================
// Core Iterator Behavior
// ============================================================================

/// The core iterator behavior.
///
/// All iterators must implement this behavior, providing at minimum the `next` method.
pub behavior Iterator {
    /// The type of elements being iterated over.
    type Item

    /// Advances the iterator and returns the next value.
    ///
    /// Returns `Just(item)` while there are elements, and `Nothing` once
    /// the iterator is exhausted.
    pub func next(mut this) -> Maybe[This::Item]
}

// ============================================================================
// IntoIterator Behavior
// ============================================================================

/// Conversion into an [`Iterator`].
///
/// Types implementing this behavior can be converted into iterators.
pub behavior IntoIterator {
    /// The type of elements being iterated over.
    type Item

    /// The iterator type returned.
    type IntoIter: Iterator

    /// Creates an iterator from a value.
    pub func into_iter(this) -> This::IntoIter
}

// ============================================================================
// FromIterator Behavior
// ============================================================================

/// Conversion from an [`Iterator`].
///
/// Types implementing this behavior can be built from iterators.
pub behavior FromIterator[T] {
    /// Creates a value from an iterator.
    pub func from_iter[I: Iterator](iter: I) -> This where I::Item = T
}

// ============================================================================
// Extend Behavior
// ============================================================================

/// Extend a collection with the contents of an iterator.
pub behavior Extend[T] {
    /// Extends the collection with elements from the iterator.
    pub func extend[I: Iterator](mut this, iter: I) where I::Item = T
}

// ============================================================================
// DoubleEndedIterator Behavior
// ============================================================================

/// An iterator that can iterate from both ends.
pub behavior DoubleEndedIterator: Iterator {
    /// Removes and returns an element from the end of the iterator.
    pub func next_back(mut this) -> Maybe[This::Item]
}

// ============================================================================
// ExactSizeIterator Behavior
// ============================================================================

/// An iterator that knows its exact length.
pub behavior ExactSizeIterator: Iterator {
    /// Returns the exact number of remaining elements.
    pub func len(this) -> I64

    /// Returns whether the iterator is empty.
    pub func is_empty(this) -> Bool {
        return this.len() == 0
    }
}

// ============================================================================
// FusedIterator Behavior (marker)
// ============================================================================

/// An iterator that always returns `Nothing` after returning `Nothing` once.
///
/// This is a marker behavior - implementing it indicates that once the
/// iterator returns `Nothing`, it will continue to return `Nothing` forever.
pub behavior FusedIterator: Iterator {
}

// ============================================================================
// TrustedLen Behavior (marker)
// ============================================================================

/// An iterator that reports an accurate length using `size_hint`.
///
/// This is a marker behavior that indicates the iterator's reported length
/// (via `ExactSizeIterator::len` or the upper bound of `size_hint`) is
/// guaranteed to be accurate. This allows certain optimizations like
/// pre-allocating exact capacity.
///
/// # Safety (lowlevel)
///
/// Implementing this incorrectly can lead to memory unsafety if consumers
/// rely on the reported length for allocation.
///
/// # Examples
///
/// ```tml
/// // ArrayIter implements TrustedLen because the array size is known
/// // at compile time and cannot change.
/// let arr = [1, 2, 3]
/// let iter = arr.into_iter()  // TrustedLen iterator
/// ```
pub behavior TrustedLen: Iterator {
}
