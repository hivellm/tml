//! Iterator adapter types.
//!
//! This module provides iterator adapters - types that wrap existing iterators
//! and transform their output in various ways. Adapters are the building blocks
//! of iterator chains.
//!
//! # Lazy Evaluation
//!
//! All adapters are lazy - they do no work until the iterator is consumed.
//! Creating an adapter just sets up the transformation pipeline.
//!
//! ```tml
//! // No work happens here - just setting up the chain
//! let iter = take(skip(some_iter, 5), 10)
//!
//! // Work happens here, when we consume the iterator
//! for item in iter {
//!     process(item)
//! }
//! ```
//!
//! # Available Adapters
//!
//! | Adapter | Description |
//! |---------|-------------|
//! | [`Take`] | Yields at most N elements |
//! | [`Skip`] | Skips the first N elements |
//! | [`Chain`] | Chains two iterators together |
//! | [`Enumerate`] | Yields (index, element) pairs |
//! | [`Zip`] | Zips two iterators into pairs |
//! | [`StepBy`] | Steps through by a given amount |
//! | [`Fuse`] | Guarantees Nothing forever after first Nothing |
//!
//! # Examples
//!
//! ## Taking and Skipping
//!
//! ```tml
//! use core::iter::adapters::{take, skip}
//!
//! // Skip first 5, take next 10
//! let iter = take(skip(range_iter, 5), 10)
//! ```
//!
//! ## Chaining Iterators
//!
//! ```tml
//! use core::iter::adapters::chain
//!
//! // Process first iterator, then second
//! let combined = chain(first_iter, second_iter)
//! ```
//!
//! ## Enumerating
//!
//! ```tml
//! use core::iter::adapters::enumerate
//!
//! // Get indices with elements
//! for (idx, item) in enumerate(iter) {
//!     println("{idx}: {item}")
//! }
//! ```

use core::iter::traits::Iterator

// ============================================================================
// Take Adapter
// ============================================================================

/// An iterator that yields at most `n` elements from the underlying iterator.
///
/// This struct is created by the [`take`] function. See its documentation
/// for more details.
///
/// # Examples
///
/// ```tml
/// let mut iter = take(range_iter, 3)
/// // Will yield at most 3 elements, even if range_iter has more
/// ```
pub type Take[I] {
    iter: I,
    remaining: I64
}

impl[I: Iterator] Iterator for Take[I] {
    type Item = I::Item

    pub func next(mut this) -> Maybe[I::Item] {
        if this.remaining <= 0 {
            return Nothing
        }
        this.remaining = this.remaining - 1
        return this.iter.next()
    }
}

/// Creates an iterator that yields at most `n` elements.
///
/// After `n` elements have been yielded, the iterator will return `Nothing`
/// even if the underlying iterator has more elements.
///
/// # Arguments
///
/// * `iter` - The source iterator
/// * `n` - Maximum number of elements to yield
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let numbers = [1, 2, 3, 4, 5].into_iter()
/// let mut first_three = take(numbers, 3)
///
/// assert(first_three.next() == Just(1))
/// assert(first_three.next() == Just(2))
/// assert(first_three.next() == Just(3))
/// assert(first_three.next() == Nothing)  // Stopped after 3
/// ```
///
/// Taking more than available:
///
/// ```tml
/// let numbers = [1, 2].into_iter()
/// let mut iter = take(numbers, 10)
///
/// assert(iter.next() == Just(1))
/// assert(iter.next() == Just(2))
/// assert(iter.next() == Nothing)  // Only 2 elements existed
/// ```
pub func take[I: Iterator](iter: I, n: I64) -> Take[I] {
    return Take { iter: iter, remaining: n }
}

// ============================================================================
// Skip Adapter
// ============================================================================

/// An iterator that skips the first `n` elements of the underlying iterator.
///
/// This struct is created by the [`skip`] function. See its documentation
/// for more details.
///
/// The skipping happens lazily - elements are consumed from the underlying
/// iterator only when `next` is called.
pub type Skip[I] {
    iter: I,
    remaining: I64
}

impl[I: Iterator] Iterator for Skip[I] {
    type Item = I::Item

    pub func next(mut this) -> Maybe[I::Item] {
        loop {
            if this.remaining <= 0 {
                return this.iter.next()
            }
            this.remaining = this.remaining - 1
            when this.iter.next() {
                Just(_) => {},
                Nothing => return Nothing
            }
        }
    }
}

/// Creates an iterator that skips the first `n` elements.
///
/// After skipping `n` elements, the iterator yields the remaining elements
/// from the underlying iterator.
///
/// # Arguments
///
/// * `iter` - The source iterator
/// * `n` - Number of elements to skip
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let numbers = [1, 2, 3, 4, 5].into_iter()
/// let mut after_two = skip(numbers, 2)
///
/// assert(after_two.next() == Just(3))  // Skipped 1, 2
/// assert(after_two.next() == Just(4))
/// assert(after_two.next() == Just(5))
/// assert(after_two.next() == Nothing)
/// ```
///
/// Skipping more than available:
///
/// ```tml
/// let numbers = [1, 2].into_iter()
/// let mut iter = skip(numbers, 10)
///
/// assert(iter.next() == Nothing)  // Nothing left after skipping
/// ```
///
/// Combining with take:
///
/// ```tml
/// // Get elements 5-15 (skip first 5, take next 10)
/// let slice = take(skip(iter, 5), 10)
/// ```
pub func skip[I: Iterator](iter: I, n: I64) -> Skip[I] {
    return Skip { iter: iter, remaining: n }
}

// ============================================================================
// Chain Adapter
// ============================================================================

/// An iterator that chains two iterators together sequentially.
///
/// This struct is created by the [`chain`] function. See its documentation
/// for more details.
///
/// The chained iterator first yields all elements from the first iterator,
/// then all elements from the second.
pub type Chain[A, B] {
    first: Maybe[A],
    second: B
}

impl[A: Iterator, B: Iterator] Iterator for Chain[A, B] where A::Item = B::Item {
    type Item = A::Item

    pub func next(mut this) -> Maybe[A::Item] {
        when this.first {
            Just(iter) => {
                when iter.next() {
                    Just(item) => return Just(item),
                    Nothing => {
                        this.first = Nothing
                        return this.second.next()
                    }
                }
            },
            Nothing => return this.second.next()
        }
    }
}

/// Creates an iterator that chains two iterators together.
///
/// The resulting iterator yields all elements from the first iterator,
/// followed by all elements from the second. Both iterators must yield
/// the same element type.
///
/// # Arguments
///
/// * `first` - The first iterator to consume
/// * `second` - The second iterator, consumed after `first` is exhausted
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let a = [1, 2, 3].into_iter()
/// let b = [4, 5, 6].into_iter()
/// let mut chained = chain(a, b)
///
/// assert(chained.next() == Just(1))
/// assert(chained.next() == Just(2))
/// assert(chained.next() == Just(3))
/// assert(chained.next() == Just(4))  // Now from second iterator
/// assert(chained.next() == Just(5))
/// assert(chained.next() == Just(6))
/// assert(chained.next() == Nothing)
/// ```
///
/// Chaining with empty:
///
/// ```tml
/// let data = [1, 2, 3].into_iter()
/// let empty = empty_i32()
///
/// // Chain with empty is a no-op
/// let iter = chain(data, empty)
/// ```
pub func chain[A: Iterator, B: Iterator](first: A, second: B) -> Chain[A, B] where A::Item = B::Item {
    return Chain { first: Just(first), second: second }
}

// ============================================================================
// Enumerate Adapter
// ============================================================================

/// An iterator that yields pairs of (index, element).
///
/// This struct is created by the [`enumerate`] function. See its documentation
/// for more details.
///
/// The index starts at 0 and increments by 1 for each element yielded.
pub type Enumerate[I] {
    iter: I,
    index: I64
}

impl[I: Iterator] Iterator for Enumerate[I] {
    type Item = (I64, I::Item)

    pub func next(mut this) -> Maybe[(I64, I::Item)] {
        when this.iter.next() {
            Just(item) => {
                let idx: I64 = this.index
                this.index = this.index + 1
                return Just((idx, item))
            },
            Nothing => return Nothing
        }
    }
}

/// Creates an iterator that yields pairs of (index, element).
///
/// The index starts at 0 and increments by 1 for each element. This is
/// useful when you need both the position and value of elements.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let names = ["Alice", "Bob", "Carol"].into_iter()
///
/// for (i, name) in enumerate(names) {
///     println("{i}: {name}")
/// }
/// // Output:
/// // 0: Alice
/// // 1: Bob
/// // 2: Carol
/// ```
///
/// Finding an element's position:
///
/// ```tml
/// let mut iter = enumerate([10, 20, 30, 40].into_iter())
///
/// loop {
///     when iter.next() {
///         Just((idx, val)) => {
///             if val == 30 {
///                 println("Found 30 at index {idx}")
///                 break
///             }
///         },
///         Nothing => break
///     }
/// }
/// ```
///
/// # Overflow
///
/// The index is an `I64`, so overflow won't happen in practice. For iterators
/// with more than `I64::MAX` elements, the index would wrap around.
pub func enumerate[I: Iterator](iter: I) -> Enumerate[I] {
    return Enumerate { iter: iter, index: 0 }
}

// ============================================================================
// Zip Adapter
// ============================================================================

/// An iterator that zips two iterators together into pairs.
///
/// This struct is created by the [`zip`] function. See its documentation
/// for more details.
///
/// The iterator stops when either input iterator is exhausted.
pub type Zip[A, B] {
    first: A,
    second: B
}

impl[A: Iterator, B: Iterator] Iterator for Zip[A, B] {
    type Item = (A::Item, B::Item)

    pub func next(mut this) -> Maybe[(A::Item, B::Item)] {
        when this.first.next() {
            Just(a) => {
                when this.second.next() {
                    Just(b) => return Just((a, b)),
                    Nothing => return Nothing
                }
            },
            Nothing => return Nothing
        }
    }
}

/// Creates an iterator that zips two iterators into pairs.
///
/// The resulting iterator yields tuples `(A, B)` where `A` comes from the
/// first iterator and `B` from the second. The iterator stops when either
/// input iterator is exhausted.
///
/// # Arguments
///
/// * `first` - The first iterator
/// * `second` - The second iterator
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let names = ["Alice", "Bob", "Carol"].into_iter()
/// let ages = [30, 25, 35].into_iter()
///
/// for (name, age) in zip(names, ages) {
///     println("{name} is {age} years old")
/// }
/// ```
///
/// Different lengths:
///
/// ```tml
/// let short = [1, 2].into_iter()
/// let long = [10, 20, 30, 40].into_iter()
/// let mut zipped = zip(short, long)
///
/// assert(zipped.next() == Just((1, 10)))
/// assert(zipped.next() == Just((2, 20)))
/// assert(zipped.next() == Nothing)  // Stopped when short was exhausted
/// ```
///
/// Parallel iteration:
///
/// ```tml
/// // Process two collections in lockstep
/// let keys = keys_iter
/// let values = values_iter
///
/// for (key, value) in zip(keys, values) {
///     map.insert(key, value)
/// }
/// ```
pub func zip[A: Iterator, B: Iterator](first: A, second: B) -> Zip[A, B] {
    return Zip { first: first, second: second }
}

// ============================================================================
// StepBy Adapter
// ============================================================================

/// An iterator that steps through by a given amount.
///
/// This struct is created by the [`step_by`] function. See its documentation
/// for more details.
///
/// The first element is always returned, then every `step`th element after.
pub type StepBy[I] {
    iter: I,
    step: I64,
    first_take: Bool
}

impl[I: Iterator] Iterator for StepBy[I] {
    type Item = I::Item

    pub func next(mut this) -> Maybe[I::Item] {
        if this.first_take {
            this.first_take = false
            return this.iter.next()
        }

        // Skip (step - 1) elements
        var i: I64 = 1
        loop {
            if i >= this.step {
                break
            }
            when this.iter.next() {
                Just(_) => {},
                Nothing => return Nothing
            }
            i = i + 1
        }
        return this.iter.next()
    }
}

/// Creates an iterator that steps through by a given amount.
///
/// The first element is always returned. Then, every `step`th element is
/// returned. For step=2, this yields elements at indices 0, 2, 4, 6, ...
///
/// # Arguments
///
/// * `iter` - The source iterator
/// * `step` - The step size (must be >= 1)
///
/// # Panics
///
/// Behavior is undefined if `step` is less than 1.
///
/// # Examples
///
/// Basic usage (every other element):
///
/// ```tml
/// let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].into_iter()
/// let mut evens = step_by(numbers, 2)
///
/// assert(evens.next() == Just(0))  // Index 0
/// assert(evens.next() == Just(2))  // Index 2
/// assert(evens.next() == Just(4))  // Index 4
/// // ...
/// ```
///
/// Every third element:
///
/// ```tml
/// let numbers = [0, 1, 2, 3, 4, 5, 6].into_iter()
/// let mut thirds = step_by(numbers, 3)
///
/// assert(thirds.next() == Just(0))  // Index 0
/// assert(thirds.next() == Just(3))  // Index 3
/// assert(thirds.next() == Just(6))  // Index 6
/// assert(thirds.next() == Nothing)
/// ```
pub func step_by[I: Iterator](iter: I, step: I64) -> StepBy[I] {
    return StepBy { iter: iter, step: step, first_take: true }
}

// ============================================================================
// Fuse Adapter
// ============================================================================

/// An iterator that guarantees `Nothing` is returned forever after the first.
///
/// This struct is created by the [`fuse`] function. See its documentation
/// for more details.
///
/// Some iterators can return `Just(x)` after returning `Nothing` once. A
/// fused iterator guarantees that once it returns `Nothing`, it will always
/// return `Nothing`.
pub type Fuse[I] {
    iter: Maybe[I]
}

impl[I: Iterator] Iterator for Fuse[I] {
    type Item = I::Item

    pub func next(mut this) -> Maybe[I::Item] {
        when this.iter {
            Just(it) => {
                when it.next() {
                    Just(item) => return Just(item),
                    Nothing => {
                        this.iter = Nothing
                        return Nothing
                    }
                }
            },
            Nothing => return Nothing
        }
    }
}

/// Creates a fused iterator that guarantees `Nothing` forever after exhaustion.
///
/// Most iterators already behave this way (returning `Nothing` forever after
/// the first `Nothing`), but `fuse` provides a guarantee. This is useful when
/// you're unsure about an iterator's behavior after exhaustion.
///
/// If an iterator implements [`FusedIterator`], calling `fuse` on it is a
/// no-op since it's already guaranteed to be fused.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter = fuse(some_iter)
///
/// // Once Nothing is returned...
/// assert(iter.next() == Nothing)
///
/// // ...it's guaranteed to be Nothing forever
/// assert(iter.next() == Nothing)
/// assert(iter.next() == Nothing)
/// ```
///
/// Why fuse is useful:
///
/// ```tml
/// // Some hypothetical iterator that might resume after Nothing
/// let suspicious_iter = get_unreliable_iterator()
///
/// // Fuse it to guarantee consistent behavior
/// let reliable_iter = fuse(suspicious_iter)
/// ```
pub func fuse[I: Iterator](iter: I) -> Fuse[I] {
    return Fuse { iter: Just(iter) }
}

// ============================================================================
// Rev Adapter
// ============================================================================

/// An iterator that reverses a double-ended iterator.
///
/// This struct is created by the `rev` function on double-ended iterators.
/// A double-ended iterator is one that can yield elements from both ends.
///
/// # Note
///
/// Full implementation requires [`DoubleEndedIterator`] support which is
/// not yet complete. This type exists for API compatibility.
pub type Rev[I] {
    iter: I
}

// Note: Full implementation requires DoubleEndedIterator which needs
// more complex trait resolution. Placeholder for now.

// ============================================================================
// Placeholder Types for Future Implementation
// ============================================================================

// These types exist for API compatibility and documentation purposes.
// Full implementation requires closures and/or more advanced type features.
//
// When these features are available, each type will gain full Iterator
// implementations. Until then, they serve as type definitions for the API.

/// An iterator that transforms each element using a function.
///
/// Created by `iter.map(func)`. Applies `func` to each element.
/// Implementation pending closure support.
pub type Map[I, F] { iter: I, f: F }

/// An iterator that yields only elements matching a predicate.
///
/// Created by `iter.filter(pred)`. Yields elements where `pred(elem)` is true.
/// Implementation pending closure support.
pub type Filter[I, P] { iter: I, pred: P }

/// An iterator that both filters and maps in one operation.
///
/// Created by `iter.filter_map(func)`. For each element, `func` returns
/// `Just(transformed)` to include or `Nothing` to skip.
/// Implementation pending closure support.
pub type FilterMap[I, F] { iter: I, f: F }

/// An iterator that maps while the function returns `Just`.
///
/// Created by `iter.map_while(func)`. Yields transformed values until
/// `func` returns `Nothing`, then stops.
/// Implementation pending closure support.
pub type MapWhile[I, F] { iter: I, f: F }

/// An iterator that yields elements while a predicate is true.
///
/// Created by `iter.take_while(pred)`. Yields elements until `pred(elem)`
/// returns false, then stops forever.
/// Implementation pending closure support.
pub type TakeWhile[I, P] { iter: I, pred: P }

/// An iterator that skips elements while a predicate is true.
///
/// Created by `iter.skip_while(pred)`. Skips elements until `pred(elem)`
/// returns false, then yields all remaining elements.
/// Implementation pending closure support.
pub type SkipWhile[I, P] { iter: I, pred: P }

/// An iterator that maintains state while transforming elements.
///
/// Created by `iter.scan(initial, func)`. Similar to fold, but yields
/// intermediate states.
/// Implementation pending closure support.
pub type Scan[I, St, F] { iter: I, state: St, f: F }

/// An iterator that calls a function on each element without changing it.
///
/// Created by `iter.inspect(func)`. Useful for debugging or side effects.
/// Implementation pending closure support.
pub type Inspect[I, F] { iter: I, f: F }

/// An iterator that places a separator between adjacent elements.
///
/// Created by `iter.intersperse(sep)`. Example: [1,2,3] with sep=0
/// becomes [1,0,2,0,3].
pub type Intersperse[I, T] { iter: I, sep: T }

/// An iterator that places separators using a function.
///
/// Like `Intersperse` but calls a function to generate each separator.
/// Implementation pending closure support.
pub type IntersperseWith[I, F] { iter: I, sep_fn: F }

/// An iterator that alternates between two iterators.
///
/// Yields A, B, A, B, ... until one is exhausted.
pub type Interleave[A, B] { a: A, b: B, flag: Bool }

/// An iterator that flattens nested iterators.
///
/// Created by `iter.flatten()`. Transforms `Iterator[Iterator[T]]` into
/// `Iterator[T]`.
pub type Flatten[I] { iter: I }

/// An iterator that maps then flattens.
///
/// Created by `iter.flat_map(func)`. Equivalent to `iter.map(func).flatten()`.
/// Implementation pending closure support.
pub type FlatMap[I, F] { iter: I, f: F }

/// An iterator that clones borrowed elements.
///
/// Created by `iter.cloned()`. Transforms `Iterator[ref T]` into `Iterator[T]`
/// by cloning each element.
pub type Cloned[I] { iter: I }

/// An iterator that copies borrowed elements.
///
/// Created by `iter.copied()`. Like `cloned` but for `Copy` types.
pub type Copied[I] { iter: I }

/// An iterator that allows peeking at the next element.
///
/// Created by `iter.peekable()`. Adds a `peek()` method to look at the next
/// element without consuming it.
pub type Peekable[I, T] { iter: I, peeked: Maybe[T] }

/// An iterator that repeats forever by cycling through elements.
///
/// Created by `iter.cycle()`. Restarts from the beginning after exhaustion.
pub type Cycle[I] { orig: I, iter: I }

/// An iterator adapter that yields references to another iterator.
///
/// Created by `iter.by_ref()`. Allows taking a mutable reference to an
/// iterator while still being able to use adapters.
pub type ByRef[I] { iter: I }

/// An iterator that yields chunks of elements.
///
/// Created by `iter.chunks(size)`. Yields arrays/vectors of `size` elements.
pub type Chunks[I, T] { iter: I, size: I64 }

/// An iterator that yields sliding windows over elements.
///
/// Created by `iter.windows(size)`. Each window overlaps with the previous.
pub type Windows[I, T] { iter: I, size: I64 }

/// An iterator that batches elements into groups.
///
/// Similar to chunks but with different semantics for the final batch.
pub type Batched[I, T] { iter: I, size: I64 }

/// An iterator that yields only unique elements.
///
/// Tracks seen elements and skips duplicates.
pub type Unique[I, T] { iter: I }

/// An iterator that removes consecutive duplicate elements.
///
/// Only removes duplicates that are adjacent; does not track all seen values.
pub type Dedup[I, T] { iter: I }

// ============================================================================
// Placeholder Functions
// ============================================================================

/// Creates an iterator that yields chunks of elements.
///
/// See [`Chunks`] for more details. Full implementation pending.
pub func chunks[I: Iterator](iter: I, size: I64) -> Chunks[I, I::Item] {
    return Chunks { iter: iter, size: size }
}

/// Creates an iterator that yields sliding windows.
///
/// See [`Windows`] for more details. Full implementation pending.
pub func windows[I: Iterator](iter: I, size: I64) -> Windows[I, I::Item] {
    return Windows { iter: iter, size: size }
}
