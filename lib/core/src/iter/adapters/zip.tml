//! The Zip adapter.
//!
//! This module provides the `Zip` iterator adapter which zips two
//! iterators together into pairs.

// ============================================================================
// Zip Adapter
// ============================================================================

/// An iterator that zips two iterators together into pairs.
///
/// This struct is created by the [`zip`] function. See its documentation
/// for more details.
///
/// # Example
///
/// ```tml
/// use core::iter::*
///
/// let a: OnceI32 = once_i32(1)
/// let b: OnceI64 = once_i64(2)
/// let paired: Zip[OnceI32, OnceI64] = zip(a, b)
/// // Yields (1, 2)
/// ```
pub type Zip[A, B] {
    first: A,
    second: B
}

impl[A: Iterator, B: Iterator] Iterator for Zip[A, B] {
    type Item = (A::Item, B::Item)

    pub func next(mut this) -> Maybe[(A::Item, B::Item)] {
        when this.first.next() {
            Just(a) => {
                when this.second.next() {
                    Just(b) => return Just((a, b)),
                    Nothing => return Nothing
                }
            },
            Nothing => return Nothing
        }
    }

    pub func size_hint(this) -> (I64, Maybe[I64]) {
        let hint_a: (I64, Maybe[I64]) = this.first.size_hint()
        let hint_b: (I64, Maybe[I64]) = this.second.size_hint()

        var lo: I64 = hint_a.0
        if hint_b.0 < lo {
            lo = hint_b.0
        }

        let hi: Maybe[I64] = when hint_a.1 {
            Just(a) => {
                when hint_b.1 {
                    Just(b) => {
                        if a < b {
                            Just(a)
                        } else {
                            Just(b)
                        }
                    },
                    Nothing => Just(a)
                }
            },
            Nothing => hint_b.1
        }

        return (lo, hi)
    }
}

// ============================================================================
// Constructor Function
// ============================================================================

/// Creates an iterator that zips two iterators into pairs.
///
/// The resulting iterator yields tuples `(A, B)` where `A` comes from the
/// first iterator and `B` from the second. The iterator stops when either
/// input iterator is exhausted.
///
/// # Example
///
/// ```tml
/// use core::iter::*
///
/// let iter_a: RepeatNI32 = repeat_n_i32(1, 3)
/// let iter_b: RepeatNI32 = repeat_n_i32(2, 3)
/// let paired: Zip[RepeatNI32, RepeatNI32] = zip(iter_a, iter_b)
/// // Yields (1, 2), (1, 2), (1, 2)
/// ```
pub func zip[A: Iterator, B: Iterator](first: A, second: B) -> Zip[A, B] {
    return Zip { first: first, second: second }
}
