//! Type conversion behaviors.
//!
//! This module provides behaviors for converting between types, both
//! infallible (always succeeds) and fallible (may fail):
//!
//! | Behavior | Direction | Fallible? | Description |
//! |----------|-----------|-----------|-------------|
//! | [`From`] | `T -> Self` | No | Convert from another type |
//! | [`Into`] | `Self -> T` | No | Convert into another type |
//! | [`TryFrom`] | `T -> Outcome[Self, E]` | Yes | Fallible conversion from |
//! | [`TryInto`] | `Self -> Outcome[T, E]` | Yes | Fallible conversion into |
//! | [`AsRef`] | `&Self -> &T` | No | Cheap reference conversion |
//! | [`AsMut`] | `&mut Self -> &mut T` | No | Cheap mutable ref conversion |
//!
//! # From and Into
//!
//! [`From`] and [`Into`] are reciprocal behaviors. You should prefer
//! implementing `From`, as `Into` is automatically available when `From`
//! is implemented.
//!
//! ```tml
//! use core::convert::From
//!
//! // I64 can be created from I32
//! let big: I64 = I64::from(42 as I32)
//!
//! // Or use .into() on the source
//! let big: I64 = (42 as I32).into()
//! ```
//!
//! # Fallible Conversions
//!
//! When a conversion might fail (e.g., converting a large `I64` to `I32`),
//! use [`TryFrom`] and [`TryInto`]:
//!
//! ```tml
//! use core::convert::TryFrom
//!
//! // This might overflow
//! when I32::try_from(very_large_i64) {
//!     Ok(n) => use_number(n),
//!     Err(_) => println("Number too large!")
//! }
//! ```
//!
//! # Reference Conversions
//!
//! [`AsRef`] and [`AsMut`] provide cheap reference-to-reference conversions,
//! useful for generic code that needs to accept various types:
//!
//! ```tml
//! use core::convert::AsRef
//!
//! // Function that accepts anything that can be viewed as a [U8] slice
//! func process_bytes[T: AsRef[[U8]]](data: T) {
//!     let bytes: ref [U8] = data.as_ref()
//!     // ... process bytes
//! }
//!
//! process_bytes("hello")     // Str implements AsRef[[U8]]
//! process_bytes([1, 2, 3])   // Arrays implement AsRef[[U8]]
//! ```

// ============================================================================
// From Behavior
// ============================================================================

/// Infallible conversion from another type.
///
/// Implementing `From[T]` for type `U` means you can create a `U` from any `T`.
/// This is the preferred way to define type conversions.
///
/// # Implementing From
///
/// ```tml
/// use core::convert::From
///
/// pub type Celsius { value: F64 }
/// pub type Fahrenheit { value: F64 }
///
/// impl From[Celsius] for Fahrenheit {
///     pub func from(c: Celsius) -> Fahrenheit {
///         return Fahrenheit { value: c.value * 9.0 / 5.0 + 32.0 }
///     }
/// }
///
/// let c = Celsius { value: 100.0 }
/// let f = Fahrenheit::from(c)  // 212.0
/// ```
///
/// # Reflexivity
///
/// `From[T]` is automatically implemented for all types `T`, meaning
/// every type can be converted from itself: `T::from(t)` returns `t`.
pub behavior From[T] {
    /// Performs the conversion.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let n: I64 = I64::from(42 as I32)
    /// ```
    func from(value: T) -> Self
}

// ============================================================================
// Into Behavior
// ============================================================================

/// Conversion into another type.
///
/// `Into` is the reciprocal of [`From`]. You should prefer implementing
/// `From` over `Into`, because implementing `From` automatically provides
/// a corresponding `Into` implementation.
///
/// # Using Into
///
/// `Into` is most useful in generic contexts where you want to accept
/// any type that can be converted:
///
/// ```tml
/// use core::convert::Into
///
/// func takes_string[T: Into[Str]](value: T) {
///     let s: Str = value.into()
///     println(s)
/// }
///
/// takes_string("hello")  // Str -> Str
/// takes_string(42)       // I64 -> Str (if implemented)
/// ```
pub behavior Into[T] {
    /// Performs the conversion.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let n: I32 = 42
    /// let big: I64 = n.into()
    /// ```
    func into(this) -> T
}

// ============================================================================
// TryFrom Behavior
// ============================================================================

/// Fallible conversion from another type.
///
/// Use this when a conversion might fail, returning `Err` on failure.
/// This is the fallible version of [`From`].
///
/// # Examples
///
/// ```tml
/// use core::convert::TryFrom
///
/// let large: I64 = 999999999999
/// when I32::try_from(large) {
///     Ok(n) => println("Fits in I32: " + n.to_string()),
///     Err(e) => println("Too large for I32")
/// }
/// ```
///
/// # When to Use
///
/// - Numeric conversions that might overflow
/// - Parsing strings into structured types
/// - Any conversion where not all inputs are valid
pub behavior TryFrom[T] {
    /// The error type returned when conversion fails.
    type Error

    /// Attempts the conversion, returning `Err` on failure.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let result = I32::try_from(very_large_number)
    /// ```
    func try_from(value: T) -> Outcome[Self, This::Error]
}

// ============================================================================
// TryInto Behavior
// ============================================================================

/// Fallible conversion into another type.
///
/// This is the reciprocal of [`TryFrom`]. Prefer implementing `TryFrom`,
/// as `TryInto` should be automatically provided when `TryFrom` exists.
///
/// # Examples
///
/// ```tml
/// use core::convert::TryInto
///
/// let large: I64 = 999999999999
/// let result: Outcome[I32, _] = large.try_into()
/// ```
pub behavior TryInto[T] {
    /// The error type returned when conversion fails.
    type Error

    /// Attempts the conversion, returning `Err` on failure.
    func try_into(this) -> Outcome[T, This::Error]
}

// ============================================================================
// AsRef Behavior
// ============================================================================

/// Cheap reference-to-reference conversion.
///
/// Use `AsRef` when you want to accept different types that can all be
/// "viewed as" a common reference type. This is a zero-cost abstraction
/// for generic programming.
///
/// # Examples
///
/// ```tml
/// use core::convert::AsRef
///
/// // Accept anything that can be viewed as a string
/// func print_len[T: AsRef[Str]](value: ref T) {
///     let s: ref Str = value.as_ref()
///     println("Length: " + s.len().to_string())
/// }
/// ```
///
/// # Implementing AsRef
///
/// ```tml
/// impl AsRef[Str] for MyString {
///     pub func as_ref(this) -> ref Str {
///         return ref this.inner
///     }
/// }
/// ```
pub behavior AsRef[T] {
    /// Converts this reference to a reference of type `T`.
    ///
    /// This should be a cheap operation (ideally O(1)).
    func as_ref(this) -> ref T
}

// ============================================================================
// AsMut Behavior
// ============================================================================

/// Cheap mutable reference-to-reference conversion.
///
/// This is the mutable version of [`AsRef`]. Use it when you need to
/// accept different types that can all be "viewed as" a common mutable
/// reference type.
///
/// # Examples
///
/// ```tml
/// use core::convert::AsMut
///
/// func clear_data[T: AsMut[[U8]]](data: mut ref T) {
///     let bytes: mut ref [U8] = data.as_mut()
///     loop i in 0 to bytes.len() {
///         bytes[i] = 0
///     }
/// }
/// ```
pub behavior AsMut[T] {
    /// Converts this mutable reference to a mutable reference of type `T`.
    ///
    /// This should be a cheap operation (ideally O(1)).
    func as_mut(mut this) -> mut ref T
}

// ============================================================================
// Identity conversions
// ============================================================================

/// Every type can be converted from itself (identity conversion).
///
/// This allows generic code to accept any type where `T::from(value)` works.
impl[T] From[T] for T {
    pub func from(value: T) -> T {
        return value
    }
}

// ============================================================================
// Numeric conversions: smaller to larger (infallible)
// ============================================================================
// These conversions are always safe because the destination type is larger.

/// `I8` -> `I16` (widening conversion, always safe)
impl From[I8] for I16 {
    pub func from(value: I8) -> I16 {
        return value as I16
    }
}

/// `I8` -> `I32` (widening conversion, always safe)
impl From[I8] for I32 {
    pub func from(value: I8) -> I32 {
        return value as I32
    }
}

/// `I8` -> `I64` (widening conversion, always safe)
impl From[I8] for I64 {
    pub func from(value: I8) -> I64 {
        return value as I64
    }
}

/// `I16` -> `I32` (widening conversion, always safe)
impl From[I16] for I32 {
    pub func from(value: I16) -> I32 {
        return value as I32
    }
}

/// `I16` -> `I64` (widening conversion, always safe)
impl From[I16] for I64 {
    pub func from(value: I16) -> I64 {
        return value as I64
    }
}

/// `I32` -> `I64` (widening conversion, always safe)
impl From[I32] for I64 {
    pub func from(value: I32) -> I64 {
        return value as I64
    }
}

/// `U8` -> `U16` (widening conversion, always safe)
impl From[U8] for U16 {
    pub func from(value: U8) -> U16 {
        return value as U16
    }
}

/// `U8` -> `U32` (widening conversion, always safe)
impl From[U8] for U32 {
    pub func from(value: U8) -> U32 {
        return value as U32
    }
}

/// `U8` -> `U64` (widening conversion, always safe)
impl From[U8] for U64 {
    pub func from(value: U8) -> U64 {
        return value as U64
    }
}

/// `U16` -> `U32` (widening conversion, always safe)
impl From[U16] for U32 {
    pub func from(value: U16) -> U32 {
        return value as U32
    }
}

/// `U16` -> `U64` (widening conversion, always safe)
impl From[U16] for U64 {
    pub func from(value: U16) -> U64 {
        return value as U64
    }
}

/// `U32` -> `U64` (widening conversion, always safe)
impl From[U32] for U64 {
    pub func from(value: U32) -> U64 {
        return value as U64
    }
}

/// `F32` -> `F64` (widening conversion, always safe)
impl From[F32] for F64 {
    pub func from(value: F32) -> F64 {
        return value as F64
    }
}

// ============================================================================
// Bool conversions
// ============================================================================

/// `Bool` -> `I32`: `false` becomes `0`, `true` becomes `1`.
impl From[Bool] for I32 {
    pub func from(value: Bool) -> I32 {
        if value {
            return 1
        }
        return 0
    }
}

/// `Bool` -> `I64`: `false` becomes `0`, `true` becomes `1`.
impl From[Bool] for I64 {
    pub func from(value: Bool) -> I64 {
        if value {
            return 1
        }
        return 0
    }
}

// ============================================================================
// Maybe conversions
// ============================================================================

/// Any value `T` can be converted into `Just(value)`.
///
/// This makes it easy to wrap values in `Maybe`:
///
/// ```tml
/// let x: Maybe[I64] = Maybe::from(42)  // Just(42)
/// ```
impl[T] From[T] for Maybe[T] {
    pub func from(value: T) -> Maybe[T] {
        return Just(value)
    }
}

// ============================================================================
// Outcome conversions
// ============================================================================

/// Any value `T` can be converted into `Ok(value)`.
///
/// This makes it easy to wrap successful values:
///
/// ```tml
/// let x: Outcome[I64, Str] = Outcome::from(42)  // Ok(42)
/// ```
impl[T, E] From[T] for Outcome[T, E] {
    pub func from(value: T) -> Outcome[T, E] {
        return Ok(value)
    }
}

// ============================================================================
// TryFrom narrowing conversions: larger to smaller (fallible)
// ============================================================================
// These conversions may fail if the value doesn't fit in the target type.

/// Error type for numeric conversion failures.
pub type TryFromIntError {
    /// Attempted to convert a value that was too large for the target type.
    Overflow,
    /// Attempted to convert a negative value to an unsigned type.
    NegativeToUnsigned
}

/// `I16` -> `I8` (narrowing conversion, may overflow)
impl TryFrom[I16] for I8 {
    type Error = TryFromIntError

    pub func try_from(value: I16) -> Outcome[I8, TryFromIntError] {
        if value < -128 or value > 127 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I8)
    }
}

/// `I32` -> `I8` (narrowing conversion, may overflow)
impl TryFrom[I32] for I8 {
    type Error = TryFromIntError

    pub func try_from(value: I32) -> Outcome[I8, TryFromIntError] {
        if value < -128 or value > 127 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I8)
    }
}

/// `I32` -> `I16` (narrowing conversion, may overflow)
impl TryFrom[I32] for I16 {
    type Error = TryFromIntError

    pub func try_from(value: I32) -> Outcome[I16, TryFromIntError] {
        if value < -32768 or value > 32767 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I16)
    }
}

/// `I64` -> `I8` (narrowing conversion, may overflow)
impl TryFrom[I64] for I8 {
    type Error = TryFromIntError

    pub func try_from(value: I64) -> Outcome[I8, TryFromIntError] {
        if value < -128 or value > 127 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I8)
    }
}

/// `I64` -> `I16` (narrowing conversion, may overflow)
impl TryFrom[I64] for I16 {
    type Error = TryFromIntError

    pub func try_from(value: I64) -> Outcome[I16, TryFromIntError] {
        if value < -32768 or value > 32767 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I16)
    }
}

/// `I64` -> `I32` (narrowing conversion, may overflow)
impl TryFrom[I64] for I32 {
    type Error = TryFromIntError

    pub func try_from(value: I64) -> Outcome[I32, TryFromIntError] {
        if value < -2147483648 or value > 2147483647 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I32)
    }
}

/// `U16` -> `U8` (narrowing conversion, may overflow)
impl TryFrom[U16] for U8 {
    type Error = TryFromIntError

    pub func try_from(value: U16) -> Outcome[U8, TryFromIntError] {
        if value > 255 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U8)
    }
}

/// `U32` -> `U8` (narrowing conversion, may overflow)
impl TryFrom[U32] for U8 {
    type Error = TryFromIntError

    pub func try_from(value: U32) -> Outcome[U8, TryFromIntError] {
        if value > 255 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U8)
    }
}

/// `U32` -> `U16` (narrowing conversion, may overflow)
impl TryFrom[U32] for U16 {
    type Error = TryFromIntError

    pub func try_from(value: U32) -> Outcome[U16, TryFromIntError] {
        if value > 65535 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U16)
    }
}

/// `U64` -> `U8` (narrowing conversion, may overflow)
impl TryFrom[U64] for U8 {
    type Error = TryFromIntError

    pub func try_from(value: U64) -> Outcome[U8, TryFromIntError] {
        if value > 255 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U8)
    }
}

/// `U64` -> `U16` (narrowing conversion, may overflow)
impl TryFrom[U64] for U16 {
    type Error = TryFromIntError

    pub func try_from(value: U64) -> Outcome[U16, TryFromIntError] {
        if value > 65535 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U16)
    }
}

/// `U64` -> `U32` (narrowing conversion, may overflow)
impl TryFrom[U64] for U32 {
    type Error = TryFromIntError

    pub func try_from(value: U64) -> Outcome[U32, TryFromIntError] {
        if value > 4294967295 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as U32)
    }
}

// ============================================================================
// TryFrom signed/unsigned cross conversions
// ============================================================================

/// `I8` -> `U8` (may fail if negative)
impl TryFrom[I8] for U8 {
    type Error = TryFromIntError

    pub func try_from(value: I8) -> Outcome[U8, TryFromIntError] {
        if value < 0 {
            return Err(TryFromIntError::NegativeToUnsigned)
        }
        return Ok(value as U8)
    }
}

/// `I16` -> `U16` (may fail if negative)
impl TryFrom[I16] for U16 {
    type Error = TryFromIntError

    pub func try_from(value: I16) -> Outcome[U16, TryFromIntError] {
        if value < 0 {
            return Err(TryFromIntError::NegativeToUnsigned)
        }
        return Ok(value as U16)
    }
}

/// `I32` -> `U32` (may fail if negative)
impl TryFrom[I32] for U32 {
    type Error = TryFromIntError

    pub func try_from(value: I32) -> Outcome[U32, TryFromIntError] {
        if value < 0 {
            return Err(TryFromIntError::NegativeToUnsigned)
        }
        return Ok(value as U32)
    }
}

/// `I64` -> `U64` (may fail if negative)
impl TryFrom[I64] for U64 {
    type Error = TryFromIntError

    pub func try_from(value: I64) -> Outcome[U64, TryFromIntError] {
        if value < 0 {
            return Err(TryFromIntError::NegativeToUnsigned)
        }
        return Ok(value as U64)
    }
}

/// `U8` -> `I8` (may overflow if > 127)
impl TryFrom[U8] for I8 {
    type Error = TryFromIntError

    pub func try_from(value: U8) -> Outcome[I8, TryFromIntError] {
        if value > 127 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I8)
    }
}

/// `U16` -> `I16` (may overflow if > 32767)
impl TryFrom[U16] for I16 {
    type Error = TryFromIntError

    pub func try_from(value: U16) -> Outcome[I16, TryFromIntError] {
        if value > 32767 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I16)
    }
}

/// `U32` -> `I32` (may overflow if > 2147483647)
impl TryFrom[U32] for I32 {
    type Error = TryFromIntError

    pub func try_from(value: U32) -> Outcome[I32, TryFromIntError] {
        if value > 2147483647 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I32)
    }
}

/// `U64` -> `I64` (may overflow if > 9223372036854775807)
impl TryFrom[U64] for I64 {
    type Error = TryFromIntError

    pub func try_from(value: U64) -> Outcome[I64, TryFromIntError] {
        if value > 9223372036854775807 {
            return Err(TryFromIntError::Overflow)
        }
        return Ok(value as I64)
    }
}
