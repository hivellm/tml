// Tests for core::error â€” ChainedError, ParseError with position
use test::{assert, assert_eq}
use core::error::{SimpleError, ParseError, ChainedError}

// === ParseError with position ===

@test
func test_parse_error_with_position_fmt() -> I32 {
    let err = ParseError::with_position("bad token", 10)
    let s = err.to_string()
    assert(s.contains("10"), "should contain position 10")
    assert(s.contains("bad token"), "should contain message")
    assert(s.contains("position"), "should say position")
    return 0
}

@test
func test_parse_error_debug_with_pos() -> I32 {
    let err = ParseError::with_position("x", 5)
    let dbg = err.debug_string()
    assert(dbg.contains("Just"), "debug should show Just for position")
    assert(dbg.contains("5"), "debug should contain position value")
    return 0
}

@test
func test_simple_error_description() -> I32 {
    let err = SimpleError::new("desc test")
    let d = err.description()
    assert_eq(d, "desc test", "description should match to_string")
    return 0
}

// === ChainedError ===

@test
func test_chained_error_to_string() -> I32 {
    let cause: SimpleError = SimpleError::new("root cause")
    let chained: ChainedError[SimpleError] = ChainedError::new("context", cause)
    assert_eq(chained.to_string(), "context: root cause", "ChainedError to_string")
    return 0
}

@test
func test_chained_error_debug_string() -> I32 {
    let cause: SimpleError = SimpleError::new("oops")
    let chained: ChainedError[SimpleError] = ChainedError::new("failed", cause)
    let dbg: Str = chained.debug_string()
    assert(dbg.contains("ChainedError"), "debug contains type name")
    assert(dbg.contains("failed"), "debug contains message")
    return 0
}

@test
func test_chained_error_cause() -> I32 {
    let cause: SimpleError = SimpleError::new("inner")
    let chained: ChainedError[SimpleError] = ChainedError::new("outer", cause)
    let c: ref SimpleError = chained.cause()
    assert_eq(c.to_string(), "inner", "cause returns inner error")
    return 0
}
