// Tests for uncovered str functions
use test
use core::str
use test::{assert, assert_eq}

@test
func test_str_len() -> I32 {
    let s: Str = "hello"
    let n: I64 = str::len(s)
    assert(n == 5 as I64, "len of hello = 5")
    return 0
}

@test
func test_str_is_empty_false() -> I32 {
    assert(str::is_empty("hello") == false, "hello is not empty")
    return 0
}

@test
func test_str_is_empty_true() -> I32 {
    assert(str::is_empty("") == true, "empty string is empty")
    return 0
}

@test
func test_str_contains_true() -> I32 {
    assert(str::contains("hello world", "world"), "contains world")
    return 0
}

@test
func test_str_contains_false() -> I32 {
    assert(str::contains("hello", "xyz") == false, "does not contain xyz")
    return 0
}

@test
func test_str_starts_with() -> I32 {
    assert(str::starts_with("hello world", "hello"), "starts with hello")
    assert(str::starts_with("hello", "xyz") == false, "not starts with xyz")
    return 0
}

@test
func test_str_ends_with() -> I32 {
    assert(str::ends_with("hello world", "world"), "ends with world")
    assert(str::ends_with("hello", "xyz") == false, "not ends with xyz")
    return 0
}

// =============================================================================
// str::join (free function â€” currently 0% coverage)
// =============================================================================

@test
func test_str_join_basic() -> I32 {
    let parts: List[Str] = str::split("hello world", " ")
    let result: Str = str::join(parts, "-")
    assert_eq(result, "hello-world", "join with dash")
    return 0
}

@test
func test_str_join_comma() -> I32 {
    let parts: List[Str] = str::split("a,b,c", ",")
    let result: Str = str::join(parts, " + ")
    assert_eq(result, "a + b + c", "join with plus")
    return 0
}

@test
func test_str_join_empty_sep() -> I32 {
    let parts: List[Str] = str::split("x-y-z", "-")
    let result: Str = str::join(parts, "")
    assert_eq(result, "xyz", "join with empty separator")
    return 0
}

// =============================================================================
// str::concat_all (free function â€” currently 0% coverage)
// =============================================================================

@test
func test_str_concat_all() -> I32 {
    let parts: List[Str] = str::split("a,b,c", ",")
    let result: Str = str::concat_all(parts)
    assert_eq(result, "abc", "concat_all")
    return 0
}

// NOTE: Str::split method, Str::chars method, Str::parse_i64/u16 methods
// are blocked by codegen issues (List[Str] return type, Maybe[I64] layout).
// These need compiler fixes before tests can cover them.

@test
func test_str_slice_str() -> I32 {
    let s: Str = "hello world"
    let sub: Str = s.slice_str(0, 5)
    assert_eq(sub, "hello", "slice_str(0,5)")
    return 0
}

@test
func test_str_slice_str_middle() -> I32 {
    let s: Str = "hello world"
    let sub: Str = s.slice_str(6, 11)
    assert_eq(sub, "world", "slice_str(6,11)")
    return 0
}

@test
func test_str_slice_str_empty() -> I32 {
    let s: Str = "hello"
    let sub: Str = s.slice_str(0, 0)
    assert_eq(sub, "", "slice_str(0,0) = empty")
    return 0
}

// ============================================================================
// Str::chars
// ============================================================================

@test
func test_str_chars() -> I32 {
    let s: Str = "abc"
    let ch = s.chars()
    assert(true, "chars() runs without crash")
    return 0
}
