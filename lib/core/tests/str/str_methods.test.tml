// Tests for Str methods that work (builtin dispatch)
use test

// Str.char_at() skipped - returns () instead of I32 (behavior dispatch bug)

// =============================================================================
// Str.to_uppercase() / Str.to_lowercase()
// =============================================================================

@test
func test_str_to_uppercase() -> I32 {
    let s: Str = "hello"
    assert_eq(s.to_uppercase(), "HELLO", "to_uppercase hello")
    return 0
}

@test
func test_str_to_uppercase_mixed() -> I32 {
    let s: Str = "Hello World"
    assert_eq(s.to_uppercase(), "HELLO WORLD", "to_uppercase mixed")
    return 0
}

@test
func test_str_to_lowercase() -> I32 {
    let s: Str = "HELLO"
    assert_eq(s.to_lowercase(), "hello", "to_lowercase HELLO")
    return 0
}

@test
func test_str_to_lowercase_mixed() -> I32 {
    let s: Str = "Hello World"
    assert_eq(s.to_lowercase(), "hello world", "to_lowercase mixed")
    return 0
}

// =============================================================================
// Str.trim() / Str.trim_start() / Str.trim_end()
// =============================================================================

@test
func test_str_trim() -> I32 {
    let s: Str = "  hello  "
    assert_eq(s.trim(), "hello", "trim spaces")
    return 0
}

@test
func test_str_trim_no_spaces() -> I32 {
    let s: Str = "hello"
    assert_eq(s.trim(), "hello", "trim no spaces")
    return 0
}

@test
func test_str_trim_start() -> I32 {
    let s: Str = "  hello  "
    assert_eq(s.trim_start(), "hello  ", "trim_start")
    return 0
}

@test
func test_str_trim_end() -> I32 {
    let s: Str = "  hello  "
    assert_eq(s.trim_end(), "  hello", "trim_end")
    return 0
}

// =============================================================================
// Str.starts_with() / Str.ends_with() / Str.contains()
// =============================================================================

@test
func test_str_starts_with_true() -> I32 {
    let s: Str = "hello world"
    assert(s.starts_with("hello"), "starts_with hello")
    return 0
}

@test
func test_str_starts_with_false() -> I32 {
    let s: Str = "hello world"
    assert(not s.starts_with("world"), "not starts_with world")
    return 0
}

@test
func test_str_ends_with_true() -> I32 {
    let s: Str = "hello world"
    assert(s.ends_with("world"), "ends_with world")
    return 0
}

@test
func test_str_ends_with_false() -> I32 {
    let s: Str = "hello world"
    assert(not s.ends_with("hello"), "not ends_with hello")
    return 0
}

@test
func test_str_contains_true() -> I32 {
    let s: Str = "hello world"
    assert(s.contains("lo wo"), "contains lo wo")
    return 0
}

@test
func test_str_contains_false() -> I32 {
    let s: Str = "hello"
    assert(not s.contains("xyz"), "not contains xyz")
    return 0
}

@test
func test_str_contains_empty() -> I32 {
    let s: Str = "hello"
    assert(s.contains(""), "contains empty")
    return 0
}

// =============================================================================
// String concatenation
// =============================================================================

@test
func test_str_concat_plus() -> I32 {
    let a: Str = "Hello"
    let b: Str = " World"
    let result: Str = a + b
    assert_eq(result, "Hello World", "concat +")
    return 0
}

@test
func test_str_concat_empty() -> I32 {
    let a: Str = "Hello"
    let result: Str = a + ""
    assert_eq(result, "Hello", "concat empty")
    return 0
}

// Note: Str.slice(), Str.find(), Str.rfind(), Str.replace() return ()
// due to behavior dispatch bug - skipped
