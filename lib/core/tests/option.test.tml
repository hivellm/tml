// Consolidated tests for core::option (51 tests)
use test::*

// =============================================================================
// Helper functions
// =============================================================================

func find_first_positive(a: I32, b: I32, c: I32) -> Maybe[I32] {
    if a > 0 {
        return Just(a)
    }
    if b > 0 {
        return Just(b)
    }
    if c > 0 {
        return Just(c)
    }
    return Nothing
}

// =============================================================================
// From: option_basics.test.tml
// Tests for Maybe[T] basic state checking and value extraction
// =============================================================================

@test
func test_maybe_is_just() -> I32 {
    let j: Maybe[I32] = Just(10)
    let n: Maybe[I32] = Nothing
    assert(j.is_just(), "Just should be is_just")
    assert(not n.is_just(), "Nothing should not be is_just")
    return 0
}

@test
func test_maybe_is_nothing() -> I32 {
    let j: Maybe[I32] = Just(10)
    let n: Maybe[I32] = Nothing
    assert(not j.is_nothing(), "Just should not be is_nothing")
    assert(n.is_nothing(), "Nothing should be is_nothing")
    return 0
}

@test
func test_maybe_unwrap_just() -> I32 {
    let opt: Maybe[I32] = Just(77)
    let val: I32 = opt.unwrap()
    assert(val == 77, "unwrap on Just should return value")
    return 0
}

// =============================================================================
// From: option_extract.test.tml
// Tests for Maybe[T] value extraction: unwrap_or, unwrap
// =============================================================================

@test
func test_maybe_unwrap_or_just() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let val: I32 = opt.unwrap_or(0)
    assert(val == 42, "unwrap_or on Just should return inner value")
    return 0
}

@test
func test_maybe_unwrap_or_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let val: I32 = opt.unwrap_or(99)
    assert(val == 99, "unwrap_or on Nothing should return default")
    return 0
}

@test
func test_maybe_unwrap_or_zero() -> I32 {
    let opt: Maybe[I32] = Nothing
    let val: I32 = opt.unwrap_or(0)
    assert(val == 0, "unwrap_or on Nothing with 0 default")
    return 0
}

// =============================================================================
// From: option_convert.test.tml
// Tests for Maybe[T] additional patterns and edge cases
// =============================================================================

@test
func test_maybe_unwrap_or_negative() -> I32 {
    let opt: Maybe[I32] = Nothing
    let val: I32 = opt.unwrap_or(-100)
    assert(val == -100, "unwrap_or with negative default")
    return 0
}

@test
func test_maybe_and_then_to_nothing() -> I32 {
    let opt: Maybe[I32] = Just(3)
    let result: Maybe[I32] = opt.and_then(do(_x) Nothing)
    assert(result.is_nothing(), "and_then returning Nothing should be Nothing")
    return 0
}

@test
func test_maybe_filter_boundary() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let pass: Maybe[I32] = opt.filter(do(x) x >= 5)
    let fail: Maybe[I32] = opt.filter(do(x) x > 5)
    assert(pass.is_just(), "filter >= 5 should keep 5")
    assert(fail.is_nothing(), "filter > 5 should drop 5")
    return 0
}

// =============================================================================
// From: option.test.tml
// Tests for core::option module (Maybe type)
// Note: Some tests commented out due to codegen bugs with generic closures
// =============================================================================

// -- Maybe::contains Tests --

@test
func test_maybe_contains_just_true() -> I32 {
    let opt: Maybe[I32] = Just(42)
    assert(opt.contains(42), "Just(42) should contain 42")
    return 0
}

@test
func test_maybe_contains_just_false() -> I32 {
    let opt: Maybe[I32] = Just(42)
    assert(not opt.contains(99), "Just(42) should not contain 99")
    return 0
}

@test
func test_maybe_contains_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    assert(not opt.contains(42), "Nothing should not contain anything")
    return 0
}

// -- Maybe::expect Tests --

@test
func test_maybe_expect_just() -> I32 {
    let opt: Maybe[I32] = Just(123)
    let value: I32 = opt.expect("should have value")
    assert(value == 123, "expect on Just should return value")
    return 0
}

// -- Maybe::unwrap_or_else Tests --

@test
func test_maybe_unwrap_or_else_just() -> I32 {
    let opt: Maybe[I32] = Just(50)
    let value: I32 = opt.unwrap_or_else(do() 0)
    assert(value == 50, "unwrap_or_else on Just should return inner value")
    return 0
}

@test
func test_maybe_unwrap_or_else_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.unwrap_or_else(do() 99)
    assert(value == 99, "unwrap_or_else on Nothing should call closure")
    return 0
}

// -- Maybe::map Tests --

@test
func test_maybe_map_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let mapped: Maybe[I32] = opt.map(do(x) x * 2)
    when mapped {
        Just(v) => assert(v == 10, "map on Just(5) with *2 should be Just(10)"),
        Nothing => assert(false, "map on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_map_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let mapped: Maybe[I32] = opt.map(do(x) x * 2)
    when mapped {
        Just(_) => assert(false, "map on Nothing should be Nothing"),
        Nothing => assert(true, "map on Nothing returns Nothing")
    }
    return 0
}

@test
func test_maybe_map_type_change() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let mapped: Maybe[I64] = opt.map(do(x) x as I64 + 100)
    when mapped {
        Just(v) => assert(v == (142 as I64), "map can change type"),
        Nothing => assert(false, "should be Just")
    }
    return 0
}

// -- Maybe::map_or Tests --

@test
func test_maybe_map_or_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let value: I32 = opt.map_or(0, do(x) x + 10)
    assert(value == 15, "map_or on Just should transform value")
    return 0
}

@test
func test_maybe_map_or_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.map_or(42, do(x) x + 10)
    assert(value == 42, "map_or on Nothing should return default")
    return 0
}

// -- Maybe::and_then Tests --

@test
func test_maybe_and_then_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let result: Maybe[I32] = opt.and_then(do(x) Just(x * 2))
    when result {
        Just(v) => assert(v == 10, "and_then on Just should chain"),
        Nothing => assert(false, "and_then on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_and_then_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.and_then(do(x) Just(x * 2))
    when result {
        Just(_) => assert(false, "and_then on Nothing should be Nothing"),
        Nothing => assert(true, "and_then on Nothing returns Nothing")
    }
    return 0
}

@test
func test_maybe_and_then_returns_nothing() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let result: Maybe[I32] = opt.and_then(do(_x) Nothing)
    when result {
        Just(_) => assert(false, "and_then returning Nothing should be Nothing"),
        Nothing => assert(true, "and_then can return Nothing")
    }
    return 0
}

// -- Maybe::filter Tests --

@test
func test_maybe_filter_just_passes() -> I32 {
    let opt: Maybe[I32] = Just(10)
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(v) => assert(v == 10, "filter should keep value when predicate passes"),
        Nothing => assert(false, "filter should not return Nothing when predicate passes")
    }
    return 0
}

@test
func test_maybe_filter_just_fails() -> I32 {
    let opt: Maybe[I32] = Just(3)
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(_) => assert(false, "filter should return Nothing when predicate fails"),
        Nothing => assert(true, "filter returns Nothing when predicate fails")
    }
    return 0
}

@test
func test_maybe_filter_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(_) => assert(false, "filter on Nothing should be Nothing"),
        Nothing => assert(true, "filter on Nothing returns Nothing")
    }
    return 0
}

// -- Maybe::alt Tests --

@test
func test_maybe_alt_just_just() -> I32 {
    let opt1: Maybe[I32] = Just(1)
    let opt2: Maybe[I32] = Just(2)
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(v) => assert(v == 1, "alt should return first Just"),
        Nothing => assert(false, "alt with Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_alt_nothing_just() -> I32 {
    let opt1: Maybe[I32] = Nothing
    let opt2: Maybe[I32] = Just(2)
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(v) => assert(v == 2, "alt should return second when first is Nothing"),
        Nothing => assert(false, "alt with second Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_alt_nothing_nothing() -> I32 {
    let opt1: Maybe[I32] = Nothing
    let opt2: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(_) => assert(false, "alt with both Nothing should be Nothing"),
        Nothing => assert(true, "alt with both Nothing returns Nothing")
    }
    return 0
}

// -- Maybe::or_else Tests --

@test
func test_maybe_or_else_just() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let result: Maybe[I32] = opt.or_else(do() Just(99))
    when result {
        Just(v) => assert(v == 42, "or_else on Just should return original"),
        Nothing => assert(false, "or_else on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_or_else_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.or_else(do() Just(99))
    when result {
        Just(v) => assert(v == 99, "or_else on Nothing should call closure"),
        Nothing => assert(false, "or_else returning Just should not be Nothing")
    }
    return 0
}

// -- Maybe::unwrap_or_default Tests --

@test
func test_maybe_unwrap_or_default_just() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let value: I32 = opt.unwrap_or_default()
    assert(value == 42, "unwrap_or_default on Just should return value")
    return 0
}

@test
func test_maybe_unwrap_or_default_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.unwrap_or_default()
    assert(value == 0, "unwrap_or_default on Nothing should return 0 for I32")
    return 0
}

// =============================================================================
// From: option_one_of.test.tml
// Test for Maybe::one_of method (renamed from xor because xor is a keyword)
// =============================================================================

@test
func test_maybe_one_of_just_nothing() {
    let x: Maybe[I32] = Just(2)
    let y: Maybe[I32] = Nothing
    let result: Maybe[I32] = x.one_of(y)
    // Just xor Nothing = Just
    assert(result.is_just())
}

@test
func test_maybe_one_of_nothing_just() {
    let x: Maybe[I32] = Nothing
    let y: Maybe[I32] = Just(3)
    let result: Maybe[I32] = x.one_of(y)
    // Nothing xor Just = Just
    assert(result.is_just())
}

@test
func test_maybe_one_of_just_just() {
    let x: Maybe[I32] = Just(2)
    let y: Maybe[I32] = Just(3)
    let result: Maybe[I32] = x.one_of(y)
    // Just xor Just = Nothing
    assert(result.is_nothing())
}

@test
func test_maybe_one_of_nothing_nothing() {
    let x: Maybe[I32] = Nothing
    let y: Maybe[I32] = Nothing
    let result: Maybe[I32] = x.one_of(y)
    // Nothing xor Nothing = Nothing
    assert(result.is_nothing())
}

// =============================================================================
// From: option_value_assertions.test.tml
// Tests for Maybe[T] with value assertions
// =============================================================================

// -- Just/Nothing creation and unwrap --

@test
func test_just_unwrap() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap(), 42, "Just(42).unwrap() should be 42")
    return 0
}

@test
func test_just_is_just() -> I32 {
    let m: Maybe[I32] = Just(10)
    assert(m.is_just(), "Just should be just")
    assert(not m.is_nothing(), "Just should not be nothing")
    return 0
}

@test
func test_nothing_is_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    assert(m.is_nothing(), "Nothing should be nothing")
    assert(not m.is_just(), "Nothing should not be just")
    return 0
}

// -- unwrap_or --

@test
func test_just_unwrap_or() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap_or(0), 42, "Just(42).unwrap_or(0) should be 42")
    return 0
}

@test
func test_nothing_unwrap_or() -> I32 {
    let m: Maybe[I32] = Nothing
    assert_eq(m.unwrap_or(99), 99, "Nothing.unwrap_or(99) should be 99")
    return 0
}

// -- Maybe from functions --

@test
func test_find_first_positive_found() -> I32 {
    let r: Maybe[I32] = find_first_positive(-1, 5, 10)
    assert(r.is_just(), "should find positive")
    assert_eq(r.unwrap(), 5, "first positive should be 5")
    return 0
}

@test
func test_find_first_positive_none() -> I32 {
    let r: Maybe[I32] = find_first_positive(-1, -2, -3)
    assert(r.is_nothing(), "no positive should be Nothing")
    return 0
}

@test
func test_find_first_positive_first() -> I32 {
    let r: Maybe[I32] = find_first_positive(7, 8, 9)
    assert_eq(r.unwrap(), 7, "first positive should be 7")
    return 0
}

// -- contains --

@test
func test_contains_true() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert(m.contains(42), "Just(42) should contain 42")
    return 0
}

@test
func test_contains_false() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert(not m.contains(99), "Just(42) should not contain 99")
    return 0
}

@test
func test_nothing_contains() -> I32 {
    let m: Maybe[I32] = Nothing
    assert(not m.contains(42), "Nothing should not contain anything")
    return 0
}
