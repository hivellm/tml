// Tests for core::option module (Maybe type)
// Note: Some tests commented out due to codegen bugs with generic closures
use test

// ============================================================================
// Maybe::contains Tests
// ============================================================================

@test
func test_maybe_contains_just_true() -> I32 {
    let opt: Maybe[I32] = Just(42)
    assert(opt.contains(42), "Just(42) should contain 42")
    return 0
}

@test
func test_maybe_contains_just_false() -> I32 {
    let opt: Maybe[I32] = Just(42)
    assert(not opt.contains(99), "Just(42) should not contain 99")
    return 0
}

@test
func test_maybe_contains_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    assert(not opt.contains(42), "Nothing should not contain anything")
    return 0
}

// ============================================================================
// Maybe::expect Tests
// ============================================================================

@test
func test_maybe_expect_just() -> I32 {
    let opt: Maybe[I32] = Just(123)
    let value: I32 = opt.expect("should have value")
    assert(value == 123, "expect on Just should return value")
    return 0
}

// ============================================================================
// Maybe::unwrap_or_else Tests
// ============================================================================

@test
func test_maybe_unwrap_or_else_just() -> I32 {
    let opt: Maybe[I32] = Just(50)
    let value: I32 = opt.unwrap_or_else(do() 0)
    assert(value == 50, "unwrap_or_else on Just should return inner value")
    return 0
}

@test
func test_maybe_unwrap_or_else_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.unwrap_or_else(do() 99)
    assert(value == 99, "unwrap_or_else on Nothing should call closure")
    return 0
}

// ============================================================================
// Maybe::map Tests
// ============================================================================

@test
func test_maybe_map_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let mapped: Maybe[I32] = opt.map(do(x) x * 2)
    when mapped {
        Just(v) => assert(v == 10, "map on Just(5) with *2 should be Just(10)"),
        Nothing => assert(false, "map on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_map_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let mapped: Maybe[I32] = opt.map(do(x) x * 2)
    when mapped {
        Just(_) => assert(false, "map on Nothing should be Nothing"),
        Nothing => assert(true, "map on Nothing returns Nothing")
    }
    return 0
}

@test
func test_maybe_map_type_change() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let mapped: Maybe[I64] = opt.map(do(x) x as I64 + 100)
    when mapped {
        Just(v) => assert(v == (142 as I64), "map can change type"),
        Nothing => assert(false, "should be Just")
    }
    return 0
}

// ============================================================================
// Maybe::map_or Tests
// ============================================================================

@test
func test_maybe_map_or_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let value: I32 = opt.map_or(0, do(x) x + 10)
    assert(value == 15, "map_or on Just should transform value")
    return 0
}

@test
func test_maybe_map_or_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.map_or(42, do(x) x + 10)
    assert(value == 42, "map_or on Nothing should return default")
    return 0
}

// ============================================================================
// Maybe::and_then Tests
// ============================================================================

@test
func test_maybe_and_then_just() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let result: Maybe[I32] = opt.and_then(do(x) Just(x * 2))
    when result {
        Just(v) => assert(v == 10, "and_then on Just should chain"),
        Nothing => assert(false, "and_then on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_and_then_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.and_then(do(x) Just(x * 2))
    when result {
        Just(_) => assert(false, "and_then on Nothing should be Nothing"),
        Nothing => assert(true, "and_then on Nothing returns Nothing")
    }
    return 0
}

@test
func test_maybe_and_then_returns_nothing() -> I32 {
    let opt: Maybe[I32] = Just(5)
    let result: Maybe[I32] = opt.and_then(do(_x) Nothing)
    when result {
        Just(_) => assert(false, "and_then returning Nothing should be Nothing"),
        Nothing => assert(true, "and_then can return Nothing")
    }
    return 0
}

// ============================================================================
// Maybe::filter Tests
// ============================================================================

@test
func test_maybe_filter_just_passes() -> I32 {
    let opt: Maybe[I32] = Just(10)
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(v) => assert(v == 10, "filter should keep value when predicate passes"),
        Nothing => assert(false, "filter should not return Nothing when predicate passes")
    }
    return 0
}

@test
func test_maybe_filter_just_fails() -> I32 {
    let opt: Maybe[I32] = Just(3)
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(_) => assert(false, "filter should return Nothing when predicate fails"),
        Nothing => assert(true, "filter returns Nothing when predicate fails")
    }
    return 0
}

@test
func test_maybe_filter_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.filter(do(x) x > 5)
    when result {
        Just(_) => assert(false, "filter on Nothing should be Nothing"),
        Nothing => assert(true, "filter on Nothing returns Nothing")
    }
    return 0
}

// ============================================================================
// Maybe::alt Tests
// ============================================================================

@test
func test_maybe_alt_just_just() -> I32 {
    let opt1: Maybe[I32] = Just(1)
    let opt2: Maybe[I32] = Just(2)
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(v) => assert(v == 1, "alt should return first Just"),
        Nothing => assert(false, "alt with Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_alt_nothing_just() -> I32 {
    let opt1: Maybe[I32] = Nothing
    let opt2: Maybe[I32] = Just(2)
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(v) => assert(v == 2, "alt should return second when first is Nothing"),
        Nothing => assert(false, "alt with second Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_alt_nothing_nothing() -> I32 {
    let opt1: Maybe[I32] = Nothing
    let opt2: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt1.alt(opt2)
    when result {
        Just(_) => assert(false, "alt with both Nothing should be Nothing"),
        Nothing => assert(true, "alt with both Nothing returns Nothing")
    }
    return 0
}

// ============================================================================
// Maybe::or_else Tests
// ============================================================================

@test
func test_maybe_or_else_just() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let result: Maybe[I32] = opt.or_else(do() Just(99))
    when result {
        Just(v) => assert(v == 42, "or_else on Just should return original"),
        Nothing => assert(false, "or_else on Just should not be Nothing")
    }
    return 0
}

@test
func test_maybe_or_else_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let result: Maybe[I32] = opt.or_else(do() Just(99))
    when result {
        Just(v) => assert(v == 99, "or_else on Nothing should call closure"),
        Nothing => assert(false, "or_else returning Just should not be Nothing")
    }
    return 0
}

// ============================================================================
// Maybe::unwrap_or_default Tests
// ============================================================================

@test
func test_maybe_unwrap_or_default_just() -> I32 {
    let opt: Maybe[I32] = Just(42)
    let value: I32 = opt.unwrap_or_default()
    assert(value == 42, "unwrap_or_default on Just should return value")
    return 0
}

@test
func test_maybe_unwrap_or_default_nothing() -> I32 {
    let opt: Maybe[I32] = Nothing
    let value: I32 = opt.unwrap_or_default()
    assert(value == 0, "unwrap_or_default on Nothing should return 0 for I32")
    return 0
}
