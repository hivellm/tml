// Tests for core::ascii module
// Tests ASCII character type and operations

use core::ascii::AsciiChar

// Helper to extract AsciiChar from Maybe
func get_char(m: Maybe[AsciiChar]) -> AsciiChar {
    when m {
        Just(c) => return c,
        Nothing => {
            assert(false, "unexpected Nothing")
            return AsciiChar::from_u8_unchecked(0)
        }
    }
}

// Helper to extract U8 from Maybe
func get_u8(m: Maybe[U8]) -> U8 {
    when m {
        Just(v) => return v,
        Nothing => {
            assert(false, "unexpected Nothing")
            return 0
        }
    }
}

// ============================================================================
// Char Creation
// ============================================================================

@test
func test_char_from_u8_valid() -> I32 {
    // Valid ASCII values (0-127)
    let a: Maybe[AsciiChar] = AsciiChar::from_u8(65)
    assert(a.is_just(), "65 should be valid ASCII")

    let zero: Maybe[AsciiChar] = AsciiChar::from_u8(0)
    assert(zero.is_just(), "0 should be valid ASCII")

    let max: Maybe[AsciiChar] = AsciiChar::from_u8(127)
    assert(max.is_just(), "127 should be valid ASCII")

    return 0
}

@test
func test_char_from_u8_invalid() -> I32 {
    // Invalid ASCII values (> 127)
    let invalid1: Maybe[AsciiChar] = AsciiChar::from_u8(128)
    assert(invalid1.is_nothing(), "128 should be invalid ASCII")

    let invalid2: Maybe[AsciiChar] = AsciiChar::from_u8(255)
    assert(invalid2.is_nothing(), "255 should be invalid ASCII")

    return 0
}

@test
func test_char_digit() -> I32 {
    // Valid digits
    let d0: Maybe[AsciiChar] = AsciiChar::digit(0)
    assert(d0.is_just(), "digit 0 should be valid")

    let d5: Maybe[AsciiChar] = AsciiChar::digit(5)
    assert(d5.is_just(), "digit 5 should be valid")

    let d9: Maybe[AsciiChar] = AsciiChar::digit(9)
    assert(d9.is_just(), "digit 9 should be valid")

    // Invalid digit
    let d10: Maybe[AsciiChar] = AsciiChar::digit(10)
    assert(d10.is_nothing(), "digit 10 should be invalid")

    return 0
}

@test
func test_char_to_u8() -> I32 {
    let a: AsciiChar = get_char(AsciiChar::from_u8(65))
    assert(a.to_u8() == 65, "A should have value 65")

    let space: AsciiChar = get_char(AsciiChar::from_u8(32))
    assert(space.to_u8() == 32, "space should have value 32")

    return 0
}

// ============================================================================
// Character Classification - Alphabetic
// ============================================================================

@test
func test_char_is_alphabetic() -> I32 {
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))       // 'a'
    let z: AsciiChar = get_char(AsciiChar::from_u8(122))      // 'z'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65)) // 'A'
    let upper_z: AsciiChar = get_char(AsciiChar::from_u8(90)) // 'Z'
    let digit: AsciiChar = get_char(AsciiChar::from_u8(48))   // '0'
    let space: AsciiChar = get_char(AsciiChar::from_u8(32))   // ' '

    assert(a.is_alphabetic(), "a should be alphabetic")
    assert(z.is_alphabetic(), "z should be alphabetic")
    assert(upper_a.is_alphabetic(), "A should be alphabetic")
    assert(upper_z.is_alphabetic(), "Z should be alphabetic")
    assert(not digit.is_alphabetic(), "0 should not be alphabetic")
    assert(not space.is_alphabetic(), "space should not be alphabetic")

    return 0
}

@test
func test_char_is_uppercase() -> I32 {
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65))  // 'A'
    let upper_z: AsciiChar = get_char(AsciiChar::from_u8(90))  // 'Z'
    let lower_a: AsciiChar = get_char(AsciiChar::from_u8(97))  // 'a'

    assert(upper_a.is_uppercase(), "A should be uppercase")
    assert(upper_z.is_uppercase(), "Z should be uppercase")
    assert(not lower_a.is_uppercase(), "a should not be uppercase")

    return 0
}

@test
func test_char_is_lowercase() -> I32 {
    let lower_a: AsciiChar = get_char(AsciiChar::from_u8(97))  // 'a'
    let lower_z: AsciiChar = get_char(AsciiChar::from_u8(122)) // 'z'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65))  // 'A'

    assert(lower_a.is_lowercase(), "a should be lowercase")
    assert(lower_z.is_lowercase(), "z should be lowercase")
    assert(not upper_a.is_lowercase(), "A should not be lowercase")

    return 0
}

// ============================================================================
// Character Classification - Numeric
// ============================================================================

@test
func test_char_is_digit() -> I32 {
    let d0: AsciiChar = get_char(AsciiChar::from_u8(48))  // '0'
    let d5: AsciiChar = get_char(AsciiChar::from_u8(53))  // '5'
    let d9: AsciiChar = get_char(AsciiChar::from_u8(57))  // '9'
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))   // 'a'

    assert(d0.is_digit(), "0 should be digit")
    assert(d5.is_digit(), "5 should be digit")
    assert(d9.is_digit(), "9 should be digit")
    assert(not a.is_digit(), "a should not be digit")

    return 0
}

@test
func test_char_is_hexdigit() -> I32 {
    let d0: AsciiChar = get_char(AsciiChar::from_u8(48))      // '0'
    let d9: AsciiChar = get_char(AsciiChar::from_u8(57))      // '9'
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))       // 'a'
    let f: AsciiChar = get_char(AsciiChar::from_u8(102))      // 'f'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65)) // 'A'
    let upper_f: AsciiChar = get_char(AsciiChar::from_u8(70)) // 'F'
    let g: AsciiChar = get_char(AsciiChar::from_u8(103))      // 'g'

    assert(d0.is_hexdigit(), "0 should be hexdigit")
    assert(d9.is_hexdigit(), "9 should be hexdigit")
    assert(a.is_hexdigit(), "a should be hexdigit")
    assert(f.is_hexdigit(), "f should be hexdigit")
    assert(upper_a.is_hexdigit(), "A should be hexdigit")
    assert(upper_f.is_hexdigit(), "F should be hexdigit")
    assert(not g.is_hexdigit(), "g should not be hexdigit")

    return 0
}

@test
func test_char_is_alphanumeric() -> I32 {
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))     // 'a'
    let z: AsciiChar = get_char(AsciiChar::from_u8(90))     // 'Z'
    let d5: AsciiChar = get_char(AsciiChar::from_u8(53))    // '5'
    let space: AsciiChar = get_char(AsciiChar::from_u8(32))

    assert(a.is_alphanumeric(), "a should be alphanumeric")
    assert(z.is_alphanumeric(), "Z should be alphanumeric")
    assert(d5.is_alphanumeric(), "5 should be alphanumeric")
    assert(not space.is_alphanumeric(), "space should not be alphanumeric")

    return 0
}

// ============================================================================
// Character Classification - Whitespace and Control
// ============================================================================

@test
func test_char_is_whitespace() -> I32 {
    let space: AsciiChar = get_char(AsciiChar::from_u8(32))  // ' '
    let tab: AsciiChar = get_char(AsciiChar::from_u8(9))     // '\t'
    let lf: AsciiChar = get_char(AsciiChar::from_u8(10))     // '\n'
    let cr: AsciiChar = get_char(AsciiChar::from_u8(13))     // '\r'
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))      // 'a'

    assert(space.is_whitespace(), "space should be whitespace")
    assert(tab.is_whitespace(), "tab should be whitespace")
    assert(lf.is_whitespace(), "line feed should be whitespace")
    assert(cr.is_whitespace(), "carriage return should be whitespace")
    assert(not a.is_whitespace(), "a should not be whitespace")

    return 0
}

@test
func test_char_is_control() -> I32 {
    let null_char: AsciiChar = get_char(AsciiChar::from_u8(0))
    let bell: AsciiChar = get_char(AsciiChar::from_u8(7))
    let del: AsciiChar = get_char(AsciiChar::from_u8(127))
    let space: AsciiChar = get_char(AsciiChar::from_u8(32))
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))

    assert(null_char.is_control(), "null should be control")
    assert(bell.is_control(), "bell should be control")
    assert(del.is_control(), "delete should be control")
    assert(not space.is_control(), "space should not be control")
    assert(not a.is_control(), "a should not be control")

    return 0
}

@test
func test_char_is_printable() -> I32 {
    let space: AsciiChar = get_char(AsciiChar::from_u8(32))
    let tilde: AsciiChar = get_char(AsciiChar::from_u8(126))
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))
    let null_char: AsciiChar = get_char(AsciiChar::from_u8(0))
    let del: AsciiChar = get_char(AsciiChar::from_u8(127))

    assert(space.is_printable(), "space should be printable")
    assert(tilde.is_printable(), "tilde should be printable")
    assert(a.is_printable(), "a should be printable")
    assert(not null_char.is_printable(), "null should not be printable")
    assert(not del.is_printable(), "delete should not be printable")

    return 0
}

// ============================================================================
// Case Conversion
// ============================================================================

@test
func test_char_to_lowercase() -> I32 {
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65))  // 'A'
    let upper_z: AsciiChar = get_char(AsciiChar::from_u8(90))  // 'Z'
    let lower_a: AsciiChar = get_char(AsciiChar::from_u8(97))  // 'a'
    let digit: AsciiChar = get_char(AsciiChar::from_u8(48))    // '0'

    // Test method chaining: .to_lowercase().to_u8()
    assert(upper_a.to_lowercase().to_u8() == 97, "A should lowercase to a")
    assert(upper_z.to_lowercase().to_u8() == 122, "Z should lowercase to z")
    assert(lower_a.to_lowercase().to_u8() == 97, "a should stay a")
    assert(digit.to_lowercase().to_u8() == 48, "0 should stay 0")

    return 0
}

@test
func test_char_to_uppercase() -> I32 {
    let lower_a: AsciiChar = get_char(AsciiChar::from_u8(97))  // 'a'
    let lower_z: AsciiChar = get_char(AsciiChar::from_u8(122)) // 'z'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65))  // 'A'
    let digit: AsciiChar = get_char(AsciiChar::from_u8(48))    // '0'

    // Test method chaining: .to_uppercase().to_u8()
    assert(lower_a.to_uppercase().to_u8() == 65, "a should uppercase to A")
    assert(lower_z.to_uppercase().to_u8() == 90, "z should uppercase to Z")
    assert(upper_a.to_uppercase().to_u8() == 65, "A should stay A")
    assert(digit.to_uppercase().to_u8() == 48, "0 should stay 0")

    return 0
}

@test
func test_char_eq_ignore_case() -> I32 {
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))       // 'a'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65)) // 'A'
    let b: AsciiChar = get_char(AsciiChar::from_u8(98))       // 'b'

    assert(a.eq_ignore_case(upper_a), "a should equal A ignoring case")
    assert(upper_a.eq_ignore_case(a), "A should equal a ignoring case")
    assert(not a.eq_ignore_case(b), "a should not equal b")

    return 0
}

// ============================================================================
// Digit Conversion
// ============================================================================

@test
func test_char_to_digit() -> I32 {
    let d0: AsciiChar = get_char(AsciiChar::from_u8(48))  // '0'
    let d5: AsciiChar = get_char(AsciiChar::from_u8(53))  // '5'
    let d9: AsciiChar = get_char(AsciiChar::from_u8(57))  // '9'
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))   // 'a'

    assert(get_u8(d0.to_digit()) == 0, "0 should convert to 0")
    assert(get_u8(d5.to_digit()) == 5, "5 should convert to 5")
    assert(get_u8(d9.to_digit()) == 9, "9 should convert to 9")
    assert(a.to_digit().is_nothing(), "a should not convert to digit")

    return 0
}

@test
func test_char_to_hexdigit() -> I32 {
    let d0: AsciiChar = get_char(AsciiChar::from_u8(48))      // '0'
    let d9: AsciiChar = get_char(AsciiChar::from_u8(57))      // '9'
    let a: AsciiChar = get_char(AsciiChar::from_u8(97))       // 'a'
    let f: AsciiChar = get_char(AsciiChar::from_u8(102))      // 'f'
    let upper_a: AsciiChar = get_char(AsciiChar::from_u8(65)) // 'A'

    assert(get_u8(d0.to_hexdigit()) == 0, "0 should convert to 0")
    assert(get_u8(d9.to_hexdigit()) == 9, "9 should convert to 9")
    assert(get_u8(a.to_hexdigit()) == 10, "a should convert to 10")
    assert(get_u8(f.to_hexdigit()) == 15, "f should convert to 15")
    assert(get_u8(upper_a.to_hexdigit()) == 10, "A should convert to 10")

    return 0
}

// Note: Constants tests removed - TML doesn't support accessing
// pub const defined in impl blocks via Type::Constant syntax yet
