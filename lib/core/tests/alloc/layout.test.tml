// Tests for core::alloc::layout - Layout and LayoutError
use test
use core::alloc::layout::{Layout, LayoutError}

@test
func test_layout_from_size_align_valid() -> I32 {
    let result: Outcome[Layout, LayoutError] = Layout::from_size_align(64, 8)
    assert(result.is_ok(), "64,8 should be valid layout")
    let layout: Layout = result.unwrap()
    assert_eq(layout.size(), 64 as I64, "size should be 64")
    assert_eq(layout.align(), 8 as I64, "align should be 8")
    return 0
}

@test
func test_layout_from_size_align_zero_size() -> I32 {
    let result: Outcome[Layout, LayoutError] = Layout::from_size_align(0, 4)
    assert(result.is_ok(), "zero size should be valid")
    let layout: Layout = result.unwrap()
    assert(layout.is_zero_sized(), "should be zero sized")
    return 0
}

@test
func test_layout_from_size_align_invalid_align() -> I32 {
    // align=3 is not a power of two
    let result: Outcome[Layout, LayoutError] = Layout::from_size_align(8, 3)
    assert(result.is_err(), "align 3 should be invalid")
    // align=0 is invalid
    let result2: Outcome[Layout, LayoutError] = Layout::from_size_align(8, 0)
    assert(result2.is_err(), "align 0 should be invalid")
    return 0
}

@test
func test_layout_unchecked() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(100, 16)
    assert_eq(layout.size(), 100 as I64, "unchecked size should be 100")
    assert_eq(layout.align(), 16 as I64, "unchecked align should be 16")
    return 0
}

@test
func test_layout_dangling() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(0, 8)
    assert_eq(layout.dangling(), 8 as I64, "dangling should return alignment")
    return 0
}

@test
func test_layout_padding_needed_for() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(8, 8)
    // 8 is already aligned to 8, padding = 0
    assert_eq(layout.padding_needed_for(8), 0 as I64, "8 aligned to 8 needs 0 padding")
    // 5 needs 3 more bytes to reach 8
    assert_eq(layout.padding_needed_for(5), 3 as I64, "5 aligned to 8 needs 3 padding")
    // 0 is aligned
    assert_eq(layout.padding_needed_for(0), 0 as I64, "0 aligned to 8 needs 0 padding")
    return 0
}

@test
func test_layout_pad_to_align() -> I32 {
    // size=5, align=4 -> padded size = 8 (next multiple of 4)
    let layout: Layout = Layout::from_size_align_unchecked(5, 4)
    let result: Outcome[Layout, LayoutError] = layout.pad_to_align()
    assert(result.is_ok(), "pad_to_align should succeed")
    let padded: Layout = result.unwrap()
    assert_eq(padded.size(), 8 as I64, "5 padded to align 4 should be 8")
    assert_eq(padded.align(), 4 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_pad_to_align_already_aligned() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(16, 8)
    let result: Outcome[Layout, LayoutError] = layout.pad_to_align()
    assert(result.is_ok(), "pad_to_align should succeed")
    let padded: Layout = result.unwrap()
    assert_eq(padded.size(), 16 as I64, "16 already aligned to 8")
    return 0
}

@test
func test_layout_align_to() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(8, 4)
    // Increase alignment to 16
    let result: Outcome[Layout, LayoutError] = layout.align_to(16)
    assert(result.is_ok(), "align_to 16 should succeed")
    let aligned: Layout = result.unwrap()
    assert_eq(aligned.size(), 8 as I64, "size unchanged")
    assert_eq(aligned.align(), 16 as I64, "alignment should be 16")
    return 0
}

@test
func test_layout_extend_packed() -> I32 {
    let a: Layout = Layout::from_size_align_unchecked(8, 4)
    let b: Layout = Layout::from_size_align_unchecked(16, 8)
    let result: Outcome[Layout, LayoutError] = a.extend_packed(b)
    assert(result.is_ok(), "extend_packed should succeed")
    let packed: Layout = result.unwrap()
    assert_eq(packed.size(), 24 as I64, "8 + 16 = 24")
    assert_eq(packed.align(), 1 as I64, "packed alignment is 1")
    return 0
}

@test
func test_layout_repeat_packed() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(12, 4)
    let result: Outcome[Layout, LayoutError] = layout.repeat_packed(5)
    assert(result.is_ok(), "repeat_packed should succeed")
    let repeated: Layout = result.unwrap()
    assert_eq(repeated.size(), 60 as I64, "12 * 5 = 60")
    assert_eq(repeated.align(), 4 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_equals() -> I32 {
    let a: Layout = Layout::from_size_align_unchecked(32, 8)
    let b: Layout = Layout::from_size_align_unchecked(32, 8)
    let c: Layout = Layout::from_size_align_unchecked(32, 16)
    assert(a.equals(b), "same size and align should be equal")
    assert(not a.equals(c), "different align should not be equal")
    return 0
}

@test
func test_layout_to_string() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(64, 8)
    let s: Str = layout.to_string()
    assert(s == "Layout(size=64, align=8)", "to_string format")
    return 0
}

@test
func test_layout_error_to_string() -> I32 {
    let err: LayoutError = LayoutError::new()
    assert(err.to_string() == "invalid parameters to Layout::from_size_align", "error message")
    assert(err.debug_string() == "LayoutError", "debug message")
    return 0
}

@test
func test_layout_with_size() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(32, 8)
    let result: Outcome[Layout, LayoutError] = layout.with_size(64)
    assert(result.is_ok(), "with_size should succeed")
    let new_layout: Layout = result.unwrap()
    assert_eq(new_layout.size(), 64 as I64, "new size should be 64")
    assert_eq(new_layout.align(), 8 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_with_align() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(32, 8)
    let result: Outcome[Layout, LayoutError] = layout.with_align(16)
    assert(result.is_ok(), "with_align should succeed")
    let new_layout: Layout = result.unwrap()
    assert_eq(new_layout.size(), 32 as I64, "size preserved")
    assert_eq(new_layout.align(), 16 as I64, "new alignment should be 16")
    return 0
}

@test
func test_layout_negative_size_rejected() -> I32 {
    let result: Outcome[Layout, LayoutError] = Layout::from_size_align(-1, 4)
    assert(result.is_err(), "negative size should be rejected")
    return 0
}
