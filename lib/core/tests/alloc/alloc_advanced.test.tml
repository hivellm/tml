// =============================================================================
// Consolidated alloc tests - Smart pointers (Heap, Shared, Sync) + layout dupes
// Total @test count: 45
// Sources: layout.test.tml (dupes), smart_pointers.test.tml, heap_basic.test.tml,
//          shared_basic.test.tml, sync_basic.test.tml, heap_extra.test.tml,
//          shared_extra.test.tml, sync_extra.test.tml, heap_duplicate.test.tml
// =============================================================================
use test
use core::alloc::{Heap, Shared, Sync, heap, shared, sync}
use core::alloc::layout::{Layout, LayoutError}
use core::alloc::heap::{Heap}
use core::alloc::shared::{Shared}
use core::alloc::sync::{Sync}
use core::mem::mem_free

// ============================================================================
// From layout.test.tml - Duplicate tests (renamed with _v2 suffix)
// ============================================================================

@test
func test_layout_from_size_align_valid_v2() -> I32 {
    let result: Outcome[Layout, LayoutError] = Layout::from_size_align(64, 8)
    assert(result.is_ok(), "64,8 should be valid layout")
    let layout: Layout = result.unwrap()
    assert_eq(layout.size(), 64 as I64, "size should be 64")
    assert_eq(layout.align(), 8 as I64, "align should be 8")
    return 0
}

@test
func test_layout_unchecked_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(100, 16)
    assert_eq(layout.size(), 100 as I64, "unchecked size should be 100")
    assert_eq(layout.align(), 16 as I64, "unchecked align should be 16")
    return 0
}

@test
func test_layout_dangling_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(0, 8)
    assert_eq(layout.dangling(), 8 as I64, "dangling should return alignment")
    return 0
}

@test
func test_layout_padding_needed_for_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(8, 8)
    // 8 is already aligned to 8, padding = 0
    assert_eq(layout.padding_needed_for(8), 0 as I64, "8 aligned to 8 needs 0 padding")
    // 5 needs 3 more bytes to reach 8
    assert_eq(layout.padding_needed_for(5), 3 as I64, "5 aligned to 8 needs 3 padding")
    // 0 is aligned
    assert_eq(layout.padding_needed_for(0), 0 as I64, "0 aligned to 8 needs 0 padding")
    return 0
}

@test
func test_layout_pad_to_align_v2() -> I32 {
    // size=5, align=4 -> padded size = 8 (next multiple of 4)
    let layout: Layout = Layout::from_size_align_unchecked(5, 4)
    let result: Outcome[Layout, LayoutError] = layout.pad_to_align()
    assert(result.is_ok(), "pad_to_align should succeed")
    let padded: Layout = result.unwrap()
    assert_eq(padded.size(), 8 as I64, "5 padded to align 4 should be 8")
    assert_eq(padded.align(), 4 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_align_to_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(8, 4)
    // Increase alignment to 16
    let result: Outcome[Layout, LayoutError] = layout.align_to(16)
    assert(result.is_ok(), "align_to 16 should succeed")
    let aligned: Layout = result.unwrap()
    assert_eq(aligned.size(), 8 as I64, "size unchanged")
    assert_eq(aligned.align(), 16 as I64, "alignment should be 16")
    return 0
}

@test
func test_layout_extend_packed_v2() -> I32 {
    let a: Layout = Layout::from_size_align_unchecked(8, 4)
    let b: Layout = Layout::from_size_align_unchecked(16, 8)
    let result: Outcome[Layout, LayoutError] = a.extend_packed(b)
    assert(result.is_ok(), "extend_packed should succeed")
    let packed: Layout = result.unwrap()
    assert_eq(packed.size(), 24 as I64, "8 + 16 = 24")
    assert_eq(packed.align(), 1 as I64, "packed alignment is 1")
    return 0
}

@test
func test_layout_repeat_packed_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(12, 4)
    let result: Outcome[Layout, LayoutError] = layout.repeat_packed(5)
    assert(result.is_ok(), "repeat_packed should succeed")
    let repeated: Layout = result.unwrap()
    assert_eq(repeated.size(), 60 as I64, "12 * 5 = 60")
    assert_eq(repeated.align(), 4 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_equals_v2() -> I32 {
    let a: Layout = Layout::from_size_align_unchecked(32, 8)
    let b: Layout = Layout::from_size_align_unchecked(32, 8)
    let c: Layout = Layout::from_size_align_unchecked(32, 16)
    assert(a.equals(b), "same size and align should be equal")
    assert(not a.equals(c), "different align should not be equal")
    return 0
}

@test
func test_layout_to_string_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(64, 8)
    let s: Str = layout.to_string()
    assert(s == "Layout(size=64, align=8)", "to_string format")
    return 0
}

@test
func test_layout_error_to_string_v2() -> I32 {
    let err: LayoutError = LayoutError::new()
    assert(err.to_string() == "invalid parameters to Layout::from_size_align", "error message")
    assert(err.debug_string() == "LayoutError", "debug message")
    return 0
}

@test
func test_layout_with_size_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(32, 8)
    let result: Outcome[Layout, LayoutError] = layout.with_size(64)
    assert(result.is_ok(), "with_size should succeed")
    let new_layout: Layout = result.unwrap()
    assert_eq(new_layout.size(), 64 as I64, "new size should be 64")
    assert_eq(new_layout.align(), 8 as I64, "alignment preserved")
    return 0
}

@test
func test_layout_with_align_v2() -> I32 {
    let layout: Layout = Layout::from_size_align_unchecked(32, 8)
    let result: Outcome[Layout, LayoutError] = layout.with_align(16)
    assert(result.is_ok(), "with_align should succeed")
    let new_layout: Layout = result.unwrap()
    assert_eq(new_layout.size(), 32 as I64, "size preserved")
    assert_eq(new_layout.align(), 16 as I64, "new alignment should be 16")
    return 0
}

// ============================================================================
// Heap[T] Tests (from smart_pointers.test.tml)
// ============================================================================

@test
func test_heap_new() -> I32 {
    let boxed: Heap[I32] = Heap::new(42)
    assert_eq(boxed.get(), 42, "Heap should store value")
    return 0
}

@test
func test_heap_set() -> I32 {
    let mut boxed: Heap[I32] = Heap::new(10)
    assert_eq(boxed.get(), 10, "Initial value")

    boxed.set(100)
    assert_eq(boxed.get(), 100, "Updated value")
    return 0
}

@test
func test_heap_helper() -> I32 {
    let boxed: Heap[I32] = heap(999)
    assert_eq(boxed.get(), 999, "Helper function should work")
    return 0
}

// TODO: Re-enable when local type definitions are supported
// @test
// func test_heap_struct() -> I32 {
//     type Point { x: I32, y: I32 }
//
//     let boxed: Heap[Point] = Heap::new(Point { x: 5, y: 10 })
//     let p: Point = boxed.get()
//
//     assert_eq(p.x, 5, "Point x coordinate")
//     assert_eq(p.y, 10, "Point y coordinate")
//     return 0
// }

// ============================================================================
// Shared[T] Tests (from smart_pointers.test.tml)
// ============================================================================

@test
func test_shared_new() -> I32 {
    let shared: Shared[I32] = Shared::new(42)
    assert_eq(shared.get(), 42, "Shared should store value")
    assert_eq(shared.strong_count(), 1, "Initial count is 1")
    return 0
}

@test
func test_shared_duplicate() -> I32 {
    let original: Shared[I32] = Shared::new(100)
    assert_eq(original.strong_count(), 1, "Count starts at 1")

    let clone1: Shared[I32] = original.duplicate()
    assert_eq(original.strong_count(), 2, "Count after first clone")
    assert_eq(clone1.strong_count(), 2, "Both refs see same count")

    let clone2: Shared[I32] = original.duplicate()
    assert_eq(original.strong_count(), 3, "Count after second clone")

    // All should see the same value
    assert_eq(original.get(), 100, "Original value")
    assert_eq(clone1.get(), 100, "Clone1 value")
    assert_eq(clone2.get(), 100, "Clone2 value")
    return 0
}

@test
func test_shared_is_unique() -> I32 {
    let original: Shared[I32] = Shared::new(50)
    assert(original.is_unique(), "Should be unique initially")

    let clone: Shared[I32] = original.duplicate()
    assert(not original.is_unique(), "Should not be unique after clone")
    assert(not clone.is_unique(), "Clone should not be unique")
    return 0
}

@test
func test_shared_helper() -> I32 {
    let s: Shared[I32] = shared(777)
    assert_eq(s.get(), 777, "Helper function should work")
    assert_eq(s.strong_count(), 1, "Count is 1")
    return 0
}

// ============================================================================
// Sync[T] Tests (from smart_pointers.test.tml)
// ============================================================================

@test
func test_sync_new() -> I32 {
    let synced: Sync[I32] = Sync::new(42)
    assert_eq(synced.get(), 42, "Sync should store value")
    assert_eq(synced.strong_count(), 1, "Initial atomic count is 1")
    return 0
}

@test
func test_sync_duplicate() -> I32 {
    let original: Sync[I32] = Sync::new(200)
    assert_eq(original.strong_count(), 1, "Count starts at 1")

    let clone1: Sync[I32] = original.duplicate()
    assert_eq(original.strong_count(), 2, "Atomic count after first clone")
    assert_eq(clone1.strong_count(), 2, "Both refs see same atomic count")

    let clone2: Sync[I32] = original.duplicate()
    assert_eq(original.strong_count(), 3, "Atomic count after second clone")

    // All should see the same value
    assert_eq(original.get(), 200, "Original value")
    assert_eq(clone1.get(), 200, "Clone1 value")
    assert_eq(clone2.get(), 200, "Clone2 value")
    return 0
}

@test
func test_sync_is_unique() -> I32 {
    let original: Sync[I32] = Sync::new(75)
    assert(original.is_unique(), "Should be unique initially")

    let clone: Sync[I32] = original.duplicate()
    assert(not original.is_unique(), "Should not be unique after clone")
    assert(not clone.is_unique(), "Clone should not be unique")
    return 0
}

@test
func test_sync_helper() -> I32 {
    let s: Sync[I32] = sync(888)
    assert_eq(s.get(), 888, "Helper function should work")
    assert_eq(s.strong_count(), 1, "Atomic count is 1")
    return 0
}

// ============================================================================
// Complex Scenarios (from smart_pointers.test.tml)
// ============================================================================

@test
func test_heap_nested_in_shared() -> I32 {
    // Shared reference to a Heap-allocated value
    let inner: Heap[I32] = Heap::new(123)
    let outer: Shared[Heap[I32]] = Shared::new(inner)

    assert_eq(outer.get().get(), 123, "Nested smart pointers")
    assert_eq(outer.strong_count(), 1, "Outer count")
    return 0
}

@test
func test_shared_multiple_clones() -> I32 {
    let original: Shared[I32] = Shared::new(500)

    let clone1: Shared[I32] = original.duplicate()
    let clone2: Shared[I32] = original.duplicate()
    let clone3: Shared[I32] = clone1.duplicate()
    let clone4: Shared[I32] = clone2.duplicate()

    // All should have count of 5
    assert_eq(original.strong_count(), 5, "All refs have same count")
    assert_eq(clone1.strong_count(), 5, "Clone1 count")
    assert_eq(clone2.strong_count(), 5, "Clone2 count")
    assert_eq(clone3.strong_count(), 5, "Clone3 count")
    assert_eq(clone4.strong_count(), 5, "Clone4 count")

    // All see same value
    assert_eq(original.get(), 500, "Original value")
    assert_eq(clone4.get(), 500, "Clone4 value")
    return 0
}

@test
func test_sync_multiple_clones() -> I32 {
    let original: Sync[I32] = Sync::new(600)

    let clone1: Sync[I32] = original.duplicate()
    let clone2: Sync[I32] = original.duplicate()
    let clone3: Sync[I32] = clone1.duplicate()

    // All should have atomic count of 4
    assert_eq(original.strong_count(), 4, "All refs have same atomic count")
    assert_eq(clone1.strong_count(), 4, "Clone1 count")
    assert_eq(clone2.strong_count(), 4, "Clone2 count")
    assert_eq(clone3.strong_count(), 4, "Clone3 count")

    // All see same value
    assert_eq(original.get(), 600, "Original value")
    assert_eq(clone3.get(), 600, "Clone3 value")
    return 0
}

@test
func test_heap_with_string() -> I32 {
    let boxed: Heap[Str] = Heap::new("Hello, Heap!")
    let s: Str = boxed.get()

    assert(s.len() > 0, "String should have length")
    return 0
}

// TODO: Re-enable when local type definitions are supported
// @test
// func test_shared_with_struct() -> I32 {
//     type Person {
//         name: Str,
//         age: I32,
//     }
//
//     let person: Person = Person {
//         name: "Alice",
//         age: 30,
//     }
//
//     let shared: Shared[Person] = Shared::new(person)
//     let p: Person = shared.get()
//
//     assert_eq(p.age, 30, "Person age")
//     return 0
// }

// ============================================================================
// From heap_basic.test.tml - Duplicate tests (renamed with _v2 suffix)
// ============================================================================

@test
func test_heap_new_get() -> I32 {
    let h: Heap[I32] = Heap::new(42 as I32)
    assert_eq(h.get(), 42 as I32, "Heap::new stores value")
    return 0
}

@test
func test_heap_set_v2() -> I32 {
    var h: Heap[I32] = Heap::new(10 as I32)
    h.set(99 as I32)
    assert_eq(h.get(), 99 as I32, "Heap::set updates value")
    return 0
}

@test
func test_heap_into_inner() -> I32 {
    let h: Heap[I32] = Heap::new(55 as I32)
    let val: I32 = h.into_inner()
    assert_eq(val, 55 as I32, "into_inner returns stored value")
    return 0
}

// ============================================================================
// From shared_basic.test.tml - Duplicate tests (renamed with _v2 suffix)
// ============================================================================

@test
func test_shared_new_v2() -> I32 {
    let s: Shared[I32] = Shared::new(42 as I32)
    assert_eq(s.get(), 42 as I32, "Shared::new stores value")
    assert_eq(s.strong_count(), 1 as I32, "initial count is 1")
    return 0
}

@test
func test_shared_is_unique_v2() -> I32 {
    let s: Shared[I32] = Shared::new(10 as I32)
    assert(s.is_unique(), "single ref should be unique")
    return 0
}

@test
func test_shared_duplicate_v2() -> I32 {
    let s1: Shared[I32] = Shared::new(77 as I32)
    let s2: Shared[I32] = s1.duplicate()
    assert_eq(s1.strong_count(), 2 as I32, "count after duplicate is 2")
    assert_eq(s2.get(), 77 as I32, "duplicate shares same value")
    assert(not s1.is_unique(), "no longer unique after duplicate")
    return 0
}

// ============================================================================
// From sync_basic.test.tml - Duplicate tests (renamed with _v2 suffix)
// ============================================================================

@test
func test_sync_new_v2() -> I32 {
    let s: Sync[I32] = Sync::new(42 as I32)
    assert_eq(s.get(), 42 as I32, "Sync::new stores value")
    assert_eq(s.strong_count(), 1 as I32, "initial count is 1")
    return 0
}

@test
func test_sync_is_unique_v2() -> I32 {
    let s: Sync[I32] = Sync::new(10 as I32)
    assert(s.is_unique(), "single ref should be unique")
    return 0
}

@test
func test_sync_duplicate_v2() -> I32 {
    let s1: Sync[I32] = Sync::new(88 as I32)
    let s2: Sync[I32] = s1.duplicate()
    assert_eq(s1.strong_count(), 2 as I32, "count after duplicate is 2")
    assert_eq(s2.get(), 88 as I32, "duplicate shares same value")
    assert(not s1.is_unique(), "no longer unique after duplicate")
    return 0
}

// ============================================================================
// From heap_extra.test.tml - Heap extra methods
// ============================================================================

@test
func test_heap_new_default_i32() -> I32 {
    let h: Heap[I32] = Heap::new_default()
    let v: I32 = h.get()
    assert_eq(v, 0, "Heap::new_default I32 = 0")
    return 0
}

@test
func test_heap_into_raw_from_raw() -> I32 {
    var h: Heap[I32] = Heap::new(42)
    let raw: *I32 = h.into_raw()
    let h2: Heap[I32] = Heap::from_raw(raw)
    assert_eq(h2.get(), 42, "from_raw should restore value")
    return 0
}

@test
func test_heap_leak() -> I32 {
    var h: Heap[I32] = Heap::new(99)
    let ptr: *I32 = h.leak()
    // Verify leak() returns a valid pointer, then clean up
    assert(ptr != null, "leak() should return non-null pointer")
    mem_free(ptr as *Unit)
    return 0
}

// ============================================================================
// From shared_extra.test.tml - Shared extra methods
// ============================================================================

@test
func test_shared_new_default_i32() -> I32 {
    let s: Shared[I32] = Shared::new_default()
    let v: I32 = s.get()
    assert_eq(v, 0, "Shared::new_default I32 = 0")
    return 0
}

@test
func test_shared_as_ptr() -> I32 {
    let s: Shared[I32] = Shared::new(42)
    let p: *I32 = s.as_ptr()
    return 0
}

// ============================================================================
// From sync_extra.test.tml - Sync extra methods
// ============================================================================

@test
func test_sync_new_default_i32() -> I32 {
    let s: Sync[I32] = Sync::new_default()
    let v: I32 = s.get()
    assert_eq(v, 0, "Sync::new_default I32 = 0")
    return 0
}

@test
func test_sync_as_ptr() -> I32 {
    let s: Sync[I32] = Sync::new(42)
    let p: *I32 = s.as_ptr()
    return 0
}

// ============================================================================
// From heap_duplicate.test.tml - Heap duplicate
// ============================================================================

@test
func test_heap_duplicate() -> I32 {
    let h1: Heap[I32] = Heap::new(42)
    let h2: Heap[I32] = h1.duplicate()
    assert_eq(h2.get(), 42, "duplicate should have same value")
    return 0
}
