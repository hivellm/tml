// Tests for core::ops::bit module
// Tests BitAnd, BitOr, BitXor, Not, Shl, Shr behaviors

use test

// =============================================================================
// BitAnd Tests (&)
// =============================================================================

@test
func test_bitand_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a & b
    assert_eq(c, 8, "12 & 10 should be 8")  // 0b1000
    return 0
}

@test
func test_bitand_i64() -> I32 {
    let a: I64 = 0xFF00
    let b: I64 = 0x0FF0
    let c: I64 = a & b
    assert_eq(c, 0x0F00, "0xFF00 & 0x0FF0 should be 0x0F00")
    return 0
}

@test
func test_bitand_u8() -> I32 {
    let a: U8 = 0xF0
    let b: U8 = 0x0F
    let c: U8 = a & b
    assert_eq(c, 0, "0xF0 & 0x0F should be 0")
    return 0
}

@test
func test_bitand_identity() -> I32 {
    let x: I32 = 42
    let result: I32 = x & x
    assert_eq(result, 42, "x & x should be x")
    return 0
}

@test
func test_bitand_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x & 0
    assert_eq(result, 0, "x & 0 should be 0")
    return 0
}

// =============================================================================
// BitOr Tests (|)
// =============================================================================

@test
func test_bitor_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a | b
    assert_eq(c, 14, "12 | 10 should be 14")  // 0b1110
    return 0
}

@test
func test_bitor_i64() -> I32 {
    let a: I64 = 0xFF00
    let b: I64 = 0x00FF
    let c: I64 = a | b
    assert_eq(c, 0xFFFF, "0xFF00 | 0x00FF should be 0xFFFF")
    return 0
}

@test
func test_bitor_identity() -> I32 {
    let x: I32 = 42
    let result: I32 = x | x
    assert_eq(result, 42, "x | x should be x")
    return 0
}

@test
func test_bitor_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x | 0
    assert_eq(result, 12345, "x | 0 should be x")
    return 0
}

// =============================================================================
// BitXor Tests (^)
// =============================================================================

@test
func test_bitxor_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a ^ b
    assert_eq(c, 6, "12 ^ 10 should be 6")  // 0b0110
    return 0
}

@test
func test_bitxor_i64() -> I32 {
    let a: I64 = 0xFFFF
    let b: I64 = 0xFF00
    let c: I64 = a ^ b
    assert_eq(c, 0x00FF, "0xFFFF ^ 0xFF00 should be 0x00FF")
    return 0
}

@test
func test_bitxor_self_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x ^ x
    assert_eq(result, 0, "x ^ x should be 0")
    return 0
}

@test
func test_bitxor_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x ^ 0
    assert_eq(result, 12345, "x ^ 0 should be x")
    return 0
}

// =============================================================================
// Shift Left Tests (<<)
// =============================================================================

@test
func test_shl_i32() -> I32 {
    let x: I32 = 1
    let result: I32 = x << 4
    assert_eq(result, 16, "1 << 4 should be 16")
    return 0
}

@test
func test_shl_i64() -> I32 {
    let x: I64 = 1
    let result: I64 = x << 32
    assert_eq(result, 4294967296, "1 << 32 should be 4294967296")
    return 0
}

@test
func test_shl_multiple() -> I32 {
    let x: I32 = 5  // 0b101
    let result: I32 = x << 2
    assert_eq(result, 20, "5 << 2 should be 20")  // 0b10100
    return 0
}

@test
func test_shl_zero() -> I32 {
    let x: I32 = 42
    let result: I32 = x << 0
    assert_eq(result, 42, "x << 0 should be x")
    return 0
}

// =============================================================================
// Shift Right Tests (>>)
// =============================================================================

@test
func test_shr_i32() -> I32 {
    let x: I32 = 16
    let result: I32 = x >> 4
    assert_eq(result, 1, "16 >> 4 should be 1")
    return 0
}

@test
func test_shr_i64() -> I32 {
    let x: I64 = 4294967296
    let result: I64 = x >> 32
    assert_eq(result, 1, "4294967296 >> 32 should be 1")
    return 0
}

@test
func test_shr_multiple() -> I32 {
    let x: I32 = 20  // 0b10100
    let result: I32 = x >> 2
    assert_eq(result, 5, "20 >> 2 should be 5")  // 0b101
    return 0
}

@test
func test_shr_zero() -> I32 {
    let x: I32 = 42
    let result: I32 = x >> 0
    assert_eq(result, 42, "x >> 0 should be x")
    return 0
}

// =============================================================================
// Combined Bitwise Tests
// =============================================================================

@test
func test_bitwise_combined() -> I32 {
    let a: I32 = 0xFF
    let b: I32 = 0x0F

    // (a & b) | (a ^ b) should equal a | b
    let left: I32 = (a & b) | (a ^ b)
    let right: I32 = a | b
    assert_eq(left, right, "bitwise identity should hold")
    return 0
}

@test
func test_shift_roundtrip() -> I32 {
    let x: I32 = 42
    let shifted: I32 = (x << 8) >> 8
    assert_eq(shifted, 42, "shift roundtrip should preserve value")
    return 0
}

@test
func test_mask_extraction() -> I32 {
    let value: I32 = 0x12345678
    let low_byte: I32 = value & 0xFF
    assert_eq(low_byte, 0x78, "low byte extraction should work")
    return 0
}

@test
func test_bit_set_clear() -> I32 {
    let mut x: I32 = 0
    // Set bit 3
    x = x | (1 << 3)
    assert_eq(x, 8, "setting bit 3 should give 8")

    // Clear bit 3
    x = x & (0 - 1 - (1 << 3))
    assert_eq(x, 0, "clearing bit 3 should give 0")
    return 0
}
