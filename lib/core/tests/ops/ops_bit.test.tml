// Consolidated: Bitwise operators - basic I32/I64 + extended types (I8/I16/U16/U64)
// Sources: ops_bit_basic.test.tml (25 tests) + ops_bit_types.test.tml (20 tests)
// Total: 45 @test functions
use test

// =============================================================================
// BitAnd Tests (&) - I32/I64/U8
// =============================================================================

@test
func test_bitand_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a & b
    assert_eq(c, 8, "12 & 10 should be 8")  // 0b1000
    return 0
}

@test
func test_bitand_i64() -> I32 {
    let a: I64 = 0xFF00
    let b: I64 = 0x0FF0
    let c: I64 = a & b
    assert_eq(c, 0x0F00, "0xFF00 & 0x0FF0 should be 0x0F00")
    return 0
}

@test
func test_bitand_u8() -> I32 {
    let a: U8 = 0xF0
    let b: U8 = 0x0F
    let c: U8 = a & b
    assert_eq(c, 0, "0xF0 & 0x0F should be 0")
    return 0
}

@test
func test_bitand_identity() -> I32 {
    let x: I32 = 42
    let result: I32 = x & x
    assert_eq(result, 42, "x & x should be x")
    return 0
}

@test
func test_bitand_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x & 0
    assert_eq(result, 0, "x & 0 should be 0")
    return 0
}

// =============================================================================
// BitOr Tests (|) - I32/I64
// =============================================================================

@test
func test_bitor_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a | b
    assert_eq(c, 14, "12 | 10 should be 14")  // 0b1110
    return 0
}

@test
func test_bitor_i64() -> I32 {
    let a: I64 = 0xFF00
    let b: I64 = 0x00FF
    let c: I64 = a | b
    assert_eq(c, 0xFFFF, "0xFF00 | 0x00FF should be 0xFFFF")
    return 0
}

@test
func test_bitor_identity() -> I32 {
    let x: I32 = 42
    let result: I32 = x | x
    assert_eq(result, 42, "x | x should be x")
    return 0
}

@test
func test_bitor_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x | 0
    assert_eq(result, 12345, "x | 0 should be x")
    return 0
}

// =============================================================================
// BitXor Tests (^) - I32/I64
// =============================================================================

@test
func test_bitxor_i32() -> I32 {
    let a: I32 = 12  // 0b1100
    let b: I32 = 10  // 0b1010
    let c: I32 = a ^ b
    assert_eq(c, 6, "12 ^ 10 should be 6")  // 0b0110
    return 0
}

@test
func test_bitxor_i64() -> I32 {
    let a: I64 = 0xFFFF
    let b: I64 = 0xFF00
    let c: I64 = a ^ b
    assert_eq(c, 0x00FF, "0xFFFF ^ 0xFF00 should be 0x00FF")
    return 0
}

@test
func test_bitxor_self_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x ^ x
    assert_eq(result, 0, "x ^ x should be 0")
    return 0
}

@test
func test_bitxor_zero() -> I32 {
    let x: I32 = 12345
    let result: I32 = x ^ 0
    assert_eq(result, 12345, "x ^ 0 should be x")
    return 0
}

// =============================================================================
// Shift Left Tests (<<) - I32/I64
// =============================================================================

@test
func test_shl_i32() -> I32 {
    let x: I32 = 1
    let result: I32 = x << 4
    assert_eq(result, 16, "1 << 4 should be 16")
    return 0
}

@test
func test_shl_i64() -> I32 {
    let x: I64 = 1
    let result: I64 = x << 32
    assert_eq(result, 4294967296, "1 << 32 should be 4294967296")
    return 0
}

@test
func test_shl_multiple() -> I32 {
    let x: I32 = 5  // 0b101
    let result: I32 = x << 2
    assert_eq(result, 20, "5 << 2 should be 20")  // 0b10100
    return 0
}

@test
func test_shl_zero() -> I32 {
    let x: I32 = 42
    let result: I32 = x << 0
    assert_eq(result, 42, "x << 0 should be x")
    return 0
}

// =============================================================================
// Shift Right Tests (>>) - I32/I64
// =============================================================================

@test
func test_shr_i32() -> I32 {
    let x: I32 = 16
    let result: I32 = x >> 4
    assert_eq(result, 1, "16 >> 4 should be 1")
    return 0
}

@test
func test_shr_i64() -> I32 {
    let x: I64 = 4294967296
    let result: I64 = x >> 32
    assert_eq(result, 1, "4294967296 >> 32 should be 1")
    return 0
}

@test
func test_shr_multiple() -> I32 {
    let x: I32 = 20  // 0b10100
    let result: I32 = x >> 2
    assert_eq(result, 5, "20 >> 2 should be 5")  // 0b101
    return 0
}

@test
func test_shr_zero() -> I32 {
    let x: I32 = 42
    let result: I32 = x >> 0
    assert_eq(result, 42, "x >> 0 should be x")
    return 0
}

// =============================================================================
// Combined Bitwise Tests
// =============================================================================

@test
func test_bitwise_combined() -> I32 {
    let a: I32 = 0xFF
    let b: I32 = 0x0F

    // (a & b) | (a ^ b) should equal a | b
    let left: I32 = (a & b) | (a ^ b)
    let right: I32 = a | b
    assert_eq(left, right, "bitwise identity should hold")
    return 0
}

@test
func test_shift_roundtrip() -> I32 {
    let x: I32 = 42
    let shifted: I32 = (x << 8) >> 8
    assert_eq(shifted, 42, "shift roundtrip should preserve value")
    return 0
}

@test
func test_mask_extraction() -> I32 {
    let value: I32 = 0x12345678
    let low_byte: I32 = value & 0xFF
    assert_eq(low_byte, 0x78, "low byte extraction should work")
    return 0
}

@test
func test_bit_set_clear() -> I32 {
    let mut x: I32 = 0
    // Set bit 3
    x = x | (1 << 3)
    assert_eq(x, 8, "setting bit 3 should give 8")

    // Clear bit 3
    x = x & (0 - 1 - (1 << 3))
    assert_eq(x, 0, "clearing bit 3 should give 0")
    return 0
}

// =============================================================================
// I8 bitwise operators (from ops_bit_types)
// =============================================================================

@test
func test_i8_bitand() -> I32 {
    let a: I8 = 0x0F
    let b: I8 = 0x3C
    let r: I8 = a & b
    assert_eq(r as I32, 0x0C, "I8 & operation")
    return 0
}

@test
func test_i8_bitor() -> I32 {
    let a: I8 = 0x0F
    let b: I8 = 0x30
    let r: I8 = a | b
    assert_eq(r as I32, 0x3F, "I8 | operation")
    return 0
}

@test
func test_i8_bitxor() -> I32 {
    let a: I8 = 0x3F
    let b: I8 = 0x0F
    let r: I8 = a ^ b
    assert_eq(r as I32, 0x30, "I8 ^ operation")
    return 0
}

@test
func test_i8_shl() -> I32 {
    let a: I8 = 1
    let r: I8 = a << 4
    assert_eq(r as I32, 16, "I8 << 4")
    return 0
}

@test
func test_i8_shr() -> I32 {
    let a: I8 = 64
    let r: I8 = a >> 3
    assert_eq(r as I32, 8, "I8 >> 3")
    return 0
}

// =============================================================================
// I16 bitwise operators (from ops_bit_types)
// =============================================================================

@test
func test_i16_bitand() -> I32 {
    let a: I16 = 0x0F0F
    let b: I16 = 0x00FF
    let r: I16 = a & b
    assert_eq(r as I32, 0x000F, "I16 & operation")
    return 0
}

@test
func test_i16_bitor() -> I32 {
    let a: I16 = 0x0F00
    let b: I16 = 0x00FF
    let r: I16 = a | b
    assert_eq(r as I32, 0x0FFF, "I16 | operation")
    return 0
}

@test
func test_i16_bitxor() -> I32 {
    let a: I16 = 0x0FFF
    let b: I16 = 0x00FF
    let r: I16 = a ^ b
    assert_eq(r as I32, 0x0F00, "I16 ^ operation")
    return 0
}

@test
func test_i16_shl() -> I32 {
    let a: I16 = 1
    let r: I16 = a << 8
    assert_eq(r as I32, 256, "I16 << 8")
    return 0
}

@test
func test_i16_shr() -> I32 {
    let a: I16 = 256
    let r: I16 = a >> 4
    assert_eq(r as I32, 16, "I16 >> 4")
    return 0
}

// =============================================================================
// U16 bitwise operators (from ops_bit_types)
// =============================================================================

@test
func test_u16_bitand() -> I32 {
    let a: U16 = 0xFF0F
    let b: U16 = 0x0FFF
    let r: U16 = a & b
    assert_eq(r as I32, 0x0F0F, "U16 & operation")
    return 0
}

@test
func test_u16_bitor() -> I32 {
    let a: U16 = 0xF000
    let b: U16 = 0x000F
    let r: U16 = a | b
    assert_eq(r as I32, 0xF00F, "U16 | operation")
    return 0
}

@test
func test_u16_bitxor() -> I32 {
    let a: U16 = 0xFFFF
    let b: U16 = 0x0F0F
    let r: U16 = a ^ b
    assert_eq(r as I32, 0xF0F0, "U16 ^ operation")
    return 0
}

@test
func test_u16_shl() -> I32 {
    let a: U16 = 1
    let r: U16 = a << 12
    assert_eq(r as I32, 4096, "U16 << 12")
    return 0
}

@test
func test_u16_shr() -> I32 {
    let a: U16 = 4096
    let r: U16 = a >> 8
    assert_eq(r as I32, 16, "U16 >> 8")
    return 0
}

// =============================================================================
// U64 bitwise operators (from ops_bit_types)
// =============================================================================

@test
func test_u64_bitand() -> I32 {
    let a: U64 = 0xFF00FF00
    let b: U64 = 0x0F0F0F0F
    let r: U64 = a & b
    assert_eq(r as I64, 0x0F000F00, "U64 & operation")
    return 0
}

@test
func test_u64_bitor() -> I32 {
    let a: U64 = 0xFF000000
    let b: U64 = 0x000000FF
    let r: U64 = a | b
    assert_eq(r as I64, 0xFF0000FF, "U64 | operation")
    return 0
}

@test
func test_u64_bitxor() -> I32 {
    let a: U64 = 0xFFFF0000
    let b: U64 = 0x0000FFFF
    let r: U64 = a ^ b
    assert_eq(r as I64, 0xFFFFFFFF, "U64 ^ operation")
    return 0
}

@test
func test_u64_shl() -> I32 {
    let a: U64 = 1
    let r: U64 = a << 32
    assert_eq(r as I64, 4294967296, "U64 << 32")
    return 0
}

@test
func test_u64_shr() -> I32 {
    let a: U64 = 4294967296
    let r: U64 = a >> 16
    assert_eq(r as I64, 65536, "U64 >> 16")
    return 0
}
