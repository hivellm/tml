// Tests for arithmetic operators (core::ops::arith)
use test

// Note: Add, Sub, Mul, Div, Rem, Neg are builtin behaviors - no import needed
// The import of core::ops causes issues with generic debug_string in range.tml

// ============================================================================
// Custom Point type for testing custom operator implementations
// ============================================================================

type Point {
    x: I64,
    y: I64
}

impl Point {
    func new(x: I64, y: I64) -> Point {
        return Point { x: x, y: y }
    }
}

impl Add for Point {
    type Output = Point
    pub func add(this, rhs: Point) -> Point {
        return Point { x: this.x + rhs.x, y: this.y + rhs.y }
    }
}

impl Sub for Point {
    type Output = Point
    pub func sub(this, rhs: Point) -> Point {
        return Point { x: this.x - rhs.x, y: this.y - rhs.y }
    }
}

impl Neg for Point {
    type Output = Point
    pub func neg(this) -> Point {
        // Use explicit I64 literals to match field types
        let zero: I64 = 0
        return Point { x: zero - this.x, y: zero - this.y }
    }
}

// ============================================================================
// Add Tests
// ============================================================================

@test
func test_add_i32() -> I32 {
    let a: I32 = 10
    let b: I32 = 20
    let result: I32 = a.add(b)
    assert_eq(result, 30, "10 + 20 should be 30")
    return 0
}

@test
func test_add_i64() -> I32 {
    let a: I64 = 100
    let b: I64 = 200
    let result: I64 = a.add(b)
    assert_eq(result, 300, "100 + 200 should be 300")
    return 0
}

@test
func test_add_negative() -> I32 {
    let a: I32 = -5
    let b: I32 = 10
    let result: I32 = a.add(b)
    assert_eq(result, 5, "-5 + 10 should be 5")
    return 0
}

@test
func test_add_custom_point() -> I32 {
    let p1: Point = Point::new(1, 2)
    let p2: Point = Point::new(3, 4)
    let p3: Point = p1.add(p2)
    assert_eq(p3.x, 4, "x should be 4")
    assert_eq(p3.y, 6, "y should be 6")
    return 0
}

// ============================================================================
// Sub Tests
// ============================================================================

@test
func test_sub_i32() -> I32 {
    let a: I32 = 30
    let b: I32 = 10
    let result: I32 = a.sub(b)
    assert_eq(result, 20, "30 - 10 should be 20")
    return 0
}

@test
func test_sub_i64() -> I32 {
    let a: I64 = 500
    let b: I64 = 300
    let result: I64 = a.sub(b)
    assert_eq(result, 200, "500 - 300 should be 200")
    return 0
}

@test
func test_sub_negative_result() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let result: I32 = a.sub(b)
    assert_eq(result, -5, "5 - 10 should be -5")
    return 0
}

@test
func test_sub_custom_point() -> I32 {
    let p1: Point = Point::new(5, 8)
    let p2: Point = Point::new(2, 3)
    let p3: Point = p1.sub(p2)
    assert_eq(p3.x, 3, "x should be 3")
    assert_eq(p3.y, 5, "y should be 5")
    return 0
}

// ============================================================================
// Mul Tests
// ============================================================================

@test
func test_mul_i32() -> I32 {
    let a: I32 = 6
    let b: I32 = 7
    let result: I32 = a.mul(b)
    assert_eq(result, 42, "6 * 7 should be 42")
    return 0
}

@test
func test_mul_i64() -> I32 {
    let a: I64 = 100
    let b: I64 = 100
    let result: I64 = a.mul(b)
    assert_eq(result, 10000, "100 * 100 should be 10000")
    return 0
}

@test
func test_mul_by_zero() -> I32 {
    let a: I32 = 12345
    let b: I32 = 0
    let result: I32 = a.mul(b)
    assert_eq(result, 0, "x * 0 should be 0")
    return 0
}

@test
func test_mul_negative() -> I32 {
    let a: I32 = -5
    let b: I32 = 3
    let result: I32 = a.mul(b)
    assert_eq(result, -15, "-5 * 3 should be -15")
    return 0
}

@test
func test_mul_both_negative() -> I32 {
    let a: I32 = -4
    let b: I32 = -5
    let result: I32 = a.mul(b)
    assert_eq(result, 20, "-4 * -5 should be 20")
    return 0
}

// ============================================================================
// Div Tests
// ============================================================================

@test
func test_div_i32() -> I32 {
    let a: I32 = 20
    let b: I32 = 4
    let result: I32 = a.div(b)
    assert_eq(result, 5, "20 / 4 should be 5")
    return 0
}

@test
func test_div_i64() -> I32 {
    let a: I64 = 1000
    let b: I64 = 10
    let result: I64 = a.div(b)
    assert_eq(result, 100, "1000 / 10 should be 100")
    return 0
}

@test
func test_div_truncation() -> I32 {
    let a: I32 = 17
    let b: I32 = 5
    let result: I32 = a.div(b)
    assert_eq(result, 3, "17 / 5 should be 3 (truncated)")
    return 0
}

@test
func test_div_negative() -> I32 {
    let a: I32 = -20
    let b: I32 = 4
    let result: I32 = a.div(b)
    assert_eq(result, -5, "-20 / 4 should be -5")
    return 0
}

// ============================================================================
// Rem Tests
// ============================================================================

@test
func test_rem_i32() -> I32 {
    let a: I32 = 17
    let b: I32 = 5
    let result: I32 = a.rem(b)
    assert_eq(result, 2, "17 % 5 should be 2")
    return 0
}

@test
func test_rem_i64() -> I32 {
    let a: I64 = 100
    let b: I64 = 7
    let result: I64 = a.rem(b)
    assert_eq(result, 2, "100 % 7 should be 2")
    return 0
}

@test
func test_rem_no_remainder() -> I32 {
    let a: I32 = 20
    let b: I32 = 5
    let result: I32 = a.rem(b)
    assert_eq(result, 0, "20 % 5 should be 0")
    return 0
}

@test
func test_rem_negative() -> I32 {
    let a: I32 = -17
    let b: I32 = 5
    let result: I32 = a.rem(b)
    assert_eq(result, -2, "-17 % 5 should be -2")
    return 0
}

// ============================================================================
// Neg Tests
// ============================================================================

@test
func test_neg_i32() -> I32 {
    let a: I32 = 42
    let result: I32 = a.neg()
    assert_eq(result, -42, "neg(42) should be -42")
    return 0
}

@test
func test_neg_i64() -> I32 {
    let a: I64 = 100
    let result: I64 = a.neg()
    assert_eq(result, -100, "neg(100) should be -100")
    return 0
}

@test
func test_neg_negative() -> I32 {
    let a: I32 = -10
    let result: I32 = a.neg()
    assert_eq(result, 10, "neg(-10) should be 10")
    return 0
}

@test
func test_neg_zero() -> I32 {
    let a: I32 = 0
    let result: I32 = a.neg()
    assert_eq(result, 0, "neg(0) should be 0")
    return 0
}

@test
func test_neg_custom_point() -> I32 {
    let p: Point = Point::new(3, -4)
    let neg_p: Point = p.neg()
    assert_eq(neg_p.x, -3, "neg x should be -3")
    assert_eq(neg_p.y, 4, "neg y should be 4")
    return 0
}

// ============================================================================
// Unsigned Type Tests
// ============================================================================

@test
func test_add_u32() -> I32 {
    let a: U32 = 100 as U32
    let b: U32 = 200 as U32
    let result: U32 = a.add(b)
    let expected: U32 = 300 as U32
    assert(result == expected, "100 + 200 should be 300 for U32")
    return 0
}

@test
func test_sub_u64() -> I32 {
    let a: U64 = 500 as U64
    let b: U64 = 200 as U64
    let result: U64 = a.sub(b)
    let expected: U64 = 300 as U64
    assert(result == expected, "500 - 200 should be 300 for U64")
    return 0
}

@test
func test_mul_u32() -> I32 {
    let a: U32 = 15 as U32
    let b: U32 = 20 as U32
    let result: U32 = a.mul(b)
    let expected: U32 = 300 as U32
    assert(result == expected, "15 * 20 should be 300 for U32")
    return 0
}

@test
func test_div_u64() -> I32 {
    let a: U64 = 100 as U64
    let b: U64 = 4 as U64
    let result: U64 = a.div(b)
    let expected: U64 = 25 as U64
    assert(result == expected, "100 / 4 should be 25 for U64")
    return 0
}

@test
func test_rem_u32() -> I32 {
    let a: U32 = 17 as U32
    let b: U32 = 5 as U32
    let result: U32 = a.rem(b)
    let expected: U32 = 2 as U32
    assert(result == expected, "17 % 5 should be 2 for U32")
    return 0
}
