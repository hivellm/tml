// Tests for bitwise compound assignment on types not fully covered
// Covers: shift assign for I8, I16, U8, U16, U64
// Also: BitAnd/Or/Xor assign for I64, U8, U16, U64 (methods)
use test

// =============================================================================
// ShlAssign for small types
// =============================================================================

@test
func test_i8_shl_assign() -> I32 {
    var a: I8 = 1
    a <<= 4
    assert_eq(a as I32, 16, "I8 <<= 4")
    return 0
}

@test
func test_i16_shl_assign() -> I32 {
    var a: I16 = 1
    a <<= 8
    assert_eq(a as I32, 256, "I16 <<= 8")
    return 0
}

@test
func test_u8_shl_assign() -> I32 {
    var a: U8 = 1
    a <<= 4
    assert_eq(a as I32, 16, "U8 <<= 4")
    return 0
}

@test
func test_u16_shl_assign() -> I32 {
    var a: U16 = 1
    a <<= 8
    assert_eq(a as I32, 256, "U16 <<= 8")
    return 0
}

@test
func test_u64_shl_assign() -> I32 {
    var a: U64 = 1
    a <<= 32
    assert_eq(a as I64, 4294967296, "U64 <<= 32")
    return 0
}

// =============================================================================
// ShrAssign for small types
// =============================================================================

@test
func test_i8_shr_assign() -> I32 {
    var a: I8 = 64
    a >>= 3
    assert_eq(a as I32, 8, "I8 >>= 3")
    return 0
}

@test
func test_i16_shr_assign() -> I32 {
    var a: I16 = 256
    a >>= 4
    assert_eq(a as I32, 16, "I16 >>= 4")
    return 0
}

@test
func test_u64_shr_assign() -> I32 {
    var a: U64 = 4294967296
    a >>= 16
    assert_eq(a as I64, 65536, "U64 >>= 16")
    return 0
}

// =============================================================================
// BitAndAssign for remaining types
// =============================================================================

@test
func test_u16_bitand_assign() -> I32 {
    var a: U16 = 0x0FFF
    let b: U16 = 0x00FF
    a &= b
    assert_eq(a as I32, 0x00FF, "U16 &= ")
    return 0
}

@test
func test_u64_bitand_assign() -> I32 {
    var a: U64 = 0xFF00FF00
    let b: U64 = 0x0F0F0F0F
    a &= b
    assert_eq(a as I64, 0x0F000F00, "U64 &= ")
    return 0
}

// =============================================================================
// BitOrAssign for remaining types
// =============================================================================

@test
func test_u16_bitor_assign() -> I32 {
    var a: U16 = 0x0F00
    let b: U16 = 0x00FF
    a |= b
    assert_eq(a as I32, 0x0FFF, "U16 |= ")
    return 0
}

@test
func test_u64_bitor_assign() -> I32 {
    var a: U64 = 0xFF000000
    let b: U64 = 0x000000FF
    a |= b
    assert_eq(a as I64, 0xFF0000FF, "U64 |= ")
    return 0
}

// =============================================================================
// BitXorAssign for remaining types
// =============================================================================

@test
func test_u16_bitxor_assign() -> I32 {
    var a: U16 = 0x0FFF
    let b: U16 = 0x00FF
    a ^= b
    assert_eq(a as I32, 0x0F00, "U16 ^= ")
    return 0
}

@test
func test_u64_bitxor_assign() -> I32 {
    var a: U64 = 0xFFFF0000
    let b: U64 = 0x0000FFFF
    a ^= b
    assert_eq(a as I64, 0xFFFFFFFF, "U64 ^= ")
    return 0
}
