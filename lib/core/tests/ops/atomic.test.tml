// Atomic Operations Tests
//
// Tests for thread-safe atomic operations including load, store,
// arithmetic, exchange, compare-exchange, and memory fences.

use test::{assert, assert_eq}

// ============ I32 Atomic Operations ============

@test
func test_atomic_fetch_add_i32() -> I32 {
    let mut value: I32 = 10
    let old: I32 = atomic_fetch_add_i32(&mut value, 5)
    assert_eq(old, 10, "Should return old value")
    assert_eq(value, 15, "Should add to value")
    return 0
}

@test
func test_atomic_fetch_sub_i32() -> I32 {
    let mut value: I32 = 20
    let old: I32 = atomic_fetch_sub_i32(&mut value, 7)
    assert_eq(old, 20, "Should return old value")
    assert_eq(value, 13, "Should subtract from value")
    return 0
}

@test
func test_atomic_load_i32() -> I32 {
    let value: I32 = 42
    let loaded: I32 = atomic_load_i32(&value)
    assert_eq(loaded, 42, "Should load value atomically")
    return 0
}

@test
func test_atomic_store_i32() -> I32 {
    let mut value: I32 = 0
    atomic_store_i32(&mut value, 99)
    assert_eq(value, 99, "Should store value atomically")
    return 0
}

@test
func test_atomic_compare_exchange_i32_success() -> I32 {
    let mut value: I32 = 100
    // Compare 100 (matches), swap to 200
    let old: I32 = atomic_compare_exchange_i32(&mut value, 100, 200)
    assert_eq(old, 100, "Should return old value")
    assert_eq(value, 200, "Should exchange when match")
    return 0
}

@test
func test_atomic_compare_exchange_i32_fail() -> I32 {
    let mut value: I32 = 100
    // Compare 50 (doesn't match), don't swap
    let old: I32 = atomic_compare_exchange_i32(&mut value, 50, 200)
    assert_eq(old, 100, "Should return current value")
    assert_eq(value, 100, "Should not exchange when no match")
    return 0
}

@test
func test_atomic_swap_i32() -> I32 {
    let mut value: I32 = 77
    let old: I32 = atomic_swap_i32(&mut value, 88)
    assert_eq(old, 77, "Should return old value")
    assert_eq(value, 88, "Should swap to new value")
    return 0
}

// ============ I64 Atomic Operations ============
// NOTE: I64 atomic tests disabled due to codegen bug with I64 to I32 casts
// TODO: Re-enable once codegen properly handles I64 comparisons in assert_eq

// @test
// func test_atomic_fetch_add_i64() -> I32 {
//     let mut value: I64 = 1000
//     let old: I64 = atomic_fetch_add_i64(&mut value, 500)
//     assert(old == 1000, "Should return old value")
//     assert(value == 1500, "Should add to value")
//     return 0
// }

// ============ Memory Fences ============

@test
func test_atomic_fence() -> I32 {
    // Full memory barrier
    atomic_fence()
    assert(true, "Fence should complete")
    return 0
}

@test
func test_atomic_fence_acquire() -> I32 {
    // Acquire fence - prevents reads/writes from moving before fence
    atomic_fence_acquire()
    assert(true, "Acquire fence should complete")
    return 0
}

@test
func test_atomic_fence_release() -> I32 {
    // Release fence - prevents reads/writes from moving after fence
    atomic_fence_release()
    assert(true, "Release fence should complete")
    return 0
}

// ============ Sequence Tests (Multiple Operations) ============

@test
func test_atomic_sequence_i32() -> I32 {
    let mut counter: I32 = 0

    // Multiple atomic increments (each in its own scope to avoid borrow conflicts)
    {
        atomic_fetch_add_i32(&mut counter, 1)
    }
    {
        atomic_fetch_add_i32(&mut counter, 1)
    }
    {
        atomic_fetch_add_i32(&mut counter, 1)
    }

    {
        let result: I32 = atomic_load_i32(&counter)
        assert_eq(result, 3, "Should accumulate increments")
    }

    // Atomic decrement
    {
        atomic_fetch_sub_i32(&mut counter, 1)
    }
    {
        let result2: I32 = atomic_load_i32(&counter)
        assert_eq(result2, 2, "Should decrement correctly")
    }

    return 0
}

// @test
// func test_atomic_sequence_i64() -> I32 {
//     // Disabled due to I64 codegen bug
//     return 0
// }

// ============ Edge Cases ============

@test
func test_atomic_zero_operations() -> I32 {
    let mut value: I32 = 42

    // Add zero
    let old1: I32 = {
        atomic_fetch_add_i32(&mut value, 0)
    }
    assert_eq(old1, 42, "Add zero returns old value")
    assert_eq(value, 42, "Add zero doesn't change value")

    // Subtract zero
    let old2: I32 = {
        atomic_fetch_sub_i32(&mut value, 0)
    }
    assert_eq(old2, 42, "Sub zero returns old value")
    assert_eq(value, 42, "Sub zero doesn't change value")

    return 0
}

@test
func test_atomic_negative_values() -> I32 {
    let mut value: I32 = -10

    {
        atomic_fetch_add_i32(&mut value, -5)
    }
    assert_eq(value, -15, "Should handle negative addition")

    {
        atomic_fetch_sub_i32(&mut value, -5)
    }
    assert_eq(value, -10, "Should handle negative subtraction")

    return 0
}

@test
func test_atomic_swap_same_value() -> I32 {
    let mut value: I32 = 123
    let old: I32 = atomic_swap_i32(&mut value, 123)
    assert_eq(old, 123, "Should return old value")
    assert_eq(value, 123, "Value should remain same")
    return 0
}
