// Tests for bitwise operators on types not covered by existing tests
// Covers: I8, I16, U16, U64 for &, |, ^, <<, >>
use test

// =============================================================================
// I8 bitwise operators
// =============================================================================

@test
func test_i8_bitand() -> I32 {
    let a: I8 = 0x0F
    let b: I8 = 0x3C
    let r: I8 = a & b
    assert_eq(r as I32, 0x0C, "I8 & operation")
    return 0
}

@test
func test_i8_bitor() -> I32 {
    let a: I8 = 0x0F
    let b: I8 = 0x30
    let r: I8 = a | b
    assert_eq(r as I32, 0x3F, "I8 | operation")
    return 0
}

@test
func test_i8_bitxor() -> I32 {
    let a: I8 = 0x3F
    let b: I8 = 0x0F
    let r: I8 = a ^ b
    assert_eq(r as I32, 0x30, "I8 ^ operation")
    return 0
}

@test
func test_i8_shl() -> I32 {
    let a: I8 = 1
    let r: I8 = a << 4
    assert_eq(r as I32, 16, "I8 << 4")
    return 0
}

@test
func test_i8_shr() -> I32 {
    let a: I8 = 64
    let r: I8 = a >> 3
    assert_eq(r as I32, 8, "I8 >> 3")
    return 0
}

// =============================================================================
// I16 bitwise operators
// =============================================================================

@test
func test_i16_bitand() -> I32 {
    let a: I16 = 0x0F0F
    let b: I16 = 0x00FF
    let r: I16 = a & b
    assert_eq(r as I32, 0x000F, "I16 & operation")
    return 0
}

@test
func test_i16_bitor() -> I32 {
    let a: I16 = 0x0F00
    let b: I16 = 0x00FF
    let r: I16 = a | b
    assert_eq(r as I32, 0x0FFF, "I16 | operation")
    return 0
}

@test
func test_i16_bitxor() -> I32 {
    let a: I16 = 0x0FFF
    let b: I16 = 0x00FF
    let r: I16 = a ^ b
    assert_eq(r as I32, 0x0F00, "I16 ^ operation")
    return 0
}

@test
func test_i16_shl() -> I32 {
    let a: I16 = 1
    let r: I16 = a << 8
    assert_eq(r as I32, 256, "I16 << 8")
    return 0
}

@test
func test_i16_shr() -> I32 {
    let a: I16 = 256
    let r: I16 = a >> 4
    assert_eq(r as I32, 16, "I16 >> 4")
    return 0
}

// =============================================================================
// U16 bitwise operators
// =============================================================================

@test
func test_u16_bitand() -> I32 {
    let a: U16 = 0xFF0F
    let b: U16 = 0x0FFF
    let r: U16 = a & b
    assert_eq(r as I32, 0x0F0F, "U16 & operation")
    return 0
}

@test
func test_u16_bitor() -> I32 {
    let a: U16 = 0xF000
    let b: U16 = 0x000F
    let r: U16 = a | b
    assert_eq(r as I32, 0xF00F, "U16 | operation")
    return 0
}

@test
func test_u16_bitxor() -> I32 {
    let a: U16 = 0xFFFF
    let b: U16 = 0x0F0F
    let r: U16 = a ^ b
    assert_eq(r as I32, 0xF0F0, "U16 ^ operation")
    return 0
}

@test
func test_u16_shl() -> I32 {
    let a: U16 = 1
    let r: U16 = a << 12
    assert_eq(r as I32, 4096, "U16 << 12")
    return 0
}

@test
func test_u16_shr() -> I32 {
    let a: U16 = 4096
    let r: U16 = a >> 8
    assert_eq(r as I32, 16, "U16 >> 8")
    return 0
}

// =============================================================================
// U64 bitwise operators
// =============================================================================

@test
func test_u64_bitand() -> I32 {
    let a: U64 = 0xFF00FF00
    let b: U64 = 0x0F0F0F0F
    let r: U64 = a & b
    assert_eq(r as I64, 0x0F000F00, "U64 & operation")
    return 0
}

@test
func test_u64_bitor() -> I32 {
    let a: U64 = 0xFF000000
    let b: U64 = 0x000000FF
    let r: U64 = a | b
    assert_eq(r as I64, 0xFF0000FF, "U64 | operation")
    return 0
}

@test
func test_u64_bitxor() -> I32 {
    let a: U64 = 0xFFFF0000
    let b: U64 = 0x0000FFFF
    let r: U64 = a ^ b
    assert_eq(r as I64, 0xFFFFFFFF, "U64 ^ operation")
    return 0
}

@test
func test_u64_shl() -> I32 {
    let a: U64 = 1
    let r: U64 = a << 32
    assert_eq(r as I64, 4294967296, "U64 << 32")
    return 0
}

@test
func test_u64_shr() -> I32 {
    let a: U64 = 4294967296
    let r: U64 = a >> 16
    assert_eq(r as I64, 65536, "U64 >> 16")
    return 0
}
