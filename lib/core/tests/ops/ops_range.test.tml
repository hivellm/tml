// Tests for range types (core::ops::range)
use test

use core::ops::range::{
    Range,
    RangeInclusive,
    RangeFrom,
    RangeTo,
    RangeToInclusive,
    RangeFull
}

// Note: Bound tests disabled until generic enum variant resolution is fixed
// The compiler doesn't properly resolve Bound::Unbounded in generic contexts

// ============================================================================
// Range Tests (half-open: start to end)
// ============================================================================

@test
func test_range_new() -> I32 {
    let r: Range[I64] = Range::new(0, 10)
    assert_eq(r.start, 0, "start should be 0")
    assert_eq(r.end, 10, "end should be 10")
    return 0
}

@test
func test_range_is_empty_false() -> I32 {
    let r: Range[I64] = Range::new(0, 10)
    assert(not r.is_empty(), "0 to 10 should not be empty")
    return 0
}

@test
func test_range_is_empty_true() -> I32 {
    let r: Range[I64] = Range::new(10, 10)
    assert(r.is_empty(), "10 to 10 should be empty")
    return 0
}

@test
func test_range_is_empty_inverted() -> I32 {
    let r: Range[I64] = Range::new(10, 5)
    assert(r.is_empty(), "10 to 5 should be empty (inverted)")
    return 0
}

@test
func test_range_contains() -> I32 {
    let r: Range[I64] = Range::new(0, 10)
    let v0: I64 = 0
    let v5: I64 = 5
    let v9: I64 = 9
    let v10: I64 = 10
    let v100: I64 = 100
    let vm1: I64 = -1

    assert(r.contains(ref v0), "0 to 10 should contain 0")
    assert(r.contains(ref v5), "0 to 10 should contain 5")
    assert(r.contains(ref v9), "0 to 10 should contain 9")
    assert(not r.contains(ref v10), "0 to 10 should not contain 10 (exclusive)")
    assert(not r.contains(ref v100), "0 to 10 should not contain 100")
    assert(not r.contains(ref vm1), "0 to 10 should not contain -1")
    return 0
}

// ============================================================================
// RangeInclusive Tests (closed: start through end)
// ============================================================================

@test
func test_range_inclusive_new() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(1, 5)
    assert_eq(*r.start(), 1, "start should be 1")
    assert_eq(*r.end(), 5, "end should be 5")
    return 0
}

@test
func test_range_inclusive_is_empty_false() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(1, 5)
    assert(not r.is_empty(), "1 through 5 should not be empty")
    return 0
}

@test
func test_range_inclusive_is_empty_single() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(5, 5)
    assert(not r.is_empty(), "5 through 5 should not be empty (single element)")
    return 0
}

@test
func test_range_inclusive_is_empty_inverted() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(10, 5)
    assert(r.is_empty(), "10 through 5 should be empty (inverted)")
    return 0
}

@test
func test_range_inclusive_contains() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(1, 5)
    let v1: I64 = 1
    let v3: I64 = 3
    let v5: I64 = 5
    let v0: I64 = 0
    let v6: I64 = 6

    assert(r.contains(ref v1), "1 through 5 should contain 1")
    assert(r.contains(ref v3), "1 through 5 should contain 3")
    assert(r.contains(ref v5), "1 through 5 should contain 5 (inclusive!)")
    assert(not r.contains(ref v0), "1 through 5 should not contain 0")
    assert(not r.contains(ref v6), "1 through 5 should not contain 6")
    return 0
}

// Note: into_inner test commented out due to generic tuple return type limitation
// @test
// func test_range_inclusive_into_inner() -> I32 {
//     let r: RangeInclusive[I64] = RangeInclusive::new(10, 20)
//     let tuple: (I64, I64) = r.into_inner()
//     assert_eq(tuple.0, 10, "first should be 10")
//     assert_eq(tuple.1, 20, "second should be 20")
//     return 0
// }

// ============================================================================
// RangeFrom Tests (no upper: start to)
// ============================================================================

@test
func test_range_from_new() -> I32 {
    let r: RangeFrom[I64] = RangeFrom::new(5)
    assert_eq(r.start, 5, "start should be 5")
    return 0
}

@test
func test_range_from_contains() -> I32 {
    let r: RangeFrom[I64] = RangeFrom::new(10)
    let v9: I64 = 9
    let v10: I64 = 10
    let v100: I64 = 100

    assert(not r.contains(ref v9), "10 to should not contain 9")
    assert(r.contains(ref v10), "10 to should contain 10")
    assert(r.contains(ref v100), "10 to should contain 100")
    return 0
}

// ============================================================================
// RangeTo Tests (no lower: to end)
// ============================================================================

@test
func test_range_to_new() -> I32 {
    let r: RangeTo[I64] = RangeTo::new(10)
    assert_eq(r.end, 10, "end should be 10")
    return 0
}

@test
func test_range_to_contains() -> I32 {
    let r: RangeTo[I64] = RangeTo::new(10)
    let vm100: I64 = -100
    let v0: I64 = 0
    let v9: I64 = 9
    let v10: I64 = 10
    let v11: I64 = 11

    assert(r.contains(ref vm100), "to 10 should contain -100")
    assert(r.contains(ref v0), "to 10 should contain 0")
    assert(r.contains(ref v9), "to 10 should contain 9")
    assert(not r.contains(ref v10), "to 10 should not contain 10 (exclusive)")
    assert(not r.contains(ref v11), "to 10 should not contain 11")
    return 0
}

// ============================================================================
// RangeToInclusive Tests (no lower, inclusive: through end)
// ============================================================================

@test
func test_range_to_inclusive_new() -> I32 {
    let r: RangeToInclusive[I64] = RangeToInclusive::new(10)
    assert_eq(r.end, 10, "end should be 10")
    return 0
}

@test
func test_range_to_inclusive_contains() -> I32 {
    let r: RangeToInclusive[I64] = RangeToInclusive::new(10)
    let vm100: I64 = -100
    let v0: I64 = 0
    let v9: I64 = 9
    let v10: I64 = 10
    let v11: I64 = 11

    assert(r.contains(ref vm100), "through 10 should contain -100")
    assert(r.contains(ref v0), "through 10 should contain 0")
    assert(r.contains(ref v9), "through 10 should contain 9")
    assert(r.contains(ref v10), "through 10 should contain 10 (inclusive!)")
    assert(not r.contains(ref v11), "through 10 should not contain 11")
    return 0
}

// ============================================================================
// RangeFull Tests (all values: ..)
// ============================================================================

@test
func test_range_full_new() -> I32 {
    let _r: RangeFull = RangeFull::new()
    // Just test that we can create it
    return 0
}

// Note: Generic methods on non-generic types not yet supported
// @test
// func test_range_full_contains_everything() -> I32 {
//     let r: RangeFull = RangeFull::new()
//     let vm1000000: I64 = -1000000
//     let v0: I64 = 0
//     let v1000000: I64 = 1000000
//
//     assert(r.contains(ref vm1000000), ".. should contain -1000000")
//     assert(r.contains(ref v0), ".. should contain 0")
//     assert(r.contains(ref v1000000), ".. should contain 1000000")
//     return 0
// }

// ============================================================================
// Debug/Display Tests
// ============================================================================

@test
func test_range_debug_string() -> I32 {
    let r: Range[I64] = Range::new(1, 10)
    let s: Str = r.debug_string()
    assert(s == "1 to 10", "Range debug should be '1 to 10'")
    return 0
}

@test
func test_range_inclusive_debug_string() -> I32 {
    let r: RangeInclusive[I64] = RangeInclusive::new(1, 10)
    let s: Str = r.debug_string()
    assert(s == "1 through 10", "RangeInclusive debug should be '1 through 10'")
    return 0
}

@test
func test_range_from_debug_string() -> I32 {
    let r: RangeFrom[I64] = RangeFrom::new(5)
    let s: Str = r.debug_string()
    assert(s == "5 to", "RangeFrom debug should be '5 to'")
    return 0
}

@test
func test_range_to_debug_string() -> I32 {
    let r: RangeTo[I64] = RangeTo::new(5)
    let s: Str = r.debug_string()
    assert(s == "to 5", "RangeTo debug should be 'to 5'")
    return 0
}

@test
func test_range_full_debug_string() -> I32 {
    let r: RangeFull = RangeFull::new()
    let s: Str = r.debug_string()
    assert(s == "..", "RangeFull debug should be '..'")
    return 0
}
