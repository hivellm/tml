// Consolidated: Arithmetic behavior method tests for all types
// Sources: ops_arith_methods_i8 (6) + i16 (6) + u8 (5) + u16 (5) + u32 (5) + u64 (5) + float (10)
// Total: 42 @test functions
use test

// =============================================================================
// I8 behavior methods
// =============================================================================

@test
func test_i8_add_method() -> I32 {
    let a: I8 = 10
    let b: I8 = 20
    let r: I8 = a.add(b)
    assert_eq(r as I32, 30, "I8.add()")
    return 0
}

@test
func test_i8_sub_method() -> I32 {
    let a: I8 = 50
    let b: I8 = 20
    let r: I8 = a.sub(b)
    assert_eq(r as I32, 30, "I8.sub()")
    return 0
}

@test
func test_i8_mul_method() -> I32 {
    let a: I8 = 6
    let b: I8 = 7
    let r: I8 = a.mul(b)
    assert_eq(r as I32, 42, "I8.mul()")
    return 0
}

@test
func test_i8_div_method() -> I32 {
    let a: I8 = 100
    let b: I8 = 10
    let r: I8 = a.div(b)
    assert_eq(r as I32, 10, "I8.div()")
    return 0
}

@test
func test_i8_rem_method() -> I32 {
    let a: I8 = 17
    let b: I8 = 5
    let r: I8 = a.rem(b)
    assert_eq(r as I32, 2, "I8.rem()")
    return 0
}

@test
func test_i8_neg_method() -> I32 {
    let a: I8 = 42
    let r: I8 = a.neg()
    assert_eq(r as I32, -42, "I8.neg()")
    return 0
}

// =============================================================================
// I16 behavior methods
// =============================================================================

@test
func test_i16_add_method() -> I32 {
    let a: I16 = 100
    let b: I16 = 200
    let r: I16 = a.add(b)
    assert_eq(r as I32, 300, "I16.add()")
    return 0
}

@test
func test_i16_sub_method() -> I32 {
    let a: I16 = 500
    let b: I16 = 200
    let r: I16 = a.sub(b)
    assert_eq(r as I32, 300, "I16.sub()")
    return 0
}

@test
func test_i16_mul_method() -> I32 {
    let a: I16 = 30
    let b: I16 = 40
    let r: I16 = a.mul(b)
    assert_eq(r as I32, 1200, "I16.mul()")
    return 0
}

@test
func test_i16_div_method() -> I32 {
    let a: I16 = 1000
    let b: I16 = 50
    let r: I16 = a.div(b)
    assert_eq(r as I32, 20, "I16.div()")
    return 0
}

@test
func test_i16_rem_method() -> I32 {
    let a: I16 = 103
    let b: I16 = 10
    let r: I16 = a.rem(b)
    assert_eq(r as I32, 3, "I16.rem()")
    return 0
}

@test
func test_i16_neg_method() -> I32 {
    let a: I16 = 123
    let r: I16 = a.neg()
    assert_eq(r as I32, -123, "I16.neg()")
    return 0
}

// =============================================================================
// U8 behavior methods
// =============================================================================

@test
func test_u8_add_method() -> I32 {
    let a: U8 = 10
    let b: U8 = 20
    let r: U8 = a.add(b)
    assert_eq(r as I32, 30, "U8.add()")
    return 0
}

@test
func test_u8_sub_method() -> I32 {
    let a: U8 = 50
    let b: U8 = 20
    let r: U8 = a.sub(b)
    assert_eq(r as I32, 30, "U8.sub()")
    return 0
}

@test
func test_u8_mul_method() -> I32 {
    let a: U8 = 6
    let b: U8 = 7
    let r: U8 = a.mul(b)
    assert_eq(r as I32, 42, "U8.mul()")
    return 0
}

@test
func test_u8_div_method() -> I32 {
    let a: U8 = 100
    let b: U8 = 10
    let r: U8 = a.div(b)
    assert_eq(r as I32, 10, "U8.div()")
    return 0
}

@test
func test_u8_rem_method() -> I32 {
    let a: U8 = 17
    let b: U8 = 5
    let r: U8 = a.rem(b)
    assert_eq(r as I32, 2, "U8.rem()")
    return 0
}

// =============================================================================
// U16 behavior methods
// =============================================================================

@test
func test_u16_add_method() -> I32 {
    let a: U16 = 100
    let b: U16 = 200
    let r: U16 = a.add(b)
    assert_eq(r as I32, 300, "U16.add()")
    return 0
}

@test
func test_u16_sub_method() -> I32 {
    let a: U16 = 500
    let b: U16 = 200
    let r: U16 = a.sub(b)
    assert_eq(r as I32, 300, "U16.sub()")
    return 0
}

@test
func test_u16_mul_method() -> I32 {
    let a: U16 = 30
    let b: U16 = 40
    let r: U16 = a.mul(b)
    assert_eq(r as I32, 1200, "U16.mul()")
    return 0
}

@test
func test_u16_div_method() -> I32 {
    let a: U16 = 1000
    let b: U16 = 50
    let r: U16 = a.div(b)
    assert_eq(r as I32, 20, "U16.div()")
    return 0
}

@test
func test_u16_rem_method() -> I32 {
    let a: U16 = 103
    let b: U16 = 10
    let r: U16 = a.rem(b)
    assert_eq(r as I32, 3, "U16.rem()")
    return 0
}

// =============================================================================
// U32 behavior methods
// =============================================================================

@test
func test_u32_add_method() -> I32 {
    let a: U32 = 100
    let b: U32 = 200
    let r: U32 = a.add(b)
    assert_eq(r as I32, 300, "U32.add()")
    return 0
}

@test
func test_u32_sub_method() -> I32 {
    let a: U32 = 500
    let b: U32 = 200
    let r: U32 = a.sub(b)
    assert_eq(r as I32, 300, "U32.sub()")
    return 0
}

@test
func test_u32_mul_method() -> I32 {
    let a: U32 = 15
    let b: U32 = 20
    let r: U32 = a.mul(b)
    assert_eq(r as I32, 300, "U32.mul()")
    return 0
}

@test
func test_u32_div_method() -> I32 {
    let a: U32 = 1000
    let b: U32 = 50
    let r: U32 = a.div(b)
    assert_eq(r as I32, 20, "U32.div()")
    return 0
}

@test
func test_u32_rem_method() -> I32 {
    let a: U32 = 103
    let b: U32 = 10
    let r: U32 = a.rem(b)
    assert_eq(r as I32, 3, "U32.rem()")
    return 0
}

// =============================================================================
// U64 behavior methods
// =============================================================================

@test
func test_u64_add_method() -> I32 {
    let a: U64 = 1000
    let b: U64 = 2000
    let r: U64 = a.add(b)
    assert_eq(r as I64, 3000, "U64.add()")
    return 0
}

@test
func test_u64_sub_method() -> I32 {
    let a: U64 = 5000
    let b: U64 = 2000
    let r: U64 = a.sub(b)
    assert_eq(r as I64, 3000, "U64.sub()")
    return 0
}

@test
func test_u64_mul_method() -> I32 {
    let a: U64 = 150
    let b: U64 = 20
    let r: U64 = a.mul(b)
    assert_eq(r as I64, 3000, "U64.mul()")
    return 0
}

@test
func test_u64_div_method() -> I32 {
    let a: U64 = 10000
    let b: U64 = 50
    let r: U64 = a.div(b)
    assert_eq(r as I64, 200, "U64.div()")
    return 0
}

@test
func test_u64_rem_method() -> I32 {
    let a: U64 = 1003
    let b: U64 = 100
    let r: U64 = a.rem(b)
    assert_eq(r as I64, 3, "U64.rem()")
    return 0
}

// =============================================================================
// F32 behavior methods
// =============================================================================

@test
func test_f32_add_method() -> I32 {
    let a: F32 = 1.5
    let b: F32 = 2.5
    let r: F32 = a.add(b)
    assert_eq((r * 10.0) as I32, 40, "F32.add()")
    return 0
}

@test
func test_f32_sub_method() -> I32 {
    let a: F32 = 5.0
    let b: F32 = 2.0
    let r: F32 = a.sub(b)
    assert_eq((r * 10.0) as I32, 30, "F32.sub()")
    return 0
}

@test
func test_f32_mul_method() -> I32 {
    let a: F32 = 3.0
    let b: F32 = 4.0
    let r: F32 = a.mul(b)
    assert_eq(r as I32, 12, "F32.mul()")
    return 0
}

@test
func test_f32_div_method() -> I32 {
    let a: F32 = 10.0
    let b: F32 = 4.0
    let r: F32 = a.div(b)
    assert_eq((r * 10.0) as I32, 25, "F32.div()")
    return 0
}

@test
func test_f32_neg_method() -> I32 {
    let a: F32 = 3.14
    let r: F32 = a.neg()
    assert(r < 0.0, "F32.neg() should be negative")
    return 0
}

// =============================================================================
// F64 behavior methods
// =============================================================================

@test
func test_f64_add_method() -> I32 {
    let a: F64 = 1.5
    let b: F64 = 2.5
    let r: F64 = a.add(b)
    assert_eq(r as I64, 4, "F64.add()")
    return 0
}

@test
func test_f64_sub_method() -> I32 {
    let a: F64 = 100.0
    let b: F64 = 42.0
    let r: F64 = a.sub(b)
    assert_eq(r as I64, 58, "F64.sub()")
    return 0
}

@test
func test_f64_mul_method() -> I32 {
    let a: F64 = 7.0
    let b: F64 = 6.0
    let r: F64 = a.mul(b)
    assert_eq(r as I64, 42, "F64.mul()")
    return 0
}

@test
func test_f64_div_method() -> I32 {
    let a: F64 = 22.0
    let b: F64 = 7.0
    let r: F64 = a.div(b)
    assert_eq((r * 100.0) as I64, 314, "F64.div()")
    return 0
}

@test
func test_f64_neg_method() -> I32 {
    let a: F64 = 42.0
    let r: F64 = a.neg()
    assert_eq(r as I64, -42, "F64.neg()")
    return 0
}
