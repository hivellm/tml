// Consolidated cmp tests - File 1 of 3
// Primitive equality, comparison operators, cmp methods, small integer types, float comparisons
// Total @test count: 50
// Sources: cmp.test.tml, cmp_eq_small.test.tml, cmp_float.test.tml (partial)
use test
use core::cmp::{Ordering, min, max}

// ============================================================================
// Ordering tests using pattern matching (from cmp.test.tml)
// ============================================================================

@test
func test_ordering_less() -> I32 {
    let ord: Ordering = Ordering::Less
    var is_less: Bool = false
    when ord {
        Less => { is_less = true },
        Greater => {},
        Equal => {}
    }
    assert(is_less, "should be Less")
    return 0
}

@test
func test_ordering_greater() -> I32 {
    let ord: Ordering = Ordering::Greater
    var is_greater: Bool = false
    when ord {
        Less => {},
        Greater => { is_greater = true },
        Equal => {}
    }
    assert(is_greater, "should be Greater")
    return 0
}

@test
func test_ordering_equal() -> I32 {
    let ord: Ordering = Ordering::Equal
    var is_equal: Bool = false
    when ord {
        Less => {},
        Greater => {},
        Equal => { is_equal = true }
    }
    assert(is_equal, "should be Equal")
    return 0
}

// ============================================================================
// PartialEq tests on primitives (from cmp.test.tml)
// ============================================================================

@test
func test_i32_eq() -> I32 {
    let a: I32 = 42
    let b: I32 = 42
    let c: I32 = 0

    assert(a == b, "42 == 42")
    assert(a != c, "42 != 0")
    return 0
}

@test
func test_i64_eq() -> I32 {
    let a: I64 = 1000000
    let b: I64 = 1000000
    let c: I64 = 0

    assert(a == b, "1000000 == 1000000")
    assert(a != c, "1000000 != 0")
    return 0
}

// ============================================================================
// min/max free function tests (from cmp.test.tml)
// ============================================================================

@test
func test_min_i32() -> I32 {
    let result: I32 = min(5, 10)
    assert_eq(result, 5, "min(5, 10) = 5")
    return 0
}

@test
func test_max_i32() -> I32 {
    let result: I32 = max(5, 10)
    assert_eq(result, 10, "max(5, 10) = 10")
    return 0
}

@test
func test_min_negative() -> I32 {
    let result: I32 = min(-5, -10)
    assert_eq(result, -10, "min(-5, -10) = -10")
    return 0
}

@test
func test_max_negative() -> I32 {
    let result: I32 = max(-5, -10)
    assert_eq(result, -5, "max(-5, -10) = -5")
    return 0
}

@test
func test_min_equal() -> I32 {
    let result: I32 = min(7, 7)
    assert_eq(result, 7, "min(7, 7) = 7")
    return 0
}

@test
func test_max_equal() -> I32 {
    let result: I32 = max(7, 7)
    assert_eq(result, 7, "max(7, 7) = 7")
    return 0
}

// ============================================================================
// Ordering method tests (from cmp.test.tml)
// ============================================================================

@test
func test_ordering_is_less() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_less(), "Less.is_less() should be true")
    assert(equal.is_less() == false, "Equal.is_less() should be false")
    assert(greater.is_less() == false, "Greater.is_less() should be false")
    return 0
}

@test
func test_ordering_is_equal() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_equal() == false, "Less.is_equal() should be false")
    assert(equal.is_equal(), "Equal.is_equal() should be true")
    assert(greater.is_equal() == false, "Greater.is_equal() should be false")
    return 0
}

@test
func test_ordering_is_greater() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_greater() == false, "Less.is_greater() should be false")
    assert(equal.is_greater() == false, "Equal.is_greater() should be false")
    assert(greater.is_greater(), "Greater.is_greater() should be true")
    return 0
}

@test
func test_ordering_reverse() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.reverse().is_greater(), "Less.reverse() should be Greater")
    assert(equal.reverse().is_equal(), "Equal.reverse() should be Equal")
    assert(greater.reverse().is_less(), "Greater.reverse() should be Less")
    return 0
}

@test
func test_ordering_then_cmp() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    // When first is Equal, use second
    assert(equal.then_cmp(less).is_less(), "Equal.then_cmp(Less) should be Less")
    assert(equal.then_cmp(greater).is_greater(), "Equal.then_cmp(Greater) should be Greater")
    assert(equal.then_cmp(equal).is_equal(), "Equal.then_cmp(Equal) should be Equal")

    // When first is not Equal, keep first
    assert(less.then_cmp(greater).is_less(), "Less.then_cmp(Greater) should be Less")
    assert(greater.then_cmp(less).is_greater(), "Greater.then_cmp(Less) should be Greater")
    return 0
}

// ============================================================================
// Comparison operator tests (from cmp.test.tml)
// ============================================================================

@test
func test_i32_less_than() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    assert(a < b, "5 < 10")
    assert((a < c) == false, "5 < 5 should be false")
    assert((b < a) == false, "10 < 5 should be false")
    return 0
}

@test
func test_i32_less_equal() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    assert(a <= b, "5 <= 10")
    assert(a <= c, "5 <= 5")
    assert((b <= a) == false, "10 <= 5 should be false")
    return 0
}

@test
func test_i32_greater_than() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    let c: I32 = 10

    assert(a > b, "10 > 5")
    assert((a > c) == false, "10 > 10 should be false")
    assert((b > a) == false, "5 > 10 should be false")
    return 0
}

@test
func test_i32_greater_equal() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    let c: I32 = 10

    assert(a >= b, "10 >= 5")
    assert(a >= c, "10 >= 10")
    assert((b >= a) == false, "5 >= 10 should be false")
    return 0
}

// ============================================================================
// Ord method tests - cmp, partial_cmp, max, min (from cmp.test.tml)
// ============================================================================

@test
func test_i32_cmp() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "5.cmp(10) should be Less")
    let ord2: Ordering = b.cmp(ref a)
    assert(ord2.is_greater(), "10.cmp(5) should be Greater")
    let ord3: Ordering = a.cmp(ref c)
    assert(ord3.is_equal(), "5.cmp(5) should be Equal")
    return 0
}

@test
func test_i32_partial_cmp() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: Maybe[Ordering] = a.partial_cmp(ref b)
    when result {
        Just(ord) => {
            when ord {
                Ordering::Less => { assert(true, "5.partial_cmp(10) is Just(Less)") },
                _ => { assert(false, "expected Less") }
            }
        },
        Nothing => {
            assert(false, "partial_cmp should return Just for integers")
        }
    }
    return 0
}

@test
func test_i32_ord_max() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: I32 = a.max(b)
    assert_eq(result, 10, "5.max(10) should be 10")

    let result2: I32 = b.max(a)
    assert_eq(result2, 10, "10.max(5) should be 10")
    return 0
}

@test
func test_i32_ord_min() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: I32 = a.min(b)
    assert_eq(result, 5, "5.min(10) should be 5")

    let result2: I32 = b.min(a)
    assert_eq(result2, 5, "10.min(5) should be 5")
    return 0
}

// Note: clamp method has a codegen bug (Self type not substituted) - skipping for now
// @test
// func test_i32_clamp() -> I32 {
//     let low: I32 = 0
//     let high: I32 = 10
//     let below: I32 = -5
//     assert_eq(below.clamp(low, high), 0, "(-5).clamp(0, 10) should be 0")
//     return 0
// }

// ============================================================================
// Ordering equality tests (from cmp.test.tml)
// ============================================================================

@test
func test_ordering_eq() -> I32 {
    let less1: Ordering = Ordering::Less
    let less2: Ordering = Ordering::Less
    let equal1: Ordering = Ordering::Equal
    let greater1: Ordering = Ordering::Greater

    assert(less1.eq(ref less2), "Less == Less")
    assert(less1.eq(ref equal1) == false, "Less != Equal")
    assert(less1.eq(ref greater1) == false, "Less != Greater")
    assert(equal1.eq(ref equal1), "Equal == Equal")
    assert(greater1.eq(ref greater1), "Greater == Greater")
    return 0
}

// ============================================================================
// Different integer type tests - U32, I64, U64 (from cmp.test.tml)
// ============================================================================

@test
func test_u32_cmp() -> I32 {
    let a: U32 = 5
    let b: U32 = 10

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "5u32.cmp(10) should be Less")
    let ord2: Ordering = b.cmp(ref a)
    assert(ord2.is_greater(), "10u32.cmp(5) should be Greater")
    assert(a < b, "5u32 < 10u32")
    assert(b > a, "10u32 > 5u32")
    return 0
}

@test
func test_i64_cmp() -> I32 {
    let a: I64 = -100
    let b: I64 = 100

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "(-100i64).cmp(100) should be Less")
    assert(a < b, "-100i64 < 100i64")
    assert(b >= a, "100i64 >= -100i64")
    return 0
}

@test
func test_u64_cmp() -> I32 {
    let a: U64 = 1000000
    let b: U64 = 2000000

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "1000000u64.cmp(2000000) should be Less")
    assert(a <= b, "1000000u64 <= 2000000u64")
    return 0
}

// Note: Bool.cmp method has codegen issues - skipping for now
// @test
// func test_bool_cmp() -> I32 { ... }
// @test
// func test_bool_lt_gt() -> I32 { ... }

// Note: F64.partial_cmp method has codegen issues - skipping for now
// These can be re-enabled once behavior method codegen is fixed for primitive types

@test
func test_f64_operators() -> I32 {
    let a: F64 = 1.0
    let b: F64 = 2.0
    let c: F64 = 1.0

    // Test using operators directly (these work)
    assert(a < b, "1.0 < 2.0")
    assert(a <= b, "1.0 <= 2.0")
    assert(a <= c, "1.0 <= 1.0")
    assert(b > a, "2.0 > 1.0")
    assert(b >= a, "2.0 >= 1.0")
    assert(a >= c, "1.0 >= 1.0")
    return 0
}

// ============================================================================
// Small integer type equality and comparison (from cmp_eq_small.test.tml)
// ============================================================================

// --- I8 ---

@test
func test_i8_equality() -> I32 {
    let a: I8 = 42
    let b: I8 = 42
    let c: I8 = 10
    assert(a == b, "I8 42 == 42")
    assert(a != c, "I8 42 != 10")
    return 0
}

@test
func test_i8_comparison() -> I32 {
    let a: I8 = 5
    let b: I8 = 10
    assert(a < b, "I8 5 < 10")
    assert(b > a, "I8 10 > 5")
    assert(a <= b, "I8 5 <= 10")
    assert(b >= a, "I8 10 >= 5")
    assert(a <= a, "I8 5 <= 5")
    assert(a >= a, "I8 5 >= 5")
    return 0
}

@test
func test_i8_cmp_method() -> I32 {
    let a: I8 = 5
    let b: I8 = 10
    let c: I8 = 5
    let ord1 = a.cmp(ref b)
    assert(ord1.is_less(), "I8 5.cmp(10) is Less")
    let ord2 = b.cmp(ref a)
    assert(ord2.is_greater(), "I8 10.cmp(5) is Greater")
    let ord3 = a.cmp(ref c)
    assert(ord3.is_equal(), "I8 5.cmp(5) is Equal")
    return 0
}

// --- I16 ---

@test
func test_i16_equality() -> I32 {
    let a: I16 = 1000
    let b: I16 = 1000
    let c: I16 = 500
    assert(a == b, "I16 1000 == 1000")
    assert(a != c, "I16 1000 != 500")
    return 0
}

@test
func test_i16_comparison() -> I32 {
    let a: I16 = 100
    let b: I16 = 200
    assert(a < b, "I16 100 < 200")
    assert(b > a, "I16 200 > 100")
    assert(a <= b, "I16 100 <= 200")
    assert(b >= a, "I16 200 >= 100")
    return 0
}

@test
func test_i16_cmp_method() -> I32 {
    let a: I16 = 100
    let b: I16 = 200
    let c: I16 = 100
    let ord1 = a.cmp(ref b)
    assert(ord1.is_less(), "I16 100.cmp(200) is Less")
    let ord2 = b.cmp(ref a)
    assert(ord2.is_greater(), "I16 200.cmp(100) is Greater")
    let ord3 = a.cmp(ref c)
    assert(ord3.is_equal(), "I16 100.cmp(100) is Equal")
    return 0
}

// --- U8 ---

@test
func test_u8_equality() -> I32 {
    let a: U8 = 255
    let b: U8 = 255
    let c: U8 = 0
    assert(a == b, "U8 255 == 255")
    assert(a != c, "U8 255 != 0")
    return 0
}

@test
func test_u8_comparison() -> I32 {
    let a: U8 = 10
    let b: U8 = 200
    assert(a < b, "U8 10 < 200")
    assert(b > a, "U8 200 > 10")
    assert(a <= b, "U8 10 <= 200")
    assert(b >= a, "U8 200 >= 10")
    return 0
}

@test
func test_u8_cmp_method() -> I32 {
    let a: U8 = 10
    let b: U8 = 200
    let c: U8 = 10
    let ord1 = a.cmp(ref b)
    assert(ord1.is_less(), "U8 10.cmp(200) is Less")
    let ord2 = b.cmp(ref a)
    assert(ord2.is_greater(), "U8 200.cmp(10) is Greater")
    let ord3 = a.cmp(ref c)
    assert(ord3.is_equal(), "U8 10.cmp(10) is Equal")
    return 0
}

// --- U16 ---

@test
func test_u16_equality() -> I32 {
    let a: U16 = 65535
    let b: U16 = 65535
    let c: U16 = 0
    assert(a == b, "U16 65535 == 65535")
    assert(a != c, "U16 65535 != 0")
    return 0
}

@test
func test_u16_comparison() -> I32 {
    let a: U16 = 100
    let b: U16 = 60000
    assert(a < b, "U16 100 < 60000")
    assert(b > a, "U16 60000 > 100")
    assert(a <= b, "U16 100 <= 60000")
    assert(b >= a, "U16 60000 >= 100")
    return 0
}

@test
func test_u16_cmp_method() -> I32 {
    let a: U16 = 100
    let b: U16 = 60000
    let c: U16 = 100
    let ord1 = a.cmp(ref b)
    assert(ord1.is_less(), "U16 100.cmp(60000) is Less")
    let ord2 = b.cmp(ref a)
    assert(ord2.is_greater(), "U16 60000.cmp(100) is Greater")
    let ord3 = a.cmp(ref c)
    assert(ord3.is_equal(), "U16 100.cmp(100) is Equal")
    return 0
}

// ============================================================================
// Float comparison operators (from cmp_float.test.tml)
// ============================================================================

// --- F32 ---

@test
func test_f32_equality() -> I32 {
    let a: F32 = 3.14
    let b: F32 = 3.14
    let c: F32 = 2.71
    assert(a == b, "F32 3.14 == 3.14")
    assert(a != c, "F32 3.14 != 2.71")
    return 0
}

@test
func test_f32_less_than() -> I32 {
    let a: F32 = 1.0
    let b: F32 = 2.0
    assert(a < b, "F32 1.0 < 2.0")
    assert((b < a) == false, "F32 2.0 < 1.0 false")
    assert((a < a) == false, "F32 1.0 < 1.0 false")
    return 0
}

@test
func test_f32_less_equal() -> I32 {
    let a: F32 = 1.0
    let b: F32 = 2.0
    let c: F32 = 1.0
    assert(a <= b, "F32 1.0 <= 2.0")
    assert(a <= c, "F32 1.0 <= 1.0")
    assert((b <= a) == false, "F32 2.0 <= 1.0 false")
    return 0
}

@test
func test_f32_greater_than() -> I32 {
    let a: F32 = 2.0
    let b: F32 = 1.0
    assert(a > b, "F32 2.0 > 1.0")
    assert((b > a) == false, "F32 1.0 > 2.0 false")
    return 0
}

@test
func test_f32_greater_equal() -> I32 {
    let a: F32 = 2.0
    let b: F32 = 1.0
    let c: F32 = 2.0
    assert(a >= b, "F32 2.0 >= 1.0")
    assert(a >= c, "F32 2.0 >= 2.0")
    assert((b >= a) == false, "F32 1.0 >= 2.0 false")
    return 0
}

// --- F64 ---

@test
func test_f64_equality() -> I32 {
    let a: F64 = 3.14159
    let b: F64 = 3.14159
    let c: F64 = 2.71828
    assert(a == b, "F64 3.14159 == 3.14159")
    assert(a != c, "F64 3.14159 != 2.71828")
    return 0
}

@test
func test_f64_less_than() -> I32 {
    let a: F64 = 1.0
    let b: F64 = 2.0
    assert(a < b, "F64 1.0 < 2.0")
    assert((b < a) == false, "F64 2.0 < 1.0 false")
    return 0
}

@test
func test_f64_greater_than() -> I32 {
    let a: F64 = 100.0
    let b: F64 = 50.0
    assert(a > b, "F64 100.0 > 50.0")
    assert((b > a) == false, "F64 50.0 > 100.0 false")
    return 0
}

@test
func test_f64_less_equal() -> I32 {
    let a: F64 = 1.0
    let b: F64 = 2.0
    let c: F64 = 1.0
    assert(a <= b, "F64 1.0 <= 2.0")
    assert(a <= c, "F64 1.0 <= 1.0")
    return 0
}
