// Tests for core::cmp module
// Force cache invalidation (2026-02-04)
use test
use core::cmp::{Ordering, min, max}

// ============================================================================
// Ordering tests using pattern matching
// ============================================================================

@test
func test_ordering_less() -> I32 {
    let ord: Ordering = Ordering::Less
    var is_less: Bool = false
    when ord {
        Less => { is_less = true },
        Greater => {},
        Equal => {}
    }
    assert(is_less, "should be Less")
    return 0
}

@test
func test_ordering_greater() -> I32 {
    let ord: Ordering = Ordering::Greater
    var is_greater: Bool = false
    when ord {
        Less => {},
        Greater => { is_greater = true },
        Equal => {}
    }
    assert(is_greater, "should be Greater")
    return 0
}

@test
func test_ordering_equal() -> I32 {
    let ord: Ordering = Ordering::Equal
    var is_equal: Bool = false
    when ord {
        Less => {},
        Greater => {},
        Equal => { is_equal = true }
    }
    assert(is_equal, "should be Equal")
    return 0
}

// ============================================================================
// PartialEq tests on primitives
// ============================================================================

@test
func test_i32_eq() -> I32 {
    let a: I32 = 42
    let b: I32 = 42
    let c: I32 = 0
    
    assert(a == b, "42 == 42")
    assert(a != c, "42 != 0")
    return 0
}

@test
func test_i64_eq() -> I32 {
    let a: I64 = 1000000
    let b: I64 = 1000000
    let c: I64 = 0
    
    assert(a == b, "1000000 == 1000000")
    assert(a != c, "1000000 != 0")
    return 0
}

// ============================================================================
// min/max tests
// ============================================================================

@test
func test_min_i32() -> I32 {
    let result: I32 = min(5, 10)
    assert_eq(result, 5, "min(5, 10) = 5")
    return 0
}

@test
func test_max_i32() -> I32 {
    let result: I32 = max(5, 10)
    assert_eq(result, 10, "max(5, 10) = 10")
    return 0
}

@test
func test_min_negative() -> I32 {
    let result: I32 = min(-5, -10)
    assert_eq(result, -10, "min(-5, -10) = -10")
    return 0
}

@test
func test_max_negative() -> I32 {
    let result: I32 = max(-5, -10)
    assert_eq(result, -5, "max(-5, -10) = -5")
    return 0
}

@test
func test_min_equal() -> I32 {
    let result: I32 = min(7, 7)
    assert_eq(result, 7, "min(7, 7) = 7")
    return 0
}

@test
func test_max_equal() -> I32 {
    let result: I32 = max(7, 7)
    assert_eq(result, 7, "max(7, 7) = 7")
    return 0
}

// ============================================================================
// Ordering method tests
// ============================================================================

@test
func test_ordering_is_less() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_less(), "Less.is_less() should be true")
    assert(equal.is_less() == false, "Equal.is_less() should be false")
    assert(greater.is_less() == false, "Greater.is_less() should be false")
    return 0
}

@test
func test_ordering_is_equal() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_equal() == false, "Less.is_equal() should be false")
    assert(equal.is_equal(), "Equal.is_equal() should be true")
    assert(greater.is_equal() == false, "Greater.is_equal() should be false")
    return 0
}

@test
func test_ordering_is_greater() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.is_greater() == false, "Less.is_greater() should be false")
    assert(equal.is_greater() == false, "Equal.is_greater() should be false")
    assert(greater.is_greater(), "Greater.is_greater() should be true")
    return 0
}

@test
func test_ordering_reverse() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    assert(less.reverse().is_greater(), "Less.reverse() should be Greater")
    assert(equal.reverse().is_equal(), "Equal.reverse() should be Equal")
    assert(greater.reverse().is_less(), "Greater.reverse() should be Less")
    return 0
}

@test
func test_ordering_then_cmp() -> I32 {
    let less: Ordering = Ordering::Less
    let equal: Ordering = Ordering::Equal
    let greater: Ordering = Ordering::Greater

    // When first is Equal, use second
    assert(equal.then_cmp(less).is_less(), "Equal.then_cmp(Less) should be Less")
    assert(equal.then_cmp(greater).is_greater(), "Equal.then_cmp(Greater) should be Greater")
    assert(equal.then_cmp(equal).is_equal(), "Equal.then_cmp(Equal) should be Equal")

    // When first is not Equal, keep first
    assert(less.then_cmp(greater).is_less(), "Less.then_cmp(Greater) should be Less")
    assert(greater.then_cmp(less).is_greater(), "Greater.then_cmp(Less) should be Greater")
    return 0
}

// ============================================================================
// Comparison operator tests (using <, <=, >, >= operators)
// ============================================================================

@test
func test_i32_less_than() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    assert(a < b, "5 < 10")
    assert((a < c) == false, "5 < 5 should be false")
    assert((b < a) == false, "10 < 5 should be false")
    return 0
}

@test
func test_i32_less_equal() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    assert(a <= b, "5 <= 10")
    assert(a <= c, "5 <= 5")
    assert((b <= a) == false, "10 <= 5 should be false")
    return 0
}

@test
func test_i32_greater_than() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    let c: I32 = 10

    assert(a > b, "10 > 5")
    assert((a > c) == false, "10 > 10 should be false")
    assert((b > a) == false, "5 > 10 should be false")
    return 0
}

@test
func test_i32_greater_equal() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    let c: I32 = 10

    assert(a >= b, "10 >= 5")
    assert(a >= c, "10 >= 10")
    assert((b >= a) == false, "5 >= 10 should be false")
    return 0
}

// ============================================================================
// Ord method tests (cmp, partial_cmp, max, min, clamp)
// ============================================================================

@test
func test_i32_cmp() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 5

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "5.cmp(10) should be Less")
    let ord2: Ordering = b.cmp(ref a)
    assert(ord2.is_greater(), "10.cmp(5) should be Greater")
    let ord3: Ordering = a.cmp(ref c)
    assert(ord3.is_equal(), "5.cmp(5) should be Equal")
    return 0
}

@test
func test_i32_partial_cmp() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: Maybe[Ordering] = a.partial_cmp(ref b)
    when result {
        Just(ord) => {
            when ord {
                Ordering::Less => { assert(true, "5.partial_cmp(10) is Just(Less)") },
                _ => { assert(false, "expected Less") }
            }
        },
        Nothing => {
            assert(false, "partial_cmp should return Just for integers")
        }
    }
    return 0
}

@test
func test_i32_ord_max() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: I32 = a.max(b)
    assert_eq(result, 10, "5.max(10) should be 10")

    let result2: I32 = b.max(a)
    assert_eq(result2, 10, "10.max(5) should be 10")
    return 0
}

@test
func test_i32_ord_min() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let result: I32 = a.min(b)
    assert_eq(result, 5, "5.min(10) should be 5")

    let result2: I32 = b.min(a)
    assert_eq(result2, 5, "10.min(5) should be 5")
    return 0
}

// Note: clamp method has a codegen bug (Self type not substituted) - skipping for now
// @test
// func test_i32_clamp() -> I32 {
//     let low: I32 = 0
//     let high: I32 = 10
//     let below: I32 = -5
//     assert_eq(below.clamp(low, high), 0, "(-5).clamp(0, 10) should be 0")
//     return 0
// }

// ============================================================================
// Ordering equality tests
// ============================================================================

@test
func test_ordering_eq() -> I32 {
    let less1: Ordering = Ordering::Less
    let less2: Ordering = Ordering::Less
    let equal1: Ordering = Ordering::Equal
    let greater1: Ordering = Ordering::Greater

    assert(less1.eq(ref less2), "Less == Less")
    assert(less1.eq(ref equal1) == false, "Less != Equal")
    assert(less1.eq(ref greater1) == false, "Less != Greater")
    assert(equal1.eq(ref equal1), "Equal == Equal")
    assert(greater1.eq(ref greater1), "Greater == Greater")
    return 0
}

// ============================================================================
// Different integer type tests (U32, I64, U64)
// ============================================================================

@test
func test_u32_cmp() -> I32 {
    let a: U32 = 5
    let b: U32 = 10

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "5u32.cmp(10) should be Less")
    let ord2: Ordering = b.cmp(ref a)
    assert(ord2.is_greater(), "10u32.cmp(5) should be Greater")
    assert(a < b, "5u32 < 10u32")
    assert(b > a, "10u32 > 5u32")
    return 0
}

@test
func test_i64_cmp() -> I32 {
    let a: I64 = -100
    let b: I64 = 100

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "(-100i64).cmp(100) should be Less")
    assert(a < b, "-100i64 < 100i64")
    assert(b >= a, "100i64 >= -100i64")
    return 0
}

@test
func test_u64_cmp() -> I32 {
    let a: U64 = 1000000
    let b: U64 = 2000000

    let ord1: Ordering = a.cmp(ref b)
    assert(ord1.is_less(), "1000000u64.cmp(2000000) should be Less")
    assert(a <= b, "1000000u64 <= 2000000u64")
    return 0
}

// ============================================================================
// Bool comparison tests (disabled - Bool.cmp method not emitted correctly)
// ============================================================================

// Note: Bool.cmp method has codegen issues - skipping for now
// @test
// func test_bool_cmp() -> I32 { ... }
// @test
// func test_bool_lt_gt() -> I32 { ... }

// ============================================================================
// Floating point partial comparison tests (disabled - codegen issues)
// ============================================================================

// Note: F64.partial_cmp method has codegen issues - skipping for now
// These can be re-enabled once behavior method codegen is fixed for primitive types

@test
func test_f64_operators() -> I32 {
    let a: F64 = 1.0
    let b: F64 = 2.0
    let c: F64 = 1.0

    // Test using operators directly (these work)
    assert(a < b, "1.0 < 2.0")
    assert(a <= b, "1.0 <= 2.0")
    assert(a <= c, "1.0 <= 1.0")
    assert(b > a, "2.0 > 1.0")
    assert(b >= a, "2.0 >= 1.0")
    assert(a >= c, "1.0 >= 1.0")
    return 0
}
