// Tests for DefaultHasher sequential writes and finish behavior
use test
use core::hash::DefaultHasher

@test
func test_hasher_multiple_writes() -> I32 {
    var h1: DefaultHasher = DefaultHasher::new()
    h1.write_u8(1 as U8)
    h1.write_u8(2 as U8)

    var h2: DefaultHasher = DefaultHasher::new()
    h2.write_u8(1 as U8)
    h2.write_u8(2 as U8)

    assert_eq(h1.finish(), h2.finish(), "same sequence should produce same hash")
    return 0
}

@test
func test_hasher_write_order_matters() -> I32 {
    var h1: DefaultHasher = DefaultHasher::new()
    h1.write_u8(1 as U8)
    h1.write_u8(2 as U8)

    var h2: DefaultHasher = DefaultHasher::new()
    h2.write_u8(2 as U8)
    h2.write_u8(1 as U8)

    assert(h1.finish() != h2.finish(), "write order should matter")
    return 0
}

@test
func test_hasher_finish_idempotent() -> I32 {
    var hasher: DefaultHasher = DefaultHasher::new()
    hasher.write_i32(42)
    let h1: I64 = hasher.finish()
    let h2: I64 = hasher.finish()
    assert_eq(h1, h2, "finish() should be idempotent without more writes")
    return 0
}

@test
func test_hasher_mixed_writes() -> I32 {
    var h1: DefaultHasher = DefaultHasher::new()
    h1.write_u8(10 as U8)
    h1.write_i32(200)
    h1.write_i64(3000)

    var h2: DefaultHasher = DefaultHasher::new()
    h2.write_u8(10 as U8)
    h2.write_i32(200)
    h2.write_i64(3000)

    assert_eq(h1.finish(), h2.finish(), "same mixed writes should produce same hash")
    return 0
}
