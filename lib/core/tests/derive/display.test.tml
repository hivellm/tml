// Tests for @derive(Display) macro
use test

// ============================================================================
// Simple Struct Tests
// ============================================================================

@derive(Display)
type DisplayPoint {
    x: I32,
    y: I32
}

@test
func test_display_point() -> I32 {
    let p: DisplayPoint = DisplayPoint { x: 10, y: 20 }
    let s: Str = p.to_string()
    // Display produces just the values: "10, 20"
    assert(s.contains("10"), "Should contain value 10")
    assert(s.contains("20"), "Should contain value 20")
    return 0
}

// ============================================================================
// Multiple Field Types
// ============================================================================

@derive(Display)
type DisplayPerson {
    age: I32,
    height: I64
}

@test
func test_display_person() -> I32 {
    let p: DisplayPerson = DisplayPerson { age: 25, height: 180 }
    let s: Str = p.to_string()
    assert(s.contains("25"), "Should contain age value")
    assert(s.contains("180"), "Should contain height value")
    return 0
}

// ============================================================================
// Simple Enum Tests
// ============================================================================

@derive(Display)
type DisplayStatus = Active | Inactive | Pending

@test
func test_display_enum_active() -> I32 {
    let s: DisplayStatus = DisplayStatus::Active
    let str: Str = s.to_string()
    assert(str.contains("Active"), "Should contain variant name Active")
    return 0
}

@test
func test_display_enum_inactive() -> I32 {
    let s: DisplayStatus = DisplayStatus::Inactive
    let str: Str = s.to_string()
    assert(str.contains("Inactive"), "Should contain variant name Inactive")
    return 0
}

@test
func test_display_enum_pending() -> I32 {
    let s: DisplayStatus = DisplayStatus::Pending
    let str: Str = s.to_string()
    assert(str.contains("Pending"), "Should contain variant name Pending")
    return 0
}
