// Tests for core::range - RangeInclusiveIterI64
use test
use core::range::RangeInclusiveIterI64

@test
func test_range_inclusive_basic() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: 1, end: 3, exhausted: false }
    let v0: Maybe[I64] = iter.next()
    assert_eq(v0.unwrap(), 1 as I64, "first should be 1")
    let v1: Maybe[I64] = iter.next()
    assert_eq(v1.unwrap(), 2 as I64, "second should be 2")
    let v2: Maybe[I64] = iter.next()
    assert_eq(v2.unwrap(), 3 as I64, "third should be 3 (inclusive)")
    let v3: Maybe[I64] = iter.next()
    assert(v3.is_nothing(), "fourth should be Nothing")
    return 0
}

@test
func test_range_inclusive_single() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: 5, end: 5, exhausted: false }
    let v: Maybe[I64] = iter.next()
    assert(v.is_just(), "single element inclusive range should yield one value")
    assert_eq(v.unwrap(), 5 as I64, "value should be 5")
    let v2: Maybe[I64] = iter.next()
    assert(v2.is_nothing(), "should be exhausted after single element")
    return 0
}

@test
func test_range_inclusive_empty() -> I32 {
    // start > end produces no elements
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: 10, end: 5, exhausted: false }
    let v: Maybe[I64] = iter.next()
    assert(v.is_nothing(), "reversed inclusive range should be empty")
    return 0
}
