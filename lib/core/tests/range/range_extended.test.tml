// Extended tests for core::range iterators
use test::{assert, assert_eq}
use core::range::RangeIterI64
use core::range::RangeInclusiveIterI64

@test
func test_range_iter_sum() -> I32 {
    var iter: RangeIterI64 = RangeIterI64 { current: 1, end: 11 }
    var sum: I64 = 0 as I64
    var done: Bool = false
    loop (not done) {
        let v: Maybe[I64] = iter.next()
        if v.is_nothing() {
            done = true
        } else {
            sum = sum + v.unwrap()
        }
    }
    assert_eq(sum, 55 as I64, "sum of 1..11 = 55")
    return 0
}

@test
func test_range_inclusive_iter_sum() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: 1, end: 10, exhausted: false }
    var sum: I64 = 0 as I64
    var done: Bool = false
    loop (not done) {
        let v: Maybe[I64] = iter.next()
        if v.is_nothing() {
            done = true
        } else {
            sum = sum + v.unwrap()
        }
    }
    assert_eq(sum, 55 as I64, "sum of 1..=10 = 55")
    return 0
}

@test
func test_range_iter_negative_range() -> I32 {
    var iter: RangeIterI64 = RangeIterI64 { current: -5, end: 0 }
    var count: I64 = 0 as I64
    var first: I64 = 0 as I64
    var last_val: I64 = 0 as I64
    var done: Bool = false
    loop (not done) {
        let v: Maybe[I64] = iter.next()
        if v.is_nothing() {
            done = true
        } else {
            if count == 0 as I64 {
                first = v.unwrap()
            }
            last_val = v.unwrap()
            count = count + 1 as I64
        }
    }
    assert_eq(count, 5 as I64, "range -5..0 has 5 elements")
    assert_eq(first, -5 as I64, "first element is -5")
    assert_eq(last_val, -1 as I64, "last element is -1")
    return 0
}

@test
func test_range_inclusive_already_exhausted() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: 1, end: 1, exhausted: true }
    let v: Maybe[I64] = iter.next()
    assert(v.is_nothing(), "exhausted iter should return Nothing")
    return 0
}

@test
func test_range_inclusive_negative() -> I32 {
    var iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 { current: -2, end: 2, exhausted: false }
    var count: I64 = 0 as I64
    var done: Bool = false
    loop (not done) {
        let v: Maybe[I64] = iter.next()
        if v.is_nothing() {
            done = true
        } else {
            count = count + 1 as I64
        }
    }
    assert_eq(count, 5 as I64, "range -2..=2 has 5 elements")
    return 0
}
