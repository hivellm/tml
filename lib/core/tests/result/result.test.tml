// Tests for core::result (Outcome[T, E])
use test

// ============================================================================
// Basic Outcome creation and querying
// ============================================================================

@test
func test_outcome_is_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert(ok.is_ok(), "Ok should be ok")
    assert(not err.is_ok(), "Err should not be ok")

    return 0
}

@test
func test_outcome_is_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert(not ok.is_err(), "Ok should not be err")
    assert(err.is_err(), "Err should be err")

    return 0
}

// ============================================================================
// Extracting values
// ============================================================================

@test
func test_outcome_unwrap() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let val: I32 = ok.unwrap()

    assert_eq(val, 42, "unwrap should return value")

    return 0
}

@test
func test_outcome_unwrap_or() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert_eq(ok.unwrap_or(0), 42, "Ok unwrap_or returns value")
    assert_eq(err.unwrap_or(0), 0, "Err unwrap_or returns default")

    return 0
}

@test
func test_outcome_unwrap_err() -> I32 {
    let err: Outcome[I32, Str] = Err("my error")
    let e: Str = err.unwrap_err()

    assert_eq(e, "my error", "unwrap_err should return error")

    return 0
}

@test
func test_outcome_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    let ok_maybe: Maybe[I32] = ok.ok()
    let err_maybe: Maybe[I32] = err.ok()

    when ok_maybe {
        Just(v) => assert_eq(v, 42, "Ok.ok() should be Just"),
        Nothing => assert(false, "Ok.ok() should not be Nothing")
    }

    when err_maybe {
        Just(v) => assert(false, "Err.ok() should not be Just"),
        Nothing => {}
    }

    return 0
}

@test
func test_outcome_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    let ok_maybe: Maybe[Str] = ok.err()
    let err_maybe: Maybe[Str] = err.err()

    when ok_maybe {
        Just(v) => assert(false, "Ok.err() should not be Just"),
        Nothing => {}
    }

    when err_maybe {
        Just(v) => assert_eq(v, "error", "Err.err() should be Just"),
        Nothing => assert(false, "Err.err() should not be Nothing")
    }

    return 0
}

// ============================================================================
// Pattern matching
// ============================================================================

@test
func test_outcome_when_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    var val: I32 = 0

    when result {
        Ok(v) => { val = v },
        Err(e) => { val = -1 }
    }

    assert_eq(val, 42, "when should extract Ok value")

    return 0
}

@test
func test_outcome_when_err() -> I32 {
    let result: Outcome[I32, Str] = Err("error")
    var val: I32 = 0

    when result {
        Ok(v) => { val = v },
        Err(e) => { val = -1 }
    }

    assert_eq(val, -1, "when should match Err")

    return 0
}

// ============================================================================
// Type with different error types
// ============================================================================

@test
func test_outcome_different_types() -> I32 {
    let str_result: Outcome[Str, I32] = Ok("hello")
    let bool_result: Outcome[Bool, Str] = Err("not found")

    assert(str_result.is_ok(), "Str result should be ok")
    assert(bool_result.is_err(), "Bool result should be err")

    assert_eq(str_result.unwrap(), "hello", "should unwrap string")
    assert_eq(bool_result.unwrap_err(), "not found", "should unwrap error")

    return 0
}

// Note: nested Outcome tests have drop function generation issues
