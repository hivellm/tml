// Consolidated tests for core::result (73 tests)
use test
use core::result::OutcomeIter

// ############################################################################
// From: result.test.tml
// ############################################################################

// ============================================================================
// Basic Outcome creation and querying
// ============================================================================

@test
func test_outcome_is_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert(ok.is_ok(), "Ok should be ok")
    assert(not err.is_ok(), "Err should not be ok")

    return 0
}

@test
func test_outcome_is_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert(not ok.is_err(), "Ok should not be err")
    assert(err.is_err(), "Err should be err")

    return 0
}

// ============================================================================
// Extracting values
// ============================================================================

@test
func test_outcome_unwrap() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let val: I32 = ok.unwrap()

    assert_eq(val, 42, "unwrap should return value")

    return 0
}

@test
func test_outcome_unwrap_or() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    assert_eq(ok.unwrap_or(0), 42, "Ok unwrap_or returns value")
    assert_eq(err.unwrap_or(0), 0, "Err unwrap_or returns default")

    return 0
}

@test
func test_outcome_unwrap_err() -> I32 {
    let err: Outcome[I32, Str] = Err("my error")
    let e: Str = err.unwrap_err()

    assert_eq(e, "my error", "unwrap_err should return error")

    return 0
}

@test
func test_outcome_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    let ok_maybe: Maybe[I32] = ok.ok()
    let err_maybe: Maybe[I32] = err.ok()

    when ok_maybe {
        Just(v) => assert_eq(v, 42, "Ok.ok() should be Just"),
        Nothing => assert(false, "Ok.ok() should not be Nothing")
    }

    when err_maybe {
        Just(v) => assert(false, "Err.ok() should not be Just"),
        Nothing => {}
    }

    return 0
}

@test
func test_outcome_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error")

    let ok_maybe: Maybe[Str] = ok.err()
    let err_maybe: Maybe[Str] = err.err()

    when ok_maybe {
        Just(v) => assert(false, "Ok.err() should not be Just"),
        Nothing => {}
    }

    when err_maybe {
        Just(v) => assert_eq(v, "error", "Err.err() should be Just"),
        Nothing => assert(false, "Err.err() should not be Nothing")
    }

    return 0
}

// ============================================================================
// Pattern matching
// ============================================================================

@test
func test_outcome_when_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    var val: I32 = 0

    when result {
        Ok(v) => { val = v },
        Err(e) => { val = -1 }
    }

    assert_eq(val, 42, "when should extract Ok value")

    return 0
}

@test
func test_outcome_when_err() -> I32 {
    let result: Outcome[I32, Str] = Err("error")
    var val: I32 = 0

    when result {
        Ok(v) => { val = v },
        Err(e) => { val = -1 }
    }

    assert_eq(val, -1, "when should match Err")

    return 0
}

// ============================================================================
// Type with different error types
// ============================================================================

@test
func test_outcome_different_types() -> I32 {
    let str_result: Outcome[Str, I32] = Ok("hello")
    let bool_result: Outcome[Bool, Str] = Err("not found")

    assert(str_result.is_ok(), "Str result should be ok")
    assert(bool_result.is_err(), "Bool result should be err")

    assert_eq(str_result.unwrap(), "hello", "should unwrap string")
    assert_eq(bool_result.unwrap_err(), "not found", "should unwrap error")

    return 0
}

// Note: nested Outcome tests have drop function generation issues

// ############################################################################
// From: result_methods.test.tml
// ############################################################################

// ============================================================================
// Predicate methods: is_ok_and, is_err_and
// ============================================================================

func is_positive(n: I32) -> Bool {
    return n > 0
}

func is_negative(n: I32) -> Bool {
    return n < 0
}

@test
func test_is_ok_and_true() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    assert(ok.is_ok_and(is_positive), "42 is positive")
    return 0
}

@test
func test_is_ok_and_false_value() -> I32 {
    let ok: Outcome[I32, Str] = Ok(-5)
    assert(not ok.is_ok_and(is_positive), "-5 is not positive")
    return 0
}

@test
func test_is_ok_and_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    assert(not err.is_ok_and(is_positive), "Err is_ok_and should be false")
    return 0
}

func is_not_found(s: Str) -> Bool {
    return s == "not found"
}

@test
func test_is_err_and_true() -> I32 {
    let err: Outcome[I32, Str] = Err("not found")
    assert(err.is_err_and(is_not_found), "error matches predicate")
    return 0
}

@test
func test_is_err_and_false_value() -> I32 {
    let err: Outcome[I32, Str] = Err("other error")
    assert(not err.is_err_and(is_not_found), "error doesn't match")
    return 0
}

@test
func test_is_err_and_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    assert(not ok.is_err_and(is_not_found), "Ok is_err_and should be false")
    return 0
}

// ============================================================================
// Extracting: expect, expect_err
// ============================================================================

@test
func test_expect_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(100)
    let val: I32 = ok.expect("should have value")
    assert_eq(val, 100, "expect returns value")
    return 0
}

@test
func test_expect_err_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("my error")
    let e: Str = err.expect_err("should have error")
    assert_eq(e, "my error", "expect_err returns error")
    return 0
}

// ============================================================================
// unwrap_or_else
// ============================================================================

func error_len(s: Str) -> I32 {
    return s.len() as I32
}

@test
func test_unwrap_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let val: I32 = ok.unwrap_or_else(error_len)
    assert_eq(val, 42, "unwrap_or_else returns Ok value")
    return 0
}

@test
func test_unwrap_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("hello")
    let val: I32 = err.unwrap_or_else(error_len)
    assert_eq(val, 5, "unwrap_or_else computes from error")
    return 0
}

// ============================================================================
// map, map_err
// ============================================================================

func double(n: I32) -> I32 {
    return n * 2
}

func to_upper_err(s: Str) -> Str {
    return "ERROR: " + s
}

@test
func test_map_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let mapped: Outcome[I32, Str] = ok.map(double)
    assert(mapped.is_ok(), "map preserves Ok")
    assert_eq(mapped.unwrap(), 42, "map applies function")
    return 0
}

@test
func test_map_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let mapped: Outcome[I32, Str] = err.map(double)
    assert(mapped.is_err(), "map preserves Err")
    assert_eq(mapped.unwrap_err(), "error", "map doesn't touch error")
    return 0
}

@test
func test_map_err_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("oops")
    let mapped: Outcome[I32, Str] = err.map_err(to_upper_err)
    assert(mapped.is_err(), "map_err preserves Err")
    assert_eq(mapped.unwrap_err(), "ERROR: oops", "map_err transforms error")
    return 0
}

@test
func test_map_err_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let mapped: Outcome[I32, Str] = ok.map_err(to_upper_err)
    assert(mapped.is_ok(), "map_err preserves Ok")
    assert_eq(mapped.unwrap(), 42, "map_err doesn't touch value")
    return 0
}

// ============================================================================
// map_or, map_or_else
// ============================================================================

@test
func test_map_or_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let val: I32 = ok.map_or(0, double)
    assert_eq(val, 42, "map_or applies function on Ok")
    return 0
}

@test
func test_map_or_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let val: I32 = err.map_or(100, double)
    assert_eq(val, 100, "map_or returns default on Err")
    return 0
}

func default_from_error(s: Str) -> I32 {
    return -1
}

@test
func test_map_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let val: I32 = ok.map_or_else(default_from_error, double)
    assert_eq(val, 42, "map_or_else applies f on Ok")
    return 0
}

@test
func test_map_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let val: I32 = err.map_or_else(default_from_error, double)
    assert_eq(val, -1, "map_or_else applies default_fn on Err")
    return 0
}

// ============================================================================
// and_then, or_else
// ============================================================================

func validate_positive(n: I32) -> Outcome[I32, Str] {
    if n > 0 {
        return Ok(n * 2)
    }
    return Err("not positive")
}

@test
func test_and_then_ok_to_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(5)
    let result: Outcome[I32, Str] = ok.and_then(validate_positive)
    assert(result.is_ok(), "and_then chains Ok")
    assert_eq(result.unwrap(), 10, "and_then applies function")
    return 0
}

@test
func test_and_then_ok_to_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(-5)
    let result: Outcome[I32, Str] = ok.and_then(validate_positive)
    assert(result.is_err(), "and_then can return Err")
    assert_eq(result.unwrap_err(), "not positive", "and_then error value")
    return 0
}

@test
func test_and_then_err() -> I32 {
    let err: Outcome[I32, Str] = Err("original error")
    let result: Outcome[I32, Str] = err.and_then(validate_positive)
    assert(result.is_err(), "and_then preserves Err")
    assert_eq(result.unwrap_err(), "original error", "and_then keeps original error")
    return 0
}

func recover_error(s: Str) -> Outcome[I32, Str] {
    return Ok(0)
}

@test
func test_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = err.or_else(recover_error)
    assert(result.is_ok(), "or_else recovers from Err")
    assert_eq(result.unwrap(), 0, "or_else recovery value")
    return 0
}

@test
func test_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let result: Outcome[I32, Str] = ok.or_else(recover_error)
    assert(result.is_ok(), "or_else preserves Ok")
    assert_eq(result.unwrap(), 42, "or_else keeps Ok value")
    return 0
}

// ============================================================================
// alt, also
// ============================================================================

@test
func test_alt_ok_alt_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.alt(y)
    assert_eq(result.unwrap(), 1, "alt returns first Ok")
    return 0
}

@test
func test_alt_err_alt_ok() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.alt(y)
    assert_eq(result.unwrap(), 2, "alt returns alternative when first is Err")
    return 0
}

@test
func test_alt_err_alt_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error1")
    let y: Outcome[I32, Str] = Err("error2")
    let result: Outcome[I32, Str] = x.alt(y)
    assert(result.is_err(), "alt returns Err when both are Err")
    return 0
}

@test
func test_also_ok_also_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.also(y)
    assert_eq(result.unwrap(), 2, "also returns second when first is Ok")
    return 0
}

@test
func test_also_ok_also_err() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = x.also(y)
    assert(result.is_err(), "also returns second Err")
    return 0
}

@test
func test_also_err_also_ok() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.also(y)
    assert(result.is_err(), "also returns first Err")
    assert_eq(result.unwrap_err(), "error", "also keeps first error")
    return 0
}

// ============================================================================
// contains, contains_err
// ============================================================================

@test
func test_contains_true() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(x.contains(ref 42), "contains finds value")
    return 0
}

@test
func test_contains_false_different_value() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(not x.contains(ref 0), "contains doesn't match different value")
    return 0
}

@test
func test_contains_on_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    assert(not x.contains(ref 42), "contains is false on Err")
    return 0
}

@test
func test_contains_err_true() -> I32 {
    let x: Outcome[I32, Str] = Err("not found")
    assert(x.contains_err(ref "not found"), "contains_err finds error")
    return 0
}

@test
func test_contains_err_false() -> I32 {
    let x: Outcome[I32, Str] = Err("not found")
    assert(not x.contains_err(ref "other"), "contains_err doesn't match different error")
    return 0
}

@test
func test_contains_err_on_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(not x.contains_err(ref "error"), "contains_err is false on Ok")
    return 0
}

// ============================================================================
// iter
// ============================================================================

@test
func test_iter_on_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    var iter: OutcomeIter[I32] = x.iter()
    let first: Maybe[I32] = iter.next()
    when first {
        Just(v) => assert_eq(v, 42, "iter yields Ok value"),
        Nothing => assert(false, "iter should yield value")
    }
    let second: Maybe[I32] = iter.next()
    when second {
        Just(_) => assert(false, "iter should be exhausted"),
        Nothing => {}
    }
    return 0
}

@test
func test_iter_on_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    var iter: OutcomeIter[I32] = x.iter()
    let first: Maybe[I32] = iter.next()
    when first {
        Just(_) => assert(false, "iter on Err should yield Nothing"),
        Nothing => {}
    }
    return 0
}

// ############################################################################
// From: result_basics.test.tml
// ############################################################################

// ============================================================================
// Outcome::is_ok and is_err Tests
// ============================================================================

@test
func test_outcome_is_ok_true() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    assert(result.is_ok(), "Ok should be is_ok")
    return 0
}

@test
func test_outcome_is_ok_false() -> I32 {
    let result: Outcome[I32, Str] = Err("error")
    assert(not result.is_ok(), "Err should not be is_ok")
    return 0
}

@test
func test_outcome_is_err_true() -> I32 {
    let result: Outcome[I32, Str] = Err("error")
    assert(result.is_err(), "Err should be is_err")
    return 0
}

@test
func test_outcome_is_err_false() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    assert(not result.is_err(), "Ok should not be is_err")
    return 0
}

// ============================================================================
// Outcome::unwrap Tests
// ============================================================================

@test
func test_outcome_unwrap_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(123)
    let value: I32 = result.unwrap()
    assert(value == 123, "unwrap should return value")
    return 0
}

@test
func test_outcome_unwrap_or_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    let value: I32 = result.unwrap_or(0)
    assert(value == 42, "unwrap_or on Ok should return inner value")
    return 0
}

@test
func test_outcome_unwrap_or_err() -> I32 {
    let result: Outcome[I32, Str] = Err("failed")
    let value: I32 = result.unwrap_or(99)
    assert(value == 99, "unwrap_or on Err should return default")
    return 0
}

// ============================================================================
// Outcome::expect Tests
// ============================================================================

@test
func test_outcome_expect_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(777)
    let value: I32 = result.expect("should not fail")
    assert(value == 777, "expect on Ok should return value")
    return 0
}

// ============================================================================
// Outcome::unwrap_err Tests
// ============================================================================

@test
func test_outcome_unwrap_err_v2() -> I32 {
    let result: Outcome[I32, Str] = Err("my error")
    let err: Str = result.unwrap_err()
    assert(err == "my error", "unwrap_err should return error")
    return 0
}

// ============================================================================
// Outcome::expect_err Tests
// ============================================================================

@test
func test_outcome_expect_err() -> I32 {
    let result: Outcome[I32, Str] = Err("expected error")
    let err: Str = result.expect_err("should be error")
    assert(err == "expected error", "expect_err should return error")
    return 0
}

// ============================================================================
// Outcome::is_ok_and / is_err_and Tests
// ============================================================================

@test
func test_outcome_is_ok_and_true() -> I32 {
    let result: Outcome[I32, Str] = Ok(10)
    let check: Bool = result.is_ok_and(do(x) x > 5)
    assert(check, "is_ok_and should return true when predicate matches")
    return 0
}

@test
func test_outcome_is_ok_and_false_predicate() -> I32 {
    let result: Outcome[I32, Str] = Ok(3)
    let check: Bool = result.is_ok_and(do(x) x > 5)
    assert(not check, "is_ok_and should return false when predicate fails")
    return 0
}

@test
func test_outcome_is_ok_and_on_err() -> I32 {
    let result: Outcome[I32, Str] = Err("nope")
    let check: Bool = result.is_ok_and(do(x) x > 0)
    assert(not check, "is_ok_and on Err should return false")
    return 0
}

@test
func test_outcome_is_err_and_true() -> I32 {
    let result: Outcome[I32, Str] = Err("error 404")
    let check: Bool = result.is_err_and(do(e) e == "error 404")
    assert(check, "is_err_and should return true when predicate matches")
    return 0
}

@test
func test_outcome_is_err_and_on_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(42)
    let check: Bool = result.is_err_and(do(e) e == "anything")
    assert(not check, "is_err_and on Ok should return false")
    return 0
}

// ============================================================================
// Outcome::unwrap_or_else Tests
// ============================================================================

@test
func test_outcome_unwrap_or_else_ok() -> I32 {
    let result: Outcome[I32, Str] = Ok(50)
    let value: I32 = result.unwrap_or_else(do(e) 0)
    assert(value == 50, "unwrap_or_else on Ok should return inner value")
    return 0
}

@test
func test_outcome_unwrap_or_else_err() -> I32 {
    let result: Outcome[I32, Str] = Err("fail")
    let value: I32 = result.unwrap_or_else(do(e) -1)
    assert(value == -1, "unwrap_or_else on Err should call closure")
    return 0
}

// ############################################################################
// From: result_value_assertions.test.tml
// ############################################################################

// =============================================================================
// Basic Ok/Err creation and unwrap
// =============================================================================

@test
func test_ok_unwrap() -> I32 {
    let r: Outcome[I32, Str] = Ok(42)
    assert_eq(r.unwrap(), 42, "Ok(42).unwrap() should be 42")
    return 0
}

@test
func test_ok_is_ok() -> I32 {
    let r: Outcome[I32, Str] = Ok(100)
    assert(r.is_ok(), "Ok should be ok")
    assert(not r.is_err(), "Ok should not be err")
    return 0
}

@test
func test_err_is_err() -> I32 {
    let r: Outcome[I32, Str] = Err("failed")
    assert(r.is_err(), "Err should be err")
    assert(not r.is_ok(), "Err should not be ok")
    return 0
}

// =============================================================================
// unwrap_or
// =============================================================================

@test
func test_ok_unwrap_or() -> I32 {
    let r: Outcome[I32, Str] = Ok(42)
    assert_eq(r.unwrap_or(0), 42, "Ok(42).unwrap_or(0) should be 42")
    return 0
}

@test
func test_err_unwrap_or() -> I32 {
    let r: Outcome[I32, Str] = Err("oops")
    assert_eq(r.unwrap_or(99), 99, "Err.unwrap_or(99) should be 99")
    return 0
}

// =============================================================================
// Outcome from functions
// =============================================================================

func divide(a: I32, b: I32) -> Outcome[I32, Str] {
    if b == 0 {
        return Err("division by zero")
    }
    return Ok(a / b)
}

func safe_parse(s: Str) -> Outcome[I32, Str] {
    if s == "42" {
        return Ok(42)
    }
    if s == "0" {
        return Ok(0)
    }
    if s == "-1" {
        return Ok(-1)
    }
    return Err("parse error")
}

@test
func test_divide_ok() -> I32 {
    let r: Outcome[I32, Str] = divide(10, 2)
    assert(r.is_ok(), "10/2 should be Ok")
    assert_eq(r.unwrap(), 5, "10/2 should be 5")
    return 0
}

@test
func test_divide_by_zero() -> I32 {
    let r: Outcome[I32, Str] = divide(10, 0)
    assert(r.is_err(), "10/0 should be Err")
    return 0
}

@test
func test_safe_parse_valid() -> I32 {
    let r: Outcome[I32, Str] = safe_parse("42")
    assert_eq(r.unwrap(), 42, "parsing 42 should work")
    return 0
}

@test
func test_safe_parse_invalid() -> I32 {
    let r: Outcome[I32, Str] = safe_parse("abc")
    assert(r.is_err(), "parsing abc should fail")
    assert_eq(r.unwrap_or(-999), -999, "invalid parse should use default")
    return 0
}
