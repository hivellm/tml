// Tests for Outcome[T, E] methods - comprehensive coverage
use test
use core::result::OutcomeIter

// ============================================================================
// Predicate methods: is_ok_and, is_err_and
// ============================================================================

func is_positive(n: I32) -> Bool {
    return n > 0
}

func is_negative(n: I32) -> Bool {
    return n < 0
}

@test
func test_is_ok_and_true() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    assert(ok.is_ok_and(is_positive), "42 is positive")
    return 0
}

@test
func test_is_ok_and_false_value() -> I32 {
    let ok: Outcome[I32, Str] = Ok(-5)
    assert(not ok.is_ok_and(is_positive), "-5 is not positive")
    return 0
}

@test
func test_is_ok_and_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    assert(not err.is_ok_and(is_positive), "Err is_ok_and should be false")
    return 0
}

func is_not_found(s: Str) -> Bool {
    return s == "not found"
}

@test
func test_is_err_and_true() -> I32 {
    let err: Outcome[I32, Str] = Err("not found")
    assert(err.is_err_and(is_not_found), "error matches predicate")
    return 0
}

@test
func test_is_err_and_false_value() -> I32 {
    let err: Outcome[I32, Str] = Err("other error")
    assert(not err.is_err_and(is_not_found), "error doesn't match")
    return 0
}

@test
func test_is_err_and_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    assert(not ok.is_err_and(is_not_found), "Ok is_err_and should be false")
    return 0
}

// ============================================================================
// Extracting: expect, expect_err
// ============================================================================

@test
func test_expect_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(100)
    let val: I32 = ok.expect("should have value")
    assert_eq(val, 100, "expect returns value")
    return 0
}

@test
func test_expect_err_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("my error")
    let e: Str = err.expect_err("should have error")
    assert_eq(e, "my error", "expect_err returns error")
    return 0
}

// ============================================================================
// unwrap_or_else
// ============================================================================

func error_len(s: Str) -> I32 {
    return s.len() as I32
}

@test
func test_unwrap_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let val: I32 = ok.unwrap_or_else(error_len)
    assert_eq(val, 42, "unwrap_or_else returns Ok value")
    return 0
}

@test
func test_unwrap_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("hello")
    let val: I32 = err.unwrap_or_else(error_len)
    assert_eq(val, 5, "unwrap_or_else computes from error")
    return 0
}

// ============================================================================
// map, map_err
// ============================================================================

func double(n: I32) -> I32 {
    return n * 2
}

func to_upper_err(s: Str) -> Str {
    return "ERROR: " + s
}

@test
func test_map_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let mapped: Outcome[I32, Str] = ok.map(double)
    assert(mapped.is_ok(), "map preserves Ok")
    assert_eq(mapped.unwrap(), 42, "map applies function")
    return 0
}

@test
func test_map_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let mapped: Outcome[I32, Str] = err.map(double)
    assert(mapped.is_err(), "map preserves Err")
    assert_eq(mapped.unwrap_err(), "error", "map doesn't touch error")
    return 0
}

@test
func test_map_err_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("oops")
    let mapped: Outcome[I32, Str] = err.map_err(to_upper_err)
    assert(mapped.is_err(), "map_err preserves Err")
    assert_eq(mapped.unwrap_err(), "ERROR: oops", "map_err transforms error")
    return 0
}

@test
func test_map_err_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let mapped: Outcome[I32, Str] = ok.map_err(to_upper_err)
    assert(mapped.is_ok(), "map_err preserves Ok")
    assert_eq(mapped.unwrap(), 42, "map_err doesn't touch value")
    return 0
}

// ============================================================================
// map_or, map_or_else
// ============================================================================

@test
func test_map_or_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let val: I32 = ok.map_or(0, double)
    assert_eq(val, 42, "map_or applies function on Ok")
    return 0
}

@test
func test_map_or_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let val: I32 = err.map_or(100, double)
    assert_eq(val, 100, "map_or returns default on Err")
    return 0
}

func default_from_error(s: Str) -> I32 {
    return -1
}

@test
func test_map_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(21)
    let val: I32 = ok.map_or_else(default_from_error, double)
    assert_eq(val, 42, "map_or_else applies f on Ok")
    return 0
}

@test
func test_map_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let val: I32 = err.map_or_else(default_from_error, double)
    assert_eq(val, -1, "map_or_else applies default_fn on Err")
    return 0
}

// ============================================================================
// and_then, or_else
// ============================================================================

func validate_positive(n: I32) -> Outcome[I32, Str] {
    if n > 0 {
        return Ok(n * 2)
    }
    return Err("not positive")
}

@test
func test_and_then_ok_to_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(5)
    let result: Outcome[I32, Str] = ok.and_then(validate_positive)
    assert(result.is_ok(), "and_then chains Ok")
    assert_eq(result.unwrap(), 10, "and_then applies function")
    return 0
}

@test
func test_and_then_ok_to_err() -> I32 {
    let ok: Outcome[I32, Str] = Ok(-5)
    let result: Outcome[I32, Str] = ok.and_then(validate_positive)
    assert(result.is_err(), "and_then can return Err")
    assert_eq(result.unwrap_err(), "not positive", "and_then error value")
    return 0
}

@test
func test_and_then_err() -> I32 {
    let err: Outcome[I32, Str] = Err("original error")
    let result: Outcome[I32, Str] = err.and_then(validate_positive)
    assert(result.is_err(), "and_then preserves Err")
    assert_eq(result.unwrap_err(), "original error", "and_then keeps original error")
    return 0
}

func recover_error(s: Str) -> Outcome[I32, Str] {
    return Ok(0)
}

@test
func test_or_else_on_err() -> I32 {
    let err: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = err.or_else(recover_error)
    assert(result.is_ok(), "or_else recovers from Err")
    assert_eq(result.unwrap(), 0, "or_else recovery value")
    return 0
}

@test
func test_or_else_on_ok() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let result: Outcome[I32, Str] = ok.or_else(recover_error)
    assert(result.is_ok(), "or_else preserves Ok")
    assert_eq(result.unwrap(), 42, "or_else keeps Ok value")
    return 0
}

// ============================================================================
// alt, also
// ============================================================================

@test
func test_alt_ok_alt_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.alt(y)
    assert_eq(result.unwrap(), 1, "alt returns first Ok")
    return 0
}

@test
func test_alt_err_alt_ok() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.alt(y)
    assert_eq(result.unwrap(), 2, "alt returns alternative when first is Err")
    return 0
}

@test
func test_alt_err_alt_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error1")
    let y: Outcome[I32, Str] = Err("error2")
    let result: Outcome[I32, Str] = x.alt(y)
    assert(result.is_err(), "alt returns Err when both are Err")
    return 0
}

@test
func test_also_ok_also_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.also(y)
    assert_eq(result.unwrap(), 2, "also returns second when first is Ok")
    return 0
}

@test
func test_also_ok_also_err() -> I32 {
    let x: Outcome[I32, Str] = Ok(1)
    let y: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = x.also(y)
    assert(result.is_err(), "also returns second Err")
    return 0
}

@test
func test_also_err_also_ok() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    let y: Outcome[I32, Str] = Ok(2)
    let result: Outcome[I32, Str] = x.also(y)
    assert(result.is_err(), "also returns first Err")
    assert_eq(result.unwrap_err(), "error", "also keeps first error")
    return 0
}

// ============================================================================
// contains, contains_err
// ============================================================================

@test
func test_contains_true() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(x.contains(ref 42), "contains finds value")
    return 0
}

@test
func test_contains_false_different_value() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(not x.contains(ref 0), "contains doesn't match different value")
    return 0
}

@test
func test_contains_on_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    assert(not x.contains(ref 42), "contains is false on Err")
    return 0
}

@test
func test_contains_err_true() -> I32 {
    let x: Outcome[I32, Str] = Err("not found")
    assert(x.contains_err(ref "not found"), "contains_err finds error")
    return 0
}

@test
func test_contains_err_false() -> I32 {
    let x: Outcome[I32, Str] = Err("not found")
    assert(not x.contains_err(ref "other"), "contains_err doesn't match different error")
    return 0
}

@test
func test_contains_err_on_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    assert(not x.contains_err(ref "error"), "contains_err is false on Ok")
    return 0
}

// ============================================================================
// iter
// ============================================================================

@test
func test_iter_on_ok() -> I32 {
    let x: Outcome[I32, Str] = Ok(42)
    var iter: OutcomeIter[I32] = x.iter()
    let first: Maybe[I32] = iter.next()
    when first {
        Just(v) => assert_eq(v, 42, "iter yields Ok value"),
        Nothing => assert(false, "iter should yield value")
    }
    let second: Maybe[I32] = iter.next()
    when second {
        Just(_) => assert(false, "iter should be exhausted"),
        Nothing => {}
    }
    return 0
}

@test
func test_iter_on_err() -> I32 {
    let x: Outcome[I32, Str] = Err("error")
    var iter: OutcomeIter[I32] = x.iter()
    let first: Maybe[I32] = iter.next()
    when first {
        Just(_) => assert(false, "iter on Err should yield Nothing"),
        Nothing => {}
    }
    return 0
}
