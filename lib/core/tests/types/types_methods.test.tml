// Consolidated tuple and marker type tests
// Source files: tuple.test.tml, marker.test.tml
// Total @test count: 43

use test

use core::marker::PhantomPinned
use core::marker::PhantomData

// ============================================================================
// Pair (A, B) Tests - Basic Operations (from tuple.test.tml)
// ============================================================================

@test
func test_pair_creation_and_access() -> I32 {
    let pair: (I32, I32) = (10, 20)
    assert(pair.0 == 10, "first element should be 10")
    assert(pair.1 == 20, "second element should be 20")
    return 0
}

@test
func test_pair_mixed_types() -> I32 {
    let pair: (I32, Bool) = (42, true)
    assert(pair.0 == 42, "first element should be 42")
    assert(pair.1, "second element should be true")
    return 0
}

@test
func test_pair_element_access() -> I32 {
    let pair: (I32, I32) = (5, 15)
    let a: I32 = pair.0
    let b: I32 = pair.1
    assert(a == 5, "a should be 5")
    assert(b == 15, "b should be 15")
    return 0
}

// ============================================================================
// Triple (A, B, C) Tests
// ============================================================================

@test
func test_triple_creation_and_access() -> I32 {
    let triple: (I32, I32, I32) = (1, 2, 3)
    assert(triple.0 == 1, "first element should be 1")
    assert(triple.1 == 2, "second element should be 2")
    assert(triple.2 == 3, "third element should be 3")
    return 0
}

@test
func test_triple_element_access() -> I32 {
    let triple: (I32, I32, I32) = (10, 20, 30)
    let x: I32 = triple.0
    let y: I32 = triple.1
    let z: I32 = triple.2
    assert(x == 10, "x should be 10")
    assert(y == 20, "y should be 20")
    assert(z == 30, "z should be 30")
    return 0
}

// ============================================================================
// Quad (A, B, C, D) Tests
// ============================================================================

@test
func test_quad_creation_and_access() -> I32 {
    let quad: (I32, I32, I32, I32) = (1, 2, 3, 4)
    assert(quad.0 == 1, "first element should be 1")
    assert(quad.1 == 2, "second element should be 2")
    assert(quad.2 == 3, "third element should be 3")
    assert(quad.3 == 4, "fourth element should be 4")
    return 0
}

// ============================================================================
// PartialEq Tests for Pairs
// ============================================================================

@test
func test_pair_eq_equal() -> I32 {
    let a: (I32, I32) = (1, 2)
    let b: (I32, I32) = (1, 2)
    assert(a == b, "equal pairs should be equal")
    return 0
}

@test
func test_pair_eq_not_equal_first() -> I32 {
    let a: (I32, I32) = (1, 2)
    let b: (I32, I32) = (3, 2)
    assert(a != b, "pairs with different first element should not be equal")
    return 0
}

@test
func test_pair_eq_not_equal_second() -> I32 {
    let a: (I32, I32) = (1, 2)
    let b: (I32, I32) = (1, 3)
    assert(a != b, "pairs with different second element should not be equal")
    return 0
}

// ============================================================================
// PartialEq Tests for Triples
// ============================================================================

@test
func test_triple_eq_equal() -> I32 {
    let a: (I32, I32, I32) = (1, 2, 3)
    let b: (I32, I32, I32) = (1, 2, 3)
    assert(a == b, "equal triples should be equal")
    return 0
}

@test
func test_triple_eq_not_equal() -> I32 {
    let a: (I32, I32, I32) = (1, 2, 3)
    let b: (I32, I32, I32) = (1, 2, 4)
    assert(a != b, "triples with different third element should not be equal")
    return 0
}

// ============================================================================
// PartialOrd Tests for Pairs
// ============================================================================

@test
func test_pair_cmp_less_first() -> I32 {
    let a: (I32, I32) = (1, 5)
    let b: (I32, I32) = (2, 3)
    assert(a < b, "pair with smaller first element should be less")
    return 0
}

@test
func test_pair_cmp_less_second() -> I32 {
    let a: (I32, I32) = (1, 2)
    let b: (I32, I32) = (1, 3)
    assert(a < b, "pairs with equal first, smaller second should be less")
    return 0
}

@test
func test_pair_cmp_greater() -> I32 {
    let a: (I32, I32) = (2, 1)
    let b: (I32, I32) = (1, 9)
    assert(a > b, "pair with larger first element should be greater")
    return 0
}

@test
func test_pair_cmp_equal() -> I32 {
    let a: (I32, I32) = (5, 5)
    let b: (I32, I32) = (5, 5)
    assert(not (a < b), "equal pairs should not be less")
    assert(not (a > b), "equal pairs should not be greater")
    return 0
}

// ============================================================================
// PartialOrd Tests for Triples
// ============================================================================

@test
func test_triple_cmp_less_first() -> I32 {
    let a: (I32, I32, I32) = (1, 9, 9)
    let b: (I32, I32, I32) = (2, 1, 1)
    assert(a < b, "triple with smaller first element should be less")
    return 0
}

@test
func test_triple_cmp_less_second() -> I32 {
    let a: (I32, I32, I32) = (1, 2, 9)
    let b: (I32, I32, I32) = (1, 3, 1)
    assert(a < b, "triples with equal first, smaller second should be less")
    return 0
}

@test
func test_triple_cmp_less_third() -> I32 {
    let a: (I32, I32, I32) = (1, 2, 3)
    let b: (I32, I32, I32) = (1, 2, 4)
    assert(a < b, "triples with equal first two, smaller third should be less")
    return 0
}

// ============================================================================
// Tuple with Function Return
// ============================================================================

func make_pair(x: I32, y: I32) -> (I32, I32) {
    return (x, y)
}

func swap_pair(p: (I32, I32)) -> (I32, I32) {
    return (p.1, p.0)
}

@test
func test_tuple_return_from_function() -> I32 {
    let pair: (I32, I32) = make_pair(10, 20)
    assert(pair.0 == 10, "first should be 10")
    assert(pair.1 == 20, "second should be 20")
    return 0
}

@test
func test_tuple_swap() -> I32 {
    let original: (I32, I32) = (5, 10)
    let swapped: (I32, I32) = swap_pair(original)
    assert(swapped.0 == 10, "swapped first should be 10")
    assert(swapped.1 == 5, "swapped second should be 5")
    return 0
}

// ============================================================================
// Tuple as Parameter and Return Type
// ============================================================================

func sum_pair(p: (I32, I32)) -> I32 {
    return p.0 + p.1
}

func double_pair(p: (I32, I32)) -> (I32, I32) {
    return (p.0 * 2, p.1 * 2)
}

@test
func test_tuple_parameter() -> I32 {
    let p: (I32, I32) = (3, 7)
    let sum: I32 = sum_pair(p)
    assert(sum == 10, "sum should be 10")
    return 0
}

@test
func test_tuple_transform() -> I32 {
    let p: (I32, I32) = (5, 10)
    let doubled: (I32, I32) = double_pair(p)
    assert(doubled.0 == 10, "doubled first should be 10")
    assert(doubled.1 == 20, "doubled second should be 20")
    return 0
}

// ============================================================================
// Tuple in Control Flow
// ============================================================================

func classify_pair(p: (I32, I32)) -> I32 {
    if p.0 > p.1 {
        return 1
    } else if p.0 < p.1 {
        return -1
    }
    return 0
}

@test
func test_tuple_in_condition_greater() -> I32 {
    let p: (I32, I32) = (10, 5)
    assert(classify_pair(p) == 1, "first > second should return 1")
    return 0
}

@test
func test_tuple_in_condition_less() -> I32 {
    let p: (I32, I32) = (5, 10)
    assert(classify_pair(p) == -1, "first < second should return -1")
    return 0
}

@test
func test_tuple_in_condition_equal() -> I32 {
    let p: (I32, I32) = (7, 7)
    assert(classify_pair(p) == 0, "first == second should return 0")
    return 0
}

// ============================================================================
// Larger Tuples (5 and 6 elements)
// ============================================================================

@test
func test_5tuple_creation() -> I32 {
    let t: (I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5)
    assert(t.0 == 1, "first should be 1")
    assert(t.1 == 2, "second should be 2")
    assert(t.2 == 3, "third should be 3")
    assert(t.3 == 4, "fourth should be 4")
    assert(t.4 == 5, "fifth should be 5")
    return 0
}

@test
func test_6tuple_creation() -> I32 {
    let t: (I32, I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5, 6)
    assert(t.0 == 1, "first should be 1")
    assert(t.1 == 2, "second should be 2")
    assert(t.2 == 3, "third should be 3")
    assert(t.3 == 4, "fourth should be 4")
    assert(t.4 == 5, "fifth should be 5")
    assert(t.5 == 6, "sixth should be 6")
    return 0
}

@test
func test_5tuple_eq() -> I32 {
    let a: (I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5)
    let b: (I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5)
    assert(a == b, "equal 5-tuples should be equal")
    return 0
}

@test
func test_6tuple_eq() -> I32 {
    let a: (I32, I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5, 6)
    let b: (I32, I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5, 6)
    assert(a == b, "equal 6-tuples should be equal")
    return 0
}

@test
func test_5tuple_ne() -> I32 {
    let a: (I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5)
    let b: (I32, I32, I32, I32, I32) = (1, 2, 3, 4, 6)
    assert(a != b, "different 5-tuples should not be equal")
    return 0
}

@test
func test_6tuple_ne() -> I32 {
    let a: (I32, I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5, 6)
    let b: (I32, I32, I32, I32, I32, I32) = (1, 2, 3, 4, 5, 7)
    assert(a != b, "different 6-tuples should not be equal")
    return 0
}

// ============================================================================
// Quad PartialOrd Tests
// ============================================================================

@test
func test_quad_cmp_less_first() -> I32 {
    let a: (I32, I32, I32, I32) = (1, 9, 9, 9)
    let b: (I32, I32, I32, I32) = (2, 1, 1, 1)
    assert(a < b, "quad with smaller first element should be less")
    return 0
}

@test
func test_quad_cmp_less_fourth() -> I32 {
    let a: (I32, I32, I32, I32) = (1, 2, 3, 4)
    let b: (I32, I32, I32, I32) = (1, 2, 3, 5)
    assert(a < b, "quads with equal first three, smaller fourth should be less")
    return 0
}

@test
func test_quad_eq() -> I32 {
    let a: (I32, I32, I32, I32) = (1, 2, 3, 4)
    let b: (I32, I32, I32, I32) = (1, 2, 3, 4)
    assert(a == b, "equal quads should be equal")
    return 0
}

@test
func test_quad_ne() -> I32 {
    let a: (I32, I32, I32, I32) = (1, 2, 3, 4)
    let b: (I32, I32, I32, I32) = (1, 2, 3, 5)
    assert(a != b, "different quads should not be equal")
    return 0
}

// ============================================================================
// PhantomPinned Tests (from marker.test.tml)
// ============================================================================

// A type that should not be moved after pinning
type SelfRefStruct {
    value: I64,
    _pinned: PhantomPinned
}

impl SelfRefStruct {
    pub func value(this) -> I64 {
        return this.value
    }
}

impl Display for SelfRefStruct {
    pub func to_string(this) -> Str {
        return "SelfRefStruct"
    }
}

impl Debug for SelfRefStruct {
    pub func debug_string(this) -> Str {
        let val: I64 = this.value
        return "SelfRefStruct(value=" + val.to_string() + ")"
    }
}

@test
func test_phantom_pinned_basic() -> I32 {
    // PhantomPinned can be created and used in structs
    let pinned: PhantomPinned = PhantomPinned {}

    // Can also use new()
    let pinned2: PhantomPinned = PhantomPinned::new()

    // Or default()
    let pinned3: PhantomPinned = PhantomPinned::default()

    return 0
}

@test
func test_phantom_pinned_in_struct() -> I32 {
    // PhantomPinned can be used as a field in structs
    let s: SelfRefStruct = SelfRefStruct {
        value: 42,
        _pinned: PhantomPinned {}
    }

    assert_eq(s.value(), 42, "value should be 42")

    return 0
}

@test
func test_phantom_pinned_duplicate() -> I32 {
    let pinned: PhantomPinned = PhantomPinned::new()
    let pinned2: PhantomPinned = pinned.duplicate()

    // Both should exist (no-op since PhantomPinned has no data)
    return 0
}

@test
func test_phantom_pinned_to_string() -> I32 {
    let pinned: PhantomPinned = PhantomPinned::new()
    assert(pinned.to_string() == "PhantomPinned", "Display should be PhantomPinned")
    assert(pinned.debug_string() == "PhantomPinned", "Debug should be PhantomPinned")
    return 0
}

// ============================================================================
// PhantomData Tests (from marker.test.tml)
// ============================================================================

type FileHandle {
    id: I64,
    _phantom: PhantomData[I32],
}

@test
func test_phantom_data_new() -> I32 {
    let pd: PhantomData[I32] = PhantomData::new()
    return 0
}

@test
func test_phantom_data_default() -> I32 {
    let pd: PhantomData[I64] = PhantomData::default()
    return 0
}

@test
func test_phantom_data_duplicate() -> I32 {
    let pd1: PhantomData[Bool] = PhantomData::new()
    let pd2: PhantomData[Bool] = pd1.duplicate()
    return 0
}

@test
func test_phantom_data_in_struct() -> I32 {
    let handle: FileHandle = FileHandle {
        id: 42,
        _phantom: PhantomData::new(),
    }
    assert(handle.id == 42 as I64, "id should be 42")
    return 0
}
