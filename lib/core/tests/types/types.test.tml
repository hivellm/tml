// Consolidated array type tests
// Source files: array.test.tml, array_get_mut.test.tml, array_mutation.test.tml,
//   array_map_extra.test.tml, array_cmp_extra.test.tml, array_get_i64.test.tml,
//   array_small_types.test.tml, array_partial_cmp.test.tml, array_map_i64.test.tml
// Total @test count: 48

use test

// ============================================================================
// Basic Array Creation and Indexing (from array.test.tml)
// ============================================================================

@test
func test_array_literal_i32() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    assert(arr[0] == 1, "first element should be 1")
    assert(arr[4] == 5, "last element should be 5")
    return 0
}

@test
func test_array_literal_i64() -> I32 {
    let arr: [I64; 3] = [10, 20, 30]
    assert(arr[0] == 10, "first element should be 10")
    assert(arr[1] == 20, "second element should be 20")
    assert(arr[2] == 30, "third element should be 30")
    return 0
}

@test
func test_array_indexing() -> I32 {
    let arr: [I32; 4] = [100, 200, 300, 400]
    let first: I32 = arr[0]
    let second: I32 = arr[1]
    let third: I32 = arr[2]
    let fourth: I32 = arr[3]

    assert(first == 100, "first should be 100")
    assert(second == 200, "second should be 200")
    assert(third == 300, "third should be 300")
    assert(fourth == 400, "fourth should be 400")
    return 0
}

// ============================================================================
// Array Arithmetic
// ============================================================================

@test
func test_array_sum() -> I32 {
    let arr: [I32; 4] = [1, 2, 3, 4]
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3]
    assert(sum == 10, "sum should be 10")
    return 0
}

@test
func test_array_product() -> I32 {
    let arr: [I32; 4] = [2, 3, 4, 5]
    let product: I32 = arr[0] * arr[1] * arr[2] * arr[3]
    assert(product == 120, "product should be 120")
    return 0
}

// ============================================================================
// Array with Different Element Types
// ============================================================================

@test
func test_array_i8() -> I32 {
    let arr: [I8; 3] = [1, 2, 3]
    let sum: I8 = arr[0] + arr[1] + arr[2]
    assert(sum == 6, "sum should be 6")
    return 0
}

@test
func test_array_i16() -> I32 {
    let arr: [I16; 3] = [100, 200, 300]
    let sum: I16 = arr[0] + arr[1] + arr[2]
    assert(sum == 600, "sum should be 600")
    return 0
}

@test
func test_array_u32() -> I32 {
    let arr: [U32; 3] = [10, 20, 30]
    let sum: U32 = arr[0] + arr[1] + arr[2]
    assert(sum == 60, "sum should be 60")
    return 0
}

@test
func test_array_u64() -> I32 {
    let arr: [U64; 3] = [1000, 2000, 3000]
    let sum: U64 = arr[0] + arr[1] + arr[2]
    assert(sum == 6000, "sum should be 6000")
    return 0
}

// ============================================================================
// Empty Array and Single Element
// ============================================================================

@test
func test_array_single_element() -> I32 {
    let arr: [I32; 1] = [42]
    assert(arr[0] == 42, "single element should be 42")
    return 0
}

// ============================================================================
// Array in Expressions
// ============================================================================

@test
func test_array_in_comparison() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]

    assert(arr[0] < arr[1], "first < second")
    assert(arr[1] < arr[2], "second < third")
    assert(arr[0] < arr[2], "first < third")
    return 0
}

@test
func test_array_element_modification_via_index() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [4, 5, 6]

    // Test that arrays are independent
    let sum_a: I32 = a[0] + a[1] + a[2]
    let sum_b: I32 = b[0] + b[1] + b[2]

    assert(sum_a == 6, "sum of a should be 6")
    assert(sum_b == 15, "sum of b should be 15")
    return 0
}

// ============================================================================
// Array Size and Negative Values
// ============================================================================

@test
func test_array_large() -> I32 {
    let arr: [I32; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let first_half: I32 = arr[0] + arr[1] + arr[2] + arr[3] + arr[4]
    let second_half: I32 = arr[5] + arr[6] + arr[7] + arr[8] + arr[9]
    let sum: I32 = first_half + second_half
    assert(sum == 55, "sum of 1..10 should be 55")
    return 0
}

@test
func test_array_negative_values() -> I32 {
    let arr: [I32; 4] = [1, -2, 3, -4]
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3]
    assert(sum == -2, "sum should be -2")
    return 0
}

// ============================================================================
// Array Method Tests
// ============================================================================

@test
func test_array_len() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    assert(arr.len() == 5, "len should be 5")

    let empty: [I32; 0] = []
    assert(empty.len() == 0, "empty len should be 0")
    return 0
}

@test
func test_array_is_empty() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    assert(arr.is_empty() == false, "array should not be empty")

    let empty: [I32; 0] = []
    assert(empty.is_empty(), "empty array should be empty")
    return 0
}

@test
func test_array_get() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]

    when arr.get(0) {
        Just(v) => assert(*v == 10, "get(0) should be 10"),
        Nothing => assert(false, "get(0) should return Just")
    }

    when arr.get(2) {
        Just(v) => assert(*v == 30, "get(2) should be 30"),
        Nothing => assert(false, "get(2) should return Just")
    }

    when arr.get(3) {
        Just(_) => assert(false, "get(3) should return Nothing"),
        Nothing => {}
    }

    when arr.get(-1) {
        Just(_) => assert(false, "get(-1) should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_array_first_last() -> I32 {
    let arr: [I32; 3] = [100, 200, 300]

    when arr.first() {
        Just(v) => assert(*v == 100, "first should be 100"),
        Nothing => assert(false, "first should return Just")
    }

    when arr.last() {
        Just(v) => assert(*v == 300, "last should be 300"),
        Nothing => assert(false, "last should return Just")
    }

    let empty: [I32; 0] = []
    when empty.first() {
        Just(_) => assert(false, "empty first should return Nothing"),
        Nothing => {}
    }

    when empty.last() {
        Just(_) => assert(false, "empty last should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_array_map() -> I32 {
    let arr: [I32; 4] = [1, 2, 3, 4]
    let doubled: [I32; 4] = arr.map(do(x: I32) x * 2)

    assert(doubled[0] == 2, "doubled[0] should be 2")
    assert(doubled[1] == 4, "doubled[1] should be 4")
    assert(doubled[2] == 6, "doubled[2] should be 6")
    assert(doubled[3] == 8, "doubled[3] should be 8")

    return 0
}

// ============================================================================
// Equality and Comparison Tests
// ============================================================================

@test
func test_array_equality() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [1, 2, 3]
    let c: [I32; 3] = [1, 2, 4]

    assert(a.eq(ref b), "a should equal b")
    assert(a.ne(ref c), "a should not equal c")

    return 0
}

@test
func test_array_ordering() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [1, 2, 4]
    let c: [I32; 3] = [1, 2, 3]

    when a.cmp(ref b) {
        Less => {},
        _ => assert(false, "a should be less than b")
    }

    when b.cmp(ref a) {
        Greater => {},
        _ => assert(false, "b should be greater than a")
    }

    when a.cmp(ref c) {
        Equal => {},
        _ => assert(false, "a should equal c")
    }

    return 0
}

// ============================================================================
// Array Mutation via Indexing (from array_get_mut.test.tml)
// ============================================================================

@test
func test_array_mutation_via_index() -> I32 {
    var arr: [I32; 3] = [10, 20, 30]
    arr[1] = 99
    assert(arr[1] == 99, "element at index 1 should be 99 after mutation")
    assert(arr[0] == 10, "other elements unchanged")
    assert(arr[2] == 30, "other elements unchanged")
    return 0
}

@test
func test_array_mutation_first_element() -> I32 {
    var arr: [I32; 3] = [10, 20, 30]
    arr[0] = 77
    assert(arr[0] == 77, "first element should be 77 after mutation")
    return 0
}

@test
func test_array_mutation_last_element() -> I32 {
    var arr: [I32; 3] = [10, 20, 30]
    arr[2] = 55
    assert(arr[2] == 55, "last element should be 55 after mutation")
    return 0
}

// ============================================================================
// Array Mutation Patterns (from array_mutation.test.tml)
// ============================================================================

@test
func test_array_mutation_i64() -> I32 {
    var arr: [I64; 3] = [100, 200, 300]
    arr[0] = 999
    arr[2] = 777
    assert(arr[0] == 999, "first should be 999")
    assert(arr[1] == 200, "second unchanged")
    assert(arr[2] == 777, "third should be 777")
    return 0
}

@test
func test_array_mutation_all_elements() -> I32 {
    var arr: [I32; 4] = [1, 2, 3, 4]
    arr[0] = 10
    arr[1] = 20
    arr[2] = 30
    arr[3] = 40
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3]
    assert(sum == 100, "sum after mutation should be 100")
    return 0
}

@test
func test_array_mutation_with_arithmetic() -> I32 {
    var arr: [I32; 3] = [10, 20, 30]
    arr[1] = arr[0] + arr[2]
    assert(arr[1] == 40, "middle element should be sum of first and last")
    return 0
}

// ============================================================================
// Array Map Extra (from array_map_extra.test.tml)
// ============================================================================

@test
func test_array_map_double() -> I32 {
    let arr: [I32; 4] = [1, 2, 3, 4]
    let doubled: [I32; 4] = arr.map(do(x: I32) -> I32 { return x * 2 })
    assert(doubled[0] == 2, "map doubled[0]")
    assert(doubled[1] == 4, "map doubled[1]")
    assert(doubled[2] == 6, "map doubled[2]")
    assert(doubled[3] == 8, "map doubled[3]")
    return 0
}

@test
func test_array_map_negate() -> I32 {
    let arr: [I32; 3] = [10, -20, 30]
    let neg: [I32; 3] = arr.map(do(x: I32) -> I32 { return 0 - x })
    assert(neg[0] == -10, "map negate[0]")
    assert(neg[1] == 20, "map negate[1]")
    assert(neg[2] == -30, "map negate[2]")
    return 0
}

@test
func test_array_map_constant() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    let ones: [I32; 3] = arr.map(do(_: I32) -> I32 { return 1 })
    assert(ones[0] == 1, "map constant[0]")
    assert(ones[1] == 1, "map constant[1]")
    assert(ones[2] == 1, "map constant[2]")
    return 0
}

// ============================================================================
// Array Comparison Extra (from array_cmp_extra.test.tml)
// ============================================================================

@test
func test_array_eq_single_element() -> I32 {
    let a: [I32; 1] = [42]
    let b: [I32; 1] = [42]
    let c: [I32; 1] = [99]
    assert(a.eq(ref b), "single element eq")
    assert(a.ne(ref c), "single element ne")
    return 0
}

@test
func test_array_eq_empty() -> I32 {
    let a: [I32; 0] = []
    let b: [I32; 0] = []
    assert(a.eq(ref b), "empty arrays should be equal")
    return 0
}

@test
func test_array_cmp_first_differs() -> I32 {
    let a: [I32; 3] = [1, 5, 5]
    let b: [I32; 3] = [2, 1, 1]
    when a.cmp(ref b) {
        Less => {},
        _ => assert(false, "[1,5,5] should be less than [2,1,1]")
    }
    return 0
}

// ============================================================================
// Array Comparison with I64 (from array_get_i64.test.tml)
// ============================================================================

@test
func test_array_cmp_equal() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [1, 2, 3]
    when a.cmp(ref b) {
        Equal => {},
        _ => assert(false, "equal arrays should compare Equal")
    }
    return 0
}

@test
func test_array_cmp_greater() -> I32 {
    let a: [I32; 3] = [1, 3, 0]
    let b: [I32; 3] = [1, 2, 9]
    when a.cmp(ref b) {
        Greater => {},
        _ => assert(false, "[1,3,0] should be greater than [1,2,9]")
    }
    return 0
}

@test
func test_array_eq_i64() -> I32 {
    let a: [I64; 2] = [100, 200]
    let b: [I64; 2] = [100, 200]
    let c: [I64; 2] = [100, 999]
    assert(a.eq(ref b), "I64 arrays eq")
    assert(a.ne(ref c), "I64 arrays ne")
    return 0
}

// ============================================================================
// Array Get/First/Last with I64 (from array_get_i64.test.tml)
// ============================================================================

@test
func test_array_get_i64() -> I32 {
    let arr: [I64; 4] = [100, 200, 300, 400]

    when arr.get(0) {
        Just(v) => assert(*v == 100, "get(0) should be 100"),
        Nothing => assert(false, "get(0) should return Just")
    }

    when arr.get(3) {
        Just(v) => assert(*v == 400, "get(3) should be 400"),
        Nothing => assert(false, "get(3) should return Just")
    }

    when arr.get(4) {
        Just(_) => assert(false, "get(4) should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_array_first_last_i64() -> I32 {
    let arr: [I64; 3] = [11, 22, 33]

    when arr.first() {
        Just(v) => assert(*v == 11, "first should be 11"),
        Nothing => assert(false, "first should return Just")
    }

    when arr.last() {
        Just(v) => assert(*v == 33, "last should be 33"),
        Nothing => assert(false, "last should return Just")
    }

    return 0
}

@test
func test_array_map_type_conversion() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    let mapped: [I64; 3] = arr.map(do(x: I32) -> I64 { return x as I64 * 100 })
    assert(mapped[0] == 100, "map type conversion[0]")
    assert(mapped[1] == 200, "map type conversion[1]")
    assert(mapped[2] == 300, "map type conversion[2]")
    return 0
}

// ============================================================================
// Array with Small Integer Types (from array_small_types.test.tml)
// Renamed to _v2 to avoid duplicates with basic array type tests above
// ============================================================================

@test
func test_array_i8_v2() -> I32 {
    let arr: [I8; 3] = [10, 20, 30]
    assert(arr[0] as I32 == 10, "I8 array[0]")
    assert(arr[1] as I32 == 20, "I8 array[1]")
    assert(arr[2] as I32 == 30, "I8 array[2]")
    assert(arr.len() == 3, "I8 array len")
    return 0
}

@test
func test_array_u8() -> I32 {
    let arr: [U8; 4] = [0, 128, 200, 255]
    assert(arr[0] as I32 == 0, "U8 array[0]")
    assert(arr[1] as I32 == 128, "U8 array[1]")
    assert(arr[2] as I32 == 200, "U8 array[2]")
    assert(arr[3] as I32 == 255, "U8 array[3]")
    return 0
}

@test
func test_array_i16_v2() -> I32 {
    let arr: [I16; 3] = [1000, -2000, 3000]
    assert(arr[0] as I32 == 1000, "I16 array[0]")
    assert(arr[1] as I32 == -2000, "I16 array[1]")
    assert(arr[2] as I32 == 3000, "I16 array[2]")
    return 0
}

// ============================================================================
// Array with U32, U64, Bool Types (from array_partial_cmp.test.tml)
// Renamed to _v2 to avoid duplicates with basic array type tests above
// ============================================================================

@test
func test_array_u32_v2() -> I32 {
    let arr: [U32; 3] = [100, 200, 300]
    assert(arr[0] as I32 == 100, "U32 array[0]")
    assert(arr[1] as I32 == 200, "U32 array[1]")
    assert(arr[2] as I32 == 300, "U32 array[2]")
    assert(arr.len() == 3, "U32 array len")
    return 0
}

@test
func test_array_u64_v2() -> I32 {
    let arr: [U64; 2] = [1000000, 2000000]
    assert(arr[0] as I64 == 1000000, "U64 array[0]")
    assert(arr[1] as I64 == 2000000, "U64 array[1]")
    return 0
}

@test
func test_array_bool() -> I32 {
    let arr: [Bool; 4] = [true, false, true, false]
    assert(arr[0] == true, "bool array[0]")
    assert(arr[1] == false, "bool array[1]")
    assert(arr[2] == true, "bool array[2]")
    assert(arr[3] == false, "bool array[3]")
    return 0
}

// ============================================================================
// Array Map with I64 and Accumulation (from array_map_i64.test.tml)
// ============================================================================

@test
func test_array_map_i64_square() -> I32 {
    let arr: [I64; 4] = [1, 2, 3, 4]
    let squared: [I64; 4] = arr.map(do(x: I64) -> I64 { return x * x })
    assert(squared[0] == 1, "map square[0]")
    assert(squared[1] == 4, "map square[1]")
    assert(squared[2] == 9, "map square[2]")
    assert(squared[3] == 16, "map square[3]")
    return 0
}

@test
func test_array_accumulate() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    var sum: I32 = 0
    var i: I64 = 0
    loop (i < arr.len()) {
        sum = sum + arr[i]
        i = i + 1
    }
    assert(sum == 15, "accumulate sum should be 15")
    return 0
}

@test
func test_array_find_max() -> I32 {
    let arr: [I32; 5] = [3, 1, 4, 1, 5]
    var max: I32 = arr[0]
    var i: I64 = 1
    loop (i < arr.len()) {
        if arr[i] > max {
            max = arr[i]
        }
        i = i + 1
    }
    assert(max == 5, "max should be 5")
    return 0
}
