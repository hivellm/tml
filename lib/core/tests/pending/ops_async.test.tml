// Tests for async function types (core::ops::async_function)
use test

use core::ops::async_function::{Poll, ReadyFuture, PendingFuture}

// ============================================================================
// Poll Tests
// ============================================================================

@test
func test_poll_ready() -> I32 {
    let p: Poll[I64] = Poll::Ready(42)
    assert(p.is_ready(), "Ready should be ready")
    assert(not p.is_pending(), "Ready should not be pending")
    return 0
}

@test
func test_poll_pending() -> I32 {
    let p: Poll[I64] = Poll::Pending
    assert(not p.is_ready(), "Pending should not be ready")
    assert(p.is_pending(), "Pending should be pending")
    return 0
}

@test
func test_poll_debug_ready() -> I32 {
    let p: Poll[I64] = Poll::Ready(42)
    let s: Str = p.debug_string()
    assert(s == "Ready(42)", "debug should be 'Ready(42)'")
    return 0
}

@test
func test_poll_debug_pending() -> I32 {
    let p: Poll[I64] = Poll::Pending
    let s: Str = p.debug_string()
    assert(s == "Pending", "debug should be 'Pending'")
    return 0
}

@test
func test_poll_to_string_ready() -> I32 {
    let p: Poll[I64] = Poll::Ready(99)
    let s: Str = p.to_string()
    assert(s == "Ready(99)", "to_string should be 'Ready(99)'")
    return 0
}

@test
func test_poll_to_string_pending() -> I32 {
    let p: Poll[I64] = Poll::Pending
    let s: Str = p.to_string()
    assert(s == "Pending", "to_string should be 'Pending'")
    return 0
}

@test
func test_poll_map_ready() -> I32 {
    let p: Poll[I32] = Poll::Ready(21)
    let doubled: Poll[I32] = p.map(do(x: I32) -> I32 { x * 2 })
    when doubled {
        Poll::Ready(v) => {
            assert_eq(v, 42, "mapped value should be 42")
            return 0
        },
        Poll::Pending => {
            assert(false, "should be Ready")
            return 1
        }
    }
}

@test
func test_poll_map_pending() -> I32 {
    let p: Poll[I32] = Poll::Pending
    let mapped: Poll[I32] = p.map(do(x: I32) -> I32 { x * 2 })
    when mapped {
        Poll::Ready(_) => {
            assert(false, "should be Pending")
            return 1
        },
        Poll::Pending => {
            return 0
        }
    }
}

// ============================================================================
// ReadyFuture Tests
// ============================================================================

@test
func test_ready_future_new() -> I32 {
    let rf: ReadyFuture[I64] = ReadyFuture::new(42)
    when rf.value {
        Just(v) => {
            assert_eq(v, 42, "should hold 42")
            return 0
        },
        Nothing => {
            assert(false, "should not be Nothing")
            return 1
        }
    }
}

@test
func test_ready_future_into_future() -> I32 {
    let rf: ReadyFuture[I64] = ReadyFuture::new(100)
    let future: ReadyFuture[I64] = rf.into_future()
    when future.value {
        Just(v) => {
            assert_eq(v, 100, "into_future should preserve value")
            return 0
        },
        Nothing => {
            assert(false, "should not be Nothing")
            return 1
        }
    }
}

// ============================================================================
// PendingFuture Tests
// ============================================================================

@test
func test_pending_future_new() -> I32 {
    let _pf: PendingFuture[I64] = PendingFuture::new()
    // PendingFuture just needs to be constructible
    // It will never complete when polled
    return 0
}

// ============================================================================
// Simulated Async Pattern Tests
// ============================================================================

// A simple state machine representing an async computation
pub type FetchState {
    NotStarted,
    Loading,
    Done(I64)
}

impl FetchState {
    pub func debug_string(this) -> Str {
        when this {
            FetchState::NotStarted => return "NotStarted",
            FetchState::Loading => return "Loading",
            FetchState::Done(v) => return "Done(" + v.to_string() + ")"
        }
    }
}

// Simulated async fetch that takes 3 "polls" to complete
pub type MockFetch {
    state: FetchState,
    polls_remaining: I32,
    result: I64
}

impl MockFetch {
    pub func new(result: I64, polls_to_complete: I32) -> MockFetch {
        return MockFetch {
            state: FetchState::NotStarted,
            polls_remaining: polls_to_complete,
            result: result
        }
    }

    pub func poll(mut this) -> Poll[I64] {
        when this.state {
            FetchState::NotStarted => {
                this.state = FetchState::Loading
                return Poll::Pending
            },
            FetchState::Loading => {
                this.polls_remaining = this.polls_remaining - 1
                if this.polls_remaining <= 0 {
                    this.state = FetchState::Done(this.result)
                    return Poll::Ready(this.result)
                }
                return Poll::Pending
            },
            FetchState::Done(v) => {
                return Poll::Ready(v)
            }
        }
    }

    pub func is_complete(this) -> Bool {
        when this.state {
            FetchState::Done(_) => return true,
            _ => return false
        }
    }
}

@test
func test_mock_fetch_immediate() -> I32 {
    var fetch: MockFetch = MockFetch::new(42, 1)

    // First poll: NotStarted -> Loading
    let p1: Poll[I64] = fetch.poll()
    assert(p1.is_pending(), "first poll should be pending")

    // Second poll: Loading -> Done (1 poll to complete)
    let p2: Poll[I64] = fetch.poll()
    assert(p2.is_ready(), "second poll should be ready")

    when p2 {
        Poll::Ready(v) => assert_eq(v, 42, "should be 42"),
        Poll::Pending => { assert(false, "should be ready"); return 1 }
    }

    return 0
}

@test
func test_mock_fetch_delayed() -> I32 {
    var fetch: MockFetch = MockFetch::new(100, 3)

    // First poll: NotStarted -> Loading
    let p1: Poll[I64] = fetch.poll()
    assert(p1.is_pending(), "poll 1 should be pending")

    // Second poll: still loading (2 remaining)
    let p2: Poll[I64] = fetch.poll()
    assert(p2.is_pending(), "poll 2 should be pending")

    // Third poll: still loading (1 remaining)
    let p3: Poll[I64] = fetch.poll()
    assert(p3.is_pending(), "poll 3 should be pending")

    // Fourth poll: done (0 remaining)
    let p4: Poll[I64] = fetch.poll()
    assert(p4.is_ready(), "poll 4 should be ready")

    when p4 {
        Poll::Ready(v) => assert_eq(v, 100, "should be 100"),
        Poll::Pending => { assert(false, "should be ready"); return 1 }
    }

    return 0
}

@test
func test_mock_fetch_poll_after_complete() -> I32 {
    var fetch: MockFetch = MockFetch::new(50, 1)

    // Complete the fetch
    let _p1: Poll[I64] = fetch.poll()  // NotStarted -> Loading
    let _p2: Poll[I64] = fetch.poll()  // Loading -> Done

    assert(fetch.is_complete(), "should be complete")

    // Polling after completion should still return Ready
    let p: Poll[I64] = fetch.poll()
    assert(p.is_ready(), "should still be ready")

    when p {
        Poll::Ready(v) => assert_eq(v, 50, "should still be 50"),
        Poll::Pending => { assert(false, "should be ready"); return 1 }
    }

    return 0
}
