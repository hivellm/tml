// Tests for core::unicode module
// Tests Unicode character classification and operations

use core::unicode

// ============================================================================
// Character Validation
// ============================================================================

@test
func test_is_valid_scalar() -> I32 {
    // Valid ASCII
    assert(unicode::is_valid_scalar(0), "0 should be valid")
    assert(unicode::is_valid_scalar(127), "127 should be valid")

    // Valid non-ASCII
    assert(unicode::is_valid_scalar(0x00A0), "non-breaking space should be valid")
    assert(unicode::is_valid_scalar(0x10FFFF), "max code point should be valid")

    // Surrogates are invalid
    assert(not unicode::is_valid_scalar(0xD800), "high surrogate start should be invalid")
    assert(not unicode::is_valid_scalar(0xDFFF), "low surrogate end should be invalid")
    assert(not unicode::is_valid_scalar(0xD900), "mid surrogate should be invalid")

    // Beyond max is invalid
    assert(not unicode::is_valid_scalar(0x110000), "beyond max should be invalid")

    return 0
}

// ============================================================================
// Alphabetic Classification
// ============================================================================

@test
func test_is_alphabetic_ascii() -> I32 {
    // ASCII letters
    assert(unicode::is_alphabetic(65), "A should be alphabetic")   // 'A'
    assert(unicode::is_alphabetic(90), "Z should be alphabetic")   // 'Z'
    assert(unicode::is_alphabetic(97), "a should be alphabetic")   // 'a'
    assert(unicode::is_alphabetic(122), "z should be alphabetic")  // 'z'

    // Non-letters
    assert(not unicode::is_alphabetic(48), "0 should not be alphabetic")  // '0'
    assert(not unicode::is_alphabetic(32), "space should not be alphabetic")
    assert(not unicode::is_alphabetic(64), "@ should not be alphabetic")

    return 0
}

@test
func test_is_alphabetic_unicode() -> I32 {
    // Greek letters
    assert(unicode::is_alphabetic(0x0391), "Greek Alpha should be alphabetic")
    assert(unicode::is_alphabetic(0x03C9), "Greek omega should be alphabetic")

    // Cyrillic letters
    assert(unicode::is_alphabetic(0x0410), "Cyrillic A should be alphabetic")
    assert(unicode::is_alphabetic(0x044F), "Cyrillic ya should be alphabetic")

    // CJK (Chinese/Japanese/Korean)
    assert(unicode::is_alphabetic(0x4E00), "CJK character should be alphabetic")

    return 0
}

// ============================================================================
// Case Classification
// ============================================================================

@test
func test_is_lowercase_ascii() -> I32 {
    assert(unicode::is_lowercase(97), "a should be lowercase")   // 'a'
    assert(unicode::is_lowercase(122), "z should be lowercase")  // 'z'
    assert(not unicode::is_lowercase(65), "A should not be lowercase")  // 'A'
    assert(not unicode::is_lowercase(48), "0 should not be lowercase")  // '0'

    return 0
}

@test
func test_is_lowercase_unicode() -> I32 {
    // Greek lowercase
    assert(unicode::is_lowercase(0x03B1), "Greek alpha should be lowercase")
    assert(not unicode::is_lowercase(0x0391), "Greek Alpha should not be lowercase")

    // Cyrillic lowercase
    assert(unicode::is_lowercase(0x0430), "Cyrillic a should be lowercase")

    return 0
}

@test
func test_is_uppercase_ascii() -> I32 {
    assert(unicode::is_uppercase(65), "A should be uppercase")   // 'A'
    assert(unicode::is_uppercase(90), "Z should be uppercase")   // 'Z'
    assert(not unicode::is_uppercase(97), "a should not be uppercase")  // 'a'
    assert(not unicode::is_uppercase(48), "0 should not be uppercase")  // '0'

    return 0
}

@test
func test_is_uppercase_unicode() -> I32 {
    // Greek uppercase
    assert(unicode::is_uppercase(0x0391), "Greek Alpha should be uppercase")
    assert(not unicode::is_uppercase(0x03B1), "Greek alpha should not be uppercase")

    // Cyrillic uppercase
    assert(unicode::is_uppercase(0x0410), "Cyrillic A should be uppercase")

    return 0
}

// ============================================================================
// Numeric Classification
// ============================================================================

@test
func test_is_numeric_ascii() -> I32 {
    assert(unicode::is_numeric(48), "0 should be numeric")   // '0'
    assert(unicode::is_numeric(57), "9 should be numeric")   // '9'
    assert(not unicode::is_numeric(97), "a should not be numeric")
    assert(not unicode::is_numeric(32), "space should not be numeric")

    return 0
}

@test
func test_is_numeric_unicode() -> I32 {
    // Arabic-Indic digits
    assert(unicode::is_numeric(0x0660), "Arabic-Indic 0 should be numeric")
    assert(unicode::is_numeric(0x0669), "Arabic-Indic 9 should be numeric")

    // Devanagari digits
    assert(unicode::is_numeric(0x0966), "Devanagari 0 should be numeric")

    return 0
}

@test
func test_is_alphanumeric() -> I32 {
    // Letters
    assert(unicode::is_alphanumeric(65), "A should be alphanumeric")
    assert(unicode::is_alphanumeric(97), "a should be alphanumeric")

    // Digits
    assert(unicode::is_alphanumeric(48), "0 should be alphanumeric")
    assert(unicode::is_alphanumeric(57), "9 should be alphanumeric")

    // Neither
    assert(not unicode::is_alphanumeric(32), "space should not be alphanumeric")
    assert(not unicode::is_alphanumeric(64), "@ should not be alphanumeric")

    return 0
}

// ============================================================================
// Whitespace Classification
// ============================================================================

@test
func test_is_whitespace_ascii() -> I32 {
    assert(unicode::is_whitespace(32), "space should be whitespace")
    assert(unicode::is_whitespace(9), "tab should be whitespace")
    assert(unicode::is_whitespace(10), "line feed should be whitespace")
    assert(unicode::is_whitespace(13), "carriage return should be whitespace")
    assert(unicode::is_whitespace(12), "form feed should be whitespace")
    assert(unicode::is_whitespace(11), "vertical tab should be whitespace")

    assert(not unicode::is_whitespace(97), "a should not be whitespace")
    assert(not unicode::is_whitespace(48), "0 should not be whitespace")

    return 0
}

@test
func test_is_whitespace_unicode() -> I32 {
    // Non-breaking space
    assert(unicode::is_whitespace(0x00A0), "non-breaking space should be whitespace")

    // Em space, en space
    assert(unicode::is_whitespace(0x2003), "em space should be whitespace")
    assert(unicode::is_whitespace(0x2002), "en space should be whitespace")

    // Ideographic space
    assert(unicode::is_whitespace(0x3000), "ideographic space should be whitespace")

    return 0
}

// ============================================================================
// Control Classification
// ============================================================================

@test
func test_is_control_ascii() -> I32 {
    assert(unicode::is_control(0), "null should be control")
    assert(unicode::is_control(7), "bell should be control")
    assert(unicode::is_control(31), "unit separator should be control")
    assert(unicode::is_control(127), "delete should be control")

    assert(not unicode::is_control(32), "space should not be control")
    assert(not unicode::is_control(65), "A should not be control")

    return 0
}

@test
func test_is_control_unicode() -> I32 {
    // C1 control characters
    assert(unicode::is_control(0x0080), "C1 control start should be control")
    assert(unicode::is_control(0x009F), "C1 control end should be control")

    return 0
}

// ============================================================================
// Printable Classification
// ============================================================================

@test
func test_is_printable_ascii() -> I32 {
    assert(unicode::is_printable(32), "space should be printable")
    assert(unicode::is_printable(65), "A should be printable")
    assert(unicode::is_printable(126), "tilde should be printable")

    assert(not unicode::is_printable(0), "null should not be printable")
    assert(not unicode::is_printable(31), "control char should not be printable")
    assert(not unicode::is_printable(127), "delete should not be printable")

    return 0
}

// ============================================================================
// Case Conversion
// ============================================================================

@test
func test_to_uppercase_ascii() -> I32 {
    assert(unicode::to_uppercase(97) == 65, "a should uppercase to A")
    assert(unicode::to_uppercase(122) == 90, "z should uppercase to Z")
    assert(unicode::to_uppercase(65) == 65, "A should stay A")
    assert(unicode::to_uppercase(48) == 48, "0 should stay 0")

    return 0
}

@test
func test_to_uppercase_unicode() -> I32 {
    // Greek
    assert(unicode::to_uppercase(0x03B1) == 0x0391, "Greek alpha should uppercase to Alpha")
    assert(unicode::to_uppercase(0x03C9) == 0x03A9, "Greek omega should uppercase to Omega")

    // Already uppercase
    assert(unicode::to_uppercase(0x0391) == 0x0391, "Greek Alpha should stay Alpha")

    return 0
}

@test
func test_to_lowercase_ascii() -> I32 {
    assert(unicode::to_lowercase(65) == 97, "A should lowercase to a")
    assert(unicode::to_lowercase(90) == 122, "Z should lowercase to z")
    assert(unicode::to_lowercase(97) == 97, "a should stay a")
    assert(unicode::to_lowercase(48) == 48, "0 should stay 0")

    return 0
}

@test
func test_to_lowercase_unicode() -> I32 {
    // Greek
    assert(unicode::to_lowercase(0x0391) == 0x03B1, "Greek Alpha should lowercase to alpha")
    assert(unicode::to_lowercase(0x03A9) == 0x03C9, "Greek Omega should lowercase to omega")

    // Already lowercase
    assert(unicode::to_lowercase(0x03B1) == 0x03B1, "Greek alpha should stay alpha")

    return 0
}

@test
func test_to_titlecase_ascii() -> I32 {
    // For ASCII, titlecase is same as uppercase
    assert(unicode::to_titlecase(97) == 65, "a should titlecase to A")
    assert(unicode::to_titlecase(65) == 65, "A should stay A")

    return 0
}

// ============================================================================
// Grapheme Extend
// ============================================================================

@test
func test_is_grapheme_extend() -> I32 {
    // Combining marks are grapheme extending
    assert(unicode::is_grapheme_extend(0x0300), "combining grave should be grapheme extend")
    assert(unicode::is_grapheme_extend(0x0301), "combining acute should be grapheme extend")

    // Regular characters are not
    assert(not unicode::is_grapheme_extend(65), "A should not be grapheme extend")
    assert(not unicode::is_grapheme_extend(97), "a should not be grapheme extend")

    return 0
}
