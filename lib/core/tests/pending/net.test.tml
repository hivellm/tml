// Tests for std::net module (IP addresses and sockets)
use test::{assert, assert_eq}
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr}
use std::net::{SocketAddr, SocketAddrV4}

// =============================================================================
// Ipv4Addr Tests
// =============================================================================

@test
func test_ipv4_new() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    let octs: [U8; 4] = addr.octets()
    assert_eq(octs[0], 192 as U8, "octet 0")
    assert_eq(octs[1], 168 as U8, "octet 1")
    assert_eq(octs[2], 1 as U8, "octet 2")
    assert_eq(octs[3], 1 as U8, "octet 3")
    return 0
}

@test
func test_ipv4_localhost() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let octs: [U8; 4] = addr.octets()
    assert_eq(octs[0], 127 as U8, "octet 0")
    assert_eq(octs[1], 0 as U8, "octet 1")
    assert_eq(octs[2], 0 as U8, "octet 2")
    assert_eq(octs[3], 1 as U8, "octet 3")
    assert(addr.is_loopback(), "localhost should be loopback")
    return 0
}

@test
func test_ipv4_unspecified() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::UNSPECIFIED()
    let octs: [U8; 4] = addr.octets()
    assert_eq(octs[0], 0 as U8, "octet 0")
    assert_eq(octs[1], 0 as U8, "octet 1")
    assert_eq(octs[2], 0 as U8, "octet 2")
    assert_eq(octs[3], 0 as U8, "octet 3")
    assert(addr.is_unspecified(), "unspecified should be unspecified")
    return 0
}

@test
func test_ipv4_broadcast() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::BROADCAST()
    let octs: [U8; 4] = addr.octets()
    assert_eq(octs[0], 255 as U8, "octet 0")
    assert_eq(octs[1], 255 as U8, "octet 1")
    assert_eq(octs[2], 255 as U8, "octet 2")
    assert_eq(octs[3], 255 as U8, "octet 3")
    assert(addr.is_broadcast(), "broadcast should be broadcast")
    return 0
}

@test
func test_ipv4_from_bits() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::from_bits(0x7F000001 as U32)  // 127.0.0.1
    let localhost: Ipv4Addr = Ipv4Addr::LOCALHOST()
    assert(addr == localhost, "from_bits should equal LOCALHOST")
    return 0
}

@test
func test_ipv4_to_bits() -> I32 {
    let addr: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1)
    let bits: U32 = addr.to_bits()
    assert_eq(bits, 0x7F000001 as U32, "to_bits should match")
    return 0
}

@test
func test_ipv4_is_loopback() -> I32 {
    assert(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), "127.0.0.1")
    assert(Ipv4Addr::new(127, 255, 255, 255).is_loopback(), "127.255.255.255")
    assert(not Ipv4Addr::new(128, 0, 0, 1).is_loopback(), "128.0.0.1")
    return 0
}

@test
func test_ipv4_is_private() -> I32 {
    // 10.0.0.0/8
    assert(Ipv4Addr::new(10, 0, 0, 1).is_private(), "10.0.0.1")
    assert(Ipv4Addr::new(10, 255, 255, 255).is_private(), "10.255.255.255")

    // 172.16.0.0/12
    assert(Ipv4Addr::new(172, 16, 0, 1).is_private(), "172.16.0.1")
    assert(Ipv4Addr::new(172, 31, 255, 255).is_private(), "172.31.255.255")
    assert(not Ipv4Addr::new(172, 15, 0, 1).is_private(), "172.15.0.1")
    assert(not Ipv4Addr::new(172, 32, 0, 1).is_private(), "172.32.0.1")

    // 192.168.0.0/16
    assert(Ipv4Addr::new(192, 168, 0, 1).is_private(), "192.168.0.1")
    assert(Ipv4Addr::new(192, 168, 255, 255).is_private(), "192.168.255.255")

    // Public addresses
    assert(not Ipv4Addr::new(8, 8, 8, 8).is_private(), "8.8.8.8")
    return 0
}

@test
func test_ipv4_is_link_local() -> I32 {
    assert(Ipv4Addr::new(169, 254, 0, 1).is_link_local(), "169.254.0.1")
    assert(Ipv4Addr::new(169, 254, 255, 255).is_link_local(), "169.254.255.255")
    assert(not Ipv4Addr::new(169, 253, 0, 1).is_link_local(), "169.253.0.1")
    return 0
}

@test
func test_ipv4_is_multicast() -> I32 {
    assert(Ipv4Addr::new(224, 0, 0, 1).is_multicast(), "224.0.0.1")
    assert(Ipv4Addr::new(239, 255, 255, 255).is_multicast(), "239.255.255.255")
    assert(not Ipv4Addr::new(223, 255, 255, 255).is_multicast(), "223.255.255.255")
    assert(not Ipv4Addr::new(240, 0, 0, 0).is_multicast(), "240.0.0.0")
    return 0
}

@test
func test_ipv4_is_documentation() -> I32 {
    assert(Ipv4Addr::new(192, 0, 2, 1).is_documentation(), "192.0.2.1")
    assert(Ipv4Addr::new(198, 51, 100, 1).is_documentation(), "198.51.100.1")
    assert(Ipv4Addr::new(203, 0, 113, 1).is_documentation(), "203.0.113.1")
    assert(not Ipv4Addr::new(192, 0, 3, 1).is_documentation(), "192.0.3.1")
    return 0
}

@test
func test_ipv4_equality() -> I32 {
    let a: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    let b: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    let c: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 2)

    assert(a == b, "a should equal b")
    assert(a != c, "a should not equal c")
    return 0
}

@test
func test_ipv4_to_ipv6_mapped() -> I32 {
    let v4: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    let v6: Ipv6Addr = v4.to_ipv6_mapped()
    assert(v6.is_ipv4_mapped(), "should be ipv4 mapped")
    return 0
}

// =============================================================================
// Ipv6Addr Tests
// =============================================================================

@test
func test_ipv6_new() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::new(0x2001, 0x0db8, 0, 0, 0, 0, 0, 1)
    let segs: [U16; 8] = addr.segments()
    assert_eq(segs[0], 0x2001 as U16, "segment 0")
    assert_eq(segs[1], 0x0db8 as U16, "segment 1")
    assert_eq(segs[7], 1 as U16, "segment 7")
    return 0
}

@test
func test_ipv6_localhost() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::LOCALHOST()
    let segs: [U16; 8] = addr.segments()
    assert_eq(segs[0], 0 as U16, "segment 0")
    assert_eq(segs[7], 1 as U16, "segment 7")
    assert(addr.is_loopback(), "localhost should be loopback")
    return 0
}

@test
func test_ipv6_unspecified() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::UNSPECIFIED()
    let segs: [U16; 8] = addr.segments()
    assert_eq(segs[0], 0 as U16, "segment 0")
    assert_eq(segs[7], 0 as U16, "segment 7")
    assert(addr.is_unspecified(), "unspecified should be unspecified")
    return 0
}

@test
func test_ipv6_is_multicast() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::new(0xFF00, 0, 0, 0, 0, 0, 0, 1)
    assert(addr.is_multicast(), "FF00:: should be multicast")

    let not_multicast: Ipv6Addr = Ipv6Addr::new(0x2001, 0, 0, 0, 0, 0, 0, 1)
    assert(not not_multicast.is_multicast(), "2001:: should not be multicast")
    return 0
}

@test
func test_ipv6_is_link_local() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::new(0xFE80, 0, 0, 0, 0, 0, 0, 1)
    assert(addr.is_unicast_link_local(), "FE80:: should be link local")
    return 0
}

@test
func test_ipv6_is_unique_local() -> I32 {
    let addr: Ipv6Addr = Ipv6Addr::new(0xFC00, 0, 0, 0, 0, 0, 0, 1)
    assert(addr.is_unique_local(), "FC00:: should be unique local")

    let addr2: Ipv6Addr = Ipv6Addr::new(0xFD00, 0, 0, 0, 0, 0, 0, 1)
    assert(addr2.is_unique_local(), "FD00:: should be unique local")
    return 0
}

// =============================================================================
// IpAddr Tests
// =============================================================================

@test
func test_ip_addr_is_ipv4() -> I32 {
    let v4: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST())
    let v6: IpAddr = IpAddr::V6(Ipv6Addr::LOCALHOST())

    assert(v4.is_ipv4(), "v4 should be ipv4")
    assert(not v4.is_ipv6(), "v4 should not be ipv6")
    assert(v6.is_ipv6(), "v6 should be ipv6")
    assert(not v6.is_ipv4(), "v6 should not be ipv4")
    return 0
}

@test
func test_ip_addr_is_loopback() -> I32 {
    let v4: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST())
    let v6: IpAddr = IpAddr::V6(Ipv6Addr::LOCALHOST())

    assert(v4.is_loopback(), "v4 localhost should be loopback")
    assert(v6.is_loopback(), "v6 localhost should be loopback")
    return 0
}

// =============================================================================
// SocketAddr Tests (IPv4 only - SocketAddrV6 not yet implemented)
// =============================================================================

@test
func test_socket_addr_v4() -> I32 {
    let addr: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 8080 as U16)
    let ip: Ipv4Addr = addr.ip()
    assert(ip == Ipv4Addr::LOCALHOST(), "ip should be localhost")
    assert_eq(addr.port(), 8080 as U16, "port should be 8080")
    return 0
}

@test
func test_socket_addr_v4_set() -> I32 {
    var addr: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 8080 as U16)
    addr.set_port(9090 as U16)
    assert_eq(addr.port(), 9090 as U16, "port should be 9090")

    addr.set_ip(Ipv4Addr::BROADCAST())
    let ip: Ipv4Addr = addr.ip()
    assert(ip == Ipv4Addr::BROADCAST(), "ip should be broadcast")
    return 0
}

@test
func test_socket_addr_wrapper() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)

    assert(addr.is_ipv4(), "should be ipv4")
    assert(not addr.is_ipv6(), "should not be ipv6")
    assert_eq(addr.port(), 80 as U16, "port should be 80")
    return 0
}
