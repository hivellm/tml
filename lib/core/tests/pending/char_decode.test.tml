// Tests for core::char::decode module

use core::char::decode
use core::slice::Slice

// ============================================================================
// Surrogate Detection Tests
// ============================================================================

@test
func test_is_high_surrogate() -> I32 {
    // Valid high surrogates
    assert(decode::is_high_surrogate(0xD800), "0xD800 is high surrogate")
    assert(decode::is_high_surrogate(0xDBFF), "0xDBFF is high surrogate")
    assert(decode::is_high_surrogate(0xD900), "0xD900 is high surrogate")

    // Not high surrogates
    assert(not decode::is_high_surrogate(0xDC00), "0xDC00 is low, not high")
    assert(not decode::is_high_surrogate(0x0041), "0x0041 is not surrogate")
    assert(not decode::is_high_surrogate(0xD7FF), "0xD7FF is before surrogate range")

    return 0
}

@test
func test_is_low_surrogate() -> I32 {
    // Valid low surrogates
    assert(decode::is_low_surrogate(0xDC00), "0xDC00 is low surrogate")
    assert(decode::is_low_surrogate(0xDFFF), "0xDFFF is low surrogate")
    assert(decode::is_low_surrogate(0xDD00), "0xDD00 is low surrogate")

    // Not low surrogates
    assert(not decode::is_low_surrogate(0xD800), "0xD800 is high, not low")
    assert(not decode::is_low_surrogate(0x0041), "0x0041 is not surrogate")
    assert(not decode::is_low_surrogate(0xE000), "0xE000 is after surrogate range")

    return 0
}

@test
func test_is_surrogate() -> I32 {
    // Any surrogate
    assert(decode::is_surrogate(0xD800), "0xD800 is surrogate")
    assert(decode::is_surrogate(0xDBFF), "0xDBFF is surrogate")
    assert(decode::is_surrogate(0xDC00), "0xDC00 is surrogate")
    assert(decode::is_surrogate(0xDFFF), "0xDFFF is surrogate")

    // Not surrogates
    assert(not decode::is_surrogate(0x0041), "0x0041 is not surrogate")
    assert(not decode::is_surrogate(0xD7FF), "0xD7FF is not surrogate")
    assert(not decode::is_surrogate(0xE000), "0xE000 is not surrogate")

    return 0
}

// ============================================================================
// Surrogate Pair Decoding Tests
// ============================================================================

@test
func test_decode_surrogate_pair() -> I32 {
    // U+1F600 (Grinning Face) = 0xD83D 0xDE00
    let emoji: Char = decode::decode_surrogate_pair(0xD83D, 0xDE00)
    assert((emoji as U32) == 0x1F600, "should decode to U+1F600")

    // U+10000 (first supplementary character) = 0xD800 0xDC00
    let first_supp: Char = decode::decode_surrogate_pair(0xD800, 0xDC00)
    assert((first_supp as U32) == 0x10000, "should decode to U+10000")

    // U+10FFFF (last valid Unicode) = 0xDBFF 0xDFFF
    let last_valid: Char = decode::decode_surrogate_pair(0xDBFF, 0xDFFF)
    assert((last_valid as U32) == 0x10FFFF, "should decode to U+10FFFF")

    return 0
}

// ============================================================================
// UTF-16 Validation Tests
// ============================================================================

@test
func test_is_valid_utf16_bmp() -> I32 {
    // Simple BMP string "Hi!" - allocate and fill
    let ptr: *Unit = alloc(6)  // 3 x 2 bytes
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0x0048          // H
    *(u16_ptr + 1) = 0x0069    // i
    *(u16_ptr + 2) = 0x0021    // !

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 3 }
    assert(decode::is_valid_utf16(slice), "BMP string should be valid")

    dealloc(ptr)
    return 0
}

@test
func test_is_valid_utf16_surrogate_pair() -> I32 {
    // Valid surrogate pair (emoji)
    let ptr: *Unit = alloc(4)  // 2 x 2 bytes
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0xD83D          // High surrogate
    *(u16_ptr + 1) = 0xDE00    // Low surrogate

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 2 }
    assert(decode::is_valid_utf16(slice), "valid surrogate pair should be valid")

    dealloc(ptr)
    return 0
}

@test
func test_is_valid_utf16_unpaired_high() -> I32 {
    // Unpaired high surrogate
    let ptr: *Unit = alloc(2)
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0xD83D

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 1 }
    assert(not decode::is_valid_utf16(slice), "unpaired high surrogate should be invalid")

    dealloc(ptr)
    return 0
}

@test
func test_is_valid_utf16_unpaired_low() -> I32 {
    // Unpaired low surrogate
    let ptr: *Unit = alloc(2)
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0xDC00

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 1 }
    assert(not decode::is_valid_utf16(slice), "unpaired low surrogate should be invalid")

    dealloc(ptr)
    return 0
}

// ============================================================================
// Character Count Tests
// ============================================================================

@test
func test_count_chars_bmp() -> I32 {
    // "Hello" - 5 BMP characters
    let ptr: *Unit = alloc(10)  // 5 x 2 bytes
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0x0048           // H
    *(u16_ptr + 1) = 0x0065     // e
    *(u16_ptr + 2) = 0x006C     // l
    *(u16_ptr + 3) = 0x006C     // l
    *(u16_ptr + 4) = 0x006F     // o

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 5 }
    assert(decode::count_chars_utf16(slice) == 5, "should count 5 chars")

    dealloc(ptr)
    return 0
}

@test
func test_count_chars_with_surrogate() -> I32 {
    // "A" + emoji + "B" = 3 characters but 4 code units
    let ptr: *Unit = alloc(8)  // 4 x 2 bytes
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0x0041           // A
    *(u16_ptr + 1) = 0xD83D     // High surrogate
    *(u16_ptr + 2) = 0xDE00     // Low surrogate
    *(u16_ptr + 3) = 0x0042     // B

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 4 }
    assert(decode::count_chars_utf16(slice) == 3, "should count 3 chars")

    dealloc(ptr)
    return 0
}

// ============================================================================
// Decoding to String Tests
// ============================================================================

@test
func test_decode_ascii() -> I32 {
    // "ABC"
    let ptr: *Unit = alloc(6)  // 3 x 2 bytes
    let u16_ptr: *U16 = ptr as *U16
    *u16_ptr = 0x0041           // A
    *(u16_ptr + 1) = 0x0042     // B
    *(u16_ptr + 2) = 0x0043     // C

    let slice: Slice[U16] = Slice { data: ref *u16_ptr, len: 3 }
    let result: Str = decode::decode_utf16_to_string(slice)
    assert(result == "ABC", "should decode to ABC")

    dealloc(ptr)
    return 0
}
