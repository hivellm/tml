// Tests for TryFrom narrowing and cross conversions
// Many tests are SKIPPED due to codegen bug with static method overload selection
use test
use core::convert::{TryFrom, TryFromIntError}

// ============================================================================
// TryFrom narrowing conversions: I64 -> I32 (WORKING)
// These tests also verify nested enum pattern matching with unit-only enums
// ============================================================================

@test
func test_try_from_i64_to_i32_success() -> I32 {
    let value: I64 = 100
    when I32::try_from(value) {
        Ok(n) => assert_eq(n, 100, "I64 100 -> I32 100"),
        Err(_) => panic("Should succeed")
    }
    return 0
}

@test
func test_try_from_i64_to_i32_overflow_high() -> I32 {
    let value: I64 = 3000000000  // > I32::MAX
    when I32::try_from(value) {
        Ok(_) => panic("Should fail"),
        Err(e) => {
            // Test nested enum pattern matching with TryFromIntError (unit-only enum)
            when e {
                TryFromIntError::Overflow => {},
                _ => panic("Should be Overflow")
            }
        }
    }
    return 0
}

@test
func test_try_from_i64_to_i32_overflow_low() -> I32 {
    let value: I64 = -3000000000  // < I32::MIN
    when I32::try_from(value) {
        Ok(_) => panic("Should fail"),
        Err(e) => {
            when e {
                TryFromIntError::Overflow => {},
                _ => panic("Should be Overflow")
            }
        }
    }
    return 0
}

// ============================================================================
// TryFrom cross conversions: I32 -> U32, I64 -> U64 (same size, working)
// ============================================================================

@test
func test_try_from_i32_to_u32_success() -> I32 {
    let value: I32 = 1000
    when U32::try_from(value) {
        Ok(n) => assert_eq(n, 1000 as U32, "I32 1000 -> U32 1000"),
        Err(_) => panic("Should succeed")
    }
    return 0
}

@test
func test_try_from_i32_to_u32_negative() -> I32 {
    let value: I32 = -1
    when U32::try_from(value) {
        Ok(_) => panic("Should fail"),
        Err(e) => {
            when e {
                TryFromIntError::NegativeToUnsigned => {},
                _ => panic("Should be NegativeToUnsigned")
            }
        }
    }
    return 0
}

@test
func test_try_from_i64_to_u64_success() -> I32 {
    let value: I64 = 9000000000000
    when U64::try_from(value) {
        Ok(n) => assert_eq(n, 9000000000000 as U64, "I64 -> U64 success"),
        Err(_) => panic("Should succeed")
    }
    return 0
}

@test
func test_try_from_i64_to_u64_negative() -> I32 {
    let value: I64 = -100
    when U64::try_from(value) {
        Ok(_) => panic("Should fail"),
        Err(e) => {
            when e {
                TryFromIntError::NegativeToUnsigned => {},
                _ => panic("Should be NegativeToUnsigned")
            }
        }
    }
    return 0
}

@test
func test_try_from_u32_to_i32_success() -> I32 {
    let value: U32 = 2000000000  // < I32::MAX
    when I32::try_from(value) {
        Ok(n) => assert_eq(n, 2000000000, "U32 -> I32 success"),
        Err(_) => panic("Should succeed")
    }
    return 0
}

@test
func test_try_from_u32_to_i32_overflow() -> I32 {
    let value: U32 = 3000000000  // > I32::MAX
    when I32::try_from(value) {
        Ok(_) => panic("Should fail"),
        Err(_) => {}
    }
    return 0
}

// ============================================================================
// SKIPPED TESTS: Codegen bug with static method overload selection
// The following conversions fail because the codegen selects wrong try_from:
// - I64 -> I16, I8 (expects I16/I8 but argument is I64)
// - I32 -> I16, I8 (same issue)
// - U64 -> U32, U16, U8 (same issue)
// - U32 -> U16, U8 (same issue)
// - I8/U8 cross conversions (same issue)
// ============================================================================

