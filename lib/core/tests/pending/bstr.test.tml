// Tests for ByteStr type
// Note: Some ByteStr methods have codegen issues (return () instead of proper type)
// This test file covers functionality that currently works.

use test
use core::bstr::ByteStr

// ============ Creation Tests ============

@test
func test_bytestr_from_str() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello")
    assert_eq(bs.len(), 5, "length should be 5")
    return 0
}

@test
func test_bytestr_empty() -> I32 {
    let empty_bytes: [U8] = []
    let bs: ref ByteStr = ByteStr::new(ref empty_bytes)
    assert(bs.is_empty(), "should be empty")
    assert_eq(bs.len(), 0, "length should be 0")
    return 0
}

// ============ Length and Empty Tests ============

@test
func test_bytestr_len() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    assert_eq(bs.len(), 11, "length should be 11")
    return 0
}

@test
func test_bytestr_is_empty() -> I32 {
    let empty_bytes: [U8] = []
    let empty: ref ByteStr = ByteStr::new(ref empty_bytes)
    let nonempty: ref ByteStr = ByteStr::from_str("x")

    assert(empty.is_empty(), "empty should be empty")
    assert(not nonempty.is_empty(), "nonempty should not be empty")
    return 0
}

// ============ ASCII Tests ============

@test
func test_bytestr_is_ascii_true() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("Hello World 123!")
    assert(bs.is_ascii(), "ASCII string should be ASCII")
    return 0
}

@test
func test_bytestr_is_ascii_false() -> I32 {
    // Create a byte string with non-ASCII bytes
    let bytes: [U8] = [104, 101, 108, 108, 111, 255]  // "hello" + 0xFF
    let bs: ref ByteStr = ByteStr::new(ref bytes)
    assert(not bs.is_ascii(), "should not be ASCII due to 0xFF")
    return 0
}

@test
func test_bytestr_is_ascii_high_byte() -> I32 {
    let bytes: [U8] = [128]  // Just above ASCII range
    let bs: ref ByteStr = ByteStr::new(ref bytes)
    assert(not bs.is_ascii(), "128 is not ASCII")
    return 0
}

// ============ Prefix/Suffix Tests ============

@test
func test_bytestr_starts_with() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    let prefix: [U8] = [104, 101, 108, 108, 111]  // "hello"
    assert(bs.starts_with_bytes(ref prefix), "should start with 'hello'")
    return 0
}

@test
func test_bytestr_starts_with_full() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello")
    let prefix: [U8] = [104, 101, 108, 108, 111]  // "hello"
    assert(bs.starts_with_bytes(ref prefix), "should match full string")
    return 0
}

@test
func test_bytestr_starts_with_empty() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello")
    let empty: [U8] = []
    assert(bs.starts_with_bytes(ref empty), "should start with empty")
    return 0
}

@test
func test_bytestr_starts_with_false() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello")
    let prefix: [U8] = [119, 111, 114, 108, 100]  // "world"
    assert(not bs.starts_with_bytes(ref prefix), "should not start with 'world'")
    return 0
}

@test
func test_bytestr_ends_with() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    let suffix: [U8] = [119, 111, 114, 108, 100]  // "world"
    assert(bs.ends_with_bytes(ref suffix), "should end with 'world'")
    return 0
}

@test
func test_bytestr_ends_with_false() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    let suffix: [U8] = [104, 101, 108, 108, 111]  // "hello"
    assert(not bs.ends_with_bytes(ref suffix), "should not end with 'hello'")
    return 0
}

// ============ Search Tests ============

@test
func test_bytestr_contains() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    let needle: [U8] = [111, 32, 119]  // "o w"
    assert(bs.contains_bytes(ref needle), "should contain 'o w'")
    return 0
}

@test
func test_bytestr_contains_false() -> I32 {
    let bs: ref ByteStr = ByteStr::from_str("hello world")
    let needle: [U8] = [120, 121, 122]  // "xyz"
    assert(not bs.contains_bytes(ref needle), "should not contain 'xyz'")
    return 0
}

// ============ Case-Insensitive Comparison ============

@test
func test_bytestr_eq_ignore_ascii_case_equal() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("Hello")
    let b: ref ByteStr = ByteStr::from_str("HELLO")
    assert(a.eq_ignore_ascii_case(b), "should be equal ignoring case")
    return 0
}

@test
func test_bytestr_eq_ignore_ascii_case_different() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("Hello")
    let b: ref ByteStr = ByteStr::from_str("World")
    assert(not a.eq_ignore_ascii_case(b), "should not be equal")
    return 0
}

@test
func test_bytestr_eq_ignore_ascii_case_different_length() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("Hello")
    let b: ref ByteStr = ByteStr::from_str("Hell")
    assert(not a.eq_ignore_ascii_case(b), "different length should not be equal")
    return 0
}

// ============ Equality Tests ============

@test
func test_bytestr_equality() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("hello")
    let b: ref ByteStr = ByteStr::from_str("hello")
    let c: ref ByteStr = ByteStr::from_str("world")

    assert(a.eq(b), "same content should be equal")
    assert(not a.eq(c), "different content should not be equal")
    return 0
}

// ============ Hash Tests ============

@test
func test_bytestr_hash_equal_strings() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("hello")
    let b: ref ByteStr = ByteStr::from_str("hello")
    assert_eq(a.hash(), b.hash(), "equal strings should have equal hash")
    return 0
}

@test
func test_bytestr_hash_different_strings() -> I32 {
    let a: ref ByteStr = ByteStr::from_str("hello")
    let b: ref ByteStr = ByteStr::from_str("world")
    // Note: Hash collisions are possible but unlikely for these simple strings
    assert(a.hash() != b.hash(), "different strings should have different hash (usually)")
    return 0
}

// ============ Pending Tests ============
// The following tests are pending until codegen issues are fixed:
// - first/last tests (Maybe[U8] methods return wrong type)
// - find/rfind tests (Maybe[I64] methods return wrong type)
// - iter tests (iter() returns () instead of ByteStrIter)
// - trim tests (trim_ascii* methods return () instead of ref ByteStr)
// - to_ascii_uppercase/lowercase tests (return () instead of [U8])
// - ordering tests (cmp method has issues)

