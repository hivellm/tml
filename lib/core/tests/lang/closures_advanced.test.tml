// Tests for closures - higher-order functions, composition, variable capture
use test

// =============================================================================
// Closures as function arguments (higher-order functions)
// =============================================================================

func apply_twice(f: func(I32) -> I32, x: I32) -> I32 {
    return f(f(x))
}

@test
func test_apply_twice_double() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = apply_twice(double, 3)
    assert_eq(result, 12, "double applied twice to 3 should be 12")
    return 0
}

@test
func test_apply_twice_increment() -> I32 {
    let inc: func(I32) -> I32 = do(x: I32) -> I32 { x + 1 }
    let result: I32 = apply_twice(inc, 5)
    assert_eq(result, 7, "increment applied twice to 5 should be 7")
    return 0
}

// =============================================================================
// Closure with multiple parameters
// =============================================================================

@test
func test_closure_two_params() -> I32 {
    let add: func(I32, I32) -> I32 = do(a: I32, b: I32) -> I32 { a + b }
    assert_eq(add(3, 4), 7, "add(3, 4) should be 7")
    return 0
}

@test
func test_closure_multiply_params() -> I32 {
    let mul: func(I32, I32) -> I32 = do(a: I32, b: I32) -> I32 { a * b }
    assert_eq(mul(6, 7), 42, "mul(6, 7) should be 42")
    return 0
}

// =============================================================================
// Closure returning Bool (predicate)
// =============================================================================

func count_matching(pred: func(I32) -> Bool, limit: I32) -> I32 {
    var count: I32 = 0
    var i: I32 = 0
    loop (i < limit) {
        if pred(i) {
            count = count + 1
        }
        i = i + 1
    }
    return count
}

@test
func test_closure_predicate_even() -> I32 {
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let count: I32 = count_matching(is_even, 10)
    assert_eq(count, 5, "0-9 has 5 even numbers")
    return 0
}

@test
func test_closure_predicate_positive() -> I32 {
    let is_positive: func(I32) -> Bool = do(x: I32) -> Bool { x > 0 }
    let count: I32 = count_matching(is_positive, 5)
    // 0,1,2,3,4 -> 1,2,3,4 positive = 4
    assert_eq(count, 4, "0-4 has 4 positive numbers")
    return 0
}

// =============================================================================
// Closure used with array.map
// =============================================================================

@test
func test_closure_array_map_negate() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    let negate: func(I32) -> I32 = do(x: I32) -> I32 { 0 - x }
    let result: [I32; 3] = arr.map(negate)
    assert_eq(result[0], -1, "negated[0] should be -1")
    assert_eq(result[1], -2, "negated[1] should be -2")
    assert_eq(result[2], -3, "negated[2] should be -3")
    return 0
}

@test
func test_closure_array_map_add_ten() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]
    let add_ten: func(I32) -> I32 = do(x: I32) -> I32 { x + 10 }
    let result: [I32; 3] = arr.map(add_ten)
    assert_eq(result[0], 20, "result[0] should be 20")
    assert_eq(result[1], 30, "result[1] should be 30")
    assert_eq(result[2], 40, "result[2] should be 40")
    return 0
}

// NOTE: Closures capturing outer variables (closure factories) are a known
// codegen limitation and tested separately when that feature is implemented.
