// Tests for higher-order functions - functions as parameters and return values
use test

// =============================================================================
// Function as parameter
// =============================================================================

func apply(f: func(I32) -> I32, x: I32) -> I32 {
    return f(x)
}

func double(x: I32) -> I32 {
    return x * 2
}

func square(x: I32) -> I32 {
    return x * x
}

func negate(x: I32) -> I32 {
    return 0 - x
}

@test
func test_apply_double() -> I32 {
    assert_eq(apply(double, 5), 10, "apply(double, 5) should be 10")
    return 0
}

@test
func test_apply_square() -> I32 {
    assert_eq(apply(square, 4), 16, "apply(square, 4) should be 16")
    return 0
}

@test
func test_apply_negate() -> I32 {
    assert_eq(apply(negate, 7), -7, "apply(negate, 7) should be -7")
    return 0
}

// =============================================================================
// Apply twice
// =============================================================================

func apply_twice(f: func(I32) -> I32, x: I32) -> I32 {
    return f(f(x))
}

@test
func test_apply_twice_double() -> I32 {
    assert_eq(apply_twice(double, 3), 12, "double(double(3)) should be 12")
    return 0
}

@test
func test_apply_twice_square() -> I32 {
    assert_eq(apply_twice(square, 2), 16, "square(square(2)) = (2^2)^2 = 16")
    return 0
}

// =============================================================================
// Predicate functions
// =============================================================================

func count_matching(arr: [I32; 5], pred: func(I32) -> Bool) -> I32 {
    var count: I32 = 0
    for i in 0 to 5 {
        if pred(arr[i]) {
            count = count + 1
        }
    }
    return count
}

func is_positive(x: I32) -> Bool {
    return x > 0
}

func is_even(x: I32) -> Bool {
    return x % 2 == 0
}

@test
func test_count_positive() -> I32 {
    let arr: [I32; 5] = [-2, -1, 0, 1, 2]
    assert_eq(count_matching(arr, is_positive), 2, "2 positive numbers")
    return 0
}

@test
func test_count_even() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    assert_eq(count_matching(arr, is_even), 2, "2 even numbers in [1..5]")
    return 0
}

// =============================================================================
// Closure as higher-order argument
// =============================================================================

@test
func test_closure_as_hof_arg() -> I32 {
    let result: I32 = apply(do(x: I32) -> I32 { x + 100 }, 5)
    assert_eq(result, 105, "closure adding 100 should give 105")
    return 0
}

@test
func test_closure_predicate() -> I32 {
    let arr: [I32; 5] = [10, 20, 30, 40, 50]
    let count: I32 = count_matching(arr, do(x: I32) -> Bool { x > 25 })
    assert_eq(count, 3, "3 values > 25 in [10,20,30,40,50]")
    return 0
}

// =============================================================================
// Function composition via apply chain
// =============================================================================

@test
func test_function_chain() -> I32 {
    let x: I32 = 3
    let step1: I32 = apply(double, x)     // 6
    let step2: I32 = apply(square, step1)  // 36
    let step3: I32 = apply(negate, step2)  // -36
    assert_eq(step3, -36, "double then square then negate: 3->6->36->-36")
    return 0
}
