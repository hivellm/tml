// Consolidated language tests - Variables, Control Flow, When, Arrays
// Total @test count: 41
// Sources: variables_scope.test.tml (11), loops_control.test.tml (13),
//          when_basic.test.tml (9), array_ops.test.tml (8)
use test

// =============================================================================
// SECTION: Variables and Scope (from variables_scope.test.tml)
// =============================================================================

// -- let vs var (immutable vs mutable) --

@test
func test_let_immutable() -> I32 {
    let x: I32 = 42
    assert_eq(x, 42, "let should bind immutably")
    return 0
}

@test
func test_var_mutable() -> I32 {
    var x: I32 = 10
    x = 20
    assert_eq(x, 20, "var should be mutable")
    return 0
}

@test
func test_var_increment() -> I32 {
    var count: I32 = 0
    count = count + 1
    count = count + 1
    count = count + 1
    assert_eq(count, 3, "count should be 3 after 3 increments")
    return 0
}

// -- Multiple variables --

@test
func test_multiple_vars() -> I32 {
    let a: I32 = 1
    let b: I32 = 2
    let c: I32 = 3
    assert_eq(a + b + c, 6, "sum of 1+2+3 should be 6")
    return 0
}

@test
func test_var_depends_on_other() -> I32 {
    let x: I32 = 10
    let y: I32 = x * 2
    let z: I32 = y + x
    assert_eq(z, 30, "z = (10*2) + 10 = 30")
    return 0
}

// -- Block scoping --

@test
func test_inner_scope() -> I32 {
    let x: I32 = 10
    var result: I32 = 0
    if true {
        let y: I32 = 20
        result = x + y
    }
    assert_eq(result, 30, "inner scope should access outer and local vars")
    return 0
}

@test
func test_loop_scope() -> I32 {
    var total: I32 = 0
    for i in 0 to 5 {
        let doubled: I32 = i * 2
        total = total + doubled
    }
    // 0+2+4+6+8 = 20
    assert_eq(total, 20, "loop scope vars should work correctly")
    return 0
}

// -- Variable reassignment chain --

@test
func test_var_reassignment_chain() -> I32 {
    var x: I32 = 5
    x = x + 1
    x = x * 2
    assert_eq(x, 12, "reassignment chain: (5+1)*2 = 12")
    return 0
}

// -- Different types --

@test
func test_bool_variables() -> I32 {
    let t: Bool = true
    let f: Bool = false
    assert(t, "true should be truthy")
    assert(not f, "false should be falsy")
    return 0
}

@test
func test_f64_variables() -> I32 {
    let pi: F64 = 3.14159
    let r: F64 = 2.0
    let area: F64 = pi * r * r
    // area ~ 12.566
    assert(area > 12.0, "area should be > 12")
    assert(area < 13.0, "area should be < 13")
    return 0
}

@test
func test_str_variables() -> I32 {
    let greeting: Str = "hello"
    let target: Str = "world"
    assert_eq(greeting, "hello", "string var should hold value")
    assert_eq(target, "world", "string var should hold value")
    return 0
}

// =============================================================================
// SECTION: Loops and Control Flow (from loops_control.test.tml)
// =============================================================================

// -- loop (while-style) --

@test
func test_loop_count_to_ten() -> I32 {
    var count: I32 = 0
    loop (count < 10) {
        count = count + 1
    }
    assert_eq(count, 10, "loop should count to 10")
    return 0
}

@test
func test_loop_sum() -> I32 {
    var sum: I32 = 0
    var i: I32 = 1
    loop (i <= 5) {
        sum = sum + i
        i = i + 1
    }
    assert_eq(sum, 15, "sum of 1..5 should be 15")
    return 0
}

@test
func test_loop_zero_iterations() -> I32 {
    var count: I32 = 0
    loop (false) {
        count = count + 1
    }
    assert_eq(count, 0, "loop(false) should execute 0 times")
    return 0
}

// -- loop with break --

@test
func test_loop_break() -> I32 {
    var i: I32 = 0
    loop (true) {
        if i >= 5 {
            break
        }
        i = i + 1
    }
    assert_eq(i, 5, "loop with break should stop at 5")
    return 0
}

// -- loop with continue --

@test
func test_loop_continue_skip_even() -> I32 {
    var sum: I32 = 0
    var i: I32 = 0
    loop (i < 10) {
        i = i + 1
        if i % 2 == 0 {
            continue
        }
        sum = sum + i
    }
    // sum of odd numbers 1+3+5+7+9 = 25
    assert_eq(sum, 25, "sum of odd numbers 1-9 should be 25")
    return 0
}

// -- for-in range loops --

@test
func test_for_range_to() -> I32 {
    var sum: I32 = 0
    for i in 0 to 5 {
        sum = sum + i
    }
    // 0+1+2+3+4 = 10
    assert_eq(sum, 10, "for 0 to 5 should sum to 10")
    return 0
}

@test
func test_for_range_through() -> I32 {
    var sum: I32 = 0
    for i in 1 through 5 {
        sum = sum + i
    }
    // 1+2+3+4+5 = 15
    assert_eq(sum, 15, "for 1 through 5 should sum to 15")
    return 0
}

// -- if/else --

func classify_sign(n: I32) -> I32 {
    if n > 0 {
        return 1
    } else if n < 0 {
        return -1
    } else {
        return 0
    }
}

@test
func test_if_positive() -> I32 {
    assert_eq(classify_sign(42), 1, "positive should return 1")
    return 0
}

@test
func test_if_negative() -> I32 {
    assert_eq(classify_sign(-7), -1, "negative should return -1")
    return 0
}

@test
func test_if_zero() -> I32 {
    assert_eq(classify_sign(0), 0, "zero should return 0")
    return 0
}

// -- nested loops --

@test
func test_nested_loop() -> I32 {
    var total: I32 = 0
    var i: I32 = 0
    loop (i < 3) {
        var j: I32 = 0
        loop (j < 4) {
            total = total + 1
            j = j + 1
        }
        i = i + 1
    }
    assert_eq(total, 12, "3x4 nested loop should be 12")
    return 0
}

// -- Ternary / conditional expression --

@test
func test_ternary_true() -> I32 {
    let x: I32 = 5
    let result: I32 = if x > 3 { 100 } else { 0 }
    assert_eq(result, 100, "ternary true branch should be 100")
    return 0
}

@test
func test_ternary_false() -> I32 {
    let x: I32 = 1
    let result: I32 = if x > 3 { 100 } else { 0 }
    assert_eq(result, 0, "ternary false branch should be 0")
    return 0
}

// =============================================================================
// SECTION: When (Match) Expressions (from when_basic.test.tml)
// =============================================================================

// -- when with integer matching --

func classify_number(n: I32) -> I32 {
    when n {
        0 => return 0,
        1 => return 1,
        _ => return 2
    }
}

@test
func test_when_int_zero() -> I32 {
    assert_eq(classify_number(0), 0, "when 0 should return 0")
    return 0
}

@test
func test_when_int_one() -> I32 {
    assert_eq(classify_number(1), 1, "when 1 should return 1")
    return 0
}

@test
func test_when_int_wildcard() -> I32 {
    assert_eq(classify_number(42), 2, "when 42 should match wildcard")
    assert_eq(classify_number(-5), 2, "when -5 should match wildcard")
    return 0
}

// -- when with Maybe type --

func unwrap_or_default(m: Maybe[I32], default_val: I32) -> I32 {
    when m {
        Just(v) => return v,
        Nothing => return default_val
    }
}

@test
func test_when_maybe_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert_eq(unwrap_or_default(m, 0), 42, "when Just(42) should unwrap to 42")
    return 0
}

@test
func test_when_maybe_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    assert_eq(unwrap_or_default(m, -1), -1, "when Nothing should use default")
    return 0
}

// -- when as expression (returning a value) --

func abs_val(n: I32) -> I32 {
    if n < 0 {
        return 0 - n
    }
    return n
}

@test
func test_when_expression_value() -> I32 {
    let m: Maybe[I32] = Just(10)
    let result: I32 = when m {
        Just(v) => v * 2,
        Nothing => 0
    }
    assert_eq(result, 20, "when expression should produce 20")
    return 0
}

@test
func test_when_expression_nothing_branch() -> I32 {
    let m: Maybe[I32] = Nothing
    let result: I32 = when m {
        Just(v) => v * 2,
        Nothing => -1
    }
    assert_eq(result, -1, "when expression Nothing branch should produce -1")
    return 0
}

// -- when with Bool --

func bool_to_int(b: Bool) -> I32 {
    when b {
        true => return 1,
        false => return 0
    }
}

@test
func test_when_bool_true() -> I32 {
    assert_eq(bool_to_int(true), 1, "when true should return 1")
    return 0
}

@test
func test_when_bool_false() -> I32 {
    assert_eq(bool_to_int(false), 0, "when false should return 0")
    return 0
}

// =============================================================================
// SECTION: Array Operations (from array_ops.test.tml)
// =============================================================================

// -- Array literals and indexing --

@test
func test_array_literal() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]
    assert_eq(arr[0], 10, "arr[0] should be 10")
    assert_eq(arr[1], 20, "arr[1] should be 20")
    assert_eq(arr[2], 30, "arr[2] should be 30")
    return 0
}

@test
func test_array_single_element() -> I32 {
    let arr: [I32; 1] = [42]
    assert_eq(arr[0], 42, "single element array")
    return 0
}

@test
func test_array_five_elements() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3] + arr[4]
    assert_eq(sum, 15, "sum of [1,2,3,4,5] should be 15")
    return 0
}

// -- Array map --

@test
func test_array_map_double() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    let doubled: [I32; 3] = arr.map(do(x: I32) -> I32 { x * 2 })
    assert_eq(doubled[0], 2, "doubled[0] should be 2")
    assert_eq(doubled[1], 4, "doubled[1] should be 4")
    assert_eq(doubled[2], 6, "doubled[2] should be 6")
    return 0
}

@test
func test_array_map_negate() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]
    let negated: [I32; 3] = arr.map(do(x: I32) -> I32 { 0 - x })
    assert_eq(negated[0], -10, "negated[0] should be -10")
    assert_eq(negated[1], -20, "negated[1] should be -20")
    assert_eq(negated[2], -30, "negated[2] should be -30")
    return 0
}

// -- Array as function parameter --

func sum_array(arr: [I32; 4]) -> I32 {
    return arr[0] + arr[1] + arr[2] + arr[3]
}

@test
func test_array_as_param() -> I32 {
    let arr: [I32; 4] = [10, 20, 30, 40]
    assert_eq(sum_array(arr), 100, "sum should be 100")
    return 0
}

func max_of_three(arr: [I32; 3]) -> I32 {
    var result: I32 = arr[0]
    if arr[1] > result {
        result = arr[1]
    }
    if arr[2] > result {
        result = arr[2]
    }
    return result
}

@test
func test_array_max() -> I32 {
    assert_eq(max_of_three([3, 7, 2]), 7, "max of [3,7,2] should be 7")
    assert_eq(max_of_three([10, 5, 8]), 10, "max of [10,5,8] should be 10")
    assert_eq(max_of_three([1, 2, 9]), 9, "max of [1,2,9] should be 9")
    return 0
}

// -- Array with loop --

@test
func test_array_sum_with_loop() -> I32 {
    let arr: [I32; 5] = [2, 4, 6, 8, 10]
    var sum: I32 = 0
    for i in 0 to 5 {
        sum = sum + arr[i]
    }
    assert_eq(sum, 30, "sum of [2,4,6,8,10] should be 30")
    return 0
}
