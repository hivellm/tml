// Tests for when (match) expressions - basic patterns
use test

// =============================================================================
// when with integer matching
// =============================================================================

func classify_number(n: I32) -> I32 {
    when n {
        0 => return 0,
        1 => return 1,
        _ => return 2
    }
}

@test
func test_when_int_zero() -> I32 {
    assert_eq(classify_number(0), 0, "when 0 should return 0")
    return 0
}

@test
func test_when_int_one() -> I32 {
    assert_eq(classify_number(1), 1, "when 1 should return 1")
    return 0
}

@test
func test_when_int_wildcard() -> I32 {
    assert_eq(classify_number(42), 2, "when 42 should match wildcard")
    assert_eq(classify_number(-5), 2, "when -5 should match wildcard")
    return 0
}

// =============================================================================
// when with Maybe type
// =============================================================================

func unwrap_or_default(m: Maybe[I32], default_val: I32) -> I32 {
    when m {
        Just(v) => return v,
        Nothing => return default_val
    }
}

@test
func test_when_maybe_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert_eq(unwrap_or_default(m, 0), 42, "when Just(42) should unwrap to 42")
    return 0
}

@test
func test_when_maybe_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    assert_eq(unwrap_or_default(m, -1), -1, "when Nothing should use default")
    return 0
}

// =============================================================================
// when as expression (returning a value)
// =============================================================================

func abs_val(n: I32) -> I32 {
    if n < 0 {
        return 0 - n
    }
    return n
}

@test
func test_when_expression_value() -> I32 {
    let m: Maybe[I32] = Just(10)
    let result: I32 = when m {
        Just(v) => v * 2,
        Nothing => 0
    }
    assert_eq(result, 20, "when expression should produce 20")
    return 0
}

@test
func test_when_expression_nothing_branch() -> I32 {
    let m: Maybe[I32] = Nothing
    let result: I32 = when m {
        Just(v) => v * 2,
        Nothing => -1
    }
    assert_eq(result, -1, "when expression Nothing branch should produce -1")
    return 0
}

// =============================================================================
// when with Bool
// =============================================================================

func bool_to_int(b: Bool) -> I32 {
    when b {
        true => return 1,
        false => return 0
    }
}

@test
func test_when_bool_true() -> I32 {
    assert_eq(bool_to_int(true), 1, "when true should return 1")
    return 0
}

@test
func test_when_bool_false() -> I32 {
    assert_eq(bool_to_int(false), 0, "when false should return 0")
    return 0
}
