// Tests for nested types, composition, and type methods
use test

// =============================================================================
// Type with Maybe field
// =============================================================================

type User {
    age: I32,
    level: I32
}

impl User {
    func new(age: I32) -> User {
        return User { age: age, level: 1 }
    }

    func with_level(age: I32, lvl: I32) -> User {
        return User { age: age, level: lvl }
    }

    func is_adult(this) -> Bool {
        return this.age >= 18
    }

    func level_up(this) -> User {
        return User { age: this.age, level: this.level + 1 }
    }
}

@test
func test_user_default_level() -> I32 {
    let u: User = User::new(30)
    assert_eq(u.level, 1, "default level should be 1")
    return 0
}

@test
func test_user_with_level() -> I32 {
    let u: User = User::with_level(25, 5)
    assert_eq(u.level, 5, "level should be 5")
    return 0
}

@test
func test_user_is_adult() -> I32 {
    let adult: User = User::new(30)
    let minor: User = User::new(15)
    assert(adult.is_adult(), "30 should be adult")
    assert(not minor.is_adult(), "15 should not be adult")
    return 0
}

@test
func test_user_level_up() -> I32 {
    let u: User = User::new(20)
    let u2: User = u.level_up().level_up()
    assert_eq(u2.level, 3, "two level_ups should be level 3")
    return 0
}

// =============================================================================
// Type composition
// =============================================================================

type Point {
    x: I32,
    y: I32
}

impl Point {
    func origin() -> Point {
        return Point { x: 0, y: 0 }
    }

    func distance_sq(this, other: Point) -> I32 {
        let dx: I32 = this.x - other.x
        let dy: I32 = this.y - other.y
        return dx * dx + dy * dy
    }
}

type Line {
    start: Point,
    end_pt: Point
}

impl Line {
    func length_sq(this) -> I32 {
        return this.start.distance_sq(this.end_pt)
    }
}

@test
func test_point_origin() -> I32 {
    let p: Point = Point::origin()
    assert_eq(p.x, 0, "origin x should be 0")
    assert_eq(p.y, 0, "origin y should be 0")
    return 0
}

@test
func test_point_distance_sq() -> I32 {
    let a: Point = Point { x: 0, y: 0 }
    let b: Point = Point { x: 3, y: 4 }
    assert_eq(a.distance_sq(b), 25, "distance^2 from origin to (3,4) should be 25")
    return 0
}

@test
func test_line_length_sq() -> I32 {
    let l: Line = Line {
        start: Point { x: 1, y: 1 },
        end_pt: Point { x: 4, y: 5 }
    }
    assert_eq(l.length_sq(), 25, "line (1,1)-(4,5) length^2 should be 25")
    return 0
}

// =============================================================================
// Type with mutable fields
// =============================================================================

type Accumulator {
    total: I32,
    count: I32
}

impl Accumulator {
    func empty() -> Accumulator {
        return Accumulator { total: 0, count: 0 }
    }

    func add(this, value: I32) -> Accumulator {
        return Accumulator { total: this.total + value, count: this.count + 1 }
    }

    func average(this) -> I32 {
        if this.count == 0 {
            return 0
        }
        return this.total / this.count
    }
}

@test
func test_accumulator_empty() -> I32 {
    let acc: Accumulator = Accumulator::empty()
    assert_eq(acc.total, 0, "empty total should be 0")
    assert_eq(acc.count, 0, "empty count should be 0")
    return 0
}

@test
func test_accumulator_add() -> I32 {
    let acc: Accumulator = Accumulator::empty()
    let acc2: Accumulator = acc.add(10).add(20).add(30)
    assert_eq(acc2.total, 60, "total should be 60")
    assert_eq(acc2.count, 3, "count should be 3")
    assert_eq(acc2.average(), 20, "average should be 20")
    return 0
}
