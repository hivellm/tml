// Tests for core::slice MutSlice â€” swap, reverse, rotate_left, rotate_right, fill, get, get_mut
// NOTE: ptr_offset on *Unit defaults to i32 element stride, so use element indices (0,1,2)
use test::{assert, assert_eq}
use core::slice::{Slice, MutSlice}

@test
func test_mutslice_len() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)

    let s: MutSlice[I32] = MutSlice { data: ptr, len: 3 }
    assert_eq(s.len(), 3, "len should be 3")
    assert(not s.is_empty(), "should not be empty")

    dealloc(ptr)
    return 0
}

@test
func test_mutslice_get() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 10)
    atomic_store(ptr_offset(ptr, 1), 20)
    atomic_store(ptr_offset(ptr, 2), 30)

    let s: MutSlice[I32] = MutSlice { data: ptr, len: 3 }
    let v = s.get(1)
    assert(v.is_just(), "get(1) should return Just")
    assert_eq(*v.unwrap(), 20, "get(1) should be 20")

    let oob = s.get(5)
    assert(oob.is_nothing(), "get(5) should be Nothing")

    dealloc(ptr)
    return 0
}

@test
func test_mutslice_swap() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 10)
    atomic_store(ptr_offset(ptr, 1), 20)
    atomic_store(ptr_offset(ptr, 2), 30)

    let mut s: MutSlice[I32] = MutSlice { data: ptr, len: 3 }
    s.swap(0, 2)

    let check: Slice[I32] = Slice { data: ptr, len: 3 }
    assert_eq(*check.get(0).unwrap(), 30, "after swap, [0] should be 30")
    assert_eq(*check.get(2).unwrap(), 10, "after swap, [2] should be 10")

    dealloc(ptr)
    return 0
}

@test
func test_mutslice_reverse() -> I32 {
    let ptr: *Unit = alloc(20)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    atomic_store(ptr_offset(ptr, 3), 4)
    atomic_store(ptr_offset(ptr, 4), 5)

    let mut s: MutSlice[I32] = MutSlice { data: ptr, len: 5 }
    s.reverse()

    let check: Slice[I32] = Slice { data: ptr, len: 5 }
    assert_eq(*check.get(0).unwrap(), 5, "reversed[0] should be 5")
    assert_eq(*check.get(1).unwrap(), 4, "reversed[1] should be 4")
    assert_eq(*check.get(2).unwrap(), 3, "reversed[2] should be 3")
    assert_eq(*check.get(3).unwrap(), 2, "reversed[3] should be 2")
    assert_eq(*check.get(4).unwrap(), 1, "reversed[4] should be 1")

    dealloc(ptr)
    return 0
}

@test
func test_mutslice_is_sorted() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)

    let mut s: MutSlice[I32] = MutSlice { data: ptr, len: 3 }
    assert(s.is_sorted(), "1,2,3 should be sorted")

    s.reverse()
    assert(not s.is_sorted(), "3,2,1 should not be sorted")

    dealloc(ptr)
    return 0
}

@test
func test_mutslice_fill() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 0)
    atomic_store(ptr_offset(ptr, 1), 0)
    atomic_store(ptr_offset(ptr, 2), 0)

    let mut s: MutSlice[I32] = MutSlice { data: ptr, len: 3 }
    s.fill(42)

    let check: Slice[I32] = Slice { data: ptr, len: 3 }
    assert_eq(*check.get(0).unwrap(), 42, "fill[0] should be 42")
    assert_eq(*check.get(1).unwrap(), 42, "fill[1] should be 42")
    assert_eq(*check.get(2).unwrap(), 42, "fill[2] should be 42")

    dealloc(ptr)
    return 0
}
