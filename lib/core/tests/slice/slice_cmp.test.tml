// Tests for core::slice::cmp â€” contains, starts_with, ends_with, position, rposition, eq (9 functions)
// NOTE: ptr_offset on *Unit defaults to i32 element stride, so use element indices (0,1,2) not byte offsets
use test::{assert, assert_eq}
use core::slice::Slice

@test
func test_array_index_basic() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]
    assert_eq(arr[0], 10, "first element should be 10")
    assert_eq(arr[1], 20, "second element should be 20")
    assert_eq(arr[2], 30, "third element should be 30")
    return 0
}

@test
func test_slice_contains_found() -> I32 {
    let ptr: *Unit = alloc(20)
    atomic_store(ptr, 10)
    atomic_store(ptr_offset(ptr, 1), 20)
    atomic_store(ptr_offset(ptr, 2), 30)
    atomic_store(ptr_offset(ptr, 3), 40)
    atomic_store(ptr_offset(ptr, 4), 50)

    let s: Slice[I32] = Slice { data: ptr, len: 5 }
    assert(s.contains(ref 10), "should contain first element")
    assert(s.contains(ref 30), "should contain middle element")
    assert(s.contains(ref 50), "should contain last element")
    dealloc(ptr)
    return 0
}

@test
func test_slice_contains_not_found() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)

    let s: Slice[I32] = Slice { data: ptr, len: 3 }
    assert(not s.contains(ref 0), "should not contain 0")
    assert(not s.contains(ref 99), "should not contain 99")
    dealloc(ptr)
    return 0
}

@test
func test_slice_starts_with_match() -> I32 {
    let ptr: *Unit = alloc(20)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    atomic_store(ptr_offset(ptr, 3), 4)
    atomic_store(ptr_offset(ptr, 4), 5)
    let s: Slice[I32] = Slice { data: ptr, len: 5 }

    let prefix_ptr: *Unit = alloc(8)
    atomic_store(prefix_ptr, 1)
    atomic_store(ptr_offset(prefix_ptr, 1), 2)
    let prefix: Slice[I32] = Slice { data: prefix_ptr, len: 2 }

    assert(s.starts_with(prefix), "should start with [1,2]")

    dealloc(ptr)
    dealloc(prefix_ptr)
    return 0
}

@test
func test_slice_starts_with_no_match() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    let s: Slice[I32] = Slice { data: ptr, len: 3 }

    let bad_ptr: *Unit = alloc(8)
    atomic_store(bad_ptr, 1)
    atomic_store(ptr_offset(bad_ptr, 1), 9)
    let bad: Slice[I32] = Slice { data: bad_ptr, len: 2 }

    assert(not s.starts_with(bad), "should not start with [1,9]")

    dealloc(ptr)
    dealloc(bad_ptr)
    return 0
}

@test
func test_slice_ends_with_match() -> I32 {
    let ptr: *Unit = alloc(20)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    atomic_store(ptr_offset(ptr, 3), 4)
    atomic_store(ptr_offset(ptr, 4), 5)
    let s: Slice[I32] = Slice { data: ptr, len: 5 }

    let suffix_ptr: *Unit = alloc(8)
    atomic_store(suffix_ptr, 4)
    atomic_store(ptr_offset(suffix_ptr, 1), 5)
    let suffix: Slice[I32] = Slice { data: suffix_ptr, len: 2 }

    assert(s.ends_with(suffix), "should end with [4,5]")

    dealloc(ptr)
    dealloc(suffix_ptr)
    return 0
}

@test
func test_slice_ends_with_no_match() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    let s: Slice[I32] = Slice { data: ptr, len: 3 }

    let bad_ptr: *Unit = alloc(8)
    atomic_store(bad_ptr, 9)
    atomic_store(ptr_offset(bad_ptr, 1), 3)
    let bad: Slice[I32] = Slice { data: bad_ptr, len: 2 }

    assert(not s.ends_with(bad), "should not end with [9,3]")

    dealloc(ptr)
    dealloc(bad_ptr)
    return 0
}

@test
func test_slice_position_found() -> I32 {
    let ptr: *Unit = alloc(16)
    atomic_store(ptr, 10)
    atomic_store(ptr_offset(ptr, 1), 40)
    atomic_store(ptr_offset(ptr, 2), 30)
    atomic_store(ptr_offset(ptr, 3), 40)
    let s: Slice[I32] = Slice { data: ptr, len: 4 }

    let pos = s.position(ref 40)
    assert(pos.is_just(), "should find 40")

    dealloc(ptr)
    return 0
}

@test
func test_slice_position_not_found() -> I32 {
    let ptr: *Unit = alloc(12)
    atomic_store(ptr, 1)
    atomic_store(ptr_offset(ptr, 1), 2)
    atomic_store(ptr_offset(ptr, 2), 3)
    let s: Slice[I32] = Slice { data: ptr, len: 3 }

    let pos = s.position(ref 99)
    assert(pos.is_nothing(), "should not find 99")

    dealloc(ptr)
    return 0
}

@test
func test_slice_rposition_found() -> I32 {
    let ptr: *Unit = alloc(16)
    atomic_store(ptr, 10)
    atomic_store(ptr_offset(ptr, 1), 40)
    atomic_store(ptr_offset(ptr, 2), 30)
    atomic_store(ptr_offset(ptr, 3), 40)
    let s: Slice[I32] = Slice { data: ptr, len: 4 }

    let pos = s.rposition(ref 40)
    assert(pos.is_just(), "should find 40 from end")

    dealloc(ptr)
    return 0
}

@test
func test_slice_eq_same() -> I32 {
    let ptr_a: *Unit = alloc(12)
    atomic_store(ptr_a, 1)
    atomic_store(ptr_offset(ptr_a, 1), 2)
    atomic_store(ptr_offset(ptr_a, 2), 3)

    let ptr_b: *Unit = alloc(12)
    atomic_store(ptr_b, 1)
    atomic_store(ptr_offset(ptr_b, 1), 2)
    atomic_store(ptr_offset(ptr_b, 2), 3)

    let a: Slice[I32] = Slice { data: ptr_a, len: 3 }
    let b: Slice[I32] = Slice { data: ptr_b, len: 3 }

    assert(a.eq(ref b), "equal slices should be eq")

    dealloc(ptr_a)
    dealloc(ptr_b)
    return 0
}

@test
func test_slice_eq_different() -> I32 {
    let ptr_a: *Unit = alloc(12)
    atomic_store(ptr_a, 1)
    atomic_store(ptr_offset(ptr_a, 1), 2)
    atomic_store(ptr_offset(ptr_a, 2), 3)

    let ptr_b: *Unit = alloc(12)
    atomic_store(ptr_b, 1)
    atomic_store(ptr_offset(ptr_b, 1), 2)
    atomic_store(ptr_offset(ptr_b, 2), 999)

    let a: Slice[I32] = Slice { data: ptr_a, len: 3 }
    let b: Slice[I32] = Slice { data: ptr_b, len: 3 }

    assert(not a.eq(ref b), "different slices should not be eq")

    dealloc(ptr_a)
    dealloc(ptr_b)
    return 0
}
