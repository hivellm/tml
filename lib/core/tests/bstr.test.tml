// Consolidated tests for core::bstr (6 tests)
use test
use core::bstr
use core::slice::{Slice}

// --- is_ascii tests ---

@test
func test_is_ascii_all_ascii() -> I32 {
    // "Hello" = [72, 101, 108, 108, 111] - all < 128
    let ptr: *Unit = alloc(5)
    let u8_ptr: *U8 = ptr as *U8
    *u8_ptr = 72 as U8           // H
    *(u8_ptr + 1) = 101 as U8    // e
    *(u8_ptr + 2) = 108 as U8    // l
    *(u8_ptr + 3) = 108 as U8    // l
    *(u8_ptr + 4) = 111 as U8    // o

    let slice: Slice[U8] = Slice { data: ref *u8_ptr, len: 5 }
    assert(bstr::is_ascii(slice), "all ASCII bytes should return true")

    dealloc(ptr)
    return 0
}

@test
func test_is_ascii_with_non_ascii() -> I32 {
    // [65, 200, 67] - 200 > 127 is non-ASCII
    let ptr: *Unit = alloc(3)
    let u8_ptr: *U8 = ptr as *U8
    *u8_ptr = 65 as U8           // A
    *(u8_ptr + 1) = 200 as U8    // non-ASCII
    *(u8_ptr + 2) = 67 as U8     // C

    let slice: Slice[U8] = Slice { data: ref *u8_ptr, len: 3 }
    assert(bstr::is_ascii(slice) == false, "non-ASCII byte should return false")

    dealloc(ptr)
    return 0
}

@test
func test_is_ascii_empty() -> I32 {
    let ptr: *Unit = alloc(1)
    let u8_ptr: *U8 = ptr as *U8
    let slice: Slice[U8] = Slice { data: ref *u8_ptr, len: 0 }
    assert(bstr::is_ascii(slice), "empty slice is ASCII")

    dealloc(ptr)
    return 0
}

// --- starts_with / ends_with tests ---

@test
func test_starts_with_match() -> I32 {
    // bytes = [72, 101, 108, 108, 111] ("Hello")
    // prefix = [72, 101] ("He")
    let ptr: *Unit = alloc(5)
    let u8_ptr: *U8 = ptr as *U8
    *u8_ptr = 72 as U8
    *(u8_ptr + 1) = 101 as U8
    *(u8_ptr + 2) = 108 as U8
    *(u8_ptr + 3) = 108 as U8
    *(u8_ptr + 4) = 111 as U8
    let bytes: Slice[U8] = Slice { data: ref *u8_ptr, len: 5 }

    let pptr: *Unit = alloc(2)
    let pu8: *U8 = pptr as *U8
    *pu8 = 72 as U8
    *(pu8 + 1) = 101 as U8
    let prefix: Slice[U8] = Slice { data: ref *pu8, len: 2 }

    assert(bstr::starts_with(bytes, prefix), "Hello starts with He")

    dealloc(ptr)
    dealloc(pptr)
    return 0
}

@test
func test_starts_with_no_match() -> I32 {
    // bytes = [72, 101] prefix = [88, 89]
    let ptr: *Unit = alloc(2)
    let u8_ptr: *U8 = ptr as *U8
    *u8_ptr = 72 as U8
    *(u8_ptr + 1) = 101 as U8
    let bytes: Slice[U8] = Slice { data: ref *u8_ptr, len: 2 }

    let pptr: *Unit = alloc(2)
    let pu8: *U8 = pptr as *U8
    *pu8 = 88 as U8
    *(pu8 + 1) = 89 as U8
    let prefix: Slice[U8] = Slice { data: ref *pu8, len: 2 }

    assert(bstr::starts_with(bytes, prefix) == false, "no match")

    dealloc(ptr)
    dealloc(pptr)
    return 0
}

@test
func test_ends_with_match() -> I32 {
    // bytes = [72, 101, 108, 108, 111] ("Hello")
    // suffix = [108, 111] ("lo")
    let ptr: *Unit = alloc(5)
    let u8_ptr: *U8 = ptr as *U8
    *u8_ptr = 72 as U8
    *(u8_ptr + 1) = 101 as U8
    *(u8_ptr + 2) = 108 as U8
    *(u8_ptr + 3) = 108 as U8
    *(u8_ptr + 4) = 111 as U8
    let bytes: Slice[U8] = Slice { data: ref *u8_ptr, len: 5 }

    let sptr: *Unit = alloc(2)
    let su8: *U8 = sptr as *U8
    *su8 = 108 as U8
    *(su8 + 1) = 111 as U8
    let suffix: Slice[U8] = Slice { data: ref *su8, len: 2 }

    assert(bstr::ends_with(bytes, suffix), "Hello ends with lo")

    dealloc(ptr)
    dealloc(sptr)
    return 0
}
