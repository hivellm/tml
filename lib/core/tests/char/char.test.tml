// Consolidated tests for core::char (29 tests)
// Classification, case, conversion, validation, escape, decode
// BLOCKED: DecodeUtf16Error::to_string(), debug_string() â€” behavior dispatch on structs
use test
use core::char::methods
use core::char::methods::*
use core::char::convert::*
use core::char::decode::DecodeUtf16Error

// === Classification ===

@test
func test_is_alphabetic_uppercase() -> I32 {
    assert(is_alphabetic('A'), "'A' should be alphabetic")
    assert(is_alphabetic('Z'), "'Z' should be alphabetic")
    return 0
}

@test
func test_is_alphabetic_lowercase() -> I32 {
    assert(is_alphabetic('a'), "'a' should be alphabetic")
    assert(is_alphabetic('z'), "'z' should be alphabetic")
    return 0
}

@test
func test_is_alphabetic_digit() -> I32 {
    assert(not is_alphabetic('0'), "'0' should not be alphabetic")
    assert(not is_alphabetic('9'), "'9' should not be alphabetic")
    return 0
}

@test
func test_is_numeric_digits() -> I32 {
    assert(is_numeric('0'), "'0' should be numeric")
    assert(is_numeric('5'), "'5' should be numeric")
    assert(is_numeric('9'), "'9' should be numeric")
    assert(not is_numeric('a'), "'a' should not be numeric")
    return 0
}

@test
func test_is_alphanumeric() -> I32 {
    assert(is_alphanumeric('a'), "'a' should be alphanumeric")
    assert(is_alphanumeric('Z'), "'Z' should be alphanumeric")
    assert(is_alphanumeric('5'), "'5' should be alphanumeric")
    assert(not is_alphanumeric('!'), "'!' should not be alphanumeric")
    return 0
}

@test
func test_is_control() -> I32 {
    assert(is_control('\n'), "newline should be control")
    assert(is_control('\0'), "null should be control")
    assert(not is_control('a'), "'a' should not be control")
    assert(not is_control(' '), "space should not be control")
    return 0
}

// === Case ===

@test
func test_is_lowercase_ascii() -> I32 {
    assert(is_lowercase('a'), "'a' should be lowercase")
    assert(is_lowercase('z'), "'z' should be lowercase")
    assert(not is_lowercase('A'), "'A' should not be lowercase")
    assert(not is_lowercase('1'), "'1' should not be lowercase")
    return 0
}

@test
func test_is_uppercase_ascii() -> I32 {
    assert(is_uppercase('A'), "'A' should be uppercase")
    assert(is_uppercase('Z'), "'Z' should be uppercase")
    assert(not is_uppercase('a'), "'a' should not be uppercase")
    assert(not is_uppercase('1'), "'1' should not be uppercase")
    return 0
}

@test
func test_is_whitespace() -> I32 {
    assert(is_whitespace(' '), "space should be whitespace")
    assert(is_whitespace('\t'), "tab should be whitespace")
    assert(is_whitespace('\n'), "newline should be whitespace")
    assert(not is_whitespace('a'), "'a' should not be whitespace")
    return 0
}

// === Validation ===

@test
func test_is_valid_ascii() -> I32 {
    assert(is_valid(0x41 as U32), "0x41 (A) should be valid")
    assert(is_valid(0x0 as U32), "0x0 should be valid")
    return 0
}

@test
func test_is_valid_surrogate() -> I32 {
    assert(not is_valid(0xD800 as U32), "0xD800 (surrogate) should be invalid")
    assert(not is_valid(0xDFFF as U32), "0xDFFF (surrogate) should be invalid")
    return 0
}

@test
func test_is_valid_max_unicode() -> I32 {
    assert(is_valid(0x10FFFF as U32), "0x10FFFF (max) should be valid")
    assert(not is_valid(0x110000 as U32), "0x110000 should be invalid")
    return 0
}

@test
func test_is_ascii_lowercase() -> I32 {
    assert(is_ascii_lowercase('a'), "'a' should be ASCII lowercase")
    assert(is_ascii_lowercase('z'), "'z' should be ASCII lowercase")
    assert(not is_ascii_lowercase('A'), "'A' should not be ASCII lowercase")
    assert(not is_ascii_lowercase('1'), "'1' should not be ASCII lowercase")
    return 0
}

@test
func test_is_ascii_uppercase() -> I32 {
    assert(is_ascii_uppercase('A'), "'A' should be ASCII uppercase")
    assert(is_ascii_uppercase('Z'), "'Z' should be ASCII uppercase")
    assert(not is_ascii_uppercase('a'), "'a' should not be ASCII uppercase")
    return 0
}

@test
func test_is_ascii_digit() -> I32 {
    assert(is_ascii_digit('0'), "'0' should be ASCII digit")
    assert(is_ascii_digit('9'), "'9' should be ASCII digit")
    assert(not is_ascii_digit('a'), "'a' should not be ASCII digit")
    return 0
}

// === Conversion ===

@test
func test_from_u32_valid_ascii() -> I32 {
    let result: Maybe[Char] = from_u32(0x41 as U32)
    assert(result.is_just(), "0x41 should be valid (A)")
    assert_eq(result.unwrap(), 'A', "0x41 should be 'A'")
    return 0
}

@test
func test_from_u32_surrogate_invalid() -> I32 {
    let result: Maybe[Char] = from_u32(0xD800 as U32)
    assert(result.is_nothing(), "surrogate 0xD800 should be invalid")
    return 0
}

@test
func test_from_u32_out_of_range() -> I32 {
    let result: Maybe[Char] = from_u32(0x110000 as U32)
    assert(result.is_nothing(), "0x110000 should be out of range")
    return 0
}

@test
func test_from_digit_decimal() -> I32 {
    let r: Maybe[Char] = from_digit(4 as U32, 10 as U32)
    assert(r.is_just(), "from_digit(4, 10) should be Just")
    assert_eq(r.unwrap(), '4', "from_digit(4, 10) should be '4'")
    return 0
}

@test
func test_from_digit_hex() -> I32 {
    let r: Maybe[Char] = from_digit(10 as U32, 16 as U32)
    assert(r.is_just(), "from_digit(10, 16) should be Just")
    assert_eq(r.unwrap(), 'a', "from_digit(10, 16) should be 'a'")
    return 0
}

@test
func test_from_digit_out_of_range() -> I32 {
    let r: Maybe[Char] = from_digit(17 as U32, 16 as U32)
    assert(r.is_nothing(), "from_digit(17, 16) should be Nothing")
    return 0
}

@test
func test_try_from_u32_valid() -> I32 {
    let r: Outcome[Char, CharTryFromError] = try_from_u32(0x41 as U32)
    assert(r.is_ok(), "try_from_u32(0x41) should be Ok")
    return 0
}

@test
func test_try_from_u32_surrogate() -> I32 {
    let r: Outcome[Char, CharTryFromError] = try_from_u32(0xD800 as U32)
    assert(r.is_err(), "try_from_u32(0xD800) should be Err")
    return 0
}

@test
func test_char_try_from_error_value() -> I32 {
    let err: CharTryFromError = CharTryFromError { value: 0xD800 as U32 }
    assert_eq(err.invalid_value(), 0xD800 as U32, "invalid_value should return 0xD800")
    return 0
}

// === Escape ===

@test
func test_escape_unicode_a() -> I32 {
    let s: Str = methods::escape_unicode('A')
    assert_eq(s, "\\u{41}", "escape_unicode A")
    return 0
}

@test
func test_escape_default_a() -> I32 {
    let s: Str = methods::escape_default('A')
    assert_eq(s, "A", "escape_default A is A")
    return 0
}

@test
func test_escape_debug_a() -> I32 {
    let s: Str = methods::escape_debug('A')
    assert_eq(s, "'A'", "escape_debug A is 'A'")
    return 0
}

// === Decode ===

@test
func test_unpaired_surrogate() -> I32 {
    let err: DecodeUtf16Error = DecodeUtf16Error { code: 0xD800 as U16 }
    let code: U16 = err.unpaired_surrogate()
    assert(code == 0xD800 as U16, "unpaired_surrogate returns code")
    return 0
}

@test
func test_unpaired_surrogate_dc00() -> I32 {
    let err: DecodeUtf16Error = DecodeUtf16Error { code: 0xDC00 as U16 }
    let code: U16 = err.unpaired_surrogate()
    assert(code == 0xDC00 as U16, "unpaired_surrogate returns DC00")
    return 0
}
