// Simple ASCII tests - minimal dependencies
// Tests basic ASCII character operations without importing behaviors

use core::ascii::AsciiChar
use core::option::Maybe

// Helper function to unwrap Maybe[AsciiChar]
func unwrap_char(m: Maybe[AsciiChar]) -> AsciiChar {
    when m {
        Just(c) => return c,
        Nothing => {
            assert(false, "unexpected Nothing")
            return AsciiChar::from_u8_unchecked(0)
        }
    }
}

// ============================================================================
// Basic Char Creation and Conversion
// ============================================================================

@test
func test_char_from_u8_valid() -> I32 {
    // Valid ASCII value
    let a: Maybe[AsciiChar] = AsciiChar::from_u8(65)
    assert(a.is_just(), "65 should be valid ASCII")
    return 0
}

@test
func test_char_from_u8_invalid() -> I32 {
    // Invalid ASCII value
    let invalid: Maybe[AsciiChar] = AsciiChar::from_u8(128)
    assert(invalid.is_nothing(), "128 should be invalid ASCII")
    return 0
}

@test
func test_char_to_u8() -> I32 {
    let a: AsciiChar = unwrap_char(AsciiChar::from_u8(65))
    let result: U8 = a.to_u8()
    assert(result == 65, "A should have value 65")
    return 0
}

// ============================================================================
// Character Classification
// ============================================================================

@test
func test_is_alphabetic() -> I32 {
    let a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))       // 'a'
    let upper_a: AsciiChar = unwrap_char(AsciiChar::from_u8(65)) // 'A'
    let digit: AsciiChar = unwrap_char(AsciiChar::from_u8(48))   // '0'

    assert(a.is_alphabetic(), "a should be alphabetic")
    assert(upper_a.is_alphabetic(), "A should be alphabetic")
    assert(not digit.is_alphabetic(), "0 should not be alphabetic")
    return 0
}

@test
func test_is_uppercase() -> I32 {
    let upper_a: AsciiChar = unwrap_char(AsciiChar::from_u8(65))  // 'A'
    let lower_a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))  // 'a'

    assert(upper_a.is_uppercase(), "A should be uppercase")
    assert(not lower_a.is_uppercase(), "a should not be uppercase")
    return 0
}

@test
func test_is_lowercase() -> I32 {
    let lower_a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))  // 'a'
    let upper_a: AsciiChar = unwrap_char(AsciiChar::from_u8(65))  // 'A'

    assert(lower_a.is_lowercase(), "a should be lowercase")
    assert(not upper_a.is_lowercase(), "A should not be lowercase")
    return 0
}

@test
func test_is_digit() -> I32 {
    let d0: AsciiChar = unwrap_char(AsciiChar::from_u8(48))  // '0'
    let d9: AsciiChar = unwrap_char(AsciiChar::from_u8(57))  // '9'
    let a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))   // 'a'

    assert(d0.is_digit(), "0 should be digit")
    assert(d9.is_digit(), "9 should be digit")
    assert(not a.is_digit(), "a should not be digit")
    return 0
}

@test
func test_is_whitespace() -> I32 {
    let space: AsciiChar = unwrap_char(AsciiChar::from_u8(32))  // ' '
    let tab: AsciiChar = unwrap_char(AsciiChar::from_u8(9))     // '\t'
    let a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))      // 'a'

    assert(space.is_whitespace(), "space should be whitespace")
    assert(tab.is_whitespace(), "tab should be whitespace")
    assert(not a.is_whitespace(), "a should not be whitespace")
    return 0
}

@test
func test_is_control() -> I32 {
    let null_char: AsciiChar = unwrap_char(AsciiChar::from_u8(0))
    let del: AsciiChar = unwrap_char(AsciiChar::from_u8(127))
    let a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))

    assert(null_char.is_control(), "null should be control")
    assert(del.is_control(), "delete should be control")
    assert(not a.is_control(), "a should not be control")
    return 0
}

// ============================================================================
// Case Conversion
// ============================================================================

@test
func test_to_lowercase() -> I32 {
    let upper_a: AsciiChar = unwrap_char(AsciiChar::from_u8(65))  // 'A'
    let result: AsciiChar = upper_a.to_lowercase()
    let value: U8 = result.to_u8()
    assert(value == 97, "A should lowercase to a")
    return 0
}

@test
func test_to_uppercase() -> I32 {
    let lower_a: AsciiChar = unwrap_char(AsciiChar::from_u8(97))  // 'a'
    let result: AsciiChar = lower_a.to_uppercase()
    let value: U8 = result.to_u8()
    assert(value == 65, "a should uppercase to A")
    return 0
}
