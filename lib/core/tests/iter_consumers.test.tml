// Tests for Iterator consumer methods
//
// NOTE: Most iterator consumer tests are blocked on a codegen limitation where
// calling default behavior methods on concrete types returns () instead of the
// expected type. The methods are correctly defined in the Iterator behavior
// but trait method dispatch needs compiler support.
//
// Example: `iter.count()` returns () instead of I64
//
// When this is fixed, tests should cover:
// - count() - consume and count elements
// - last() - get last element
// - nth() - get nth element
// - all() - test all elements match predicate
// - any() - test any element matches predicate
// - find() - search for element matching predicate
// - position() - get position of matching element
// - fold() - fold with accumulator
// - reduce() - reduce without initial value
// - advance_by() - skip n elements
// - for_each() - apply function to each element
// - try_fold() - fold with early termination
// - find_map() - find and transform
// - max_by() - max with custom comparator
// - min_by() - min with custom comparator
// - max() - natural max (requires Ord)
// - min() - natural min (requires Ord)
// - sum() - sum elements (requires Add + Default)
// - product() - multiply elements (requires Mul + Default)
// - eq() - compare iterators for equality
// - cmp() - lexicographic comparison

use test
use core::range::RangeIterI64

// ============================================================================
// Placeholder test - verifies basic iterator functionality
// ============================================================================

@test
func test_range_iter_next() -> I32 {
    // Basic test that next() works - this is explicitly implemented, not a default method
    let mut iter: RangeIterI64 = RangeIterI64 { current: 0, end: 3 }

    let v0: Maybe[I64] = iter.next()
    assert(v0.is_just(), "first should be Just")
    assert_eq(v0.unwrap(), 0, "first should be 0")

    let v1: Maybe[I64] = iter.next()
    assert_eq(v1.unwrap(), 1, "second should be 1")

    let v2: Maybe[I64] = iter.next()
    assert_eq(v2.unwrap(), 2, "third should be 2")

    let v3: Maybe[I64] = iter.next()
    assert(v3.is_nothing(), "fourth should be Nothing")

    return 0
}

// ============================================================================
// When default behavior method dispatch is fixed, add these tests:
// ============================================================================
//
// @test func test_count_basic() -> I32 { ... }
// @test func test_count_empty() -> I32 { ... }
// @test func test_last_basic() -> I32 { ... }
// @test func test_nth_basic() -> I32 { ... }
// @test func test_all_true() -> I32 { ... }
// @test func test_any_true() -> I32 { ... }
// @test func test_find_found() -> I32 { ... }
// @test func test_position_found() -> I32 { ... }
// @test func test_fold_sum() -> I32 { ... }
// @test func test_reduce_sum() -> I32 { ... }
// @test func test_advance_by_success() -> I32 { ... }
// @test func test_for_each_consumes() -> I32 { ... }
