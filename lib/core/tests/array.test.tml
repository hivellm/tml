// Tests for fixed-size arrays [T; N]
// Tests basic array operations that the compiler currently supports

// NOTE: These imports are for tests that require library features not yet
// supported by the compiler. Uncomment when the compiler supports them.
// use core::ascii::Char as AsciiChar
// use core::array::ArrayIter
// use core::slice::Slice

// ============================================================================
// Basic Array Creation and Indexing
// ============================================================================

@test
func test_array_literal_i32() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    assert(arr[0] == 1, "first element should be 1")
    assert(arr[4] == 5, "last element should be 5")
    return 0
}

@test
func test_array_literal_i64() -> I32 {
    let arr: [I64; 3] = [10, 20, 30]
    assert(arr[0] == 10, "first element should be 10")
    assert(arr[1] == 20, "second element should be 20")
    assert(arr[2] == 30, "third element should be 30")
    return 0
}

@test
func test_array_indexing() -> I32 {
    let arr: [I32; 4] = [100, 200, 300, 400]
    let first: I32 = arr[0]
    let second: I32 = arr[1]
    let third: I32 = arr[2]
    let fourth: I32 = arr[3]

    assert(first == 100, "first should be 100")
    assert(second == 200, "second should be 200")
    assert(third == 300, "third should be 300")
    assert(fourth == 400, "fourth should be 400")
    return 0
}

// ============================================================================
// Array Arithmetic
// ============================================================================

@test
func test_array_sum() -> I32 {
    let arr: [I32; 4] = [1, 2, 3, 4]
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3]
    assert(sum == 10, "sum should be 10")
    return 0
}

@test
func test_array_product() -> I32 {
    let arr: [I32; 4] = [2, 3, 4, 5]
    let product: I32 = arr[0] * arr[1] * arr[2] * arr[3]
    assert(product == 120, "product should be 120")
    return 0
}

// ============================================================================
// Array with Different Element Types
// ============================================================================

@test
func test_array_i8() -> I32 {
    let arr: [I8; 3] = [1, 2, 3]
    let sum: I8 = arr[0] + arr[1] + arr[2]
    assert(sum == 6, "sum should be 6")
    return 0
}

@test
func test_array_i16() -> I32 {
    let arr: [I16; 3] = [100, 200, 300]
    let sum: I16 = arr[0] + arr[1] + arr[2]
    assert(sum == 600, "sum should be 600")
    return 0
}

@test
func test_array_u32() -> I32 {
    let arr: [U32; 3] = [10, 20, 30]
    let sum: U32 = arr[0] + arr[1] + arr[2]
    assert(sum == 60, "sum should be 60")
    return 0
}

@test
func test_array_u64() -> I32 {
    let arr: [U64; 3] = [1000, 2000, 3000]
    let sum: U64 = arr[0] + arr[1] + arr[2]
    assert(sum == 6000, "sum should be 6000")
    return 0
}

// ============================================================================
// Empty Array and Single Element
// ============================================================================

@test
func test_array_single_element() -> I32 {
    let arr: [I32; 1] = [42]
    assert(arr[0] == 42, "single element should be 42")
    return 0
}

// ============================================================================
// Array in Expressions
// ============================================================================

@test
func test_array_in_comparison() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]

    assert(arr[0] < arr[1], "first < second")
    assert(arr[1] < arr[2], "second < third")
    assert(arr[0] < arr[2], "first < third")
    return 0
}

@test
func test_array_element_modification_via_index() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [4, 5, 6]

    // Test that arrays are independent
    let sum_a: I32 = a[0] + a[1] + a[2]
    let sum_b: I32 = b[0] + b[1] + b[2]

    assert(sum_a == 6, "sum of a should be 6")
    assert(sum_b == 15, "sum of b should be 15")
    return 0
}

// ============================================================================
// Array Size Inference from Type
// ============================================================================

@test
func test_array_large() -> I32 {
    let arr: [I32; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let first_half: I32 = arr[0] + arr[1] + arr[2] + arr[3] + arr[4]
    let second_half: I32 = arr[5] + arr[6] + arr[7] + arr[8] + arr[9]
    let sum: I32 = first_half + second_half
    assert(sum == 55, "sum of 1..10 should be 55")
    return 0
}

@test
func test_array_negative_values() -> I32 {
    let arr: [I32; 4] = [1, -2, 3, -4]
    let sum: I32 = arr[0] + arr[1] + arr[2] + arr[3]
    assert(sum == -2, "sum should be -2")
    return 0
}

// ============================================================================
// Array Method Tests
// ============================================================================

@test
func test_array_len() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    assert(arr.len() == 5, "len should be 5")

    let empty: [I32; 0] = []
    assert(empty.len() == 0, "empty len should be 0")
    return 0
}

@test
func test_array_is_empty() -> I32 {
    let arr: [I32; 3] = [1, 2, 3]
    assert(arr.is_empty() == false, "array should not be empty")

    let empty: [I32; 0] = []
    assert(empty.is_empty(), "empty array should be empty")
    return 0
}

@test
func test_array_get() -> I32 {
    let arr: [I32; 3] = [10, 20, 30]

    when arr.get(0) {
        Just(v) => assert(*v == 10, "get(0) should be 10"),
        Nothing => assert(false, "get(0) should return Just")
    }

    when arr.get(2) {
        Just(v) => assert(*v == 30, "get(2) should be 30"),
        Nothing => assert(false, "get(2) should return Just")
    }

    when arr.get(3) {
        Just(_) => assert(false, "get(3) should return Nothing"),
        Nothing => {}
    }

    when arr.get(-1) {
        Just(_) => assert(false, "get(-1) should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_array_first_last() -> I32 {
    let arr: [I32; 3] = [100, 200, 300]

    when arr.first() {
        Just(v) => assert(*v == 100, "first should be 100"),
        Nothing => assert(false, "first should return Just")
    }

    when arr.last() {
        Just(v) => assert(*v == 300, "last should be 300"),
        Nothing => assert(false, "last should return Just")
    }

    let empty: [I32; 0] = []
    when empty.first() {
        Just(_) => assert(false, "empty first should return Nothing"),
        Nothing => {}
    }

    when empty.last() {
        Just(_) => assert(false, "empty last should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_array_map() -> I32 {
    let arr: [I32; 4] = [1, 2, 3, 4]
    let doubled: [I32; 4] = arr.map(do(x: I32) x * 2)

    assert(doubled[0] == 2, "doubled[0] should be 2")
    assert(doubled[1] == 4, "doubled[1] should be 4")
    assert(doubled[2] == 6, "doubled[2] should be 6")
    assert(doubled[3] == 8, "doubled[3] should be 8")

    return 0
}

// NOTE: test_array_zip, test_array_into_iter, test_array_iter_double_ended,
// test_array_iter_len are commented out because they require library features
// (tuple field access, ArrayIter) that the compiler doesn't fully support yet.
// The library code is correct; these tests can be enabled when the compiler
// supports the required features.

// ============================================================================
// Equality and Comparison Tests
// ============================================================================

@test
func test_array_equality() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [1, 2, 3]
    let c: [I32; 3] = [1, 2, 4]

    assert(a.eq(ref b), "a should equal b")
    assert(a.ne(ref c), "a should not equal c")

    return 0
}

@test
func test_array_ordering() -> I32 {
    let a: [I32; 3] = [1, 2, 3]
    let b: [I32; 3] = [1, 2, 4]
    let c: [I32; 3] = [1, 2, 3]

    when a.cmp(ref b) {
        Less => {},
        _ => assert(false, "a should be less than b")
    }

    when b.cmp(ref a) {
        Greater => {},
        _ => assert(false, "b should be greater than a")
    }

    when a.cmp(ref c) {
        Equal => {},
        _ => assert(false, "a should equal c")
    }

    return 0
}

// ============================================================================
// ASCII Tests
// ============================================================================
// NOTE: ASCII tests require library features not yet supported by the compiler.
// The library code is correct; enable these tests when the compiler supports:
// - Calling methods on custom types (core::ascii::Char)
// - Custom type constructors (AsciiChar::from_u8)

// ============================================================================
// Creation Function Tests
// ============================================================================
// NOTE: from_fn and repeat tests require library features not yet supported.
// The library code is correct; enable these when the compiler supports them.

// ============================================================================
// Slice Comparison Tests
// ============================================================================
// NOTE: eq_slice tests require Slice type which needs library support.
// The library code is correct; enable when the compiler supports it.
