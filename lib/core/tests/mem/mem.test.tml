// Consolidated tests for core::mem (27 tests)
// ManuallyDrop, MaybeUninit, swap, replace, size_of, align_of, drop, forget, zeroed, transmute
// BLOCKED: MaybeUninit::uninit[T] — generic monomorphization
use test
use core::mem
use core::mem::ManuallyDrop
use core::mem::MaybeUninit
use core::mem::{swap, replace, drop}
use core::mem::{size_of, align_of, size_of_val, align_of_val}
use test::{assert, assert_eq}
use core::mem::{ManuallyDrop, MaybeUninit, forget, drop, take, size_of_val, align_of_val}

// === ManuallyDrop ===

@test
func test_manually_drop_new_into_inner() -> I32 {
    let wrapper: ManuallyDrop[I32] = ManuallyDrop::new[I32](42)
    let val: I32 = wrapper.into_inner()
    assert_eq(val, 42, "into_inner should return original value")
    return 0
}

@test
func test_manually_drop_get_ref() -> I32 {
    let wrapper: ManuallyDrop[I32] = ManuallyDrop::new[I32](99)
    let r: ref I32 = wrapper.get_ref()
    assert_eq(*r, 99, "get_ref should return reference to value")
    return 0
}

@test
func test_manually_drop_str() -> I32 {
    let wrapper: ManuallyDrop[Str] = ManuallyDrop::new[Str]("hello")
    let val: Str = wrapper.into_inner()
    assert_eq(val, "hello", "ManuallyDrop works with Str")
    return 0
}

// === MaybeUninit ===

@test
func test_maybe_uninit_new_assume_init() -> I32 {
    let m: MaybeUninit[I32] = MaybeUninit::new[I32](42)
    let val: I32 = m.assume_init()
    assert_eq(val, 42, "new + assume_init should return value")
    return 0
}

@test
func test_maybe_uninit_write_assume_init() -> I32 {
    var m: MaybeUninit[I32] = MaybeUninit::new[I32](0)
    m.write(99)
    let val: I32 = m.assume_init()
    assert_eq(val, 99, "write should overwrite value")
    return 0
}

@test
func test_maybe_uninit_assume_init_ref() -> I32 {
    let m: MaybeUninit[I32] = MaybeUninit::new[I32](77)
    let r: ref I32 = m.assume_init_ref()
    assert_eq(*r, 77, "assume_init_ref should return reference")
    return 0
}

// === swap, replace ===

@test
func test_swap_i32() -> I32 {
    var a: I32 = 10
    var b: I32 = 20
    swap[I32](mut ref a, mut ref b)
    assert_eq(a, 20, "a should be 20 after swap")
    assert_eq(b, 10, "b should be 10 after swap")
    return 0
}

@test
func test_replace_i32() -> I32 {
    var x: I32 = 5
    let old: I32 = replace[I32](mut ref x, 100)
    assert_eq(x, 100, "x should be 100 after replace")
    assert_eq(old, 5, "old should be 5")
    return 0
}

@test
func test_replace_negative() -> I32 {
    var y: I32 = -42
    let old: I32 = replace[I32](mut ref y, 0)
    assert_eq(old, -42, "old should be -42")
    assert_eq(y, 0, "y should be 0 after replace")
    return 0
}

// === size_of, align_of ===

@test
func test_size_of_i8() -> I32 {
    assert_eq(size_of[I8](), 1 as I64, "size_of I8 should be 1")
    return 0
}

@test
func test_size_of_i32() -> I32 {
    assert_eq(size_of[I32](), 4 as I64, "size_of I32 should be 4")
    return 0
}

@test
func test_size_of_i64() -> I32 {
    assert_eq(size_of[I64](), 8 as I64, "size_of I64 should be 8")
    return 0
}

@test
func test_size_of_bool() -> I32 {
    assert_eq(size_of[Bool](), 1 as I64, "size_of Bool should be 1")
    return 0
}

@test
func test_align_of_i8() -> I32 {
    assert_eq(align_of[I8](), 1 as I64, "align_of I8 should be 1")
    return 0
}

@test
func test_align_of_i32() -> I32 {
    assert_eq(align_of[I32](), 4 as I64, "align_of I32 should be 4")
    return 0
}

@test
func test_align_of_i64() -> I32 {
    assert_eq(align_of[I64](), 8 as I64, "align_of I64 should be 8")
    return 0
}

@test
func test_size_of_val_i32() -> I32 {
    let x: I32 = 42
    assert_eq(size_of_val[I32](ref x), 4 as I64, "size_of_val I32 should be 4")
    return 0
}

@test
func test_align_of_val_i64() -> I32 {
    let x: I64 = 100
    assert_eq(align_of_val[I64](ref x), 8 as I64, "align_of_val I64 should be 8")
    return 0
}

// === drop ===

@test
func test_drop_i32() -> I32 {
    let x: I32 = 42
    drop[I32](x)
    return 0
}

@test
func test_drop_i64() -> I32 {
    let x: I64 = 999 as I64
    drop[I64](x)
    return 0
}

@test
func test_drop_bool() -> I32 {
    let x: Bool = true
    drop[Bool](x)
    return 0
}

// === forget ===

@test
func test_forget_i32() -> I32 {
    let x: I32 = 42
    mem::forget[I32](x)
    return 0
}

@test
func test_forget_i64() -> I32 {
    let x: I64 = 999 as I64
    mem::forget[I64](x)
    return 0
}

// === zeroed ===

@test
func test_zeroed_i32() -> I32 {
    let x: I32 = mem::zeroed[I32]()
    assert_eq(x, 0, "zeroed I32 should be 0")
    return 0
}

@test
func test_zeroed_i64() -> I32 {
    let x: I64 = mem::zeroed[I64]()
    assert(x == 0 as I64, "zeroed I64 should be 0")
    return 0
}

@test
func test_zeroed_bool() -> I32 {
    let x: Bool = mem::zeroed[Bool]()
    assert(x == false, "zeroed Bool should be false")
    return 0
}

// === transmute ===
// BLOCKED: MaybeUninit::uninit[T] — generic monomorphization

@test
func test_manually_drop_get_mut() -> I32 {
    var w: ManuallyDrop[I32] = ManuallyDrop::new(10)
    let m: mut ref I32 = w.get_mut()
    *m = 20
    assert_eq(w.into_inner(), 20, "get_mut should allow modification")
    return 0
}

@test
func test_manually_drop_i64() -> I32 {
    let w: ManuallyDrop[I64] = ManuallyDrop::new(999 as I64)
    let v: I64 = w.into_inner()
    assert_eq(v, 999 as I64, "ManuallyDrop[I64] into_inner")
    return 0
}

// === MaybeUninit ===
// NOTE: MaybeUninit::uninit() blocked by codegen bug (ret type mismatch i32 vs struct)

@test
func test_maybe_uninit_new_i64() -> I32 {
    let m: MaybeUninit[I64] = MaybeUninit::new(1234 as I64)
    let v: I64 = m.assume_init()
    assert_eq(v, 1234 as I64, "MaybeUninit::new(1234) assume_init")
    return 0
}

// === forget / drop ===

@test
func test_forget_does_not_crash() -> I32 {
    let x: I32 = 42
    forget(x)
    assert(true, "forget should not crash")
    return 0
}

@test
func test_drop_does_not_crash() -> I32 {
    let x: I32 = 10
    drop(x)
    assert(true, "drop should not crash")
    return 0
}

// === size_of_val / align_of_val ===

@test
func test_size_of_val_i8() -> I32 {
    let x: I8 = 1 as I8
    assert_eq(size_of_val(ref x), 1 as I64, "size_of_val(I8) = 1")
    return 0
}

@test
func test_size_of_val_bool() -> I32 {
    let x: Bool = true
    assert_eq(size_of_val(ref x), 1 as I64, "size_of_val(Bool) = 1")
    return 0
}

@test
func test_align_of_val_i8() -> I32 {
    let x: I8 = 1 as I8
    assert_eq(align_of_val(ref x), 1 as I64, "align_of_val(I8) = 1")
    return 0
}
