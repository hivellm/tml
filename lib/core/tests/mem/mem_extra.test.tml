// Tests for core::mem â€” ManuallyDrop, MaybeUninit, forget, drop, take, size_of_val, align_of_val
use test::{assert, assert_eq}
use core::mem::{ManuallyDrop, MaybeUninit, forget, drop, take, size_of_val, align_of_val}

// === ManuallyDrop ===

@test
func test_manually_drop_get_ref() -> I32 {
    let w: ManuallyDrop[I32] = ManuallyDrop::new(77)
    let r: ref I32 = w.get_ref()
    assert_eq(*r, 77, "get_ref should return reference to value")
    return 0
}

@test
func test_manually_drop_get_mut() -> I32 {
    var w: ManuallyDrop[I32] = ManuallyDrop::new(10)
    let m: mut ref I32 = w.get_mut()
    *m = 20
    assert_eq(w.into_inner(), 20, "get_mut should allow modification")
    return 0
}

@test
func test_manually_drop_i64() -> I32 {
    let w: ManuallyDrop[I64] = ManuallyDrop::new(999 as I64)
    let v: I64 = w.into_inner()
    assert_eq(v, 999 as I64, "ManuallyDrop[I64] into_inner")
    return 0
}

// === MaybeUninit ===
// NOTE: MaybeUninit::uninit() blocked by codegen bug (ret type mismatch i32 vs struct)

@test
func test_maybe_uninit_new_i64() -> I32 {
    let m: MaybeUninit[I64] = MaybeUninit::new(1234 as I64)
    let v: I64 = m.assume_init()
    assert_eq(v, 1234 as I64, "MaybeUninit::new(1234) assume_init")
    return 0
}

@test
func test_maybe_uninit_assume_init_ref() -> I32 {
    let m: MaybeUninit[I32] = MaybeUninit::new(55)
    let r: ref I32 = m.assume_init_ref()
    assert_eq(*r, 55, "assume_init_ref should return ref to 55")
    return 0
}

// === forget / drop ===

@test
func test_forget_does_not_crash() -> I32 {
    let x: I32 = 42
    forget(x)
    assert(true, "forget should not crash")
    return 0
}

@test
func test_drop_does_not_crash() -> I32 {
    let x: I32 = 10
    drop(x)
    assert(true, "drop should not crash")
    return 0
}

// === size_of_val / align_of_val ===

@test
func test_size_of_val_i8() -> I32 {
    let x: I8 = 1 as I8
    assert_eq(size_of_val(ref x), 1 as I64, "size_of_val(I8) = 1")
    return 0
}

@test
func test_size_of_val_bool() -> I32 {
    let x: Bool = true
    assert_eq(size_of_val(ref x), 1 as I64, "size_of_val(Bool) = 1")
    return 0
}

@test
func test_align_of_val_i64() -> I32 {
    let x: I64 = 100
    assert_eq(align_of_val(ref x), 8 as I64, "align_of_val(I64) = 8")
    return 0
}

@test
func test_align_of_val_i8() -> I32 {
    let x: I8 = 1 as I8
    assert_eq(align_of_val(ref x), 1 as I64, "align_of_val(I8) = 1")
    return 0
}
