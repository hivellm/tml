// Tests for core::ptr::alignment - alignment utilities
use test::{assert, assert_eq}
use core::ptr::alignment::{align_up, align_down, is_aligned_to, align_offset, is_power_of_two, checked_next_power_of_two, prev_power_of_two, log2}

@test
func test_align_up() -> I32 {
    assert_eq(align_up(0, 4), 0, "0 aligned up to 4")
    assert_eq(align_up(1, 4), 4, "1 aligned up to 4")
    assert_eq(align_up(3, 4), 4, "3 aligned up to 4")
    assert_eq(align_up(4, 4), 4, "4 aligned up to 4")
    assert_eq(align_up(5, 4), 8, "5 aligned up to 4")
    return 0
}

@test
func test_align_down() -> I32 {
    assert_eq(align_down(0, 4), 0, "0 aligned down to 4")
    assert_eq(align_down(3, 4), 0, "3 aligned down to 4")
    assert_eq(align_down(4, 4), 4, "4 aligned down to 4")
    assert_eq(align_down(7, 4), 4, "7 aligned down to 4")
    assert_eq(align_down(8, 4), 8, "8 aligned down to 4")
    return 0
}

@test
func test_is_aligned_to() -> I32 {
    assert(is_aligned_to(0, 8), "0 is aligned to 8")
    assert(is_aligned_to(8, 8), "8 is aligned to 8")
    assert(is_aligned_to(16, 8), "16 is aligned to 8")
    assert(not is_aligned_to(1, 8), "1 not aligned to 8")
    assert(not is_aligned_to(7, 8), "7 not aligned to 8")
    return 0
}

@test
func test_align_offset() -> I32 {
    assert_eq(align_offset(4, 4), 0, "4 already aligned to 4")
    assert_eq(align_offset(3, 4), 1, "3 needs +1 for align 4")
    assert_eq(align_offset(5, 8), 3, "5 needs +3 for align 8")
    assert_eq(align_offset(0, 8), 0, "0 already aligned")
    return 0
}

@test
func test_is_power_of_two() -> I32 {
    assert(is_power_of_two(1), "1 is power of 2")
    assert(is_power_of_two(2), "2 is power of 2")
    assert(is_power_of_two(4), "4 is power of 2")
    assert(is_power_of_two(64), "64 is power of 2")
    assert(not is_power_of_two(0), "0 is not power of 2")
    assert(not is_power_of_two(3), "3 is not power of 2")
    assert(not is_power_of_two(-1), "-1 is not power of 2")
    return 0
}

@test
func test_checked_next_power_of_two() -> I32 {
    let p1: Maybe[I64] = checked_next_power_of_two(3)
    assert_eq(p1.unwrap(), 4, "next pow2 of 3 is 4")
    let p2: Maybe[I64] = checked_next_power_of_two(8)
    assert_eq(p2.unwrap(), 8, "next pow2 of 8 is 8")
    let p3: Maybe[I64] = checked_next_power_of_two(1)
    assert_eq(p3.unwrap(), 1, "next pow2 of 1 is 1")
    return 0
}

@test
func test_prev_power_of_two() -> I32 {
    assert_eq(prev_power_of_two(5), 4, "prev pow2 of 5 is 4")
    assert_eq(prev_power_of_two(8), 8, "prev pow2 of 8 is 8")
    assert_eq(prev_power_of_two(0), 0, "prev pow2 of 0 is 0")
    assert_eq(prev_power_of_two(1), 1, "prev pow2 of 1 is 1")
    return 0
}

@test
func test_log2() -> I32 {
    let l1: Maybe[I64] = log2(8)
    assert_eq(l1.unwrap(), 3, "log2(8) = 3")
    let l2: Maybe[I64] = log2(10)
    assert_eq(l2.unwrap(), 3, "log2(10) = 3 (floor)")
    let l3: Maybe[I64] = log2(1)
    assert_eq(l3.unwrap(), 0, "log2(1) = 0")
    let l4: Maybe[I64] = log2(0)
    assert(l4.is_nothing(), "log2(0) is Nothing")
    return 0
}
