// Tests for callable types demonstrating Fn-like patterns
//
// Note: The Fn/FnMut/FnOnce traits are defined in core::ops::function but
// implementing them requires tuple type arguments (e.g., Fn[(I32,)]) which
// the parser doesn't fully support yet. These tests show the callable pattern
// works with manually-defined methods.
use test

// ============================================================================
// Simple callable type tests
// ============================================================================

// A simple callable struct
pub type Adder {
    amount: I32
}

impl Adder {
    // Manual call method (equivalent to Fn::call)
    pub func call(this, x: I32) -> I32 {
        return x + this.amount
    }

    // Method that mutates state (equivalent to FnMut::call_mut)
    pub func call_mut(mut this, x: I32) -> I32 {
        this.amount = this.amount + 1
        return x + this.amount
    }
}

// Counter with mutable state
pub type Counter {
    count: I32
}

impl Counter {
    pub func call_mut(mut this) -> I32 {
        this.count = this.count + 1
        return this.count
    }

    pub func current(this) -> I32 {
        return this.count
    }
}

// ============================================================================
// Tests for callable types
// ============================================================================

@test
func test_adder_call() -> I32 {
    let adder: Adder = Adder { amount: 10 }
    let result: I32 = adder.call(5)
    assert_eq(result, 15, "10 + 5 should be 15")
    return 0
}

@test
func test_adder_multiple_calls() -> I32 {
    let adder: Adder = Adder { amount: 7 }
    let r1: I32 = adder.call(3)
    let r2: I32 = adder.call(4)
    assert_eq(r1, 10, "7 + 3 should be 10")
    assert_eq(r2, 11, "7 + 4 should be 11")
    return 0
}

@test
func test_adder_call_mut() -> I32 {
    var adder: Adder = Adder { amount: 10 }
    // First call: amount becomes 11, returns 5 + 11 = 16
    let r1: I32 = adder.call_mut(5)
    // Second call: amount becomes 12, returns 5 + 12 = 17
    let r2: I32 = adder.call_mut(5)
    assert_eq(r1, 16, "first call should return 16")
    assert_eq(r2, 17, "second call should return 17")
    return 0
}

@test
func test_counter() -> I32 {
    var counter: Counter = Counter { count: 0 }
    let c1: I32 = counter.call_mut()
    let c2: I32 = counter.call_mut()
    let c3: I32 = counter.call_mut()
    assert_eq(c1, 1, "first call should return 1")
    assert_eq(c2, 2, "second call should return 2")
    assert_eq(c3, 3, "third call should return 3")
    assert_eq(counter.current(), 3, "current count should be 3")
    return 0
}

// ============================================================================
// Tests for closures with function pointer types
// ============================================================================

pub type Transformer {
    f: func(I32) -> I32
}

@test
func test_closure_in_transformer() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let t: Transformer = Transformer { f: double }
    let mapper: func(I32) -> I32 = t.f
    let result: I32 = mapper(21)
    assert_eq(result, 42, "21 * 2 should be 42")
    return 0
}

// NOTE: test_closure_with_capture is disabled because TML doesn't support
// storing capturing closures in struct fields yet. The closure signature
// includes captures (e.g., func(capture, I32) -> I32) but struct fields
// only store func(I32) -> I32, losing capture information.
// This works with direct calls but not when stored in struct fields.
// See: capturing closures work with direct calls (test_closure_with_capture_direct)

// Higher-order function that takes a function pointer
pub func apply(f: func(I32) -> I32, x: I32) -> I32 {
    return f(x)
}

@test
func test_higher_order_function() -> I32 {
    let triple: func(I32) -> I32 = do(x: I32) -> I32 { x * 3 }
    let result: I32 = apply(triple, 7)
    assert_eq(result, 21, "7 * 3 should be 21")
    return 0
}

@test
func test_inline_closure() -> I32 {
    let result: I32 = apply(do(x: I32) -> I32 { x + 10 }, 5)
    assert_eq(result, 15, "5 + 10 should be 15")
    return 0
}
