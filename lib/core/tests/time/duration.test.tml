// Tests for core::time â€” Duration constructors, arithmetic, accessors
use test::{assert, assert_eq}
use core::time::Duration

// === Constructors ===

@test
func test_duration_from_secs() -> I32 {
    let d: Duration = Duration::from_secs(5 as I64)
    assert_eq(d.as_secs(), 5 as I64, "from_secs(5) should have 5 seconds")
    assert_eq(d.subsec_nanos(), 0 as I32, "from_secs should have 0 nanos")
    return 0
}

@test
func test_duration_from_millis() -> I32 {
    let d: Duration = Duration::from_millis(1500 as I64)
    assert_eq(d.as_secs(), 1 as I64, "1500ms = 1 sec")
    assert_eq(d.subsec_millis(), 500 as I32, "1500ms has 500ms subsec")
    return 0
}

@test
func test_duration_from_micros() -> I32 {
    let d: Duration = Duration::from_micros(2500000 as I64)
    assert_eq(d.as_secs(), 2 as I64, "2500000us = 2 sec")
    assert_eq(d.subsec_micros(), 500000 as I32, "2500000us has 500000us subsec")
    return 0
}

@test
func test_duration_from_nanos() -> I32 {
    let d: Duration = Duration::from_nanos(1000000000 as I64)
    assert_eq(d.as_secs(), 1 as I64, "1e9 nanos = 1 sec")
    return 0
}

@test
func test_duration_new() -> I32 {
    let d: Duration = Duration::new(3 as I64, 500000000 as I32)
    assert_eq(d.as_secs(), 3 as I64, "new(3, 500000000) secs")
    assert_eq(d.subsec_nanos(), 500000000 as I32, "new(3, 500000000) nanos")
    return 0
}

// === Predicates ===

@test
func test_duration_is_zero_true() -> I32 {
    let d: Duration = Duration::from_secs(0 as I64)
    assert(d.is_zero(), "zero duration should be zero")
    return 0
}

@test
func test_duration_is_zero_false() -> I32 {
    let d: Duration = Duration::from_secs(1 as I64)
    assert(not d.is_zero(), "non-zero duration should not be zero")
    return 0
}

// === Conversions ===

@test
func test_duration_as_millis() -> I32 {
    let d: Duration = Duration::from_secs(2 as I64)
    assert_eq(d.as_millis(), 2000 as I64, "2 secs = 2000 millis")
    return 0
}

@test
func test_duration_as_micros() -> I32 {
    let d: Duration = Duration::from_secs(1 as I64)
    assert_eq(d.as_micros(), 1000000 as I64, "1 sec = 1000000 micros")
    return 0
}

@test
func test_duration_as_nanos() -> I32 {
    let d: Duration = Duration::from_millis(1 as I64)
    assert_eq(d.as_nanos(), 1000000 as I64, "1 ms = 1000000 nanos")
    return 0
}

// === Arithmetic ===

@test
func test_duration_saturating_add() -> I32 {
    let a: Duration = Duration::from_secs(1 as I64)
    let b: Duration = Duration::from_millis(500 as I64)
    let c: Duration = a.saturating_add(b)
    assert_eq(c.as_millis(), 1500 as I64, "1s + 500ms = 1500ms")
    return 0
}

@test
func test_duration_saturating_sub() -> I32 {
    let a: Duration = Duration::from_secs(2 as I64)
    let b: Duration = Duration::from_millis(500 as I64)
    let c: Duration = a.saturating_sub(b)
    assert_eq(c.as_millis(), 1500 as I64, "2s - 500ms = 1500ms")
    return 0
}

@test
func test_duration_saturating_sub_underflow() -> I32 {
    let a: Duration = Duration::from_millis(100 as I64)
    let b: Duration = Duration::from_secs(1 as I64)
    let c: Duration = a.saturating_sub(b)
    assert(c.is_zero(), "saturating sub underflow should return zero")
    return 0
}

@test
func test_duration_mul() -> I32 {
    let d: Duration = Duration::from_millis(100 as I64)
    let result: Duration = d.mul(3 as I32)
    assert_eq(result.as_millis(), 300 as I64, "100ms * 3 = 300ms")
    return 0
}

// === Display ===

@test
func test_duration_to_string() -> I32 {
    let d: Duration = Duration::from_secs(1 as I64)
    let s: Str = d.to_string()
    assert(s.len() > 0, "Duration to_string should be non-empty")
    return 0
}

@test
func test_duration_debug_string() -> I32 {
    let d: Duration = Duration::from_millis(250 as I64)
    let dbg: Str = d.debug_string()
    assert(dbg.len() > 0, "Duration debug_string should be non-empty")
    return 0
}

@test
func test_duration_checked_add_ok() -> I32 {
    let a: Duration = Duration::from_secs(3 as I64)
    let b: Duration = Duration::from_millis(500 as I64)
    let r = a.checked_add(b)
    assert(r.is_just(), "checked_add should succeed")
    let d: Duration = r.unwrap()
    assert_eq(d.as_millis(), 3500 as I64, "3s + 500ms = 3500ms")
    return 0
}

@test
func test_duration_checked_add_nanos_carry() -> I32 {
    let a: Duration = Duration::new(1 as I64, 800000000 as I32)
    let b: Duration = Duration::new(0 as I64, 400000000 as I32)
    let r = a.checked_add(b)
    assert(r.is_just(), "checked_add nanos carry should succeed")
    let d: Duration = r.unwrap()
    assert_eq(d.as_secs(), 2 as I64, "1.8s + 0.4s = 2.2s secs")
    assert_eq(d.subsec_nanos(), 200000000 as I32, "1.8s + 0.4s nanos")
    return 0
}

@test
func test_duration_checked_sub_ok() -> I32 {
    let a: Duration = Duration::from_secs(5 as I64)
    let b: Duration = Duration::from_secs(2 as I64)
    let r = a.checked_sub(b)
    assert(r.is_just(), "checked_sub should succeed")
    let d: Duration = r.unwrap()
    assert_eq(d.as_secs(), 3 as I64, "5s - 2s = 3s")
    return 0
}

@test
func test_duration_checked_sub_underflow() -> I32 {
    let a: Duration = Duration::from_secs(1 as I64)
    let b: Duration = Duration::from_secs(5 as I64)
    let r = a.checked_sub(b)
    assert(r.is_nothing(), "1s - 5s should return Nothing")
    return 0
}

@test
func test_duration_div() -> I32 {
    let d: Duration = Duration::from_secs(10 as I64)
    let r: Duration = d.div(2)
    assert_eq(r.as_secs(), 5 as I64, "10s / 2 = 5s")
    return 0
}

@test
func test_duration_div_with_nanos() -> I32 {
    let d: Duration = Duration::from_millis(3000 as I64)
    let r: Duration = d.div(3)
    assert_eq(r.as_millis(), 1000 as I64, "3000ms / 3 = 1000ms")
    return 0
}

@test
func test_duration_subsec_micros() -> I32 {
    let d: Duration = Duration::new(1 as I64, 500000000 as I32)
    assert_eq(d.subsec_micros(), 500000 as I32, "0.5s = 500000us")
    return 0
}

@test
func test_duration_from_nanos_subsec() -> I32 {
    let d: Duration = Duration::from_nanos(1500000000 as I64)
    assert_eq(d.as_secs(), 1 as I64, "1.5e9 ns = 1s")
    assert_eq(d.subsec_nanos(), 500000000 as I32, "1.5e9 ns subsec = 0.5s nanos")
    return 0
}

@test
func test_duration_checked_sub_nanos_borrow() -> I32 {
    let a: Duration = Duration::new(2 as I64, 100000000 as I32)
    let b: Duration = Duration::new(1 as I64, 500000000 as I32)
    let r = a.checked_sub(b)
    assert(r.is_just(), "checked_sub with nanos borrow should succeed")
    let d: Duration = r.unwrap()
    assert_eq(d.subsec_nanos(), 600000000 as I32, "2.1s - 1.5s = 0.6s nanos")
    return 0
}
