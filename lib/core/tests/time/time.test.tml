// Consolidated tests for core::time::Duration
use test
use core::time::Duration

// === Constructors and basic accessors ===

@test
func test_duration_from_secs() -> I32 {
    let d: Duration = Duration::from_secs(5)
    assert_eq(d.as_secs(), 5 as I64, "from_secs(5) should be 5 seconds")
    assert_eq(d.subsec_nanos(), 0, "from_secs should have 0 nanos")
    return 0
}

@test
func test_duration_from_millis() -> I32 {
    let d: Duration = Duration::from_millis(2500)
    assert_eq(d.as_secs(), 2 as I64, "2500ms should be 2 seconds")
    assert_eq(d.subsec_millis(), 500, "2500ms should have 500ms fractional")
    assert_eq(d.as_millis(), 2500 as I64, "total should be 2500ms")
    return 0
}

@test
func test_duration_from_nanos() -> I32 {
    let d: Duration = Duration::from_nanos(1500000000)
    assert_eq(d.as_secs(), 1 as I64, "1.5B nanos should be 1 second")
    assert_eq(d.subsec_nanos(), 500000000, "should have 500M nanos fractional")
    return 0
}

@test
func test_duration_from_micros() -> I32 {
    let d: Duration = Duration::from_micros(2500000)
    assert_eq(d.as_secs(), 2 as I64, "2.5M micros = 2 seconds")
    assert_eq(d.subsec_millis(), 500, "fractional part should be 500ms")
    return 0
}

// === Accessor methods ===

@test
func test_duration_as_nanos() -> I32 {
    let d: Duration = Duration::new(2, 500000000)
    let nanos: I64 = d.as_nanos()
    assert_eq(nanos, 2500000000 as I64, "2.5 seconds = 2.5B nanos")
    return 0
}

@test
func test_duration_subsec_micros() -> I32 {
    let d: Duration = Duration::new(1, 123456789)
    let micros: I32 = d.subsec_micros()
    assert_eq(micros, 123456, "fractional micros should be 123456")
    return 0
}

@test
func test_duration_as_millis() -> I32 {
    let d: Duration = Duration::new(5, 500000000)
    assert_eq(d.as_millis(), 5500 as I64, "5.5 seconds = 5500 millis")
    return 0
}

@test
func test_duration_as_micros() -> I32 {
    let d: Duration = Duration::from_millis(100)
    assert_eq(d.as_micros(), 100000 as I64, "100ms = 100000 micros")
    return 0
}

// === Arithmetic ===

@test
func test_duration_is_zero() -> I32 {
    let zero: Duration = Duration::from_secs(0)
    let nonzero: Duration = Duration::from_secs(1)
    assert(zero.is_zero(), "0 seconds should be zero")
    assert(not nonzero.is_zero(), "1 second should not be zero")
    return 0
}

@test
func test_duration_mul() -> I32 {
    let d: Duration = Duration::from_secs(5)
    let doubled: Duration = d.mul(2)
    assert_eq(doubled.as_secs(), 10 as I64, "5 * 2 = 10 seconds")
    return 0
}

@test
func test_duration_div() -> I32 {
    let d: Duration = Duration::from_secs(10)
    let halved: Duration = d.div(2)
    assert_eq(halved.as_secs(), 5 as I64, "10 / 2 = 5 seconds")
    return 0
}

@test
func test_duration_add() -> I32 {
    let a: Duration = Duration::from_secs(2 as I64)
    let b: Duration = Duration::from_secs(3 as I64)
    let c: Duration = a.add(b)
    assert_eq(c.as_secs(), 5 as I64, "2s + 3s = 5s")
    return 0
}

@test
func test_duration_sub() -> I32 {
    let a: Duration = Duration::from_secs(5 as I64)
    let b: Duration = Duration::from_secs(2 as I64)
    let c: Duration = a.sub(b)
    assert_eq(c.as_secs(), 3 as I64, "5s - 2s = 3s")
    return 0
}

// === Saturating arithmetic ===

@test
func test_duration_saturating_add() -> I32 {
    let a: Duration = Duration::from_secs(5)
    let b: Duration = Duration::from_secs(3)
    let result: Duration = a.saturating_add(b)
    assert_eq(result.as_secs(), 8 as I64, "5 + 3 = 8 seconds")
    return 0
}

@test
func test_duration_saturating_sub() -> I32 {
    let a: Duration = Duration::from_secs(5)
    let b: Duration = Duration::from_secs(3)
    let result: Duration = a.saturating_sub(b)
    assert_eq(result.as_secs(), 2 as I64, "5 - 3 = 2 seconds")
    return 0
}

@test
func test_duration_saturating_sub_underflow() -> I32 {
    let a: Duration = Duration::from_secs(3)
    let b: Duration = Duration::from_secs(5)
    let result: Duration = a.saturating_sub(b)
    assert(result.is_zero(), "3 - 5 should saturate to zero")
    return 0
}

// === Comparison ===

@test
func test_duration_partial_cmp_less() -> I32 {
    let a: Duration = Duration::from_secs(1 as I64)
    let b: Duration = Duration::from_secs(2 as I64)
    let r: Maybe[Ordering] = a.partial_cmp(ref b)
    assert(r.is_just(), "partial_cmp should return Just")
    return 0
}

@test
func test_duration_partial_cmp_equal() -> I32 {
    let a: Duration = Duration::from_secs(5 as I64)
    let b: Duration = Duration::from_secs(5 as I64)
    let r: Maybe[Ordering] = a.partial_cmp(ref b)
    assert(r.is_just(), "partial_cmp equal should return Just")
    return 0
}

@test
func test_duration_cmp() -> I32 {
    let a: Duration = Duration::from_secs(3 as I64)
    let b: Duration = Duration::from_secs(1 as I64)
    let r: Ordering = a.cmp(ref b)
    return 0
}

// === Display ===

@test
func test_duration_to_string() -> I32 {
    let d: Duration = Duration::from_secs(5)
    let s: Str = d.to_string()
    assert_eq(s, "5s", "5 seconds should display as '5s'")
    return 0
}

@test
func test_duration_debug_string() -> I32 {
    let d: Duration = Duration::from_millis(1500 as I64)
    let s: Str = d.debug_string()
    assert(s.len() > 0, "debug_string should produce output")
    return 0
}

// === Checked arithmetic ===

@test
func test_duration_checked_add_basic() -> I32 {
    let a: Duration = Duration::from_secs(3)
    let b: Duration = Duration::from_secs(2)
    let result: Maybe[Duration] = a.checked_add(b)
    assert(result.is_just(), "checked_add should succeed")
    let d: Duration = result.unwrap()
    assert_eq(d.as_secs(), 5 as I64, "3+2=5 secs")
    return 0
}

@test
func test_duration_checked_add_nanos_carry() -> I32 {
    let a: Duration = Duration::new(1, 800000000)  // 1.8s
    let b: Duration = Duration::new(0, 400000000)  // 0.4s
    let result: Maybe[Duration] = a.checked_add(b)
    assert(result.is_just(), "should succeed")
    let d: Duration = result.unwrap()
    assert_eq(d.as_secs(), 2 as I64, "nanos carry to secs")
    assert_eq(d.subsec_nanos(), 200000000, "remaining 200ms nanos")
    return 0
}

@test
func test_duration_checked_sub_basic() -> I32 {
    let a: Duration = Duration::from_secs(5)
    let b: Duration = Duration::from_secs(3)
    let result: Maybe[Duration] = a.checked_sub(b)
    assert(result.is_just(), "checked_sub should succeed")
    let d: Duration = result.unwrap()
    assert_eq(d.as_secs(), 2 as I64, "5-3=2 secs")
    return 0
}

@test
func test_duration_checked_sub_underflow() -> I32 {
    let a: Duration = Duration::from_secs(2)
    let b: Duration = Duration::from_secs(5)
    let result: Maybe[Duration] = a.checked_sub(b)
    assert(result.is_nothing(), "2-5 should underflow to Nothing")
    return 0
}

@test
func test_duration_checked_sub_nanos_borrow() -> I32 {
    let a: Duration = Duration::new(5, 100000000)  // 5.1s
    let b: Duration = Duration::new(2, 300000000)  // 2.3s
    let result: Maybe[Duration] = a.checked_sub(b)
    assert(result.is_just(), "should succeed")
    let d: Duration = result.unwrap()
    assert_eq(d.as_secs(), 2 as I64, "5.1 - 2.3 = 2.8 secs part")
    assert_eq(d.subsec_nanos(), 800000000, "nanos part is 800ms")
    return 0
}

// === Equality ===

@test
func test_duration_eq() -> I32 {
    let a: Duration = Duration::from_millis(1000)
    let b: Duration = Duration::from_secs(1)
    assert(a.eq(ref b), "1000ms == 1s")
    return 0
}

// === Display with fractional ===

@test
func test_duration_display_millis() -> I32 {
    let d: Duration = Duration::from_millis(1500)
    let s: Str = d.to_string()
    assert_eq(s, "1.500s", "1500ms displays as 1.500s")
    return 0
}

// === Arithmetic with nanos ===

@test
func test_duration_mul_with_nanos() -> I32 {
    let d: Duration = Duration::new(1, 500000000)  // 1.5s
    let result: Duration = d.mul(3)
    assert_eq(result.as_secs(), 4 as I64, "1.5 * 3 = 4.5 secs part")
    assert_eq(result.subsec_nanos(), 500000000, "nanos part = 500ms")
    return 0
}

@test
func test_duration_div_with_nanos() -> I32 {
    let d: Duration = Duration::from_secs(10)
    let result: Duration = d.div(3)
    assert_eq(result.as_secs(), 3 as I64, "10/3 = 3 secs")
    return 0
}

// === Edge cases ===

@test
func test_duration_zero_check() -> I32 {
    let d: Duration = Duration::from_secs(0)
    assert(d.is_zero(), "zero is zero")
    assert_eq(d.as_secs(), 0 as I64, "zero secs")
    assert_eq(d.subsec_nanos(), 0, "zero nanos")
    return 0
}

@test
func test_duration_saturating_add_nanos_carry() -> I32 {
    let a: Duration = Duration::new(1, 900000000)  // 1.9s
    let b: Duration = Duration::new(0, 200000000)  // 0.2s
    let result: Duration = a.saturating_add(b)
    assert_eq(result.as_secs(), 2 as I64, "1.9 + 0.2 = 2.1 secs part")
    assert_eq(result.subsec_nanos(), 100000000, "100ms nanos")
    return 0
}

@test
func test_duration_display_zero() -> I32 {
    let d: Duration = Duration::from_secs(0)
    let s: Str = d.to_string()
    assert_eq(s, "0s", "zero displays as 0s")
    return 0
}
