// Consolidated numeric tests: inline bit manipulation, edge cases, NonZero, U64 bits, rotate/reverse
// Test count: 48 @test functions
// Sources: bit_manipulation.test.tml, integer_u64_bits.test.tml, integer_rotate_reverse.test.tml,
//          num_integer_be.test.tml, numeric_edge_cases.test.tml, nonzero.test.tml,
//          num_nonzero_sat_wrap.test.tml, num_checked.test.tml
use test
use core::num::integer
use core::num::integer::{
    count_zeros_u64, leading_zeros_u64, trailing_zeros_u64,
    rotate_left_u64, rotate_right_u64, swap_bytes_u64, reverse_bits_u64,
    rotate_left_u32, rotate_right_u32, reverse_bits_u32
}
use core::num::nonzero::NonZero

// ============================================================================
// Inline I32 bit manipulation functions (from bit_manipulation.test.tml)
// ============================================================================

func count_ones_i32(value: I32) -> I32 {
    let mut v: U32 = value as U32
    var count: I32 = 0
    let zero: U32 = 0 as U32
    loop (v != zero) {
        v = v & (v - (1 as U32))
        count = count + 1
    }
    return count
}

func count_zeros_i32(value: I32) -> I32 {
    return 32 - count_ones_i32(value)
}

func leading_zeros_i32(value: I32) -> I32 {
    if value == 0 {
        return 32
    }
    let mut v: U32 = value as U32
    var count: I32 = 0
    let high_bit: U32 = 2147483648 as U32
    let zero: U32 = 0 as U32
    loop ((v & high_bit) == zero and count < 32) {
        v = v << (1 as U32)
        count = count + 1
    }
    if count >= 32 {
        return 32
    }
    return count
}

func trailing_zeros_i32(value: I32) -> I32 {
    if value == 0 {
        return 32
    }
    let mut v: U32 = value as U32
    var count: I32 = 0
    let one: U32 = 1 as U32
    let zero: U32 = 0 as U32
    loop ((v & one) == zero and count < 32) {
        v = v >> one
        count = count + 1
    }
    if count >= 32 {
        return 32
    }
    return count
}

func rotate_left_i32(value: I32, n: I32) -> I32 {
    let n_mod: I32 = n % 32
    if n_mod == 0 {
        return value
    }
    let uval: U32 = value as U32
    let un: U32 = n_mod as U32
    let left_part: U32 = uval << un
    let right_part: U32 = uval >> (32 as U32 - un)
    return (left_part | right_part) as I32
}

func rotate_right_i32(value: I32, n: I32) -> I32 {
    let n_mod: I32 = n % 32
    if n_mod == 0 {
        return value
    }
    let uval: U32 = value as U32
    let un: U32 = n_mod as U32
    let right_part: U32 = uval >> un
    let left_part: U32 = uval << (32 as U32 - un)
    return (right_part | left_part) as I32
}

func swap_bytes_i32(value: I32) -> I32 {
    let v: U32 = value as U32
    let b0: U32 = (v & (255 as U32)) << (24 as U32)
    let b1: U32 = ((v >> (8 as U32)) & (255 as U32)) << (16 as U32)
    let b2: U32 = ((v >> (16 as U32)) & (255 as U32)) << (8 as U32)
    let b3: U32 = (v >> (24 as U32)) & (255 as U32)
    return (b0 | b1 | b2 | b3) as I32
}

func reverse_bits_i32(value: I32) -> I32 {
    let mut v: U32 = value as U32
    var result: U32 = 0 as U32
    var i: I32 = 0
    let one: U32 = 1 as U32
    loop (i < 32) {
        result = result << one
        result = result | (v & one)
        v = v >> one
        i = i + 1
    }
    return result as I32
}

func from_be_i32(value: I32) -> I32 {
    return swap_bytes_i32(value)
}

func from_le_i32(value: I32) -> I32 {
    return value
}

func to_be_i32(value: I32) -> I32 {
    return swap_bytes_i32(value)
}

func to_le_i32(value: I32) -> I32 {
    return value
}

// ============================================================================
// I32 Inline Bit Manipulation Tests (from bit_manipulation.test.tml)
// ============================================================================

@test
func test_count_ones_i32() -> I32 {
    assert_eq(count_ones_i32(0), 0, "count_ones(0) should be 0")
    assert_eq(count_ones_i32(1), 1, "count_ones(1) should be 1")
    assert_eq(count_ones_i32(3), 2, "count_ones(3) should be 2")
    assert_eq(count_ones_i32(7), 3, "count_ones(7) should be 3")
    assert_eq(count_ones_i32(15), 4, "count_ones(15) should be 4")
    assert_eq(count_ones_i32(255), 8, "count_ones(255) should be 8")
    assert_eq(count_ones_i32(-1), 32, "count_ones(-1) should be 32")
    return 0
}

@test
func test_count_zeros_i32() -> I32 {
    assert_eq(count_zeros_i32(0), 32, "count_zeros(0) should be 32")
    assert_eq(count_zeros_i32(-1), 0, "count_zeros(-1) should be 0")
    assert_eq(count_zeros_i32(1), 31, "count_zeros(1) should be 31")
    assert_eq(count_zeros_i32(255), 24, "count_zeros(255) should be 24")
    return 0
}

@test
func test_leading_zeros_i32() -> I32 {
    assert_eq(leading_zeros_i32(0), 32, "leading_zeros(0) should be 32")
    assert_eq(leading_zeros_i32(1), 31, "leading_zeros(1) should be 31")
    assert_eq(leading_zeros_i32(2), 30, "leading_zeros(2) should be 30")
    assert_eq(leading_zeros_i32(16), 27, "leading_zeros(16) should be 27")
    assert_eq(leading_zeros_i32(256), 23, "leading_zeros(256) should be 23")
    assert_eq(leading_zeros_i32(-1), 0, "leading_zeros(-1) should be 0")
    return 0
}

@test
func test_trailing_zeros_i32() -> I32 {
    assert_eq(trailing_zeros_i32(0), 32, "trailing_zeros(0) should be 32")
    assert_eq(trailing_zeros_i32(1), 0, "trailing_zeros(1) should be 0")
    assert_eq(trailing_zeros_i32(2), 1, "trailing_zeros(2) should be 1")
    assert_eq(trailing_zeros_i32(4), 2, "trailing_zeros(4) should be 2")
    assert_eq(trailing_zeros_i32(8), 3, "trailing_zeros(8) should be 3")
    assert_eq(trailing_zeros_i32(16), 4, "trailing_zeros(16) should be 4")
    return 0
}

@test
func test_rotate_left_i32() -> I32 {
    assert_eq(rotate_left_i32(1, 4), 16, "rotate_left(1, 4) should be 16")
    assert_eq(rotate_left_i32(42, 0), 42, "rotate_left(x, 0) should be x")
    assert_eq(rotate_left_i32(42, 32), 42, "rotate_left(x, 32) should be x")
    return 0
}

@test
func test_rotate_right_i32() -> I32 {
    assert_eq(rotate_right_i32(16, 4), 1, "rotate_right(16, 4) should be 1")
    assert_eq(rotate_right_i32(42, 0), 42, "rotate_right(x, 0) should be x")
    return 0
}

@test
func test_swap_bytes_i32() -> I32 {
    let val: I32 = 305419896 // 0x12345678
    let expected: I32 = 2018915346 // 0x78563412
    assert_eq(swap_bytes_i32(val), expected, "swap_bytes should reverse byte order")
    assert_eq(swap_bytes_i32(swap_bytes_i32(42)), 42, "double swap_bytes should be identity")
    return 0
}

@test
func test_reverse_bits_i32() -> I32 {
    assert_eq(reverse_bits_i32(reverse_bits_i32(12345)), 12345, "double reverse_bits should be identity")
    assert_eq(reverse_bits_i32(0), 0, "reverse_bits(0) should be 0")
    assert_eq(reverse_bits_i32(-1), -1, "reverse_bits(-1) should be -1")
    return 0
}

@test
func test_endian_i32() -> I32 {
    assert_eq(to_le_i32(42), 42, "to_le should be identity on little-endian")
    assert_eq(from_le_i32(42), 42, "from_le should be identity on little-endian")
    assert_eq(from_be_i32(to_be_i32(42)), 42, "from_be(to_be(x)) should be identity")
    return 0
}

// ============================================================================
// U64 Bit Manipulation Tests (from integer_u64_bits.test.tml)
// ============================================================================

@test
func test_count_zeros_u64() -> I32 {
    let zero: U64 = 0 as U64
    assert_eq(count_zeros_u64(zero) as I64, 64, "count_zeros U64 of 0 should be 64")
    return 0
}

@test
func test_leading_trailing_zeros_u64() -> I32 {
    let one: U64 = 1 as U64
    assert_eq(leading_zeros_u64(one) as I64, 63, "leading zeros of 1 should be 63")
    assert_eq(trailing_zeros_u64(one) as I64, 0, "trailing zeros of 1 should be 0")
    let eight: U64 = 8 as U64
    assert_eq(trailing_zeros_u64(eight) as I64, 3, "trailing zeros of 8 should be 3")
    return 0
}

@test
func test_swap_bytes_u64_double() -> I32 {
    let original: U64 = 123456789 as U64
    let swapped: U64 = swap_bytes_u64(swap_bytes_u64(original))
    assert_eq(swapped as I64, original as I64, "double swap U64 should be identity")
    return 0
}

// ============================================================================
// Rotate and reverse_bits on U32/U64 (from integer_rotate_reverse.test.tml)
// ============================================================================

@test
func test_rotate_u32_identity() -> I32 {
    let val: U32 = 42 as U32
    let rotated: U32 = rotate_right_u32(rotate_left_u32(val, 8 as U32), 8 as U32)
    assert_eq(rotated as I32, val as I32, "rotate left+right U32 should be identity")
    return 0
}

@test
func test_reverse_bits_u32_double() -> I32 {
    let original: U32 = 12345 as U32
    let reversed: U32 = reverse_bits_u32(reverse_bits_u32(original))
    assert_eq(reversed as I32, original as I32, "double reverse U32 should be identity")
    return 0
}

@test
func test_rotate_u64_identity() -> I32 {
    let val: U64 = 99999 as U64
    let rotated: U64 = rotate_right_u64(rotate_left_u64(val, 16 as U64), 16 as U64)
    assert_eq(rotated as I64, val as I64, "rotate left+right U64 should be identity")
    return 0
}

// ============================================================================
// I64 byte order and bit reversal (from num_integer_be.test.tml)
// ============================================================================

@test
func test_from_be_i64() -> I32 {
    let v: I64 = integer::from_be_i64(1 as I64)
    // On little-endian, from_be swaps bytes
    assert(v != 0 as I64, "from_be_i64(1) should be nonzero")
    return 0
}

@test
func test_to_be_i64() -> I32 {
    let v: I64 = integer::to_be_i64(1 as I64)
    assert(v != 0 as I64, "to_be_i64(1) should be nonzero")
    return 0
}

@test
func test_reverse_bits_u64() -> I32 {
    let v: U64 = integer::reverse_bits_u64(1 as U64)
    // Bit 0 reversed = bit 63 set = 0x8000000000000000
    assert(v != 0 as U64, "reverse_bits_u64(1) should be nonzero")
    return 0
}

// ============================================================================
// Integer casting (from numeric_edge_cases.test.tml)
// ============================================================================

@test
func test_i32_to_i64() -> I32 {
    let x: I32 = 42
    let y: I64 = x as I64
    assert(y == 42, "I32 to I64 should preserve value")
    return 0
}

@test
func test_i64_to_i32() -> I32 {
    let x: I64 = 100
    let y: I32 = x as I32
    assert(y == 100, "I64 to I32 small value should preserve")
    return 0
}

@test
func test_i32_to_f64() -> I32 {
    let x: I32 = 42
    let y: F64 = x as F64
    assert(y == 42.0, "I32 to F64 should preserve value")
    return 0
}

@test
func test_f64_to_i32_truncates() -> I32 {
    let x: F64 = 3.9
    let y: I32 = x as I32
    assert(y == 3, "F64 to I32 should truncate to 3")
    return 0
}

@test
func test_negative_f64_to_i32() -> I32 {
    let x: F64 = -2.7
    let y: I32 = x as I32
    assert(y == -2, "negative F64 to I32 should truncate toward zero")
    return 0
}

// ============================================================================
// Division and modulo (from numeric_edge_cases.test.tml)
// ============================================================================

@test
func test_integer_division() -> I32 {
    let a: I32 = 7
    let b: I32 = 3
    assert(a / b == 2, "7 / 3 should be 2")
    return 0
}

@test
func test_integer_modulo() -> I32 {
    let a: I32 = 7
    let b: I32 = 3
    assert(a % b == 1, "7 % 3 should be 1")
    return 0
}

@test
func test_modulo_zero_result() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    assert(a % b == 0, "10 % 5 should be 0")
    return 0
}

@test
func test_negative_modulo() -> I32 {
    let a: I32 = -7
    let b: I32 = 3
    // In most languages, sign of result follows dividend
    let result: I32 = a % b
    assert(result == -1, "-7 % 3 should be -1")
    return 0
}

@test
func test_division_by_one() -> I32 {
    let a: I32 = 42
    assert(a / 1 == 42, "x / 1 should be x")
    return 0
}

// ============================================================================
// Floating point arithmetic (from numeric_edge_cases.test.tml)
// ============================================================================

@test
func test_f64_addition() -> I32 {
    let a: F64 = 1.5
    let b: F64 = 2.5
    assert(a + b == 4.0, "1.5 + 2.5 should be 4.0")
    return 0
}

@test
func test_f64_subtraction() -> I32 {
    let a: F64 = 5.0
    let b: F64 = 3.5
    assert(a - b == 1.5, "5.0 - 3.5 should be 1.5")
    return 0
}

@test
func test_f64_multiplication() -> I32 {
    let a: F64 = 2.5
    let b: F64 = 4.0
    assert(a * b == 10.0, "2.5 * 4.0 should be 10.0")
    return 0
}

@test
func test_f64_division() -> I32 {
    let a: F64 = 7.0
    let b: F64 = 2.0
    assert(a / b == 3.5, "7.0 / 2.0 should be 3.5")
    return 0
}

// ============================================================================
// Bitwise operations (from numeric_edge_cases.test.tml)
// ============================================================================

@test
func test_bitwise_and() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a & b) == 0b1000, "1100 & 1010 should be 1000")
    return 0
}

@test
func test_bitwise_or() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a | b) == 0b1110, "1100 | 1010 should be 1110")
    return 0
}

@test
func test_bitwise_xor() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a ^ b) == 0b0110, "1100 ^ 1010 should be 0110")
    return 0
}

@test
func test_shift_left() -> I32 {
    let a: I32 = 1
    assert((a << 3) == 8, "1 << 3 should be 8")
    return 0
}

@test
func test_shift_right() -> I32 {
    let a: I32 = 16
    assert((a >> 2) == 4, "16 >> 2 should be 4")
    return 0
}

// ============================================================================
// NonZero tests (from nonzero.test.tml)
// ============================================================================

@test
func test_nonzero_new_with_positive_i32() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](42)
    assert(result.is_just(), "NonZero::new(42) should return Just")
    return 0
}

@test
func test_nonzero_new_with_zero_i32() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](0)
    assert(result.is_nothing(), "NonZero::new(0) should return Nothing")
    return 0
}

@test
func test_nonzero_new_with_negative_i32() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](-5)
    assert(result.is_just(), "NonZero::new(-5) should return Just (negative is not zero)")
    return 0
}

@test
func test_nonzero_get_i32() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](42)
    when result {
        Just(n) => {
            assert_eq(n.get(), 42, "NonZero.get() should return the value")
            return 0
        },
        Nothing => {
            assert(false, "Should not be Nothing")
            return 1
        }
    }
}

@test
func test_nonzero_get_negative() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](-100)
    when result {
        Just(n) => {
            assert_eq(n.get(), -100, "NonZero.get() should return negative value")
            return 0
        },
        Nothing => {
            assert(false, "Should not be Nothing")
            return 1
        }
    }
}

@test
func test_nonzero_i64_positive() -> I32 {
    let result: Maybe[NonZero[I64]] = NonZero::new[I64](1000000)
    assert(result.is_just(), "NonZero::new[I64](1000000) should return Just")
    return 0
}

@test
func test_nonzero_i64_zero() -> I32 {
    let zero: I64 = 0
    let result: Maybe[NonZero[I64]] = NonZero::new[I64](zero)
    assert(result.is_nothing(), "NonZero::new[I64](0) should return Nothing")
    return 0
}

@test
func test_nonzero_duplicate() -> I32 {
    let a: Maybe[NonZero[I32]] = NonZero::new[I32](42)
    when a {
        Just(na) => {
            let cloned: NonZero[I32] = na.duplicate()
            assert_eq(cloned.get(), 42, "Duplicated NonZero should have same value")
            return 0
        },
        Nothing => { return 1 }
    }
}

// ============================================================================
// NonZero additional tests (from num_nonzero_sat_wrap.test.tml)
// BLOCKED: Saturating::new[I32]().get/add/sub() -- generic monomorphization
// BLOCKED: Wrapping::new[I32]().get/add/sub() -- generic monomorphization
// ============================================================================

@test
func test_nonzero_new_valid() -> I32 {
    let nz: Maybe[NonZero[I32]] = NonZero::new[I32](42)
    assert(nz.is_just(), "NonZero::new(42) should be Just")
    return 0
}

@test
func test_nonzero_new_zero() -> I32 {
    let nz: Maybe[NonZero[I32]] = NonZero::new[I32](0)
    assert(nz.is_nothing(), "NonZero::new(0) should be Nothing")
    return 0
}

// ============================================================================
// Checked arithmetic (from num_checked.test.tml)
// ============================================================================

@test
func test_checked_add_ok_consolidated() -> I32 {
    let x: I32 = 10
    let result: Maybe[I32] = x.checked_add(20)
    when result {
        Just(v) => assert_eq(v, 30, "checked_add ok"),
        Nothing => assert(false, "should not overflow")
    }
    return 0
}

@test
func test_checked_add_overflow_consolidated() -> I32 {
    let x: I32 = 2147483647
    let result: Maybe[I32] = x.checked_add(1)
    when result {
        Just(v) => assert(false, "should overflow"),
        Nothing => assert(true, "overflow returns Nothing")
    }
    return 0
}
