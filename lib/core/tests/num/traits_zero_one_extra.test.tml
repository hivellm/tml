// Tests for core::num::traits â€” Zero and One for uncovered types
use test::{assert, assert_eq}
use core::num::traits::{Zero, One}

// === Zero for remaining types ===

@test
func test_zero_i8() -> I32 {
    let z: I8 = I8::zero()
    assert_eq(z as I32, 0, "I8::zero()")
    assert(z.is_zero(), "I8 0 is zero")
    return 0
}

@test
func test_zero_i16() -> I32 {
    let z: I16 = I16::zero()
    assert_eq(z as I32, 0, "I16::zero()")
    assert(z.is_zero(), "I16 0 is zero")
    return 0
}

@test
func test_zero_u16() -> I32 {
    let z: U16 = U16::zero()
    assert_eq(z as I32, 0, "U16::zero()")
    assert(z.is_zero(), "U16 0 is zero")
    return 0
}

@test
func test_zero_u32() -> I32 {
    let z: U32 = U32::zero()
    assert_eq(z as I32, 0, "U32::zero()")
    assert(z.is_zero(), "U32 0 is zero")
    return 0
}

@test
func test_zero_u64() -> I32 {
    let z: U64 = U64::zero()
    assert_eq(z as I64, 0 as I64, "U64::zero()")
    assert(z.is_zero(), "U64 0 is zero")
    return 0
}

@test
func test_zero_f32() -> I32 {
    let z: F32 = F32::zero()
    assert(z == 0.0 as F32, "F32::zero()")
    assert(z.is_zero(), "F32 0.0 is zero")
    return 0
}

@test
func test_zero_f64() -> I32 {
    let z: F64 = F64::zero()
    assert(z == 0.0, "F64::zero()")
    assert(z.is_zero(), "F64 0.0 is zero")
    return 0
}

// === One for remaining types ===

@test
func test_one_i8() -> I32 {
    let o: I8 = I8::one()
    assert_eq(o as I32, 1, "I8::one()")
    assert(o.is_one(), "I8 1 is one")
    return 0
}

@test
func test_one_i16() -> I32 {
    let o: I16 = I16::one()
    assert_eq(o as I32, 1, "I16::one()")
    assert(o.is_one(), "I16 1 is one")
    return 0
}

@test
func test_one_u16() -> I32 {
    let o: U16 = U16::one()
    assert_eq(o as I32, 1, "U16::one()")
    assert(o.is_one(), "U16 1 is one")
    return 0
}

@test
func test_one_u32() -> I32 {
    let o: U32 = U32::one()
    assert_eq(o as I32, 1, "U32::one()")
    assert(o.is_one(), "U32 1 is one")
    return 0
}

@test
func test_one_u64() -> I32 {
    let o: U64 = U64::one()
    assert_eq(o as I64, 1 as I64, "U64::one()")
    assert(o.is_one(), "U64 1 is one")
    return 0
}

@test
func test_one_f32() -> I32 {
    let o: F32 = F32::one()
    assert(o == 1.0 as F32, "F32::one()")
    assert(o.is_one(), "F32 1.0 is one")
    return 0
}

@test
func test_one_f64() -> I32 {
    let o: F64 = F64::one()
    assert(o == 1.0, "F64::one()")
    assert(o.is_one(), "F64 1.0 is one")
    return 0
}
