// Tests for core::num â€” I64 bit operations
use test::{assert, assert_eq}
use core::num

@test
func test_count_ones_i64() -> I32 {
    assert_eq(num::count_ones_i64(0), 0, "count_ones 0")
    assert_eq(num::count_ones_i64(1), 1, "count_ones 1")
    assert_eq(num::count_ones_i64(255), 8, "count_ones 255")
    return 0
}

@test
func test_count_zeros_i64() -> I32 {
    assert_eq(num::count_zeros_i64(0), 64, "count_zeros 0")
    assert_eq(num::count_zeros_i64(-1), 0, "count_zeros -1")
    return 0
}

@test
func test_leading_zeros_i64() -> I32 {
    assert_eq(num::leading_zeros_i64(1), 63, "leading_zeros 1")
    assert_eq(num::leading_zeros_i64(0), 64, "leading_zeros 0")
    return 0
}

@test
func test_trailing_zeros_i64() -> I32 {
    assert_eq(num::trailing_zeros_i64(1), 0, "trailing_zeros 1")
    assert_eq(num::trailing_zeros_i64(8), 3, "trailing_zeros 8")
    return 0
}

@test
func test_swap_bytes_i64() -> I32 {
    let v = num::swap_bytes_i64(0x0102030405060708)
    assert_eq(v, 0x0807060504030201, "swap_bytes_i64")
    return 0
}

@test
func test_rotate_left_i64() -> I32 {
    let v = num::rotate_left_i64(1, 1)
    assert_eq(v, 2, "rotate_left 1 by 1")
    return 0
}

@test
func test_rotate_right_i64() -> I32 {
    let v = num::rotate_right_i64(2, 1)
    assert_eq(v, 1, "rotate_right 2 by 1")
    return 0
}
