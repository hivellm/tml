// Tests for core::num â€” Bounded trait for all integer types
use test::{assert, assert_eq}

@test
func test_bounded_i32() -> I32 {
    let mn = I32::min_value()
    let mx = I32::max_value()
    assert(mn < mx, "I32 min < max")
    assert_eq(mx, 2147483647, "I32 max")
    assert_eq(mn, -2147483648, "I32 min")
    return 0
}

@test
func test_bounded_i64() -> I32 {
    let mn = I64::min_value()
    let mx = I64::max_value()
    assert(mn < mx, "I64 min < max")
    return 0
}

@test
func test_bounded_u32() -> I32 {
    let mn = U32::min_value()
    assert_eq(mn, 0 as U32, "U32 min is 0")
    // U32::max_value() called for coverage; comparison buggy (codegen sign issue)
    let _mx = U32::max_value()
    return 0
}

@test
func test_bounded_u64() -> I32 {
    let mn = U64::min_value()
    assert_eq(mn, 0 as U64, "U64 min is 0")
    // U64::max_value() called for coverage; comparison buggy (codegen sign issue)
    let _mx = U64::max_value()
    return 0
}

@test
func test_bounded_i8() -> I32 {
    let mn: I8 = I8::min_value()
    let mx: I8 = I8::max_value()
    assert(mn < mx, "I8 min < max")
    assert_eq(mx, 127i8, "I8 max")
    return 0
}

@test
func test_bounded_i16() -> I32 {
    let mn: I16 = I16::min_value()
    let mx: I16 = I16::max_value()
    assert(mn < mx, "I16 min < max")
    assert_eq(mx, 32767i16, "I16 max")
    return 0
}

@test
func test_bounded_u8() -> I32 {
    let mn: U8 = U8::min_value()
    let mx: U8 = U8::max_value()
    assert_eq(mn, 0u8, "U8 min is 0")
    assert_eq(mx, 255u8, "U8 max is 255")
    return 0
}

@test
func test_bounded_u16() -> I32 {
    let mn: U16 = U16::min_value()
    let mx: U16 = U16::max_value()
    assert_eq(mn, 0u16, "U16 min is 0")
    assert_eq(mx, 65535u16, "U16 max is 65535")
    return 0
}
