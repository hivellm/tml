// Consolidated numeric tests: basic number properties, arithmetic, float, methods
// Test count: 48 @test functions
// Sources: num.test.tml (original), overflow_checked.test.tml
use test

// Define I32 methods locally for testing
impl I32 {
    pub const MIN: I32 = -2147483648 as I32
    pub const MAX: I32 = 2147483647 as I32

    pub func abs(this) -> I32 {
        if this < 0 { return 0 - this }
        return this
    }

    pub func signum(this) -> I32 {
        if this > 0 { return 1 }
        if this < 0 { return -1 }
        return 0
    }

    pub func is_positive(this) -> Bool { return this > 0 }
    pub func is_negative(this) -> Bool { return this < 0 }

    pub func pow(this, exp: I32) -> I32 {
        if exp == 0 { return 1 }
        if exp == 1 { return this }
        let mut result: I32 = 1
        let mut b: I32 = this
        let mut e: I32 = exp
        loop (e > 0) {
            if e % 2 == 1 { result = result * b }
            b = b * b
            e = e / 2
        }
        return result
    }
}

// Helper function that returns negative I8
func get_negative_i8() -> I8 {
    return -50 as I8
}

// Helper function that returns I8::MIN (-128)
func get_i8_min() -> I8 {
    return -128 as I8
}

// ============ Zero Identity Property ============

@test
func test_zero_additive_identity_i32() -> I32 {
    // x + 0 == x for all x
    let x: I32 = 42
    let z: I32 = 0
    assert_eq(x + z, x, "x + 0 should equal x")
    assert_eq(z + x, x, "0 + x should equal x")
    return 0
}

@test
func test_zero_additive_identity_i64() -> I32 {
    let x: I64 = 12345678901234
    let z: I64 = 0
    assert_eq(x + z, x, "x + 0 should equal x")
    assert_eq(z + x, x, "0 + x should equal x")
    return 0
}

@test
func test_zero_additive_identity_f64() -> I32 {
    let x: F64 = 3.14159
    let z: F64 = 0.0
    assert(x + z == x, "x + 0 should equal x")
    assert(z + x == x, "0 + x should equal x")
    return 0
}

// ============ One Identity Property ============

@test
func test_one_multiplicative_identity_i32() -> I32 {
    // x * 1 == x for all x
    let x: I32 = 42
    let o: I32 = 1
    assert_eq(x * o, x, "x * 1 should equal x")
    assert_eq(o * x, x, "1 * x should equal x")
    return 0
}

@test
func test_one_multiplicative_identity_i64() -> I32 {
    let x: I64 = 12345678901234
    let o: I64 = 1
    assert_eq(x * o, x, "x * 1 should equal x")
    assert_eq(o * x, x, "1 * x should equal x")
    return 0
}

@test
func test_one_multiplicative_identity_f64() -> I32 {
    let x: F64 = 3.14159
    let o: F64 = 1.0
    assert(x * o == x, "x * 1 should equal x")
    assert(o * x == x, "1 * x should equal x")
    return 0
}

// ============ Zero/One Combined Tests ============

@test
func test_zero_times_anything_is_zero() -> I32 {
    let z: I32 = 0
    let x: I32 = 42
    assert_eq(z * x, 0, "0 * x should equal 0")
    assert_eq(x * z, 0, "x * 0 should equal 0")
    return 0
}

@test
func test_one_minus_one_is_zero() -> I32 {
    let o: I32 = 1
    assert_eq(o - o, 0, "1 - 1 should equal 0")
    return 0
}

// ============ Bounded Tests ============

@test
func test_bounded_i8_range() -> I32 {
    // I8 range: -128 to 127
    let min: I8 = -128
    let max: I8 = 127
    assert_eq(min, -128 as I8, "I8 min should be -128")
    assert_eq(max, 127 as I8, "I8 max should be 127")
    return 0
}

@test
func test_bounded_u8_range() -> I32 {
    // U8 range: 0 to 255
    let min: U8 = 0
    let max: U8 = 255
    assert_eq(min, 0 as U8, "U8 min should be 0")
    assert_eq(max, 255 as U8, "U8 max should be 255")
    return 0
}

@test
func test_bounded_i32_range() -> I32 {
    let min: I32 = -2147483648
    let max: I32 = 2147483647
    assert_eq(min, -2147483648, "I32 min")
    assert_eq(max, 2147483647, "I32 max")
    return 0
}

// ============ Integer Type Properties ============

@test
func test_i64_bounds() -> I32 {
    let min: I64 = -9223372036854775808
    let max: I64 = 9223372036854775807
    assert(min < 0, "I64 min should be negative")
    assert(max > 0, "I64 max should be positive")
    return 0
}

@test
func test_unsigned_no_negative() -> I32 {
    let zero: U32 = 0
    let one: U32 = 1
    assert(one > zero, "1 > 0 for unsigned")
    return 0
}

@test
func test_u64_max() -> I32 {
    let max: U64 = 18446744073709551615
    assert(max > 0, "U64 max should be positive")
    return 0
}

// ============ Additional Zero Tests ============

@test
func test_zero_subtraction() -> I32 {
    let x: I32 = 100
    let z: I32 = 0
    assert_eq(x - z, x, "x - 0 should equal x")
    return 0
}

// ============ Additional One Tests ============

@test
func test_one_division() -> I32 {
    let x: I32 = 42
    let o: I32 = 1
    assert_eq(x / o, x, "x / 1 should equal x")
    return 0
}

// ============ Signed Integer Properties ============

@test
func test_signed_negation() -> I32 {
    let x: I32 = 10
    let neg: I32 = -x
    assert_eq(neg, -10, "negation of 10 should be -10")
    assert_eq(x + neg, 0, "x + (-x) should equal 0")
    return 0
}

@test
func test_signed_i16_range() -> I32 {
    let min: I16 = -32768
    let max: I16 = 32767
    assert(min < 0, "I16 min should be negative")
    assert(max > 0, "I16 max should be positive")
    return 0
}

// ============ Unsigned Integer Properties ============

@test
func test_unsigned_u16_range() -> I32 {
    let min: U16 = 0
    let max: U16 = 65535
    assert_eq(min, 0 as U16, "U16 min should be 0")
    assert_eq(max, 65535 as U16, "U16 max should be 65535")
    return 0
}

@test
func test_unsigned_u32_max() -> I32 {
    let max: U32 = 4294967295
    assert(max > 0, "U32 max should be positive")
    return 0
}

// ============ Arithmetic Properties ============

@test
func test_commutative_addition() -> I32 {
    let a: I32 = 7
    let b: I32 = 13
    assert_eq(a + b, b + a, "addition should be commutative")
    return 0
}

@test
func test_commutative_multiplication() -> I32 {
    let a: I32 = 7
    let b: I32 = 13
    assert_eq(a * b, b * a, "multiplication should be commutative")
    return 0
}

@test
func test_associative_addition() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 15
    assert_eq((a + b) + c, a + (b + c), "addition should be associative")
    return 0
}

@test
func test_distributive_property() -> I32 {
    let a: I32 = 2
    let b: I32 = 3
    let c: I32 = 4
    assert_eq(a * (b + c), (a * b) + (a * c), "multiplication should distribute over addition")
    return 0
}

// ============ Float Properties ============

// Test F32 basic operations
@test
func test_float_f32_basic() -> I32 {
    let x: F32 = 3.14 as F32
    let y: F32 = 2.0 as F32
    let sum: F32 = x + y
    // Use F32 literals for comparison
    assert(sum > (5.0 as F32), "3.14 + 2.0 should be > 5.0")
    assert(sum < (6.0 as F32), "3.14 + 2.0 should be < 6.0")
    return 0
}

@test
func test_float_f64_arithmetic() -> I32 {
    let x: F64 = 3.14
    let y: F64 = 2.0
    let sum: F64 = x + y
    assert(sum > 5.0, "3.14 + 2.0 should be > 5.0")
    assert(sum < 5.2, "3.14 + 2.0 should be < 5.2")
    return 0
}

@test
func test_float_comparison() -> I32 {
    let x: F64 = 1.5
    let y: F64 = 2.5
    assert(x < y, "1.5 should be less than 2.5")
    assert(y > x, "2.5 should be greater than 1.5")
    return 0
}

@test
func test_float_negative() -> I32 {
    let x: F64 = -3.5
    assert(x < 0.0, "negative float should be less than 0")
    let pos: F64 = -x
    assert(pos > 0.0, "negated negative should be positive")
    return 0
}

// ============ Integer Method Tests ============

@test
func test_i32_abs() -> I32 {
    assert_eq((-5).abs(), 5, "(-5).abs() should be 5")
    assert_eq((5).abs(), 5, "(5).abs() should be 5")
    assert_eq((0).abs(), 0, "(0).abs() should be 0")
    assert_eq((-2147483647).abs(), 2147483647, "large negative abs")
    return 0
}

@test
func test_i32_signum() -> I32 {
    assert_eq((10).signum(), 1, "positive signum should be 1")
    assert_eq((0).signum(), 0, "zero signum should be 0")
    assert_eq((-10).signum(), -1, "negative signum should be -1")
    return 0
}

@test
func test_i32_is_positive() -> I32 {
    assert((10).is_positive(), "10 should be positive")
    assert(not (0).is_positive(), "0 should not be positive")
    assert(not (-10).is_positive(), "-10 should not be positive")
    return 0
}

@test
func test_i32_is_negative() -> I32 {
    assert((-10).is_negative(), "-10 should be negative")
    assert(not (0).is_negative(), "0 should not be negative")
    assert(not (10).is_negative(), "10 should not be negative")
    return 0
}

@test
func test_i32_pow() -> I32 {
    assert_eq((2).pow(10), 1024, "2^10 should be 1024")
    assert_eq((3).pow(3), 27, "3^3 should be 27")
    assert_eq((5).pow(0), 1, "5^0 should be 1")
    assert_eq((7).pow(1), 7, "7^1 should be 7")
    assert_eq((-2).pow(3), -8, "(-2)^3 should be -8")
    return 0
}

// ============ Integer MIN/MAX Constant Tests ============

@test
func test_i32_min_max_constants() -> I32 {
    assert_eq(I32::MIN, -2147483648, "I32::MIN")
    assert_eq(I32::MAX, 2147483647, "I32::MAX")
    return 0
}

// Test I8 MIN/MAX values using literals
@test
func test_i8_min_max_literals() -> I32 {
    let min_val: I8 = -128 as I8
    let max_val: I8 = 127 as I8
    assert_eq(min_val as I32, -128, "I8 -128 literal should be -128")
    assert_eq(max_val as I32, 127, "I8 127 literal should be 127")
    return 0
}

// Test I16 MIN/MAX values using literals
@test
func test_i16_min_max_literals() -> I32 {
    let min_val: I16 = -32768 as I16
    let max_val: I16 = 32767 as I16
    assert_eq(min_val as I32, -32768, "I16 -32768 literal should be -32768")
    assert_eq(max_val as I32, 32767, "I16 32767 literal should be 32767")
    return 0
}

// Test I8 negative return value
@test
func test_i8_negative_return() -> I32 {
    let val: I8 = get_negative_i8()
    assert_eq(val as I32, -50, "I8 negative return value should be -50")
    return 0
}

// Test I8 MIN return value
@test
func test_i8_min_return() -> I32 {
    let val: I8 = get_i8_min()
    assert_eq(val as I32, -128, "I8 MIN return value should be -128")
    return 0
}

// ============ Basic Arithmetic (from overflow_checked.test.tml) ============

@test
func test_i32_add() -> I32 {
    let a: I32 = 100
    let b: I32 = 200
    assert(a + b == 300, "100 + 200 should be 300")
    return 0
}

@test
func test_i32_sub() -> I32 {
    let a: I32 = 300
    let b: I32 = 100
    assert(a - b == 200, "300 - 100 should be 200")
    return 0
}

@test
func test_i32_mul() -> I32 {
    let a: I32 = 15
    let b: I32 = 20
    assert(a * b == 300, "15 * 20 should be 300")
    return 0
}

@test
func test_i32_div() -> I32 {
    let a: I32 = 100
    let b: I32 = 5
    assert(a / b == 20, "100 / 5 should be 20")
    return 0
}

@test
func test_i32_mod() -> I32 {
    let a: I32 = 17
    let b: I32 = 5
    assert(a % b == 2, "17 % 5 should be 2")
    return 0
}

@test
func test_i64_add() -> I32 {
    let a: I64 = 1000000000
    let b: I64 = 2000000000
    assert(a + b == 3000000000, "I64 add should work")
    return 0
}

@test
func test_i64_mul() -> I32 {
    let a: I64 = 100000
    let b: I64 = 100000
    assert(a * b == 10000000000, "I64 mul should work")
    return 0
}

@test
func test_i32_to_string() -> I32 {
    let a: I32 = 42
    let s: Str = a.to_string()
    assert(s.len() > 0, "I32 to_string should produce output")
    return 0
}

@test
func test_i64_to_string() -> I32 {
    let a: I64 = 1234567890
    let s: Str = a.to_string()
    assert(s.len() > 0, "I64 to_string should produce output")
    return 0
}

@test
func test_f64_to_string() -> I32 {
    let a: F64 = 3.14
    let s: Str = a.to_string()
    assert(s.len() > 0, "F64 to_string should produce output")
    return 0
}
