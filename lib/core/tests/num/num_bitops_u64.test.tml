// Tests for core::num â€” U64 bit operations
use test::{assert, assert_eq}
use core::num

@test
func test_count_ones_u64() -> I32 {
    assert_eq(num::count_ones_u64(0 as U64), 0 as U64, "count_ones 0")
    assert_eq(num::count_ones_u64(1 as U64), 1 as U64, "count_ones 1")
    assert_eq(num::count_ones_u64(255 as U64), 8 as U64, "count_ones 255")
    return 0
}

@test
func test_count_zeros_u64() -> I32 {
    assert_eq(num::count_zeros_u64(0 as U64), 64 as U64, "count_zeros 0")
    return 0
}

@test
func test_leading_zeros_u64() -> I32 {
    assert_eq(num::leading_zeros_u64(1 as U64), 63 as U64, "leading_zeros 1")
    assert_eq(num::leading_zeros_u64(0 as U64), 64 as U64, "leading_zeros 0")
    return 0
}

@test
func test_trailing_zeros_u64() -> I32 {
    assert_eq(num::trailing_zeros_u64(1 as U64), 0 as U64, "trailing_zeros 1")
    assert_eq(num::trailing_zeros_u64(16 as U64), 4 as U64, "trailing_zeros 16")
    return 0
}

@test
func test_swap_bytes_u64() -> I32 {
    let v = num::swap_bytes_u64(0x0102030405060708 as U64)
    assert_eq(v, 0x0807060504030201 as U64, "swap_bytes_u64")
    return 0
}

@test
func test_rotate_left_u64() -> I32 {
    let v = num::rotate_left_u64(1 as U64, 1 as U64)
    assert_eq(v, 2 as U64, "rotate_left 1 by 1")
    return 0
}

@test
func test_rotate_right_u64() -> I32 {
    let v = num::rotate_right_u64(2 as U64, 1 as U64)
    assert_eq(v, 1 as U64, "rotate_right 2 by 1")
    return 0
}
