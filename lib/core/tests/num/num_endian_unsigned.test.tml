// Tests for core::num â€” endianness conversion for unsigned types
use test::{assert, assert_eq}
use core::num

@test
func test_swap_bytes_u32() -> I32 {
    let v = num::swap_bytes_u32(num::swap_bytes_u32(0x12345678 as U32))
    assert_eq(v, 0x12345678 as U32, "double swap is identity")
    return 0
}

@test
func test_swap_bytes_u64() -> I32 {
    let v = num::swap_bytes_u64(num::swap_bytes_u64(0x123456789ABCDEF0 as U64))
    assert_eq(v, 0x123456789ABCDEF0 as U64, "double swap is identity")
    return 0
}

@test
func test_reverse_bits_u32() -> I32 {
    let v = num::reverse_bits_u32(num::reverse_bits_u32(0xDEADBEEF as U32))
    assert_eq(v, 0xDEADBEEF as U32, "double reverse is identity")
    return 0
}

@test
func test_reverse_bits_u64() -> I32 {
    let v = num::reverse_bits_u64(num::reverse_bits_u64(0xCAFEBABE12345678 as U64))
    assert_eq(v, 0xCAFEBABE12345678 as U64, "double reverse is identity")
    return 0
}

@test
func test_swap_bytes_i32() -> I32 {
    let v = num::swap_bytes_i32(num::swap_bytes_i32(0x12345678))
    assert_eq(v, 0x12345678, "double swap i32 is identity")
    return 0
}

@test
func test_swap_bytes_i64() -> I32 {
    let v = num::swap_bytes_i64(num::swap_bytes_i64(0x123456789ABCDEF0))
    assert_eq(v, 0x123456789ABCDEF0, "double swap i64 is identity")
    return 0
}
