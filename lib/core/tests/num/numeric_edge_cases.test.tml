// Tests for numeric edge cases - casting, division, modulo, boundaries
use test

// =============================================================================
// Integer casting
// =============================================================================

@test
func test_i32_to_i64() -> I32 {
    let x: I32 = 42
    let y: I64 = x as I64
    assert(y == 42, "I32 to I64 should preserve value")
    return 0
}

@test
func test_i64_to_i32() -> I32 {
    let x: I64 = 100
    let y: I32 = x as I32
    assert(y == 100, "I64 to I32 small value should preserve")
    return 0
}

@test
func test_i32_to_f64() -> I32 {
    let x: I32 = 42
    let y: F64 = x as F64
    assert(y == 42.0, "I32 to F64 should preserve value")
    return 0
}

@test
func test_f64_to_i32_truncates() -> I32 {
    let x: F64 = 3.9
    let y: I32 = x as I32
    assert(y == 3, "F64 to I32 should truncate to 3")
    return 0
}

@test
func test_negative_f64_to_i32() -> I32 {
    let x: F64 = -2.7
    let y: I32 = x as I32
    assert(y == -2, "negative F64 to I32 should truncate toward zero")
    return 0
}

// =============================================================================
// Division and modulo
// =============================================================================

@test
func test_integer_division() -> I32 {
    let a: I32 = 7
    let b: I32 = 3
    assert(a / b == 2, "7 / 3 should be 2")
    return 0
}

@test
func test_integer_modulo() -> I32 {
    let a: I32 = 7
    let b: I32 = 3
    assert(a % b == 1, "7 % 3 should be 1")
    return 0
}

@test
func test_modulo_zero_result() -> I32 {
    let a: I32 = 10
    let b: I32 = 5
    assert(a % b == 0, "10 % 5 should be 0")
    return 0
}

@test
func test_negative_modulo() -> I32 {
    let a: I32 = -7
    let b: I32 = 3
    // In most languages, sign of result follows dividend
    let result: I32 = a % b
    assert(result == -1, "-7 % 3 should be -1")
    return 0
}

@test
func test_division_by_one() -> I32 {
    let a: I32 = 42
    assert(a / 1 == 42, "x / 1 should be x")
    return 0
}

// =============================================================================
// Floating point arithmetic
// =============================================================================

@test
func test_f64_addition() -> I32 {
    let a: F64 = 1.5
    let b: F64 = 2.5
    assert(a + b == 4.0, "1.5 + 2.5 should be 4.0")
    return 0
}

@test
func test_f64_subtraction() -> I32 {
    let a: F64 = 5.0
    let b: F64 = 3.5
    assert(a - b == 1.5, "5.0 - 3.5 should be 1.5")
    return 0
}

@test
func test_f64_multiplication() -> I32 {
    let a: F64 = 2.5
    let b: F64 = 4.0
    assert(a * b == 10.0, "2.5 * 4.0 should be 10.0")
    return 0
}

@test
func test_f64_division() -> I32 {
    let a: F64 = 7.0
    let b: F64 = 2.0
    assert(a / b == 3.5, "7.0 / 2.0 should be 3.5")
    return 0
}

// =============================================================================
// Bitwise operations
// =============================================================================

@test
func test_bitwise_and() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a & b) == 0b1000, "1100 & 1010 should be 1000")
    return 0
}

@test
func test_bitwise_or() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a | b) == 0b1110, "1100 | 1010 should be 1110")
    return 0
}

@test
func test_bitwise_xor() -> I32 {
    let a: I32 = 0b1100
    let b: I32 = 0b1010
    assert((a ^ b) == 0b0110, "1100 ^ 1010 should be 0110")
    return 0
}

@test
func test_shift_left() -> I32 {
    let a: I32 = 1
    assert((a << 3) == 8, "1 << 3 should be 8")
    return 0
}

@test
func test_shift_right() -> I32 {
    let a: I32 = 16
    assert((a >> 2) == 4, "16 >> 2 should be 4")
    return 0
}
