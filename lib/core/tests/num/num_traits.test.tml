// Tests for core::num â€” Zero, One, Bounded traits
use test::{assert, assert_eq}
use core::num

@test
func test_i32_is_zero() -> I32 {
    let z: I32 = 0
    assert(z.is_zero(), "0 is zero")
    let n: I32 = 5
    assert(not n.is_zero(), "5 is not zero")
    return 0
}

@test
func test_i64_is_zero() -> I32 {
    let z: I64 = 0
    assert(z.is_zero(), "0 is zero")
    let n: I64 = 1
    assert(not n.is_zero(), "1 is not zero")
    return 0
}

@test
func test_i32_is_one() -> I32 {
    let o: I32 = 1
    assert(o.is_one(), "1 is one")
    let z: I32 = 0
    assert(not z.is_one(), "0 is not one")
    return 0
}

@test
func test_i64_is_one() -> I32 {
    let o: I64 = 1
    assert(o.is_one(), "1 is one")
    return 0
}

@test
func test_bounded_i32() -> I32 {
    let mn = I32::min_value()
    let mx = I32::max_value()
    assert(mn < mx, "min < max")
    return 0
}

@test
func test_bounded_i64() -> I32 {
    let mn = I64::min_value()
    let mx = I64::max_value()
    assert(mn < mx, "min < max")
    return 0
}

@test
func test_zero_i32() -> I32 {
    let z = I32::zero()
    assert_eq(z, 0, "I32 zero")
    return 0
}

@test
func test_one_i32() -> I32 {
    let o = I32::one()
    assert_eq(o, 1, "I32 one")
    return 0
}

@test
func test_zero_one_u32() -> I32 {
    let z = U32::zero()
    let o = U32::one()
    assert_eq(z, 0 as U32, "U32 zero")
    assert_eq(o, 1 as U32, "U32 one")
    return 0
}
