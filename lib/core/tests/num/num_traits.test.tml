// Consolidated numeric tests: Zero/One/Bounded traits, Wrapping wrapper, NonZero comparisons
// Test count: 49 @test functions
// Sources: traits.test.tml, num_traits.test.tml (original), wrapping.test.tml, nonzero_cmp.test.tml
use test
use core::num::traits::{Zero, One, Bounded}
use core::num::wrapping::Wrapping
use core::num::nonzero::NonZero

// ============================================================================
// Zero behavior tests (from traits.test.tml)
// ============================================================================

@test
func test_zero_i8() -> I32 {
    let z: I8 = I8::zero()
    assert_eq(z as I32, 0, "I8::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_i16() -> I32 {
    let z: I16 = I16::zero()
    assert_eq(z as I32, 0, "I16::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_i32() -> I32 {
    let z: I32 = I32::zero()
    assert_eq(z, 0, "I32::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_i64() -> I32 {
    let z: I64 = I64::zero()
    let expected: I64 = 0
    assert(z == expected, "I64::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_u8() -> I32 {
    let z: U8 = U8::zero()
    assert_eq(z as I32, 0, "U8::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_u16() -> I32 {
    let z: U16 = U16::zero()
    assert_eq(z as I32, 0, "U16::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_u32() -> I32 {
    let z: U32 = U32::zero()
    let expected: U32 = 0
    assert(z == expected, "U32::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

@test
func test_zero_u64() -> I32 {
    let z: U64 = U64::zero()
    let expected: U64 = 0
    assert(z == expected, "U64::zero() should be 0")
    assert(z.is_zero(), "0.is_zero() should be true")
    return 0
}

// Note: F32 and F64 Zero/One tests skipped due to codegen issues with
// behavior method resolution for float types

@test
func test_is_zero_false() -> I32 {
    let a: I32 = 42
    let b: I64 = 100
    assert(not a.is_zero(), "42.is_zero() should be false")
    assert(not b.is_zero(), "100.is_zero() should be false")
    // Note: F64.is_zero() method call has codegen issues
    return 0
}

// ============================================================================
// One behavior tests (from traits.test.tml)
// ============================================================================

@test
func test_one_i8() -> I32 {
    let o: I8 = I8::one()
    assert_eq(o as I32, 1, "I8::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_i16() -> I32 {
    let o: I16 = I16::one()
    assert_eq(o as I32, 1, "I16::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_i32() -> I32 {
    let o: I32 = I32::one()
    assert_eq(o, 1, "I32::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_i64() -> I32 {
    let o: I64 = I64::one()
    let expected: I64 = 1
    assert(o == expected, "I64::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_u8() -> I32 {
    let o: U8 = U8::one()
    assert_eq(o as I32, 1, "U8::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_u16() -> I32 {
    let o: U16 = U16::one()
    assert_eq(o as I32, 1, "U16::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_u32() -> I32 {
    let o: U32 = U32::one()
    let expected: U32 = 1
    assert(o == expected, "U32::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_u64() -> I32 {
    let o: U64 = U64::one()
    let expected: U64 = 1
    assert(o == expected, "U64::one() should be 1")
    assert(o.is_one(), "1.is_one() should be true")
    return 0
}

@test
func test_one_f32() -> I32 {
    let o: F32 = F32::one()
    let expected: F32 = 1.0
    assert(o == expected, "F32::one() should be 1.0")
    // Note: is_one() method call on F32 has codegen issues
    return 0
}

@test
func test_one_f64() -> I32 {
    let o: F64 = F64::one()
    assert(o == 1.0, "F64::one() should be 1.0")
    // Note: is_one() method call on F64 has codegen issues
    return 0
}

@test
func test_is_one_false() -> I32 {
    let a: I32 = 42
    let b: I64 = 100
    assert(not a.is_one(), "42.is_one() should be false")
    assert(not b.is_one(), "100.is_one() should be false")
    // Note: F64.is_one() method call has codegen issues
    return 0
}

// ============================================================================
// Bounded behavior tests (from traits.test.tml)
// ============================================================================

@test
func test_bounded_i8() -> I32 {
    let min: I8 = I8::min_value()
    let max: I8 = I8::max_value()
    assert_eq(min as I32, -128, "I8::min_value() should be -128")
    assert_eq(max as I32, 127, "I8::max_value() should be 127")
    return 0
}

@test
func test_bounded_i16() -> I32 {
    let min: I16 = I16::min_value()
    let max: I16 = I16::max_value()
    assert_eq(min as I32, -32768, "I16::min_value() should be -32768")
    assert_eq(max as I32, 32767, "I16::max_value() should be 32767")
    return 0
}

@test
func test_bounded_i32() -> I32 {
    let min: I32 = I32::min_value()
    let max: I32 = I32::max_value()
    assert_eq(min, -2147483648, "I32::min_value() should be -2147483648")
    assert_eq(max, 2147483647, "I32::max_value() should be 2147483647")
    return 0
}

@test
func test_bounded_i64() -> I32 {
    let min: I64 = I64::min_value()
    let max: I64 = I64::max_value()
    let expected_min: I64 = -9223372036854775808
    let expected_max: I64 = 9223372036854775807
    assert(min == expected_min, "I64::min_value()")
    assert(max == expected_max, "I64::max_value()")
    return 0
}

@test
func test_bounded_u8() -> I32 {
    let min: U8 = U8::min_value()
    let max: U8 = U8::max_value()
    assert_eq(min as I32, 0, "U8::min_value() should be 0")
    assert_eq(max as I32, 255, "U8::max_value() should be 255")
    return 0
}

@test
func test_bounded_u16() -> I32 {
    let min: U16 = U16::min_value()
    let max: U16 = U16::max_value()
    assert_eq(min as I32, 0, "U16::min_value() should be 0")
    assert_eq(max as I32, 65535, "U16::max_value() should be 65535")
    return 0
}

@test
func test_bounded_u32() -> I32 {
    let min: U32 = U32::min_value()
    let max: U32 = U32::max_value()
    let expected_min: U32 = 0
    let expected_max: U32 = 4294967295
    assert(min == expected_min, "U32::min_value() should be 0")
    assert(max == expected_max, "U32::max_value() should be 4294967295")
    return 0
}

@test
func test_bounded_u64() -> I32 {
    let min: U64 = U64::min_value()
    let max: U64 = U64::max_value()
    let expected_min: U64 = 0
    let expected_max: U64 = 18446744073709551615
    assert(min == expected_min, "U64::min_value() should be 0")
    assert(max == expected_max, "U64::max_value()")
    return 0
}

// ============================================================================
// Zero/One identity property tests (from traits.test.tml)
// ============================================================================

@test
func test_zero_additive_identity() -> I32 {
    let x: I32 = 42
    let z: I32 = I32::zero()
    assert_eq(x + z, x, "x + zero = x")
    assert_eq(z + x, x, "zero + x = x")
    return 0
}

@test
func test_one_multiplicative_identity() -> I32 {
    let x: I32 = 42
    let o: I32 = I32::one()
    assert_eq(x * o, x, "x * one = x")
    assert_eq(o * x, x, "one * x = x")
    return 0
}

// ============================================================================
// Compact traits tests (from num_traits.test.tml)
// ============================================================================

@test
func test_i32_zero() -> I32 {
    let z: I32 = I32::zero()
    assert_eq(z, 0, "I32::zero() = 0")
    return 0
}

@test
func test_i32_one() -> I32 {
    let o: I32 = I32::one()
    assert_eq(o, 1, "I32::one() = 1")
    return 0
}

@test
func test_i32_is_zero() -> I32 {
    let z: I32 = 0
    let r: Bool = z.is_zero()
    assert(r, "0.is_zero() = true")
    return 0
}

@test
func test_i32_bounded() -> I32 {
    let min: I32 = I32::min_value()
    let max: I32 = I32::max_value()
    assert_eq(min, -2147483648, "I32 min")
    assert_eq(max, 2147483647, "I32 max")
    return 0
}

@test
func test_f32_zero() -> I32 {
    let z: F32 = F32::zero()
    let r: Bool = z.is_zero()
    assert(r, "F32::zero().is_zero()")
    return 0
}

@test
func test_f64_zero() -> I32 {
    let z: F64 = F64::zero()
    let r: Bool = z.is_zero()
    assert(r, "F64::zero().is_zero()")
    return 0
}

@test
func test_f32_is_one() -> I32 {
    let o: F32 = F32::one()
    let r: Bool = o.is_one()
    assert(r, "F32::one().is_one()")
    return 0
}

@test
func test_f64_is_one() -> I32 {
    let o: F64 = F64::one()
    let r: Bool = o.is_one()
    assert(r, "F64::one().is_one()")
    return 0
}

// ============================================================================
// Wrapping wrapper type (from wrapping.test.tml)
// ============================================================================

@test
func test_wrapping_new_i32() -> I32 {
    let w: Wrapping[I32] = Wrapping::new[I32](42)
    assert_eq(w.value(), 42, "Wrapping::new(42).value() should return 42")
    return 0
}

@test
func test_wrapping_new_negative() -> I32 {
    let w: Wrapping[I32] = Wrapping::new[I32](-100)
    assert_eq(w.value(), -100, "Wrapping::new(-100).value() should return -100")
    return 0
}

@test
func test_wrapping_new_zero() -> I32 {
    let w: Wrapping[I32] = Wrapping::new[I32](0)
    assert_eq(w.value(), 0, "Wrapping::new(0).value() should return 0")
    return 0
}

@test
func test_wrapping_into_inner() -> I32 {
    let w: Wrapping[I32] = Wrapping::new[I32](99)
    let val: I32 = w.into_inner()
    assert_eq(val, 99, "into_inner() should return the inner value")
    return 0
}

@test
func test_wrapping_i64() -> I32 {
    let w: Wrapping[I64] = Wrapping::new[I64](1000000i64)
    assert_eq(w.value(), 1000000i64, "Wrapping[I64] should work")
    return 0
}

@test
func test_wrapping_i64_negative() -> I32 {
    let w: Wrapping[I64] = Wrapping::new[I64](-999999i64)
    assert_eq(w.value(), -999999i64, "Wrapping[I64] with negative should work")
    return 0
}

@test
func test_wrapping_i8_positive() -> I32 {
    let w: Wrapping[I8] = Wrapping::new[I8](100i8)
    let val: I8 = w.value()
    assert_eq(val, 100i8, "Wrapping[I8] positive value should work")
    return 0
}

@test
func test_wrapping_i8_negative() -> I32 {
    let w: Wrapping[I8] = Wrapping::new[I8](-50i8)
    let val: I8 = w.value()
    assert_eq(val, -50i8, "Wrapping[I8] negative value should work")
    return 0
}

// ============================================================================
// NonZero comparison tests (from nonzero_cmp.test.tml)
// ============================================================================

@test
func test_nonzero_i64_get() -> I32 {
    let big: I64 = 9999999999
    let result: Maybe[NonZero[I64]] = NonZero::new[I64](big)
    when result {
        Just(n) => {
            assert_eq(n.get(), big, "NonZero I64 get should return big value")
            return 0
        },
        Nothing => { return 1 }
    }
}

@test
func test_nonzero_new_one() -> I32 {
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](1)
    assert(result.is_just(), "NonZero::new(1) should be Just")
    when result {
        Just(n) => assert_eq(n.get(), 1, "get should return 1"),
        Nothing => {}
    }
    return 0
}

@test
func test_nonzero_new_max() -> I32 {
    let max_val: I32 = 2147483647
    let result: Maybe[NonZero[I32]] = NonZero::new[I32](max_val)
    assert(result.is_just(), "NonZero::new(MAX) should be Just")
    when result {
        Just(n) => assert_eq(n.get(), max_val, "get should return max value"),
        Nothing => {}
    }
    return 0
}
