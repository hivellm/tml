// Tests for bit manipulation functions
// Note: Using inline definitions to avoid I8/I16 MIN codegen bug in core::num
use test

// ============================================================================
// Inline I32 bit manipulation functions
// ============================================================================

func count_ones_i32(value: I32) -> I32 {
    let mut v: U32 = value as U32
    var count: I32 = 0
    let zero: U32 = 0 as U32
    loop (v != zero) {
        v = v & (v - (1 as U32))
        count = count + 1
    }
    return count
}

func count_zeros_i32(value: I32) -> I32 {
    return 32 - count_ones_i32(value)
}

func leading_zeros_i32(value: I32) -> I32 {
    if value == 0 {
        return 32
    }
    let mut v: U32 = value as U32
    var count: I32 = 0
    let high_bit: U32 = 2147483648 as U32
    let zero: U32 = 0 as U32
    loop ((v & high_bit) == zero and count < 32) {
        v = v << (1 as U32)
        count = count + 1
    }
    if count >= 32 {
        return 32
    }
    return count
}

func trailing_zeros_i32(value: I32) -> I32 {
    if value == 0 {
        return 32
    }
    let mut v: U32 = value as U32
    var count: I32 = 0
    let one: U32 = 1 as U32
    let zero: U32 = 0 as U32
    loop ((v & one) == zero and count < 32) {
        v = v >> one
        count = count + 1
    }
    if count >= 32 {
        return 32
    }
    return count
}

func rotate_left_i32(value: I32, n: I32) -> I32 {
    let n_mod: I32 = n % 32
    if n_mod == 0 {
        return value
    }
    let uval: U32 = value as U32
    let un: U32 = n_mod as U32
    let left_part: U32 = uval << un
    let right_part: U32 = uval >> (32 as U32 - un)
    return (left_part | right_part) as I32
}

func rotate_right_i32(value: I32, n: I32) -> I32 {
    let n_mod: I32 = n % 32
    if n_mod == 0 {
        return value
    }
    let uval: U32 = value as U32
    let un: U32 = n_mod as U32
    let right_part: U32 = uval >> un
    let left_part: U32 = uval << (32 as U32 - un)
    return (right_part | left_part) as I32
}

func swap_bytes_i32(value: I32) -> I32 {
    let v: U32 = value as U32
    let b0: U32 = (v & (255 as U32)) << (24 as U32)
    let b1: U32 = ((v >> (8 as U32)) & (255 as U32)) << (16 as U32)
    let b2: U32 = ((v >> (16 as U32)) & (255 as U32)) << (8 as U32)
    let b3: U32 = (v >> (24 as U32)) & (255 as U32)
    return (b0 | b1 | b2 | b3) as I32
}

func reverse_bits_i32(value: I32) -> I32 {
    let mut v: U32 = value as U32
    var result: U32 = 0 as U32
    var i: I32 = 0
    let one: U32 = 1 as U32
    loop (i < 32) {
        result = result << one
        result = result | (v & one)
        v = v >> one
        i = i + 1
    }
    return result as I32
}

func from_be_i32(value: I32) -> I32 {
    return swap_bytes_i32(value)
}

func from_le_i32(value: I32) -> I32 {
    return value
}

func to_be_i32(value: I32) -> I32 {
    return swap_bytes_i32(value)
}

func to_le_i32(value: I32) -> I32 {
    return value
}

// ============================================================================
// I32 Tests
// ============================================================================

@test
func test_count_ones_i32() -> I32 {
    assert_eq(count_ones_i32(0), 0, "count_ones(0) should be 0")
    assert_eq(count_ones_i32(1), 1, "count_ones(1) should be 1")
    assert_eq(count_ones_i32(3), 2, "count_ones(3) should be 2")
    assert_eq(count_ones_i32(7), 3, "count_ones(7) should be 3")
    assert_eq(count_ones_i32(15), 4, "count_ones(15) should be 4")
    assert_eq(count_ones_i32(255), 8, "count_ones(255) should be 8")
    assert_eq(count_ones_i32(-1), 32, "count_ones(-1) should be 32")
    return 0
}

@test
func test_count_zeros_i32() -> I32 {
    assert_eq(count_zeros_i32(0), 32, "count_zeros(0) should be 32")
    assert_eq(count_zeros_i32(-1), 0, "count_zeros(-1) should be 0")
    assert_eq(count_zeros_i32(1), 31, "count_zeros(1) should be 31")
    assert_eq(count_zeros_i32(255), 24, "count_zeros(255) should be 24")
    return 0
}

@test
func test_leading_zeros_i32() -> I32 {
    assert_eq(leading_zeros_i32(0), 32, "leading_zeros(0) should be 32")
    assert_eq(leading_zeros_i32(1), 31, "leading_zeros(1) should be 31")
    assert_eq(leading_zeros_i32(2), 30, "leading_zeros(2) should be 30")
    assert_eq(leading_zeros_i32(16), 27, "leading_zeros(16) should be 27")
    assert_eq(leading_zeros_i32(256), 23, "leading_zeros(256) should be 23")
    assert_eq(leading_zeros_i32(-1), 0, "leading_zeros(-1) should be 0")
    return 0
}

@test
func test_trailing_zeros_i32() -> I32 {
    assert_eq(trailing_zeros_i32(0), 32, "trailing_zeros(0) should be 32")
    assert_eq(trailing_zeros_i32(1), 0, "trailing_zeros(1) should be 0")
    assert_eq(trailing_zeros_i32(2), 1, "trailing_zeros(2) should be 1")
    assert_eq(trailing_zeros_i32(4), 2, "trailing_zeros(4) should be 2")
    assert_eq(trailing_zeros_i32(8), 3, "trailing_zeros(8) should be 3")
    assert_eq(trailing_zeros_i32(16), 4, "trailing_zeros(16) should be 4")
    return 0
}

@test
func test_rotate_left_i32() -> I32 {
    assert_eq(rotate_left_i32(1, 4), 16, "rotate_left(1, 4) should be 16")
    assert_eq(rotate_left_i32(42, 0), 42, "rotate_left(x, 0) should be x")
    assert_eq(rotate_left_i32(42, 32), 42, "rotate_left(x, 32) should be x")
    return 0
}

@test
func test_rotate_right_i32() -> I32 {
    assert_eq(rotate_right_i32(16, 4), 1, "rotate_right(16, 4) should be 1")
    assert_eq(rotate_right_i32(42, 0), 42, "rotate_right(x, 0) should be x")
    return 0
}

@test
func test_swap_bytes_i32() -> I32 {
    let val: I32 = 305419896 // 0x12345678
    let expected: I32 = 2018915346 // 0x78563412
    assert_eq(swap_bytes_i32(val), expected, "swap_bytes should reverse byte order")
    assert_eq(swap_bytes_i32(swap_bytes_i32(42)), 42, "double swap_bytes should be identity")
    return 0
}

@test
func test_reverse_bits_i32() -> I32 {
    assert_eq(reverse_bits_i32(reverse_bits_i32(12345)), 12345, "double reverse_bits should be identity")
    assert_eq(reverse_bits_i32(0), 0, "reverse_bits(0) should be 0")
    assert_eq(reverse_bits_i32(-1), -1, "reverse_bits(-1) should be -1")
    return 0
}

@test
func test_endian_i32() -> I32 {
    assert_eq(to_le_i32(42), 42, "to_le should be identity on little-endian")
    assert_eq(from_le_i32(42), 42, "from_le should be identity on little-endian")
    assert_eq(from_be_i32(to_be_i32(42)), 42, "from_be(to_be(x)) should be identity")
    return 0
}
