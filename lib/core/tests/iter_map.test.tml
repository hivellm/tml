// Tests for Map iterator adapter with closures
use test
use core::iter::*

// ============================================================================
// Concrete Map implementations (workaround for generic limitations)
// ============================================================================

// Map adapter for OnceI32
pub type MapOnceI32 {
    iter: OnceI32,
    f: func(I32) -> I32
}

impl MapOnceI32 {
    pub func next(mut this) -> Maybe[I32] {
        let result: Maybe[I32] = this.iter.next()
        when result {
            Just(x) => {
                // Extract function pointer and call it
                let mapper: func(I32) -> I32 = this.f
                return Just(mapper(x))
            },
            Nothing => return Nothing
        }
        // Unreachable but required for codegen
        return Nothing
    }
}

pub func map_once_i32(iter: OnceI32, f: func(I32) -> I32) -> MapOnceI32 {
    return MapOnceI32 { iter: iter, f: f }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_map_once_simple() -> I32 {
    let once: OnceI32 = once_i32(5)
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    var mapped: MapOnceI32 = map_once_i32(once, double)

    when mapped.next() {
        Just(n) => assert_eq(n, 10, "5 * 2 should be 10"),
        Nothing => assert(false, "should not be Nothing")
    }

    return 0
}

