// Consolidated tests for core::iter (29 tests)
//
// Source files:
//   iter_consumers.test.tml, iter.test.tml, iter_map.test.tml,
//   iter_adapters.test.tml, async_iter.test.tml, step_i32.test.tml,
//   range_inclusive_extra.test.tml, iter_sources.test.tml

use test
use core::iter::*
use core::range::*
use core::range::{RangeIterI64, RangeInclusiveIterI64}
use core::iter::sources::once::{Once, once}
use core::iter::sources::repeat_n::{RepeatN, repeat_n}

// ============================================================================
// Section: Iterator Consumers (from iter_consumers.test.tml)
// ============================================================================

// NOTE: Most iterator consumer tests are blocked on a codegen limitation where
// calling default behavior methods on concrete types returns () instead of the
// expected type. The methods are correctly defined in the Iterator behavior
// but trait method dispatch needs compiler support.
//
// Example: `iter.count()` returns () instead of I64
//
// When this is fixed, tests should cover:
// - count() - consume and count elements
// - last() - get last element
// - nth() - get nth element
// - all() - test all elements match predicate
// - any() - test any element matches predicate
// - find() - search for element matching predicate
// - position() - get position of matching element
// - fold() - fold with accumulator
// - reduce() - reduce without initial value
// - advance_by() - skip n elements
// - for_each() - apply function to each element
// - try_fold() - fold with early termination
// - find_map() - find and transform
// - max_by() - max with custom comparator
// - min_by() - min with custom comparator
// - max() - natural max (requires Ord)
// - min() - natural min (requires Ord)
// - sum() - sum elements (requires Add + Default)
// - product() - multiply elements (requires Mul + Default)
// - eq() - compare iterators for equality
// - cmp() - lexicographic comparison

@test
func test_range_iter_next() -> I32 {
    // Basic test that next() works - this is explicitly implemented, not a default method
    let mut iter: RangeIterI64 = RangeIterI64 { current: 0, end: 3 }

    let v0: Maybe[I64] = iter.next()
    assert(v0.is_just(), "first should be Just")
    assert_eq(v0.unwrap(), 0, "first should be 0")

    let v1: Maybe[I64] = iter.next()
    assert_eq(v1.unwrap(), 1, "second should be 1")

    let v2: Maybe[I64] = iter.next()
    assert_eq(v2.unwrap(), 2, "third should be 2")

    let v3: Maybe[I64] = iter.next()
    assert(v3.is_nothing(), "fourth should be Nothing")

    return 0
}

// When default behavior method dispatch is fixed, add these tests:
//
// @test func test_count_basic() -> I32 { ... }
// @test func test_count_empty() -> I32 { ... }
// @test func test_last_basic() -> I32 { ... }
// @test func test_nth_basic() -> I32 { ... }
// @test func test_all_true() -> I32 { ... }
// @test func test_any_true() -> I32 { ... }
// @test func test_find_found() -> I32 { ... }
// @test func test_position_found() -> I32 { ... }
// @test func test_fold_sum() -> I32 { ... }
// @test func test_reduce_sum() -> I32 { ... }
// @test func test_advance_by_success() -> I32 { ... }
// @test func test_for_each_consumes() -> I32 { ... }

// ============================================================================
// Section: Core Iterator Types (from iter.test.tml)
// ============================================================================

@test
func test_empty_i32() -> I32 {
    var e: EmptyI32 = empty_i32()

    when e.next() {
        Just(_) => assert(false, "empty iterator should return Nothing"),
        Nothing => {}
    }

    // Call again - should still be Nothing
    when e.next() {
        Just(_) => assert(false, "empty iterator should always return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_once_i32() -> I32 {
    var o: OnceI32 = once_i32(42)

    // First call should return the value
    when o.next() {
        Just(n) => assert_eq(n, 42, "once should return 42"),
        Nothing => assert(false, "first call should not be Nothing")
    }

    // Second call should be Nothing
    when o.next() {
        Just(_) => assert(false, "second call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_repeat_n_i32() -> I32 {
    var r: RepeatNI32 = repeat_n_i32(7, 3)

    // Should get 7 three times
    when r.next() {
        Just(n) => assert_eq(n, 7, "first value should be 7"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(n) => assert_eq(n, 7, "second value should be 7"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(n) => assert_eq(n, 7, "third value should be 7"),
        Nothing => assert(false, "should not be Nothing")
    }

    // Fourth call should be Nothing
    when r.next() {
        Just(_) => assert(false, "fourth call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_repeat_n_zero() -> I32 {
    var r: RepeatNI32 = repeat_n_i32(99, 0)

    // Should immediately return Nothing
    when r.next() {
        Just(_) => assert(false, "repeat_n(0) should return Nothing immediately"),
        Nothing => {}
    }

    return 0
}

@test
func test_once_i64() -> I32 {
    var o: OnceI64 = once_i64(123 as I64)

    when o.next() {
        Just(n) => assert_eq(n, 123 as I64, "once_i64 should return 123"),
        Nothing => assert(false, "should not be Nothing")
    }

    when o.next() {
        Just(_) => assert(false, "second call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_multiple_once() -> I32 {
    var o1: OnceI32 = once_i32(1)
    var o2: OnceI32 = once_i32(2)

    when o1.next() {
        Just(n) => assert_eq(n, 1, "o1 should return 1"),
        Nothing => assert(false, "o1 should not be Nothing")
    }

    when o2.next() {
        Just(n) => assert_eq(n, 2, "o2 should return 2"),
        Nothing => assert(false, "o2 should not be Nothing")
    }

    // Both should now be exhausted
    when o1.next() {
        Just(_) => assert(false, "o1 should be exhausted"),
        Nothing => {}
    }

    when o2.next() {
        Just(_) => assert(false, "o2 should be exhausted"),
        Nothing => {}
    }

    return 0
}

@test
func test_empty_i64() -> I32 {
    var e: EmptyI64 = empty_i64()

    when e.next() {
        Just(_) => assert(false, "empty_i64 should return Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_repeat_n_i64() -> I32 {
    var r: RepeatNI64 = repeat_n_i64(100 as I64, 2)

    when r.next() {
        Just(n) => assert_eq(n, 100 as I64, "first value should be 100"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(n) => assert_eq(n, 100 as I64, "second value should be 100"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(_) => assert(false, "third call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_repeat_n_one() -> I32 {
    var r: RepeatNI32 = repeat_n_i32(42, 1)

    when r.next() {
        Just(n) => assert_eq(n, 42, "single value should be 42"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(_) => assert(false, "second call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_repeat_n_negative_value() -> I32 {
    var r: RepeatNI32 = repeat_n_i32(-10, 3)

    when r.next() {
        Just(n) => assert_eq(n, -10, "first value should be -10"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(n) => assert_eq(n, -10, "second value should be -10"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(n) => assert_eq(n, -10, "third value should be -10"),
        Nothing => assert(false, "should not be Nothing")
    }

    when r.next() {
        Just(_) => assert(false, "fourth call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_once_zero() -> I32 {
    var o: OnceI32 = once_i32(0)

    when o.next() {
        Just(n) => assert_eq(n, 0, "once should return 0"),
        Nothing => assert(false, "first call should not be Nothing")
    }

    when o.next() {
        Just(_) => assert(false, "second call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_once_negative() -> I32 {
    var o: OnceI32 = once_i32(-999)

    when o.next() {
        Just(n) => assert_eq(n, -999, "once should return -999"),
        Nothing => assert(false, "first call should not be Nothing")
    }

    when o.next() {
        Just(_) => assert(false, "second call should be Nothing"),
        Nothing => {}
    }

    return 0
}

@test
func test_once_max_i32() -> I32 {
    var o: OnceI32 = once_i32(2147483647)

    when o.next() {
        Just(n) => assert_eq(n, 2147483647, "once should return max I32"),
        Nothing => assert(false, "first call should not be Nothing")
    }

    return 0
}

@test
func test_repeat_n_large_count() -> I32 {
    var r: RepeatNI32 = repeat_n_i32(1, 100)

    // Consume 100 elements
    let mut count: I32 = 0
    loop (true) {
        when r.next() {
            Just(n) => {
                assert_eq(n, 1, "each value should be 1")
                count = count + 1
            },
            Nothing => {
                assert_eq(count, 100, "should have yielded exactly 100 elements")
                return 0
            }
        }
    }
}

// Note: Additional iterator method tests (size_hint, advance_by, reduce,
// find_map, try_fold, max_by, min_by) are defined in the Iterator behavior
// but testing them requires calling default trait methods on concrete types,
// which has codegen limitations. The methods are correctly defined and
// documented; testing will be enabled when trait method dispatch is complete.

// ============================================================================
// Section: Map Adapter (from iter_map.test.tml)
// ============================================================================

// Map adapter for OnceI32
pub type MapOnceI32 {
    iter: OnceI32,
    f: func(I32) -> I32
}

impl MapOnceI32 {
    pub func next(mut this) -> Maybe[I32] {
        let result: Maybe[I32] = this.iter.next()
        when result {
            Just(x) => {
                // Extract function pointer and call it
                let mapper: func(I32) -> I32 = this.f
                return Just(mapper(x))
            },
            Nothing => return Nothing
        }
        // Unreachable but required for codegen
        return Nothing
    }
}

pub func map_once_i32(iter: OnceI32, f: func(I32) -> I32) -> MapOnceI32 {
    return MapOnceI32 { iter: iter, f: f }
}

@test
func test_map_once_simple() -> I32 {
    let once: OnceI32 = once_i32(5)
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    var mapped: MapOnceI32 = map_once_i32(once, double)

    when mapped.next() {
        Just(n) => assert_eq(n, 10, "5 * 2 should be 10"),
        Nothing => assert(false, "should not be Nothing")
    }

    return 0
}

// ============================================================================
// Section: Iterator Adapters (from iter_adapters.test.tml)
// ============================================================================

// PARTIALLY FIXED: Take, Skip, StepBy adapters now work (Phase 8.1 fix).
// Tests moved to iter_adapters.test.tml.
// Still blocked: Fuse, Chain (Maybe[StructType] crash), Enumerate, Zip
// (tuple-returning with associated types), nested adapters (recursive types).
// See Phase 14 in test-failures/tasks.md.

@test
func test_placeholder() -> I32 {
    // Placeholder — actual adapter tests are in iter_adapters.test.tml
    assert(true, "placeholder passes")
    return 0
}

// ============================================================================
// Section: Async Iterator (from async_iter.test.tml)
// ============================================================================

// BLOCKED: Full async iterator testing requires async/await support and Poll types
// which are still being implemented. The async_iter module depends on task::Waker
// which uses function pointer fields that aren't fully supported yet.
//
// Blocked on:
// - core::task module needs function pointer field call support
// - impl[T] AsyncIterator for Once[T] depends on Poll type
// - impl[T: Duplicate] AsyncIterator for Repeat[T] depends on Poll type

@test
func test_async_iter_placeholder() -> I32 {
    // Placeholder test until async_iter module is usable
    return 0
}

// ============================================================================
// Section: Range Iterators / Step (from step_i32.test.tml)
// ============================================================================

// Note: Generic Range[T] and direct Step method calls are blocked by
// compiler limitations. Tests use the concrete I64 iterator types.

@test
func test_range_iter_sum() -> I32 {
    let mut iter: RangeIterI64 = RangeIterI64 { current: 1, end: 6 }
    var sum: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { sum = sum + v },
            Nothing => { break }
        }
    }
    // 1 + 2 + 3 + 4 + 5 = 15
    assert_eq(sum, 15, "range 1..6 sum should be 15")
    return 0
}

@test
func test_range_iter_count() -> I32 {
    let mut iter: RangeIterI64 = RangeIterI64 { current: 10, end: 20 }
    var count: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { count = count + 1 },
            Nothing => { break }
        }
    }
    assert_eq(count, 10, "range 10..20 should have 10 elements")
    return 0
}

@test
func test_range_iter_single_element() -> I32 {
    let mut iter: RangeIterI64 = RangeIterI64 { current: 99, end: 100 }
    let v: Maybe[I64] = iter.next()
    assert_eq(v.unwrap(), 99, "single element should be 99")
    let v2: Maybe[I64] = iter.next()
    assert(v2.is_nothing(), "should be exhausted")
    return 0
}

// ============================================================================
// Section: RangeInclusive Extra (from range_inclusive_extra.test.tml)
// ============================================================================

@test
func test_range_inclusive_sum() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: 1, end: 5, exhausted: false
    }
    var sum: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { sum = sum + v },
            Nothing => { break }
        }
    }
    // 1 + 2 + 3 + 4 + 5 = 15
    assert_eq(sum, 15, "inclusive range 1..=5 sum should be 15")
    return 0
}

@test
func test_range_inclusive_negative() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: -3, end: -1, exhausted: false
    }
    var sum: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { sum = sum + v },
            Nothing => { break }
        }
    }
    // -3 + -2 + -1 = -6
    assert_eq(sum, -6, "inclusive range -3..=-1 sum should be -6")
    return 0
}

@test
func test_range_inclusive_zero_crossing() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: -1, end: 1, exhausted: false
    }
    var count: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { count = count + 1 },
            Nothing => { break }
        }
    }
    assert_eq(count, 3, "inclusive range -1..=1 should have 3 elements")
    return 0
}

// ============================================================================
// Section: Generic Iterator Sources (from iter_sources.test.tml)
// ============================================================================

// NOTE: test_repeat_n_zero and test_repeat_n_one from iter_sources.test.tml
// were renamed with _generic suffix to avoid name collision with the same-named
// tests from iter.test.tml (which use concrete I32 types instead of generics).

@test
func test_once_yields_one() -> I32 {
    let mut iter: Once[I32] = once(42)
    let v1: Maybe[I32] = iter.next()
    assert(v1.is_just(), "once should yield one element")
    assert_eq(v1.unwrap(), 42, "should be 42")

    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "second call should be Nothing")
    return 0
}

@test
func test_once_stays_exhausted() -> I32 {
    let mut iter: Once[I64] = once(100 as I64)
    iter.next() // consume the element
    assert(iter.next().is_nothing(), "second call Nothing")
    assert(iter.next().is_nothing(), "third call Nothing")
    return 0
}

@test
func test_repeat_n_yields_n_times() -> I32 {
    let mut iter: RepeatN[I32] = repeat_n(7, 3 as I64)
    assert_eq(iter.next().unwrap(), 7, "first should be 7")
    assert_eq(iter.next().unwrap(), 7, "second should be 7")
    assert_eq(iter.next().unwrap(), 7, "third should be 7")
    assert(iter.next().is_nothing(), "fourth should be Nothing")
    return 0
}

@test
func test_repeat_n_zero_generic() -> I32 {
    let mut iter: RepeatN[I32] = repeat_n(99, 0 as I64)
    assert(iter.next().is_nothing(), "zero repeats should be Nothing immediately")
    return 0
}

@test
func test_repeat_n_one_generic() -> I32 {
    let mut iter: RepeatN[I64] = repeat_n(42 as I64, 1 as I64)
    assert_eq(iter.next().unwrap(), 42 as I64, "should yield 42")
    assert(iter.next().is_nothing(), "should be exhausted")
    return 0
}

// Note: OnceWith and FromFn tests are in iter_sources.test.tml (fixed in Phase 8.3)
// Successors tests still blocked — requires closure-based generic sources
