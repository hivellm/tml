// Extra tests for RangeInclusiveIterI64
use test
use core::range::RangeInclusiveIterI64

@test
func test_range_inclusive_sum() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: 1, end: 5, exhausted: false
    }
    var sum: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { sum = sum + v },
            Nothing => { break }
        }
    }
    // 1 + 2 + 3 + 4 + 5 = 15
    assert_eq(sum, 15, "inclusive range 1..=5 sum should be 15")
    return 0
}

@test
func test_range_inclusive_negative() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: -3, end: -1, exhausted: false
    }
    var sum: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { sum = sum + v },
            Nothing => { break }
        }
    }
    // -3 + -2 + -1 = -6
    assert_eq(sum, -6, "inclusive range -3..=-1 sum should be -6")
    return 0
}

@test
func test_range_inclusive_zero_crossing() -> I32 {
    let mut iter: RangeInclusiveIterI64 = RangeInclusiveIterI64 {
        current: -1, end: 1, exhausted: false
    }
    var count: I64 = 0
    loop (true) {
        when iter.next() {
            Just(v) => { count = count + 1 },
            Nothing => { break }
        }
    }
    assert_eq(count, 3, "inclusive range -1..=1 should have 3 elements")
    return 0
}
