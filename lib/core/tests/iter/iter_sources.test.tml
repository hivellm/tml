// Tests for generic iterator sources: OnceWith, FromFn
// Previously blocked by Phase 8.3 codegen bugs (now fixed)

use test
use core::iter::sources::once_with::{OnceWith, once_with}
use core::iter::sources::from_fn::{FromFn, from_fn}

// ============================================================================
// OnceWith tests
// ============================================================================

@test
func test_once_with_basic() -> I32 {
    let mut iter: OnceWith[func() -> I32] = once_with(do() -> I32 { 42 })

    let v1: Maybe[I32] = iter.next()
    assert(v1.is_just(), "first should be Just")
    assert_eq(v1.unwrap(), 42, "should be 42")

    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "second should be Nothing")

    return 0
}

@test
func test_once_with_computed() -> I32 {
    let mut iter: OnceWith[func() -> I32] = once_with(do() -> I32 { 10 + 20 + 3 })

    let v1: Maybe[I32] = iter.next()
    assert_eq(v1.unwrap(), 33, "should compute 33")

    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "exhausted")
    return 0
}

@test
func test_once_with_stays_exhausted() -> I32 {
    let mut iter: OnceWith[func() -> I32] = once_with(do() -> I32 { 1 })
    let v1: Maybe[I32] = iter.next()
    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "second Nothing")
    let v3: Maybe[I32] = iter.next()
    assert(v3.is_nothing(), "third Nothing")
    return 0
}

// ============================================================================
// FromFn tests
// ============================================================================

@test
func test_from_fn_countdown() -> I32 {
    var n: I32 = 3
    let mut iter: FromFn[func() -> Maybe[I32]] = from_fn(do() -> Maybe[I32] {
        if n <= 0 {
            return Nothing
        }
        let current: I32 = n
        n = n - 1
        return Just(current)
    })

    let v1: Maybe[I32] = iter.next()
    assert_eq(v1.unwrap(), 3, "first")
    let v2: Maybe[I32] = iter.next()
    assert_eq(v2.unwrap(), 2, "second")
    let v3: Maybe[I32] = iter.next()
    assert_eq(v3.unwrap(), 1, "third")
    let v4: Maybe[I32] = iter.next()
    assert(v4.is_nothing(), "exhausted")

    return 0
}

@test
func test_from_fn_single_element() -> I32 {
    var n: I32 = 1
    let mut iter: FromFn[func() -> Maybe[I32]] = from_fn(do() -> Maybe[I32] {
        if n <= 0 {
            return Nothing
        }
        n = n - 1
        return Just(1)
    })

    let v1: Maybe[I32] = iter.next()
    assert_eq(v1.unwrap(), 1, "first")

    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "exhausted")

    return 0
}

@test
func test_from_fn_empty() -> I32 {
    let mut iter: FromFn[func() -> Maybe[I32]] = from_fn(do() -> Maybe[I32] {
        return Nothing
    })

    let v1: Maybe[I32] = iter.next()
    assert(v1.is_nothing(), "immediately empty")
    let v2: Maybe[I32] = iter.next()
    assert(v2.is_nothing(), "still empty")

    return 0
}

@test
func test_from_fn_accumulator() -> I32 {
    // Generate running sum: 1, 3, 6, 10
    var n: I32 = 0
    var sum: I32 = 0
    let mut iter: FromFn[func() -> Maybe[I32]] = from_fn(do() -> Maybe[I32] {
        n = n + 1
        if n > 4 {
            return Nothing
        }
        sum = sum + n
        return Just(sum)
    })

    let v1: Maybe[I32] = iter.next()
    assert_eq(v1.unwrap(), 1, "1")
    let v2: Maybe[I32] = iter.next()
    assert_eq(v2.unwrap(), 3, "1+2")
    let v3: Maybe[I32] = iter.next()
    assert_eq(v3.unwrap(), 6, "1+2+3")
    let v4: Maybe[I32] = iter.next()
    assert_eq(v4.unwrap(), 10, "1+2+3+4")
    let v5: Maybe[I32] = iter.next()
    assert(v5.is_nothing(), "exhausted")

    return 0
}
