// Tests for uncovered fmt/builders functions
// Covers: field_with, finish_non_exhaustive (struct+tuple), entries, key+value
use test::{assert, assert_eq}
use core::fmt::builders::{DebugStruct, DebugTuple, DebugList, DebugMap}

@test
func test_debug_struct_field_with() -> I32 {
    let s: Str = DebugStruct::new("Point")
        .field_with("x", "10")
        .field_with("y", "20")
        .finish()
    assert_eq(s, "Point \{ x: 10, y: 20 \}", "field_with should work like field")
    return 0
}

@test
func test_debug_struct_finish_non_exhaustive() -> I32 {
    let s: Str = DebugStruct::new("Config")
        .field("visible", "true")
        .finish_non_exhaustive()
    assert_eq(s, "Config \{ visible: true, .. \}", "finish_non_exhaustive with fields")
    return 0
}

@test
func test_debug_struct_finish_non_exhaustive_no_fields() -> I32 {
    let s: Str = DebugStruct::new("Config")
        .finish_non_exhaustive()
    assert_eq(s, "Config \{ .. \}", "finish_non_exhaustive without fields")
    return 0
}

@test
func test_debug_tuple_finish_non_exhaustive() -> I32 {
    let s: Str = DebugTuple::new("Pair")
        .field("1")
        .finish_non_exhaustive()
    assert_eq(s, "Pair(1, ..)", "tuple finish_non_exhaustive")
    return 0
}

@test
func test_debug_list_entries() -> I32 {
    let s: Str = DebugList::new()
        .entries("1, 2, 3")
        .finish()
    assert_eq(s, "[1, 2, 3]", "list entries")
    return 0
}

@test
func test_debug_map_key_value() -> I32 {
    let m: DebugMap = DebugMap::new()
        .key("name").value("Alice")
    let s: Str = m.finish()
    let expected: Str = "\{name: Alice\}"
    assert_eq(s, expected, "map key value")
    return 0
}
