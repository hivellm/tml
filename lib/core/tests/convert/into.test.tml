// Tests for Into behavior - .into() method on values
use test::{assert, assert_eq}
use core::convert::*

// ============================================================================
// Numeric widening via Into
// ============================================================================

@test
func test_into_i8_to_i16() -> I32 {
    let val: I8 = 42 as I8
    let result: I16 = I16::from(val)
    assert_eq(result, 42 as I16, "I8 -> I16 via From")
    return 0
}

@test
func test_into_i8_to_i32() -> I32 {
    let val: I8 = -10 as I8
    let result: I32 = I32::from(val)
    assert_eq(result, -10, "I8 -> I32 preserves sign")
    return 0
}

@test
func test_into_i8_to_i64() -> I32 {
    let val: I8 = 127 as I8
    let result: I64 = I64::from(val)
    assert_eq(result, 127 as I64, "I8 -> I64 max value")
    return 0
}

@test
func test_into_i16_to_i32() -> I32 {
    let val: I16 = -1000 as I16
    let result: I32 = I32::from(val)
    assert_eq(result, -1000, "I16 -> I32 negative")
    return 0
}

@test
func test_into_i16_to_i64() -> I32 {
    let val: I16 = 32767 as I16
    let result: I64 = I64::from(val)
    assert_eq(result, 32767 as I64, "I16 -> I64 max")
    return 0
}

// ============================================================================
// Unsigned widening via From
// ============================================================================

@test
func test_into_u8_to_u16() -> I32 {
    let val: U8 = 255 as U8
    let result: U16 = U16::from(val)
    assert_eq(result, 255 as U16, "U8 -> U16 max")
    return 0
}

@test
func test_into_u8_to_u32() -> I32 {
    let val: U8 = 200 as U8
    let result: U32 = U32::from(val)
    assert_eq(result, 200 as U32, "U8 -> U32")
    return 0
}

@test
func test_into_u8_to_u64() -> I32 {
    let val: U8 = 0 as U8
    let result: U64 = U64::from(val)
    assert_eq(result, 0 as U64, "U8 -> U64 zero")
    return 0
}

@test
func test_into_u16_to_u32() -> I32 {
    let val: U16 = 50000 as U16
    let result: U32 = U32::from(val)
    assert_eq(result, 50000 as U32, "U16 -> U32")
    return 0
}

@test
func test_into_u16_to_u64() -> I32 {
    let val: U16 = 65535 as U16
    let result: U64 = U64::from(val)
    assert_eq(result, 65535 as U64, "U16 -> U64 max")
    return 0
}

@test
func test_into_u32_to_u64() -> I32 {
    let val: U32 = 4000000000 as U32
    let result: U64 = U64::from(val)
    assert_eq(result, 4000000000 as U64, "U32 -> U64 large")
    return 0
}

// ============================================================================
// Float widening
// ============================================================================

@test
func test_into_f32_to_f64() -> I32 {
    let val: F32 = 1.5 as F32
    let result: F64 = F64::from(val)
    // F32 -> F64 should preserve value (approximately)
    assert(result > 1.4 and result < 1.6, "F32 -> F64 should preserve value")
    return 0
}
