// Consolidated convert tests: TryFrom narrowing and small-type conversions
// Sources: tryfrom.test.tml, tryfrom_small.test.tml
// Total @test count: 49
use test::{assert, assert_eq}
use core::convert::*

// ============================================================================
// Section 1: TryFrom I64 -> I32 narrowing (6 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_i64_to_i32_normal() -> I32 {
    let value: I64 = 42
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, 42, "42 should convert to I32"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_negative() -> I32 {
    let value: I64 = -1000
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, -1000, "-1000 should convert to I32"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_max() -> I32 {
    let value: I64 = 2147483647  // I32 max
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, 2147483647, "I32 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_min() -> I32 {
    let value: I64 = -2147483648  // I32 min
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, -2147483648, "I32 min should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_overflow_positive() -> I32 {
    let value: I64 = 2147483648  // I32 max + 1
    when I32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(e) => {
            when e {
                TryFromIntError::Overflow => assert(true, "correctly detected overflow"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_overflow_negative() -> I32 {
    let value: I64 = -2147483649  // I32 min - 1
    when I32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(e) => {
            when e {
                TryFromIntError::Overflow => assert(true, "correctly detected overflow"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

// ============================================================================
// Section 2: TryFrom I64 -> I16 narrowing (3 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_i64_to_i16_normal() -> I32 {
    let value: I64 = 1000
    when I16::try_from(value) {
        Ok(result) => assert_eq(result as I32, 1000, "1000 should convert to I16"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i16_max() -> I32 {
    let value: I64 = 32767  // I16 max
    when I16::try_from(value) {
        Ok(result) => assert_eq(result as I32, 32767, "I16 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i16_overflow() -> I32 {
    let value: I64 = 32768  // I16 max + 1
    when I16::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// Section 3: TryFrom I64 -> I8 narrowing (4 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_i64_to_i8_normal() -> I32 {
    let value: I64 = 100
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 100, "100 should convert to I8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_max() -> I32 {
    let value: I64 = 127  // I8 max
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 127, "I8 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_min() -> I32 {
    let value: I64 = -128  // I8 min
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, -128, "I8 min should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_overflow() -> I32 {
    let value: I64 = 128  // I8 max + 1
    when I8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// Section 4: TryFrom unsigned narrowing U64 -> U32/U8 (5 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_u64_to_u32_normal() -> I32 {
    let value: U64 = 1000000
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 1000000, "1000000 should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u32_max() -> I32 {
    let value: U64 = 4294967295  // U32 max
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 4294967295, "U32 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u32_overflow() -> I32 {
    let value: U64 = 4294967296  // U32 max + 1
    when U32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u8_normal() -> I32 {
    let value: U64 = 200
    when U8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 200, "200 should convert to U8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u8_overflow() -> I32 {
    let value: U64 = 256  // U8 max + 1
    when U8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// Section 5: TryFrom signed to unsigned I64/I32 -> U64/U32 (5 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_i64_to_u64_positive() -> I32 {
    let value: I64 = 1000
    when U64::try_from(value) {
        Ok(result) => assert_eq(result, 1000, "positive should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_u64_zero() -> I32 {
    let value: I64 = 0
    when U64::try_from(value) {
        Ok(result) => assert_eq(result, 0, "zero should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_u64_negative() -> I32 {
    let value: I64 = -1
    when U64::try_from(value) {
        Ok(_) => assert(false, "negative should fail"),
        Err(e) => {
            when e {
                TryFromIntError::NegativeToUnsigned => assert(true, "correctly detected negative"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

@test
func test_tryfrom_i32_to_u32_positive() -> I32 {
    let value: I32 = 42
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 42, "positive should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i32_to_u32_negative() -> I32 {
    let value: I32 = -42
    when U32::try_from(value) {
        Ok(_) => assert(false, "negative should fail"),
        Err(_) => assert(true, "correctly detected negative")
    }
    return 0
}

// ============================================================================
// Section 6: TryFrom unsigned to signed U64/U8 -> I64/I8 (6 tests)
// Source: tryfrom.test.tml
// ============================================================================

@test
func test_tryfrom_u64_to_i64_in_range() -> I32 {
    let value: U64 = 1000000
    when I64::try_from(value) {
        Ok(result) => assert_eq(result, 1000000, "in range should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_i64_max() -> I32 {
    let value: U64 = 9223372036854775807  // I64 max
    when I64::try_from(value) {
        Ok(result) => assert_eq(result, 9223372036854775807, "I64 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_i64_overflow() -> I32 {
    let value: U64 = 9223372036854775808  // I64 max + 1
    when I64::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_in_range() -> I32 {
    let value: U8 = 100
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 100, "100 should convert to I8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_max() -> I32 {
    let value: U8 = 127  // I8 max
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 127, "I8 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_overflow() -> I32 {
    let value: U8 = 128  // I8 max + 1
    when I8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// Section 7: TryFrom I16 -> I8 small narrowing (5 tests)
// Source: tryfrom_small.test.tml
// ============================================================================

@test
func test_tryfrom_i16_to_i8_normal() -> I32 {
    let val: I16 = 50 as I16
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 50, "50 should fit in I8"),
        Err(_) => assert(false, "50 should not overflow I8")
    }
    return 0
}

@test
func test_tryfrom_i16_to_i8_max() -> I32 {
    let val: I16 = 127 as I16
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 127, "127 is I8 max"),
        Err(_) => assert(false, "127 should fit in I8")
    }
    return 0
}

@test
func test_tryfrom_i16_to_i8_min() -> I32 {
    let val: I16 = -128 as I16
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, -128, "-128 is I8 min"),
        Err(_) => assert(false, "-128 should fit in I8")
    }
    return 0
}

@test
func test_tryfrom_i16_to_i8_overflow() -> I32 {
    let val: I16 = 200 as I16
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(_) => assert(false, "200 should overflow I8"),
        Err(_) => return 0
    }
    return 0
}

@test
func test_tryfrom_i16_to_i8_underflow() -> I32 {
    let val: I16 = -200 as I16
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(_) => assert(false, "-200 should underflow I8"),
        Err(_) => return 0
    }
    return 0
}

// ============================================================================
// Section 8: TryFrom I32 -> I16 small narrowing (3 tests)
// Source: tryfrom_small.test.tml
// ============================================================================

@test
func test_tryfrom_i32_to_i16_normal() -> I32 {
    let val: I32 = 1000
    let result: Outcome[I16, TryFromIntError] = I16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 1000, "1000 should fit in I16"),
        Err(_) => assert(false, "1000 should not overflow I16")
    }
    return 0
}

@test
func test_tryfrom_i32_to_i16_max() -> I32 {
    let val: I32 = 32767
    let result: Outcome[I16, TryFromIntError] = I16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 32767, "32767 is I16 max"),
        Err(_) => assert(false, "32767 should fit in I16")
    }
    return 0
}

@test
func test_tryfrom_i32_to_i16_overflow() -> I32 {
    let val: I32 = 40000
    let result: Outcome[I16, TryFromIntError] = I16::try_from(val)
    when result {
        Ok(_) => assert(false, "40000 should overflow I16"),
        Err(_) => return 0
    }
    return 0
}

// ============================================================================
// Section 9: TryFrom U16 -> U8, U32 -> U16 unsigned small narrowing (6 tests)
// Source: tryfrom_small.test.tml
// ============================================================================

@test
func test_tryfrom_u16_to_u8_normal() -> I32 {
    let val: U16 = 200 as U16
    let result: Outcome[U8, TryFromIntError] = U8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 200, "200 should fit in U8"),
        Err(_) => assert(false, "200 should not overflow U8")
    }
    return 0
}

@test
func test_tryfrom_u16_to_u8_max() -> I32 {
    let val: U16 = 255 as U16
    let result: Outcome[U8, TryFromIntError] = U8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 255, "255 is U8 max"),
        Err(_) => assert(false, "255 should fit in U8")
    }
    return 0
}

@test
func test_tryfrom_u16_to_u8_overflow() -> I32 {
    let val: U16 = 300 as U16
    let result: Outcome[U8, TryFromIntError] = U8::try_from(val)
    when result {
        Ok(_) => assert(false, "300 should overflow U8"),
        Err(_) => return 0
    }
    return 0
}

@test
func test_tryfrom_u32_to_u16_normal() -> I32 {
    let val: U32 = 50000 as U32
    let result: Outcome[U16, TryFromIntError] = U16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 50000, "50000 should fit in U16"),
        Err(_) => assert(false, "50000 should not overflow U16")
    }
    return 0
}

@test
func test_tryfrom_u32_to_u16_max() -> I32 {
    let val: U32 = 65535 as U32
    let result: Outcome[U16, TryFromIntError] = U16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 65535, "65535 is U16 max"),
        Err(_) => assert(false, "65535 should fit in U16")
    }
    return 0
}

@test
func test_tryfrom_u32_to_u16_overflow() -> I32 {
    let val: U32 = 70000 as U32
    let result: Outcome[U16, TryFromIntError] = U16::try_from(val)
    when result {
        Ok(_) => assert(false, "70000 should overflow U16"),
        Err(_) => return 0
    }
    return 0
}

// ============================================================================
// Section 10: TryFrom I32 -> I8 small narrowing (2 tests)
// Source: tryfrom_small.test.tml
// ============================================================================

@test
func test_tryfrom_i32_to_i8_normal() -> I32 {
    let val: I32 = 100
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 100, "100 should fit in I8"),
        Err(_) => assert(false, "100 should not overflow I8")
    }
    return 0
}

@test
func test_tryfrom_i32_to_i8_overflow() -> I32 {
    let val: I32 = 500
    let result: Outcome[I8, TryFromIntError] = I8::try_from(val)
    when result {
        Ok(_) => assert(false, "500 should overflow I8"),
        Err(_) => return 0
    }
    return 0
}

// ============================================================================
// Section 11: TryFrom I16 <-> U16 cross-type small (4 tests)
// Source: tryfrom_small.test.tml
// ============================================================================

@test
func test_tryfrom_i16_to_u16_positive() -> I32 {
    let val: I16 = 1000 as I16
    let result: Outcome[U16, TryFromIntError] = U16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 1000, "1000 should convert"),
        Err(_) => assert(false, "Positive I16 should convert to U16")
    }
    return 0
}

@test
func test_tryfrom_i16_to_u16_negative() -> I32 {
    let val: I16 = -5 as I16
    let result: Outcome[U16, TryFromIntError] = U16::try_from(val)
    when result {
        Ok(_) => assert(false, "Negative should fail"),
        Err(_) => return 0
    }
    return 0
}

@test
func test_tryfrom_u16_to_i16_in_range() -> I32 {
    let val: U16 = 30000 as U16
    let result: Outcome[I16, TryFromIntError] = I16::try_from(val)
    when result {
        Ok(n) => assert_eq(n as I32, 30000, "30000 fits in I16"),
        Err(_) => assert(false, "30000 should fit in I16")
    }
    return 0
}

@test
func test_tryfrom_u16_to_i16_overflow() -> I32 {
    let val: U16 = 40000 as U16
    let result: Outcome[I16, TryFromIntError] = I16::try_from(val)
    when result {
        Ok(_) => assert(false, "40000 should overflow I16"),
        Err(_) => return 0
    }
    return 0
}
