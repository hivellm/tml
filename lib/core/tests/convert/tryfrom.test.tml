// Tests for core::convert TryFrom behavior
use test
use core::convert::{TryFrom, TryFromIntError}

// ============================================================================
// TryFrom I64 -> I32 (narrowing)
// ============================================================================

@test
func test_tryfrom_i64_to_i32_normal() -> I32 {
    let value: I64 = 42
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, 42, "42 should convert to I32"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_negative() -> I32 {
    let value: I64 = -1000
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, -1000, "-1000 should convert to I32"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_max() -> I32 {
    let value: I64 = 2147483647  // I32 max
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, 2147483647, "I32 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_min() -> I32 {
    let value: I64 = -2147483648  // I32 min
    when I32::try_from(value) {
        Ok(result) => assert_eq(result, -2147483648, "I32 min should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_overflow_positive() -> I32 {
    let value: I64 = 2147483648  // I32 max + 1
    when I32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(e) => {
            when e {
                TryFromIntError::Overflow => assert(true, "correctly detected overflow"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

@test
func test_tryfrom_i64_to_i32_overflow_negative() -> I32 {
    let value: I64 = -2147483649  // I32 min - 1
    when I32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(e) => {
            when e {
                TryFromIntError::Overflow => assert(true, "correctly detected overflow"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

// ============================================================================
// TryFrom I64 -> I16 (narrowing)
// ============================================================================

@test
func test_tryfrom_i64_to_i16_normal() -> I32 {
    let value: I64 = 1000
    when I16::try_from(value) {
        Ok(result) => assert_eq(result as I32, 1000, "1000 should convert to I16"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i16_max() -> I32 {
    let value: I64 = 32767  // I16 max
    when I16::try_from(value) {
        Ok(result) => assert_eq(result as I32, 32767, "I16 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i16_overflow() -> I32 {
    let value: I64 = 32768  // I16 max + 1
    when I16::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// TryFrom I64 -> I8 (narrowing)
// ============================================================================

@test
func test_tryfrom_i64_to_i8_normal() -> I32 {
    let value: I64 = 100
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 100, "100 should convert to I8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_max() -> I32 {
    let value: I64 = 127  // I8 max
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 127, "I8 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_min() -> I32 {
    let value: I64 = -128  // I8 min
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, -128, "I8 min should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_i8_overflow() -> I32 {
    let value: I64 = 128  // I8 max + 1
    when I8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// TryFrom unsigned narrowing
// ============================================================================

@test
func test_tryfrom_u64_to_u32_normal() -> I32 {
    let value: U64 = 1000000
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 1000000, "1000000 should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u32_max() -> I32 {
    let value: U64 = 4294967295  // U32 max
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 4294967295, "U32 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u32_overflow() -> I32 {
    let value: U64 = 4294967296  // U32 max + 1
    when U32::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u8_normal() -> I32 {
    let value: U64 = 200
    when U8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 200, "200 should convert to U8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_u8_overflow() -> I32 {
    let value: U64 = 256  // U8 max + 1
    when U8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

// ============================================================================
// TryFrom signed to unsigned
// ============================================================================

@test
func test_tryfrom_i64_to_u64_positive() -> I32 {
    let value: I64 = 1000
    when U64::try_from(value) {
        Ok(result) => assert_eq(result, 1000, "positive should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_u64_zero() -> I32 {
    let value: I64 = 0
    when U64::try_from(value) {
        Ok(result) => assert_eq(result, 0, "zero should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i64_to_u64_negative() -> I32 {
    let value: I64 = -1
    when U64::try_from(value) {
        Ok(_) => assert(false, "negative should fail"),
        Err(e) => {
            when e {
                TryFromIntError::NegativeToUnsigned => assert(true, "correctly detected negative"),
                _ => assert(false, "wrong error type")
            }
        }
    }
    return 0
}

@test
func test_tryfrom_i32_to_u32_positive() -> I32 {
    let value: I32 = 42
    when U32::try_from(value) {
        Ok(result) => assert_eq(result, 42, "positive should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_i32_to_u32_negative() -> I32 {
    let value: I32 = -42
    when U32::try_from(value) {
        Ok(_) => assert(false, "negative should fail"),
        Err(_) => assert(true, "correctly detected negative")
    }
    return 0
}

// ============================================================================
// TryFrom unsigned to signed
// ============================================================================

@test
func test_tryfrom_u64_to_i64_in_range() -> I32 {
    let value: U64 = 1000000
    when I64::try_from(value) {
        Ok(result) => assert_eq(result, 1000000, "in range should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_i64_max() -> I32 {
    let value: U64 = 9223372036854775807  // I64 max
    when I64::try_from(value) {
        Ok(result) => assert_eq(result, 9223372036854775807, "I64 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u64_to_i64_overflow() -> I32 {
    let value: U64 = 9223372036854775808  // I64 max + 1
    when I64::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_in_range() -> I32 {
    let value: U8 = 100
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 100, "100 should convert to I8"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_max() -> I32 {
    let value: U8 = 127  // I8 max
    when I8::try_from(value) {
        Ok(result) => assert_eq(result as I32, 127, "I8 max should convert"),
        Err(_) => assert(false, "should not fail")
    }
    return 0
}

@test
func test_tryfrom_u8_to_i8_overflow() -> I32 {
    let value: U8 = 128  // I8 max + 1
    when I8::try_from(value) {
        Ok(_) => assert(false, "should overflow"),
        Err(_) => assert(true, "correctly detected overflow")
    }
    return 0
}
