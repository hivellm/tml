//! Test Execution and Management
//!
//! This module contains core utilities for test discovery, configuration,
//! statistics tracking, and result aggregation during test suite execution.
//!
//! # Test Configuration
//!
//! - [`TestConfig`] — Test suite configuration (parallel, threads, verbose, filter)
//! - [`default_config`] — Create default test configuration
//!
//! # Test Statistics
//!
//! - [`TestStats`] — Aggregated test results (passed/failed/ignored counts, duration)
//! - [`empty_stats`] — Create empty statistics structure
//! - [`stats_add_passed`] — Increment passed test count
//! - [`stats_add_failed`] — Increment failed test count
//! - [`stats_add_ignored`] — Increment ignored test count
//! - [`stats_set_duration`] — Set total test duration
//!
//! # Test Metadata
//!
//! - [`TestMetadata`] — Per-test metadata (name, module, file, line, should_panic, ignored)
//! - [`make_metadata`] — Create test metadata structure
//!
//! # Output Utilities
//!
//! - [`print_test_result`] — Print single test result (ok/FAILED)
//! - [`print_test_summary`] — Print full test summary with statistics
//!
//! # Example
//!
//! ```tml
//! use test::runner::*
//!
//! let config = default_config()
//! let mut stats = empty_stats()
//!
//! stats_add_passed(&mut stats)
//! stats_add_passed(&mut stats)
//! stats_add_failed(&mut stats)
//! stats_set_duration(&mut stats, 125000)  // 125ms in microseconds
//!
//! print_test_summary(stats)
//! // Output:
//! // test result: FAILED
//! // 2 passed; 1 failed; 0 ignored; 125 ms
//! ```
//!
//! # Integration with Test Framework
//!
//! The test runner is the core of the TML testing infrastructure. It:
//! - Discovers test functions from compiled test DLLs
//! - Applies filters to select which tests to run
//! - Executes tests (serially or in parallel based on config)
//! - Collects statistics (pass/fail/ignore counts, timing)
//! - Produces formatted output via the report module

use types

/// Create default test configuration
pub func default_config() -> TestConfig {
    TestConfig {
        parallel: false,
        threads: 1,
        nocapture: false,
        verbose: false,
        quiet: false,
        filter: Nothing,
    }
}

/// Create test statistics with initial values
pub func empty_stats() -> TestStats {
    TestStats {
        total: 0,
        passed: 0,
        failed: 0,
        ignored: 0,
        duration: 0,
    }
}

/// Increment passed test count
pub func stats_add_passed(stats: mut ref TestStats) {
    stats.passed = stats.passed + 1
    stats.total = stats.total + 1
}

/// Increment failed test count
pub func stats_add_failed(stats: mut ref TestStats) {
    stats.failed = stats.failed + 1
    stats.total = stats.total + 1
}

/// Increment ignored test count
pub func stats_add_ignored(stats: mut ref TestStats) {
    stats.ignored = stats.ignored + 1
    stats.total = stats.total + 1
}

/// Set total duration in microseconds
pub func stats_set_duration(stats: mut ref TestStats, duration_us: I64) {
    stats.duration = duration_us
}

/// Create test metadata
pub func make_metadata(
    name: Str,
    module: Str,
    file: Str,
    line: I32,
    should_panic: Bool,
    ignored: Bool
) -> TestMetadata {
    TestMetadata {
        name: name,
        module: module,
        file: file,
        line: line,
        should_panic: should_panic,
        panic_message: Nothing,
        ignored: ignored,
    }
}

/// Print test result in standard format
pub func print_test_result(name: Str, passed: Bool) {
    if passed {
        print("test ")
        print(name)
        println(" ... ok")
    } else {
        print("test ")
        print(name)
        println(" ... FAILED")
    }
}

/// Print test summary
pub func print_test_summary(stats: TestStats) {
    println("")
    print("test result: ")

    if stats.failed == 0 {
        println("ok")
    } else {
        println("FAILED")
    }

    print(stats.passed)
    print(" passed; ")
    print(stats.failed)
    print(" failed; ")
    print(stats.ignored)
    print(" ignored; ")

    // Convert microseconds to milliseconds for display
    let duration_ms: I64 = stats.duration / 1000
    print(duration_ms)
    println(" ms")
    println("")
}
