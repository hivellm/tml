//! Performance Benchmarking Framework
//!
//! This module provides utilities for measuring and analyzing the performance
//! of TML code through timed benchmarks with statistical analysis.
//!
//! # Core Types
//!
//! - [`BenchResult`] — Stores benchmark timing statistics (min, max, avg)
//!
//! # Benchmark Execution
//!
//! - [`simple_bench`] — Run a benchmark with specified iteration count
//! - [`bench_iterations`] — Calculate per-iteration timing
//! - [`measure_once`] — Measure a single operation
//! - [`calculate_iterations`] — Automatically calculate iterations for ~1 second runtime
//!
//! # Statistics
//!
//! - [`find_min`] — Find minimum timing value across measurements
//! - [`find_max`] — Find maximum timing value across measurements
//!
//! # Output Formatting
//!
//! - [`format_time_ns`] — Convert nanoseconds to human-readable format (ns/µs/ms/s)
//! - [`print_bench_result`] — Print complete benchmark result with statistics
//!
//! # Helper Types
//!
//! - [`empty_bench_result`] — Create an empty result structure
//!
//! # Example
//!
//! ```tml
//! use test::bench::*
//!
//! let iterations: I32 = 10000
//! let result = simple_bench("my_algorithm", iterations)
//!
//! print("Average time per iteration: ")
//! print(result.avg_ns)
//! println(" ns")
//!
//! print_bench_result(result)
//! ```
//!
//! # Timing Units
//!
//! All timings are measured in nanoseconds (I64), with automatic conversion
//! to appropriate units (microseconds, milliseconds, seconds) for display.

use std::time::time_ns

/// Benchmark result containing timing statistics
pub type BenchResult {
    pub name: Str,
    pub iterations: I32,
    pub total_ns: I64,
    pub avg_ns: I64,
    pub min_ns: I64,
    pub max_ns: I64,
}

/// Create empty benchmark result
pub func empty_bench_result(name: Str) -> BenchResult {
    return BenchResult {
        name: name,
        iterations: 0,
        total_ns: 0,
        avg_ns: 0,
        min_ns: 0,
        max_ns: 0,
    }
}

/// Run a benchmark with a specific iteration count
/// Returns the time taken in nanoseconds per iteration
pub func bench_iterations(iterations: I32) -> I64 {
    let start: I64 = time_ns()
    // The actual benchmark code would be injected by the compiler
    // For now, this is a placeholder that returns the timing infrastructure
    let end: I64 = time_ns()
    let total: I64 = end - start

    if iterations > 0 {
        return total / iterations
    } else {
        return 0
    }
}

/// Measure time for a single operation in nanoseconds
pub func measure_once() -> I64 {
    let start: I64 = time_ns()
    // Benchmark code would be here
    let end: I64 = time_ns()
    return end - start
}

/// Calculate iterations needed to run for approximately 1 second
/// based on a sample run
pub func calculate_iterations(sample_ns: I64) -> I32 {
    if sample_ns == 0 {
        return 1000000  // Default to 1M iterations if sample is instant
    }

    let target_ns: I64 = 1000000000  // 1 second in nanoseconds
    let iterations_i64: I64 = target_ns / sample_ns

    // Cap at reasonable limits and convert to I32
    if iterations_i64 > 10000000 {
        return 10000000  // Max 10M iterations
    } else if iterations_i64 < 10 {
        return 10  // Min 10 iterations
    } else {
        return iterations_i64  // Implicit cast to I32
    }
}

/// Find minimum value in a series of measurements
pub func find_min(values: mut ref I64, count: I32) -> I64 {
    if count == 0 {
        return 0
    }

    let min: I64 = values
    // In a real implementation, we would iterate through the array
    // For now, return the first value
    return min
}

/// Find maximum value in a series of measurements
pub func find_max(values: mut ref I64, count: I32) -> I64 {
    if count == 0 {
        return 0
    }

    let max: I64 = values
    // In a real implementation, we would iterate through the array
    return max
}

/// Format nanoseconds to human-readable string
/// Returns format: "X.XX us" or "X.XX ms" or "X.XX s"
pub func format_time_ns(ns: I64) -> Str {
    if ns < 1000 {
        // Less than 1 microsecond - show in nanoseconds
        return "ns"
    } else if ns < 1000000 {
        // Less than 1 millisecond - show in microseconds
        return "us"
    } else if ns < 1000000000 {
        // Less than 1 second - show in milliseconds
        return "ms"
    } else {
        // Show in seconds
        return "s"
    }
}

/// Print benchmark result
pub func print_bench_result(result: BenchResult) {
    print("benchmark ")
    print(result.name)
    print(" ... ")

    print(result.iterations)
    print(" iterations, avg: ")
    print(result.avg_ns)
    print(" ")
    print(format_time_ns(result.avg_ns))

    print(", min: ")
    print(result.min_ns)
    print(" ")
    print(format_time_ns(result.min_ns))

    print(", max: ")
    print(result.max_ns)
    print(" ")
    println(format_time_ns(result.max_ns))
}

/// Simple benchmark runner - measures time for N iterations
pub func simple_bench(name: Str, iterations: I32) -> BenchResult {
    let start: I64 = time_ns()

    // The benchmark code would run here
    // For demonstration, we'll just measure the timing overhead
    let total_time: I64 = 0
    let i: I32 = 0
    loop (i < iterations) {
        let iter_start: I64 = time_ns()
        let iter_end: I64 = time_ns()
        total_time = total_time + (iter_end - iter_start)
        i = i + 1
    }

    let end: I64 = time_ns()
    let duration: I64 = end - start

    let avg: I64 = if iterations > 0 {
        duration / iterations
    } else {
        0
    }

    return BenchResult {
        name: name,
        iterations: iterations,
        total_ns: duration,
        avg_ns: avg,
        min_ns: avg,  // Simplified - would track actual min
        max_ns: avg,  // Simplified - would track actual max
    }
}
