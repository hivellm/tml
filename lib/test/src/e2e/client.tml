//! E2E test clients for TCP and UDP with fluent builder API.
//!
//! # Example
//!
//! ```tml
//! use test::e2e::server::TcpTestServer
//! use test::e2e::client::TcpTestClient
//! use test::e2e::response::TestResult
//!
//! let server = TcpTestServer::new().unwrap()
//! let result: TestResult = TcpTestClient::new(server.addr())
//!     .timeout(5000)
//!     .send_byte(72).send_byte(73)     // "HI"
//!     .expect_n(2)
//!     .run(ref server)
//!
//! assert(result.ok(), result.error_msg())
//! ```

use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr}
use std::net::tcp::{TcpListener, TcpStream}
use std::net::udp::UdpSocket
use core::time::Duration
use std::time::Instant
use test::e2e::response::TestResult
use test::e2e::server::{TcpTestServer, UdpTestServer}

// ============================================================================
// TcpTestClient
// ============================================================================

/// A fluent TCP test client that connects to a test server, sends data,
/// and verifies the response.
pub type TcpTestClient {
    target: SocketAddr,
    timeout_ms: I64,
    use_nodelay: Bool,
    send_buf: [U8; 32],
    send_len: I64,
    expect_len: I64,
}

impl TcpTestClient {
    /// Create a new TCP test client targeting the given address.
    pub func new(addr: SocketAddr) -> TcpTestClient {
        TcpTestClient {
            target: addr,
            timeout_ms: 5000,
            use_nodelay: false,
            send_buf: [0 as U8; 32],
            send_len: 0,
            expect_len: 0,
        }
    }

    /// Set the timeout in milliseconds (default: 5000).
    pub func timeout(this, ms: I64) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: ms,
            use_nodelay: this.use_nodelay,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Enable TCP_NODELAY (disable Nagle's algorithm).
    pub func nodelay(this, enabled: Bool) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: enabled,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Append a single byte to the send buffer.
    pub func send_byte(this, b: I32) -> TcpTestClient {
        var buf: [U8; 32] = this.send_buf
        let idx: I64 = this.send_len
        if idx < 32 {
            buf[idx] = b as U8
        }
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: this.use_nodelay,
            send_buf: buf,
            send_len: idx + 1,
            expect_len: this.expect_len,
        }
    }

    /// Set the expected number of bytes to receive back.
    pub func expect_n(this, n: I64) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: this.use_nodelay,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: n,
        }
    }

    /// Execute the test: connect, accept, send, read echo, verify.
    ///
    /// Single-threaded loopback flow — all I/O happens inside the accept block,
    /// following the pattern proven in tcp_echo.test.tml.
    /// Uses listener.accept() directly to avoid handle invalidation through
    /// intermediate Outcome returns.
    pub func run(this, server: ref TcpTestServer) -> TestResult {
        let start: Instant = Instant::now()

        // 1. Connect (succeeds via TCP backlog without accept)
        when TcpStream::connect(this.target) {
            Err(_) => return TestResult::fail("connect failed")
            Ok(client) => {
                // 2. Server accepts — direct listener.accept() keeps handle valid
                when server.listener.accept() {
                    Err(_) => return TestResult::fail("accept failed")
                    Ok(result) => {
                        let peer: TcpStream = result.0

                        // 3. Client sends data byte-by-byte
                        var si: I64 = 0
                        loop (si < this.send_len) {
                            let byte_buf: [U8; 1] = [this.send_buf[si]]
                            when client.write(ref byte_buf) {
                                Err(_) => return TestResult::fail("client write failed")
                                Ok(_) => {}
                            }
                            si = si + 1
                        }

                        // 4. Server reads + echoes back byte-by-byte
                        var total_read: I64 = 0
                        loop (total_read < this.send_len) {
                            var one: [U8; 1] = [0 as U8]
                            when peer.read(mut ref one) {
                                Err(_) => return TestResult::fail("server read failed")
                                Ok(n) => {
                                    if n > 0 {
                                        when peer.write(ref one) {
                                            Err(_) => return TestResult::fail("server echo failed")
                                            Ok(_) => {}
                                        }
                                        total_read = total_read + n
                                    }
                                }
                            }
                        }

                        // 5. Client reads response
                        if this.expect_len > 0 {
                            var received: I64 = 0
                            loop (received < this.expect_len) {
                                var one: [U8; 1] = [0 as U8]
                                when client.read(mut ref one) {
                                    Err(_) => return TestResult::fail("client read failed")
                                    Ok(n) => {
                                        received = received + n
                                    }
                                }
                            }
                            let ms: I64 = start.elapsed().as_millis()
                            return TestResult::pass(received, ms)
                        }

                        let ms: I64 = start.elapsed().as_millis()
                        return TestResult::pass(0, ms)
                    }
                }
            }
        }
    }
}

// ============================================================================
// UdpTestClient
// ============================================================================

/// A fluent UDP test client that sends datagrams and verifies responses.
pub type UdpTestClient {
    target: SocketAddr,
    timeout_ms: I64,
    send_buf: [U8; 32],
    send_len: I64,
    expect_len: I64,
}

impl UdpTestClient {
    /// Create a new UDP test client targeting the given address.
    pub func new(addr: SocketAddr) -> UdpTestClient {
        UdpTestClient {
            target: addr,
            timeout_ms: 5000,
            send_buf: [0 as U8; 32],
            send_len: 0,
            expect_len: 0,
        }
    }

    /// Set the timeout in milliseconds (default: 5000).
    pub func timeout(this, ms: I64) -> UdpTestClient {
        UdpTestClient {
            target: this.target,
            timeout_ms: ms,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Append a single byte to the send buffer.
    pub func send_byte(this, b: I32) -> UdpTestClient {
        var buf: [U8; 32] = this.send_buf
        let idx: I64 = this.send_len
        if idx < 32 {
            buf[idx] = b as U8
        }
        UdpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            send_buf: buf,
            send_len: idx + 1,
            expect_len: this.expect_len,
        }
    }

    /// Set the expected number of bytes to receive back.
    pub func expect_n(this, n: I64) -> UdpTestClient {
        UdpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: n,
        }
    }

    /// Execute the test: bind, send datagrams, server echoes, read response.
    ///
    /// UDP is connectionless — send_to works without accept.
    /// Each byte is sent as an individual datagram and echoed individually.
    pub func run(this, server: ref UdpTestServer) -> TestResult {
        let start: Instant = Instant::now()

        // 1. Bind client socket
        let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
        let client_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))
        when UdpSocket::bind(client_addr) {
            Err(_) => return TestResult::fail("client bind failed")
            Ok(client) => {
                // 2. Send each byte as its own datagram, server echoes each
                var si: I64 = 0
                loop (si < this.send_len) {
                    // Client sends 1-byte datagram
                    let byte_buf: [U8; 1] = [this.send_buf[si]]
                    when client.send_to(ref byte_buf, this.target) {
                        Err(_) => return TestResult::fail("client send_to failed")
                        Ok(_) => {}
                    }

                    // Server receives + echoes the 1-byte datagram
                    var srv_buf: [U8; 1] = [0 as U8]
                    when server.socket.recv_from(mut ref srv_buf) {
                        Err(_) => return TestResult::fail("server recv_from failed")
                        Ok(recv_result) => {
                            let sender: SocketAddr = recv_result.1
                            when server.socket.send_to(ref srv_buf, sender) {
                                Err(_) => return TestResult::fail("server echo send_to failed")
                                Ok(_) => {}
                            }
                        }
                    }

                    si = si + 1
                }

                // 3. Client reads responses
                if this.expect_len > 0 {
                    var received: I64 = 0
                    loop (received < this.expect_len) {
                        var one: [U8; 1] = [0 as U8]
                        when client.recv_from(mut ref one) {
                            Err(_) => return TestResult::fail("client recv_from failed")
                            Ok(result) => {
                                received = received + result.0
                            }
                        }
                    }
                    let ms: I64 = start.elapsed().as_millis()
                    return TestResult::pass(received, ms)
                }

                let ms: I64 = start.elapsed().as_millis()
                return TestResult::pass(0, ms)
            }
        }
    }
}
