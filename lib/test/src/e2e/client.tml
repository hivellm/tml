//! E2E test clients for TCP and UDP with fluent builder API.
//!
//! # Example
//!
//! ```tml
//! use test::e2e::server::TcpTestServer
//! use test::e2e::client::TcpTestClient
//! use test::e2e::response::TestResult
//!
//! let server = TcpTestServer::new().unwrap()
//! let result: TestResult = TcpTestClient::new(server.addr())
//!     .timeout(5000)
//!     .send_byte(72).send_byte(73)     // "HI"
//!     .expect_n(2)
//!     .run(ref server)
//!
//! assert(result.ok(), result.error_msg())
//! ```

use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr}
use std::net::tcp::TcpStream
use std::net::udp::UdpSocket
use core::time::Duration
use std::time::Instant
use test::e2e::response::TestResult
use test::e2e::server::{TcpTestServer, UdpTestServer}

// ============================================================================
// TcpTestClient
// ============================================================================

/// A fluent TCP test client that connects to a test server, sends data,
/// and verifies the response.
pub type TcpTestClient {
    target: SocketAddr,
    timeout_ms: I64,
    use_nodelay: Bool,
    send_buf: [U8; 256],
    send_len: I64,
    expect_len: I64,
}

impl TcpTestClient {
    /// Create a new TCP test client targeting the given address.
    pub func new(addr: SocketAddr) -> TcpTestClient {
        TcpTestClient {
            target: addr,
            timeout_ms: 5000,
            use_nodelay: false,
            send_buf: [0 as U8; 256],
            send_len: 0,
            expect_len: 0,
        }
    }

    /// Set the timeout in milliseconds (default: 5000).
    pub func timeout(this, ms: I64) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: ms,
            use_nodelay: this.use_nodelay,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Enable TCP_NODELAY (disable Nagle's algorithm).
    pub func nodelay(this, enabled: Bool) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: enabled,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Append a single byte to the send buffer.
    pub func send_byte(this, b: I32) -> TcpTestClient {
        var buf: [U8; 256] = this.send_buf
        let idx: I64 = this.send_len
        if idx < 256 {
            buf[idx] = b as U8
        }
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: this.use_nodelay,
            send_buf: buf,
            send_len: idx + 1,
            expect_len: this.expect_len,
        }
    }

    /// Set the expected number of bytes to receive back.
    pub func expect_n(this, n: I64) -> TcpTestClient {
        TcpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            use_nodelay: this.use_nodelay,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: n,
        }
    }

    /// Execute the test: connect, send data, have server echo, read response.
    ///
    /// Single-threaded flow:
    /// 1. Connect to server (succeeds via TCP backlog)
    /// 2. Send data from client
    /// 3. Server accepts + reads + echoes
    /// 4. Client reads response
    pub func run(this, server: ref TcpTestServer) -> TestResult {
        let start: Instant = Instant::now()

        // 1. Connect
        let client_result = TcpStream::connect(this.target)
        when client_result {
            Err(_) => return TestResult::fail("connect failed")
            Ok(client) => {
                // Set timeout
                let dur: Duration = Duration::from_millis(this.timeout_ms)
                client.set_read_timeout(Just(dur))
                client.set_write_timeout(Just(dur))

                if this.use_nodelay {
                    client.set_nodelay(true)
                }

                // 2. Send data from client
                if this.send_len > 0 {
                    when client.write(ref this.send_buf) {
                        Err(_) => return TestResult::fail("client write failed")
                        Ok(_) => {}
                    }
                }

                // 3. Server accepts and echoes
                when server.echo_one(this.send_len) {
                    Err(e) => return TestResult::fail(e)
                    Ok(_) => {}
                }

                // 4. Client reads response
                if this.expect_len > 0 {
                    var recv_buf: [U8; 256] = [0 as U8; 256]
                    when client.read(mut ref recv_buf) {
                        Err(_) => return TestResult::fail("client read failed")
                        Ok(n) => {
                            let ms: I64 = start.elapsed().as_millis()
                            if n != this.expect_len {
                                return TestResult::fail("expected " + this.expect_len.to_string() + " bytes, got " + n.to_string())
                            }
                            return TestResult::pass(n, ms)
                        }
                    }
                }

                let ms: I64 = start.elapsed().as_millis()
                return TestResult::pass(0, ms)
            }
        }
    }
}

// ============================================================================
// UdpTestClient
// ============================================================================

/// A fluent UDP test client that sends datagrams and verifies responses.
pub type UdpTestClient {
    target: SocketAddr,
    timeout_ms: I64,
    send_buf: [U8; 256],
    send_len: I64,
    expect_len: I64,
}

impl UdpTestClient {
    /// Create a new UDP test client targeting the given address.
    pub func new(addr: SocketAddr) -> UdpTestClient {
        UdpTestClient {
            target: addr,
            timeout_ms: 5000,
            send_buf: [0 as U8; 256],
            send_len: 0,
            expect_len: 0,
        }
    }

    /// Set the timeout in milliseconds (default: 5000).
    pub func timeout(this, ms: I64) -> UdpTestClient {
        UdpTestClient {
            target: this.target,
            timeout_ms: ms,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: this.expect_len,
        }
    }

    /// Append a single byte to the send buffer.
    pub func send_byte(this, b: I32) -> UdpTestClient {
        var buf: [U8; 256] = this.send_buf
        let idx: I64 = this.send_len
        if idx < 256 {
            buf[idx] = b as U8
        }
        UdpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            send_buf: buf,
            send_len: idx + 1,
            expect_len: this.expect_len,
        }
    }

    /// Set the expected number of bytes to receive back.
    pub func expect_n(this, n: I64) -> UdpTestClient {
        UdpTestClient {
            target: this.target,
            timeout_ms: this.timeout_ms,
            send_buf: this.send_buf,
            send_len: this.send_len,
            expect_len: n,
        }
    }

    /// Execute the test: send datagram, have server echo, read response.
    ///
    /// Flow:
    /// 1. Bind client socket on ephemeral port
    /// 2. Send datagram to server
    /// 3. Server receives and echoes back
    /// 4. Client reads response
    pub func run(this, server: ref UdpTestServer) -> TestResult {
        let start: Instant = Instant::now()

        // 1. Bind client socket
        let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
        let client_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))
        let client_result = UdpSocket::bind(client_addr)
        when client_result {
            Err(_) => return TestResult::fail("client bind failed")
            Ok(client) => {
                // Set timeout
                let dur: Duration = Duration::from_millis(this.timeout_ms)
                client.set_read_timeout(Just(dur))

                // 2. Send datagram to server
                when client.send_to(ref this.send_buf, this.target) {
                    Err(_) => return TestResult::fail("client send_to failed")
                    Ok(_) => {}
                }

                // 3. Server echoes
                when server.echo_one() {
                    Err(e) => return TestResult::fail(e)
                    Ok(_) => {}
                }

                // 4. Client reads response
                if this.expect_len > 0 {
                    var recv_buf: [U8; 256] = [0 as U8; 256]
                    when client.recv_from(mut ref recv_buf) {
                        Err(_) => return TestResult::fail("client recv_from failed")
                        Ok(result) => {
                            let n: I64 = result.0
                            let ms: I64 = start.elapsed().as_millis()
                            if n < this.expect_len {
                                return TestResult::fail("expected " + this.expect_len.to_string() + " bytes, got " + n.to_string())
                            }
                            return TestResult::pass(n, ms)
                        }
                    }
                }

                let ms: I64 = start.elapsed().as_millis()
                return TestResult::pass(0, ms)
            }
        }
    }
}
