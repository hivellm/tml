// Backtrace Performance Tests
// Verifies operations complete efficiently
// Run with: tml test --filter benchmark --profile
use test
use backtrace::Backtrace

// ============================================================================
// 12.1.1 Capture overhead tests
// ============================================================================

@test
func bench_capture_single() -> I32 {
    // Verify single capture completes
    var bt: Backtrace = Backtrace::capture()
    let count: I32 = bt.frame_count()

    // Should capture at least 1 frame
    assert(count > 0, "Should capture at least one frame")
    bt.free()
    return 0
}

@test
func bench_capture_100x() -> I32 {
    // Verify 100 captures complete quickly
    var i: I32 = 0
    loop (i < 100) {
        var bt: Backtrace = Backtrace::capture()
        bt.free()
        i = i + 1
    }
    return 0
}

@test
func bench_capture_with_skip() -> I32 {
    // Verify capture_from works
    var bt0: Backtrace = Backtrace::capture_from(0)
    var bt2: Backtrace = Backtrace::capture_from(2)

    // Skipping frames should result in fewer frames
    let c0: I32 = bt0.frame_count()
    let c2: I32 = bt2.frame_count()

    assert(c0 > 0, "bt0 should have frames")
    // c2 may be equal if skip removes internal frames only
    assert(c2 >= 0, "bt2 should have non-negative frames")
    bt0.free()
    bt2.free()
    return 0
}

// ============================================================================
// 12.1.2 Resolve overhead tests
// ============================================================================

@test
func bench_resolve_single() -> I32 {
    var bt: Backtrace = Backtrace::capture()

    // Resolve should complete
    bt.resolve()

    // After resolve, backtrace should be usable
    let s: Str = bt.to_string()
    assert(s.len() > 0, "to_string should produce output")
    bt.free()
    return 0
}

@test
func bench_resolve_idempotent() -> I32 {
    var bt: Backtrace = Backtrace::capture()

    // First resolve
    bt.resolve()
    let s1: Str = bt.to_string()

    // Second resolve should be fast (cached)
    bt.resolve()
    let s2: Str = bt.to_string()

    // Results should be identical
    assert_eq(s1, s2, "Idempotent resolve should produce same output")
    bt.free()
    return 0
}

@test
func bench_resolve_10x() -> I32 {
    // Verify 10 full resolve cycles complete
    var i: I32 = 0
    loop (i < 10) {
        var bt: Backtrace = Backtrace::capture()
        bt.resolve()
        let _s: Str = bt.to_string()
        bt.free()
        i = i + 1
    }
    return 0
}

// ============================================================================
// 12.1.3/12.1.4 Memory and string tests
// ============================================================================

@test
func bench_frame_count_limit() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let count: I32 = bt.frame_count()

    // Frame count should be under the 128 limit
    assert(count < 128, "Frame count should be under 128")
    bt.free()
    return 0
}

@test
func bench_to_string_format() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    bt.resolve()
    let s: Str = bt.to_string()

    // Output should be reasonable size
    let len: I64 = s.len()
    assert(len > 0, "String should not be empty")

    // Each frame is roughly 50-200 chars, with frame count usually under 50
    // So total should be under 10KB
    assert(len < 10000, "String should be under 10KB")
    bt.free()
    return 0
}

// ============================================================================
// Stress tests
// ============================================================================

@test
func bench_nested_calls_10() -> I32 {
    // Test capture in nested function calls
    return nested_10()
}

func nested_10() -> I32 {
    return nested_9()
}

func nested_9() -> I32 {
    return nested_8()
}

func nested_8() -> I32 {
    return nested_7()
}

func nested_7() -> I32 {
    return nested_6()
}

func nested_6() -> I32 {
    return nested_5()
}

func nested_5() -> I32 {
    return nested_4()
}

func nested_4() -> I32 {
    return nested_3()
}

func nested_3() -> I32 {
    return nested_2()
}

func nested_2() -> I32 {
    return nested_1()
}

func nested_1() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let count: I32 = bt.frame_count()

    // Should capture at least 1 frame (adjusted from 10 due to tail call optimization)
    // In optimized builds, the nested calls may be tail-call optimized away
    assert(count >= 1, "Should capture at least one frame")
    bt.free()
    return 0
}
