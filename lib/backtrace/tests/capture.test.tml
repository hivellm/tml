// Tests for backtrace capture functionality
//
// NOTE: On Windows without frame pointers (default for optimized TML code),
// RtlCaptureStackBackTrace can only capture a limited number of frames.
// These tests are designed to work with this limitation.

use test
use backtrace::backtrace::Backtrace
use backtrace::backtrace::BacktraceStatus
use backtrace::backtrace::PrintFmt
use backtrace::backtrace::capture_backtrace
use backtrace::backtrace::trace_frames
use backtrace::backtrace::clear_symbol_cache
use backtrace::frame::BacktraceFrame
use backtrace::symbol::BacktraceSymbol

// ============================================================================
// Basic Capture Tests
// ============================================================================

@test
func test_capture_returns_backtrace() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let count: I32 = bt.frame_count()
    // On Windows without frame pointers, we may only get 1-2 frames
    assert(count >= 0, "backtrace should not return negative")
    return 0
}

@test
func test_capture_from_skip() -> I32 {
    var bt1: Backtrace = Backtrace::capture()
    var bt2: Backtrace = Backtrace::capture_from(1)

    let count1: I32 = bt1.frame_count()
    let count2: I32 = bt2.frame_count()

    // Both should be non-negative
    assert(count1 >= 0, "capture should not return negative")
    assert(count2 >= 0, "capture_from should not return negative")
    return 0
}

// ============================================================================
// Status Tests
// ============================================================================

@test
func test_status_captured() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let status: BacktraceStatus = bt.status()

    // After capture, status should be Captured (not resolved yet)
    when status {
        BacktraceStatus::Captured => {},
        BacktraceStatus::Unsupported => {},  // OK if platform doesn't support
        BacktraceStatus::Resolved => assert(false, "should not be resolved yet")
    }
    return 0
}

@test
func test_status_resolved() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    bt.resolve()
    let status: BacktraceStatus = bt.status()

    // After resolve, status should be Resolved
    when status {
        BacktraceStatus::Resolved => {},
        BacktraceStatus::Captured => assert(false, "should be resolved"),
        BacktraceStatus::Unsupported => {}  // OK if platform doesn't support
    }
    return 0
}

// ============================================================================
// Frame Access Tests
// ============================================================================

@test
func test_frame_access() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let count: I32 = bt.frame_count()

    // frame() is currently stubbed to return Nothing due to codegen
    // limitations with Maybe[Str] fields in BacktraceSymbol.
    // TODO: Update this test when frame() is fully implemented.
    if count > 0 {
        let frame_opt: Maybe[BacktraceFrame] = bt.frame(0)
        when frame_opt {
            Just(f) => {
                let ip: *Unit = f.instruction_pointer()
            },
            Nothing => {}
        }
    }
    return 0
}

@test
func test_frame_out_of_bounds() -> I32 {
    var bt: Backtrace = Backtrace::capture()

    // Negative index should return Nothing
    let neg: Maybe[BacktraceFrame] = bt.frame(-1)
    when neg {
        Just(_) => assert(false, "negative index should return Nothing"),
        Nothing => {}
    }

    // Index >= count should return Nothing
    let count: I32 = bt.frame_count()
    let oob: Maybe[BacktraceFrame] = bt.frame(count + 100)
    when oob {
        Just(_) => assert(false, "out of bounds should return Nothing"),
        Nothing => {}
    }
    return 0
}

// ============================================================================
// Formatting Tests
// ============================================================================

@test
func test_to_string_produces_output() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let s: Str = bt.to_string()
    let len: I64 = s.len()
    // Even with 0 frames, to_string produces some output
    assert(len > 0, "to_string should produce output")
    return 0
}

@test
func test_format_short() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let s: Str = bt.format(PrintFmt::Short)
    // Short format should produce some output
    let len: I64 = s.len()
    assert(len >= 0, "short format should work")
    return 0
}

@test
func test_format_full() -> I32 {
    var bt: Backtrace = Backtrace::capture()
    let s: Str = bt.format(PrintFmt::Full)
    let len: I64 = s.len()
    assert(len > 0, "full format should produce output")
    return 0
}

// ============================================================================
// Resolve Tests
// ============================================================================

@test
func test_resolve_is_idempotent() -> I32 {
    var bt: Backtrace = Backtrace::capture()

    // Call resolve multiple times - should not crash
    bt.resolve()
    bt.resolve()
    bt.resolve()

    // to_string should still work after multiple resolves
    let s: Str = bt.to_string()
    let len: I64 = s.len()
    assert(len > 0, "to_string should work after multiple resolves")
    return 0
}

// ============================================================================
// Convenience Function Tests
// ============================================================================

@test
func test_capture_backtrace_convenience() -> I32 {
    var bt: Backtrace = capture_backtrace(0)
    let count: I32 = bt.frame_count()
    assert(count >= 0, "capture_backtrace should return valid backtrace")
    return 0
}

@test
func test_trace_frames() -> I32 {
    var bt: Backtrace = trace_frames()
    let count: I32 = bt.frame_count()
    assert(count >= 0, "trace_frames should return valid backtrace")
    return 0
}

@test
func test_clear_symbol_cache() -> I32 {
    // Just verify it doesn't crash
    clear_symbol_cache()
    return 0
}
