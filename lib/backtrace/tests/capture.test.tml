// Tests for backtrace capture functionality

use test
use backtrace::Backtrace
use backtrace::BacktraceFrame
use backtrace::BacktraceSymbol

// ============================================================================
// Basic Capture Tests
// ============================================================================

@test
func test_capture_returns_backtrace() -> I32 {
    let bt: Backtrace = Backtrace::capture()
    // Should have at least one frame (this function)
    assert(bt.frame_count() > 0, "backtrace should capture at least one frame")
    return 0
}

@test
func test_capture_from_skip() -> I32 {
    let bt1: Backtrace = Backtrace::capture()
    let bt2: Backtrace = Backtrace::capture_from(1)

    // bt2 should have fewer frames since we skipped one
    // Note: This may not always be true due to inlining
    assert(bt1.frame_count() >= bt2.frame_count(),
           "capture_from should skip frames")
    return 0
}

// ============================================================================
// Symbol Resolution Tests
// ============================================================================

@test
func test_resolve_populates_frames() -> I32 {
    let mut bt: Backtrace = Backtrace::capture()
    bt.resolve()

    // After resolve, frames should be populated
    let frames: ref List[BacktraceFrame] = bt.frames()
    assert(frames.len() > 0, "resolved backtrace should have frames")
    return 0
}

@test
func test_resolved_frame_has_name() -> I32 {
    let mut bt: Backtrace = Backtrace::capture()
    bt.resolve()

    let frames: ref List[BacktraceFrame] = bt.frames()
    if frames.len() > 0 {
        let frame: ref BacktraceFrame = frames.first().unwrap()
        // First frame should have symbol info (our test function)
        let sym: Maybe[BacktraceSymbol] = frame.symbol()
        // Note: Symbol might not be available in release builds without debug info
        // So we just check that is_resolved() is true
        assert(frame.is_resolved(), "frame should be marked as resolved")
    }
    return 0
}

// ============================================================================
// Formatting Tests
// ============================================================================

@test
func test_to_string_contains_frames() -> I32 {
    let mut bt: Backtrace = Backtrace::capture()
    let s: Str = bt.to_string()

    // Should contain at least some text
    assert(s.len() > 0, "to_string should produce output")
    return 0
}

@test
func test_empty_backtrace_format() -> I32 {
    // Create an empty backtrace (handle is null)
    let bt: Backtrace = Backtrace {
        handle: null,
        frames: List::new(),
        resolved: false,
    }

    let s: Str = bt.to_string()
    assert(s.contains("empty"), "empty backtrace should say empty")
    return 0
}

// ============================================================================
// Symbol Type Tests
// ============================================================================

@test
func test_symbol_empty() -> I32 {
    let sym: BacktraceSymbol = BacktraceSymbol::empty()
    assert(sym.name.is_nothing(), "empty symbol has no name")
    assert(sym.filename.is_nothing(), "empty symbol has no filename")
    assert_eq(sym.lineno, 0, "empty symbol has lineno 0")
    return 0
}

@test
func test_symbol_with_name() -> I32 {
    let sym: BacktraceSymbol = BacktraceSymbol::with_name("test_func")
    assert(sym.has_name(), "symbol should have name")
    assert(not sym.has_location(), "symbol should not have location")
    return 0
}

@test
func test_symbol_to_string() -> I32 {
    let sym: BacktraceSymbol = BacktraceSymbol::new(
        Just("my_function"),
        Just("src/main.tml"),
        42,
        0
    )

    let s: Str = sym.to_string()
    assert(s.contains("my_function"), "should contain function name")
    assert(s.contains("src/main.tml"), "should contain filename")
    assert(s.contains("42"), "should contain line number")
    return 0
}

// ============================================================================
// Frame Type Tests
// ============================================================================

@test
func test_frame_new() -> I32 {
    // Use a dummy pointer value
    let ip: *Unit = 0x1234 as *Unit
    let frame: BacktraceFrame = BacktraceFrame::new(ip)

    assert_eq(frame.instruction_pointer(), ip, "frame should store IP")
    assert(not frame.is_resolved(), "new frame should not be resolved")
    assert(frame.symbol().is_nothing(), "new frame has no symbol")
    return 0
}

@test
func test_frame_with_symbol() -> I32 {
    let ip: *Unit = 0x5678 as *Unit
    let sym: BacktraceSymbol = BacktraceSymbol::with_name("test")
    let frame: BacktraceFrame = BacktraceFrame::with_symbol(ip, sym)

    assert(frame.is_resolved(), "frame with symbol should be resolved")
    assert(frame.symbol().is_just(), "frame should have symbol")
    return 0
}

@test
func test_frame_format() -> I32 {
    let ip: *Unit = 0xABCD as *Unit
    let sym: BacktraceSymbol = BacktraceSymbol::new(
        Just("some_function"),
        Just("file.tml"),
        10,
        0
    )
    let frame: BacktraceFrame = BacktraceFrame::with_symbol(ip, sym)

    let s: Str = frame.format(3)
    assert(s.contains("3:"), "format should include index")
    assert(s.contains("some_function"), "format should include name")
    assert(s.contains("file.tml"), "format should include file")
    return 0
}

// ============================================================================
// Deep Stack Tests
// ============================================================================

func recurse(depth: I32) -> I32 {
    if depth <= 0 {
        let bt: Backtrace = Backtrace::capture()
        return bt.frame_count()
    }
    return recurse(depth - 1)
}

@test
func test_deep_recursion() -> I32 {
    let count: I32 = recurse(20)
    // Should capture at least 20 frames from recursion + test framework
    assert(count >= 20, "should capture deep stack")
    return 0
}
