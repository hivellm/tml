//! Stack Trace Capture and Formatting
//!
//! Provides the main `Backtrace` type for capturing and formatting complete
//! stack traces at runtime. This module is inspired by Rust's `backtrace-rs` library.
//!
//! # Core Type
//!
//! - [`Backtrace`] â€” Represents a captured stack trace with multiple frames
//!
//! # Typical Workflow
//!
//! 1. Call [`Backtrace::capture()`] to capture the current stack
//! 2. Call [`resolve()`] to resolve symbols (function names, files, lines)
//! 3. Call [`to_string()`] or iterate frames to display the trace
//! 4. Drop the backtrace when done (automatically frees resources)
//!
//! # FFI Integration
//!
//! This module uses FFI declarations to interface with platform-specific
//! backtrace capture and symbol resolution libraries (Windows DbgHelp,
//! Linux execinfo/libbacktrace, macOS similar).

use super::frame::BacktraceFrame
use super::symbol::BacktraceSymbol

// ============================================================================
// FFI Declarations
// ============================================================================

@extern("ffi_backtrace_capture")
func ffi_backtrace_capture(skip: I32) -> *Unit

@extern("ffi_backtrace_frame_count")
func ffi_backtrace_frame_count(bt_handle: *Unit) -> I32

@extern("ffi_backtrace_frame_ip")
func ffi_backtrace_frame_ip(bt_handle: *Unit, index: I32) -> *Unit

@extern("ffi_backtrace_resolve")
func ffi_backtrace_resolve(bt_handle: *Unit)

@extern("ffi_backtrace_frame_name")
func ffi_backtrace_frame_name(bt_handle: *Unit, index: I32) -> *Unit

@extern("ffi_backtrace_frame_filename")
func ffi_backtrace_frame_filename(bt_handle: *Unit, index: I32) -> *Unit

@extern("ffi_backtrace_frame_lineno")
func ffi_backtrace_frame_lineno(bt_handle: *Unit, index: I32) -> U32

@extern("ffi_backtrace_frame_colno")
func ffi_backtrace_frame_colno(bt_handle: *Unit, index: I32) -> U32

@extern("ffi_backtrace_frame_symbol_address")
func ffi_backtrace_frame_symbol_address(bt_handle: *Unit, index: I32) -> *Unit

@extern("ffi_backtrace_frame_offset")
func ffi_backtrace_frame_offset(bt_handle: *Unit, index: I32) -> U64

@extern("ffi_backtrace_is_resolved")
func ffi_backtrace_is_resolved(bt_handle: *Unit) -> I32

@extern("ffi_backtrace_to_string")
func ffi_backtrace_to_string(bt_handle: *Unit) -> *Unit

@extern("ffi_backtrace_free")
func ffi_backtrace_free(bt_handle: *Unit)

@extern("ffi_backtrace_clear_cache")
func ffi_backtrace_clear_cache()

@extern("tml_str_from_cstr")
func tml_str_from_cstr(cstr: *Unit) -> Str

@extern("mem_free")
func mem_free(ptr: *Unit)

// ============================================================================
// Enums
// ============================================================================

/// The status of a backtrace capture.
///
/// This enum represents the state of a Backtrace object.
pub enum BacktraceStatus {
    /// Backtrace has not been captured (empty/null handle)
    Unsupported,
    /// Backtrace was captured but symbols not yet resolved
    Captured,
    /// Backtrace was captured and all symbols resolved
    Resolved,
}

/// Formatting style for backtraces.
///
/// Controls how backtraces are printed/formatted.
pub enum PrintFmt {
    /// Short format: just function names
    Short,
    /// Full format: function names with file:line info
    Full,
}

// ============================================================================
// Backtrace Type
// ============================================================================

/// A captured stack backtrace.
///
/// Backtrace captures the current call stack and can resolve symbol information
/// for each frame. This is useful for debugging, error reporting, and panic handlers.
///
/// ## Capturing a Backtrace
///
/// ```tml
/// // Capture the current stack (skipping 0 frames)
/// let bt = Backtrace::capture()
///
/// // Capture, skipping the first 2 frames
/// let bt = Backtrace::capture_from(2)
/// ```
///
/// ## Resolving Symbols
///
/// ```tml
/// let mut bt = Backtrace::capture()
/// bt.resolve()  // Resolve all symbols
/// print(bt.to_string())
/// ```
///
/// ## Accessing Individual Frames
///
/// ```tml
/// let bt = Backtrace::capture()
/// let count = bt.frame_count()
/// for i in 0 to count {
///     let frame = bt.frame(i)
///     // process frame...
/// }
/// ```
pub type Backtrace {
    /// Handle to the native backtrace structure
    handle: *Unit,

    /// Whether symbols have been resolved
    resolved: Bool,
}

impl Backtrace {
    /// Captures the current stack backtrace.
    pub func capture() -> Backtrace {
        // Skip 0: capture everything from here
        return Backtrace::capture_from(0)
    }

    /// Captures the current stack backtrace, skipping initial frames.
    /// The skip parameter indicates how many frames to skip from the caller.
    pub func capture_from(skip: I32) -> Backtrace {
        // FFI function handles the internal frame skipping
        let handle: *Unit = ffi_backtrace_capture(skip)
        return Backtrace {
            handle: handle,
            resolved: false,
        }
    }

    /// Returns the status of this backtrace.
    pub func status(this) -> BacktraceStatus {
        if this.handle == null {
            return BacktraceStatus::Unsupported
        }
        if this.resolved {
            return BacktraceStatus::Resolved
        }
        return BacktraceStatus::Captured
    }

    /// Returns the number of captured frames.
    pub func frame_count(this) -> I32 {
        if this.handle == null {
            return 0
        }
        return ffi_backtrace_frame_count(this.handle)
    }

    /// Returns the frame at the given index.
    ///
    /// The frame contains the instruction pointer and, if resolved,
    /// symbol information.
    pub func frame(this, index: I32) -> Maybe[BacktraceFrame] {
        // TODO: Re-enable when codegen properly handles structs with Maybe[Str] fields
        // The issue is that BacktraceSymbol contains Maybe[Str], which is unsized,
        // and the codegen cannot properly allocate or pass it by value.
        // Also, the codegen has issues passing *Unit to functions correctly.
        // For now, frame() always returns Nothing - users should use to_string() instead.
        return Nothing
    }

    /// Resolves symbol information for all frames.
    pub func resolve(mut this) {
        if this.handle == null or this.resolved {
            return
        }
        ffi_backtrace_resolve(this.handle)
        this.resolved = true
    }

    /// Formats the backtrace as a string.
    @allocates
    pub func to_string(mut this) -> Str {
        if this.handle == null {
            return "  <no backtrace>\n"
        }

        if not this.resolved {
            this.resolve()
        }

        let cstr: *Unit = ffi_backtrace_to_string(this.handle)
        if cstr == null {
            return "  <format error>\n"
        }

        let result: Str = tml_str_from_cstr(cstr)
        mem_free(cstr)
        return result
    }

    /// Formats the backtrace with the specified style.
    ///
    /// - `PrintFmt::Short`: Shows just function names (uses full format as fallback)
    /// - `PrintFmt::Full`: Shows full information with file:line
    ///
    /// Note: Both formats currently use the FFI formatter due to cross-module
    /// codegen limitations. Short format may be implemented in the future.
    @allocates
    pub func format(mut this, fmt: PrintFmt) -> Str {
        if this.handle == null {
            return "  <no backtrace>\n"
        }

        if not this.resolved {
            this.resolve()
        }

        // Both formats use the FFI formatter for now
        // TODO: Implement native Short format when cross-module method calls work
        return this.to_string()
    }

    /// Prints the backtrace to stdout.
    pub func print(mut this) {
        let s: Str = this.to_string()
        print(s)
    }

    /// Frees the native backtrace handle.
    pub func free(mut this) {
        if this.handle != null {
            ffi_backtrace_free(this.handle)
            this.handle = null
        }
    }
}

impl Drop for Backtrace {
    func drop(mut this) {
        this.free()
    }
}

// ============================================================================
// Low-Level Functions
// ============================================================================

/// Resolves a single address to symbol information.
///
/// This is a standalone function for resolving individual addresses
/// without capturing a full backtrace.
///
/// ## Example
///
/// ```tml
/// let sym = resolve_frame(some_address)
/// when sym {
///     Just(s) => print("Symbol: {s.to_string()}\n"),
///     Nothing => print("No symbol found\n")
/// }
/// ```
pub func resolve_frame(addr: *Unit) -> Maybe[BacktraceSymbol] {
    if addr == null {
        return Nothing
    }

    // Create a temporary backtrace with just this address
    // This is a simplified approach - in a full implementation,
    // we would call the FFI directly for single-address resolution
    var bt: Backtrace = Backtrace::capture_from(0)
    if bt.handle == null {
        return Nothing
    }

    // For now, return Nothing as single-frame resolution
    // would require additional FFI support
    bt.free()
    return Nothing
}

/// Clears any cached symbol information.
///
/// This function releases cached debug symbol data. It may be useful
/// after loading/unloading dynamic libraries to refresh symbol tables.
pub func clear_symbol_cache() {
    ffi_backtrace_clear_cache()
}

// ============================================================================
// Convenience Functions
// ============================================================================

/// Captures and prints the current backtrace.
pub func print_backtrace() {
    let mut bt: Backtrace = Backtrace::capture_from(1)
    bt.resolve()
    print("Backtrace:\n")
    bt.print()
}

/// Captures and returns a backtrace, skipping the specified frames.
pub func capture_backtrace(skip: I32) -> Backtrace {
    return Backtrace::capture_from(skip + 1)
}

/// Iterates through the current call stack, invoking the callback for each frame.
///
/// This is a low-level function that allows processing frames without
/// capturing a full backtrace. The callback receives the instruction pointer
/// for each frame.
///
/// Note: In TML, this is implemented by capturing a backtrace and iterating,
/// since we don't have closure callbacks like Rust's trace().
///
/// ## Example
///
/// ```tml
/// let bt = Backtrace::capture()
/// let count = bt.frame_count()
/// for i in 0 to count {
///     let frame = bt.frame(i)
///     // Process each frame...
/// }
/// ```
pub func trace_frames() -> Backtrace {
    return Backtrace::capture_from(1)
}
