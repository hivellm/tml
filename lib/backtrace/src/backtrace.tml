// Backtrace - Stack trace capture and formatting
//
// Provides the main Backtrace type for capturing and formatting stack traces.

// ============================================================================
// FFI Declarations
// ============================================================================

@extern("ffi_backtrace_capture")
func ffi_backtrace_capture(skip: I32) -> *Unit

@extern("ffi_backtrace_frame_count")
func ffi_backtrace_frame_count(bt_handle: *Unit) -> I32

@extern("ffi_backtrace_resolve")
func ffi_backtrace_resolve(bt_handle: *Unit)

@extern("ffi_backtrace_to_string")
func ffi_backtrace_to_string(bt_handle: *Unit) -> *Unit

@extern("ffi_backtrace_free")
func ffi_backtrace_free(bt_handle: *Unit)

@extern("tml_str_from_cstr")
func tml_str_from_cstr(cstr: *Unit) -> Str

@extern("tml_free")
func tml_free(ptr: *Unit)

// ============================================================================
// Backtrace Type
// ============================================================================

/// A captured stack backtrace.
///
/// Backtrace captures the current call stack and can resolve symbol information
/// for each frame. This is useful for debugging, error reporting, and panic handlers.
///
/// ## Capturing a Backtrace
///
/// ```tml
/// // Capture the current stack (skipping 0 frames)
/// let bt = Backtrace::capture()
///
/// // Capture, skipping the first 2 frames
/// let bt = Backtrace::capture_from(2)
/// ```
///
/// ## Resolving Symbols
///
/// ```tml
/// let mut bt = Backtrace::capture()
/// bt.resolve()  // Resolve all symbols
/// print(bt.to_string())
/// ```
pub type Backtrace {
    /// Handle to the native backtrace structure
    handle: *Unit,

    /// Whether symbols have been resolved
    resolved: Bool,
}

impl Backtrace {
    /// Captures the current stack backtrace.
    pub func capture() -> Backtrace {
        // Skip 0: capture everything from here
        return Backtrace::capture_from(0)
    }

    /// Captures the current stack backtrace, skipping initial frames.
    /// The skip parameter indicates how many frames to skip from the caller.
    pub func capture_from(skip: I32) -> Backtrace {
        // FFI function handles the internal frame skipping
        let handle: *Unit = ffi_backtrace_capture(skip)
        return Backtrace {
            handle: handle,
            resolved: false,
        }
    }

    /// Returns the number of captured frames.
    pub func frame_count(this) -> I32 {
        if this.handle == null {
            return 0
        }
        return ffi_backtrace_frame_count(this.handle)
    }

    /// Resolves symbol information for all frames.
    pub func resolve(mut this) {
        if this.handle == null or this.resolved {
            return
        }
        ffi_backtrace_resolve(this.handle)
        this.resolved = true
    }

    /// Formats the backtrace as a string.
    pub func to_string(mut this) -> Str {
        if this.handle == null {
            return "  <no backtrace>\n"
        }

        if not this.resolved {
            this.resolve()
        }

        let cstr: *Unit = ffi_backtrace_to_string(this.handle)
        if cstr == null {
            return "  <format error>\n"
        }

        let result: Str = tml_str_from_cstr(cstr)
        tml_free(cstr)
        return result
    }

    /// Prints the backtrace to stdout.
    pub func print(mut this) {
        let s: Str = this.to_string()
        print(s)
    }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/// Captures and prints the current backtrace.
pub func print_backtrace() {
    let mut bt: Backtrace = Backtrace::capture_from(1)
    bt.resolve()
    print("Backtrace:\n")
    bt.print()
}

/// Captures and returns a backtrace, skipping the specified frames.
pub func capture_backtrace(skip: I32) -> Backtrace {
    return Backtrace::capture_from(skip + 1)
}
