// BacktraceFrame - A single stack frame
//
// Represents one frame in a stack backtrace, containing the instruction
// pointer and optionally resolved symbol information.

use super::symbol::BacktraceSymbol

/// A single frame in a stack backtrace.
///
/// Each frame represents a return address on the call stack. The frame
/// can be resolved to obtain symbol information (function name, file, line).
///
/// ## Fields
///
/// - `ip`: Instruction pointer (return address)
/// - `symbol`: Resolved symbol information (if available)
/// - `resolved`: Whether symbol resolution has been attempted
///
/// ## Example
///
/// ```tml
/// for frame in bt.frames() {
///     print("  at {frame.ip:?}\n")
///     when frame.symbol() {
///         Just(sym) => print("     {sym.to_string()}\n"),
///         Nothing => print("     <no symbol>\n")
///     }
/// }
/// ```
pub type BacktraceFrame {
    /// Instruction pointer (return address on the stack)
    ip: *Unit,

    /// Resolved symbol information
    symbol_info: Maybe[BacktraceSymbol],

    /// Whether resolution has been attempted
    resolved: Bool,
}

impl BacktraceFrame {
    /// Creates a new unresolved frame from an instruction pointer.
    pub func new(ip: *Unit) -> BacktraceFrame {
        return BacktraceFrame {
            ip: ip,
            symbol_info: Nothing,
            resolved: false,
        }
    }

    /// Creates a new frame with symbol information.
    pub func with_symbol(ip: *Unit, symbol: BacktraceSymbol) -> BacktraceFrame {
        return BacktraceFrame {
            ip: ip,
            symbol_info: Just(symbol),
            resolved: true,
        }
    }

    /// Returns the instruction pointer for this frame.
    pub func instruction_pointer(this) -> *Unit {
        return this.ip
    }

    /// Returns the symbol information if available.
    pub func symbol(this) -> Maybe[BacktraceSymbol] {
        return this.symbol_info
    }

    /// Returns true if this frame has been resolved.
    pub func is_resolved(this) -> Bool {
        return this.resolved
    }

    /// Returns the symbol address (start of function) if available.
    pub func symbol_address(this) -> Maybe[*Unit] {
        let sym_opt: Maybe[BacktraceSymbol] = this.symbol_info
        when sym_opt {
            Just(sym) => {
                let addr: *Unit = sym.addr
                if addr != null {
                    let result: Maybe[*Unit] = Just(addr)
                    return result
                } else {
                    let result: Maybe[*Unit] = Nothing
                    return result
                }
            },
            Nothing => {
                let result: Maybe[*Unit] = Nothing
                return result
            }
        }
    }

    /// Returns the offset from the symbol start to the instruction pointer.
    pub func offset(this) -> U64 {
        let sym_opt: Maybe[BacktraceSymbol] = this.symbol_info
        when sym_opt {
            Just(sym) => return sym.offset,
            Nothing => return 0
        }
    }

    /// Formats the frame as a string.
    pub func format(this, index: I32) -> Str {
        let sym_opt: Maybe[BacktraceSymbol] = this.symbol_info
        when sym_opt {
            Just(sym) => {
                let name_opt: Maybe[Str] = sym.name
                let file_opt: Maybe[Str] = sym.filename

                let name: Str = when name_opt {
                    Just(n) => n,
                    Nothing => "<unknown>"
                }

                when file_opt {
                    Just(file) => {
                        if sym.lineno > 0 {
                            return "  {index}: {name}\n             at {file}:{sym.lineno}"
                        } else {
                            return "  {index}: {name}\n             at {file}"
                        }
                    },
                    Nothing => return "  {index}: {name}"
                }
            },
            Nothing => {
                let addr: I64 = this.ip as I64
                return "  {index}: <unknown>\n             at 0x{addr}"
            }
        }
    }

    /// Formats the frame as a single line.
    pub func to_string(this) -> Str {
        let sym_opt: Maybe[BacktraceSymbol] = this.symbol_info
        when sym_opt {
            Just(sym) => {
                let name_opt: Maybe[Str] = sym.name
                let file_opt: Maybe[Str] = sym.filename
                let name_str: Str = when name_opt {
                    Just(n) => n,
                    Nothing => "<unknown>"
                }
                when file_opt {
                    Just(file) => {
                        if sym.lineno > 0 {
                            if sym.colno > 0 {
                                return "{name_str} at {file}:{sym.lineno}:{sym.colno}"
                            } else {
                                return "{name_str} at {file}:{sym.lineno}"
                            }
                        } else {
                            return "{name_str} at {file}"
                        }
                    },
                    Nothing => return name_str
                }
            },
            Nothing => {
                let addr: I64 = this.ip as I64
                return "<unknown> at 0x{addr}"
            }
        }
    }
}
