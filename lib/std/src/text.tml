//! Dynamic string type with heap allocation and rich manipulation API.
//!
//! This module provides `Text`, a growable, heap-allocated string type
//! for dynamic string building and manipulation.
//!
//! # Main Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Text`] | Dynamic string with automatic growth |
//!
//! # When to Use Text
//!
//! Use `Text` when you need:
//! - Dynamic string building and manipulation
//! - Mutable strings that grow and shrink
//! - Rich string operations (split, replace, trim, etc.)
//!
//! For static, immutable strings use `Str` instead.
//!
//! # Memory Layout
//!
//! Text is implemented as a heap-allocated header (24 bytes):
//!   offset 0:  data pointer (*U8) — points to null-terminated byte buffer
//!   offset 8:  len (I64) — current byte length
//!   offset 16: capacity (I64) — allocated capacity of data buffer
//!
//! # Example
//!
//! ```tml
//! let greeting = Text::from("Hello, ")
//! greeting.push_str("World!")
//! println(greeting.as_str())  // "Hello, World!"
//!
//! let upper = greeting.to_upper_case()
//! println(upper.as_str())  // "HELLO, WORLD!"
//! ```

// ============================================================================
// Text Type Definition
// ============================================================================

/// Dynamic string with heap allocation and automatic growth.
///
/// Text provides JavaScript-like string manipulation methods.
/// Internally uses a 24-byte header (data_ptr + len + capacity)
/// with a separate heap-allocated byte buffer.
pub type Text {
    handle: *Unit
}

// ============================================================================
// Internal Helpers
// ============================================================================

// Header field offsets
func text_data_ptr_offset() -> I64 { 0 }
func text_len_offset() -> I64 { 8 }
func text_cap_offset() -> I64 { 16 }
func text_header_size() -> I64 { 24 }

// Read header field: data pointer
func text_get_data(h: *Unit) -> *U8 {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_data_ptr_offset()) as *I64
    let raw: I64 = lowlevel { ptr_read[I64](p) }
    raw as *U8
}

// Read header field: length
func text_get_len(h: *Unit) -> I64 {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_len_offset()) as *I64
    lowlevel { ptr_read[I64](p) }
}

// Read header field: capacity
func text_get_cap(h: *Unit) -> I64 {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_cap_offset()) as *I64
    lowlevel { ptr_read[I64](p) }
}

// Write header field: data pointer
func text_set_data(h: *Unit, data: *U8) {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_data_ptr_offset()) as *I64
    let val: I64 = data as I64
    lowlevel { ptr_write[I64](p, val) }
}

// Write header field: length
func text_set_len(h: *Unit, new_len: I64) {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_len_offset()) as *I64
    lowlevel { ptr_write[I64](p, new_len) }
}

// Write header field: capacity
func text_set_cap(h: *Unit, new_cap: I64) {
    let addr: I64 = h as I64
    let p: *I64 = (addr + text_cap_offset()) as *I64
    lowlevel { ptr_write[I64](p, new_cap) }
}

// Calculate new capacity using growth strategy
func text_grow_cap(current: I64, required: I64) -> I64 {
    var new_cap: I64 = 0
    if current == 0 {
        new_cap = 32
    } else if current < 4096 {
        new_cap = current * 2
    } else {
        new_cap = current + current / 2
    }
    if new_cap < required {
        new_cap = required
    }
    new_cap
}

// Ensure the data buffer has enough capacity
func text_ensure_cap(h: *Unit, required: I64) {
    let cap: I64 = text_get_cap(h)
    if required <= cap {
        return
    }
    let new_cap: I64 = text_grow_cap(cap, required)
    let old_data: *U8 = text_get_data(h)
    let old_addr: I64 = old_data as I64
    if old_addr == 0 {
        // First allocation
        let new_data: *U8 = lowlevel { mem_alloc(new_cap + 1) } as *U8
        text_set_data(h, new_data)
        text_set_cap(h, new_cap)
    } else {
        // Realloc
        let new_data: *U8 = lowlevel { mem_realloc(old_data as *Unit, new_cap + 1) } as *U8
        text_set_data(h, new_data)
        text_set_cap(h, new_cap)
    }
}

// Allocate a new header + buffer with given capacity
func text_alloc_with_cap(cap: I64) -> *Unit {
    let h: *Unit = lowlevel { mem_alloc(text_header_size()) }
    var actual_cap: I64 = cap
    if actual_cap < 8 {
        actual_cap = 8
    }
    let data: *U8 = lowlevel { mem_alloc(actual_cap + 1) } as *U8
    // null-terminate
    let p: *U8 = (data as I64) as *U8
    lowlevel { ptr_write[U8](p, 0 as U8) }
    text_set_data(h, data)
    text_set_len(h, 0)
    text_set_cap(h, actual_cap)
    h
}

// Copy bytes from Str into data buffer at offset
func text_copy_str_at(data: *U8, offset: I64, s: Str, slen: I64) {
    if slen <= 0 { return }
    let dst: *U8 = (data as I64 + offset) as *U8
    lowlevel { copy_nonoverlapping(s as *U8, dst, slen) }
}

// Copy bytes from one buffer to another
func text_copy_bytes(dst: *U8, dst_offset: I64, src: *U8, src_offset: I64, count: I64) {
    if count <= 0 { return }
    let d: *U8 = (dst as I64 + dst_offset) as *U8
    let s: *U8 = (src as I64 + src_offset) as *U8
    lowlevel { copy_nonoverlapping(s, d, count) }
}

// Get byte at index from data buffer
func text_byte_at_raw(data: *U8, index: I64) -> U8 {
    let p: *U8 = (data as I64 + index) as *U8
    lowlevel { ptr_read[U8](p) }
}

// Set byte at index in data buffer
func text_set_byte(data: *U8, index: I64, value: U8) {
    let p: *U8 = (data as I64 + index) as *U8
    lowlevel { ptr_write[U8](p, value) }
}

// Get length of a Str (null-terminated)
func text_str_len(s: Str) -> I64 {
    let addr: I64 = s as I64
    if addr == 0 {
        return 0
    }
    var i: I64 = 0
    loop (true) {
        let p: *U8 = (addr + i) as *U8
        let byte: U8 = lowlevel { ptr_read[U8](p) }
        if byte == (0 as U8) {
            return i
        }
        i = i + 1
    }
    0
}

// Push a Str into text
func text_push_str_raw(h: *Unit, s: Str) {
    let slen: I64 = text_str_len(s)
    if slen <= 0 {
        return
    }
    let cur_len: I64 = text_get_len(h)
    text_ensure_cap(h, cur_len + slen)
    let data: *U8 = text_get_data(h)
    text_copy_str_at(data, cur_len, s, slen)
    let new_len: I64 = cur_len + slen
    text_set_len(h, new_len)
    text_set_byte(data, new_len, 0 as U8)
}

// Check if byte is whitespace
func text_is_ws(b: U8) -> Bool {
    let v: I32 = b as I32
    v == 32 or v == 9 or v == 10 or v == 13 or v == 12 or v == 11
}

// ============================================================================
// Integer to string helper (avoids dependency on core::str for module ordering)
// ============================================================================

func text_i64_to_str_push(h: *Unit, n: I64) {
    if n == 0 {
        let cur_len: I64 = text_get_len(h)
        text_ensure_cap(h, cur_len + 1)
        let data: *U8 = text_get_data(h)
        text_set_byte(data, cur_len, 48 as U8) // '0'
        text_set_len(h, cur_len + 1)
        text_set_byte(data, cur_len + 1, 0 as U8)
        return
    }

    var val: I64 = n
    var is_neg: Bool = false
    if val < 0 {
        is_neg = true
        val = 0 - val
    }

    // Count digits
    var temp: I64 = val
    var digit_count: I64 = 0
    loop (temp > 0) {
        digit_count = digit_count + 1
        temp = temp / 10
    }

    var sign_len: I64 = 0
    if is_neg { sign_len = 1 }
    let total: I64 = digit_count + sign_len
    let cur_len: I64 = text_get_len(h)
    text_ensure_cap(h, cur_len + total)
    let data: *U8 = text_get_data(h)

    // Write sign
    var pos: I64 = cur_len
    if is_neg {
        text_set_byte(data, pos, 45 as U8) // '-'
        pos = pos + 1
    }

    // Write digits in reverse order
    var write_pos: I64 = cur_len + total - 1
    var v: I64 = val
    loop (v > 0) {
        let digit: I64 = v % 10
        text_set_byte(data, write_pos, (digit + 48) as U8)
        write_pos = write_pos - 1
        v = v / 10
    }

    let new_len: I64 = cur_len + total
    text_set_len(h, new_len)
    text_set_byte(data, new_len, 0 as U8)
}

// ============================================================================
// impl Text
// ============================================================================

impl Text {
    // ========================================================================
    // Constructors
    // ========================================================================

    /// Create a new empty Text
    pub func new() -> Text {
        let h: *Unit = text_alloc_with_cap(8)
        Text { handle: h }
    }

    /// Create Text from a string literal
    pub func from(s: Str) -> Text {
        let slen: I64 = text_str_len(s)
        var cap: I64 = slen
        if cap < 8 { cap = 8 }
        let h: *Unit = text_alloc_with_cap(cap)
        if slen > 0 {
            let data: *U8 = text_get_data(h)
            text_copy_str_at(data, 0, s, slen)
            text_set_len(h, slen)
            text_set_byte(data, slen, 0 as U8)
        }
        Text { handle: h }
    }

    /// Create Text with pre-allocated capacity
    pub func with_capacity(cap: I64) -> Text {
        let h: *Unit = text_alloc_with_cap(cap)
        Text { handle: h }
    }

    /// Create Text from a number
    pub func from_i64(value: I64) -> Text {
        let h: *Unit = text_alloc_with_cap(24)
        text_i64_to_str_push(h, value)
        Text { handle: h }
    }

    /// Create Text from a floating-point number
    pub func from_f64(value: F64) -> Text {
        // Use the f64_to_string C runtime (hardware-dependent snprintf)
        let s: Str = lowlevel { f64_to_string(value) }
        Text::from(s)
    }

    /// Create Text from a floating-point number with precision
    pub func from_f64_precision(value: F64, precision: I32) -> Text {
        let s: Str = lowlevel { f64_to_string_precision(value, precision) }
        Text::from(s)
    }

    /// Create Text from a boolean
    pub func from_bool(value: Bool) -> Text {
        if value {
            Text::from("true")
        } else {
            Text::from("false")
        }
    }

    // ========================================================================
    // Conversion
    // ========================================================================

    /// Get the string data as a Str (returns a fresh heap copy).
    @allocates
    pub func as_str(this) -> Str {
        let data: *U8 = text_get_data(this.handle)
        let addr: I64 = data as I64
        if addr == 0 {
            return ""
        }
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 {
            return ""
        }
        let buf: *U8 = lowlevel { mem_alloc(slen + 1) } as *U8
        lowlevel { copy_nonoverlapping(data, buf, slen) }
        lowlevel { ptr_write[U8]((buf as I64 + slen) as *U8, 0 as U8) }
        return buf as Str
    }

    /// Clone this Text (deep copy)
    pub func clone(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        var cap: I64 = slen
        if cap < 8 { cap = 8 }
        let h: *Unit = text_alloc_with_cap(cap)
        if slen > 0 {
            let src: *U8 = text_get_data(this.handle)
            let dst: *U8 = text_get_data(h)
            text_copy_bytes(dst, 0, src, 0, slen)
            text_set_len(h, slen)
            text_set_byte(dst, slen, 0 as U8)
        }
        Text { handle: h }
    }

    /// Free the Text memory
    pub func drop(mut this) {
        let addr: I64 = this.handle as I64
        if addr == 0 {
            return
        }
        let data: *U8 = text_get_data(this.handle)
        let data_addr: I64 = data as I64
        if data_addr != 0 {
            lowlevel { mem_free(data as *Unit) }
        }
        lowlevel { mem_free(this.handle) }
        this.handle = null
    }

    // ========================================================================
    // Properties
    // ========================================================================

    /// Get the length in bytes
    pub func len(this) -> I64 {
        text_get_len(this.handle)
    }

    /// Get the current capacity
    pub func capacity(this) -> I64 {
        text_get_cap(this.handle)
    }

    /// Check if the Text is empty
    pub func is_empty(this) -> Bool {
        text_get_len(this.handle) == 0
    }

    /// Get byte at index (returns -1 if out of bounds)
    pub func byte_at(this, index: I64) -> I32 {
        let slen: I64 = text_get_len(this.handle)
        if index < 0 or index >= slen {
            return -1
        }
        let data: *U8 = text_get_data(this.handle)
        let b: U8 = text_byte_at_raw(data, index)
        b as I32
    }

    // ========================================================================
    // Modification (mutates this Text)
    // ========================================================================

    /// Clear the content
    pub func clear(this) {
        text_set_len(this.handle, 0)
        let data: *U8 = text_get_data(this.handle)
        let addr: I64 = data as I64
        if addr != 0 {
            text_set_byte(data, 0, 0 as U8)
        }
    }

    /// Push a single byte
    pub func push(this, byte: I32) {
        let cur_len: I64 = text_get_len(this.handle)
        text_ensure_cap(this.handle, cur_len + 1)
        let data: *U8 = text_get_data(this.handle)
        text_set_byte(data, cur_len, byte as U8)
        text_set_len(this.handle, cur_len + 1)
        text_set_byte(data, cur_len + 1, 0 as U8)
    }

    /// UNSAFE: Get raw data pointer
    pub func data_ptr(this) -> *U8 {
        text_get_data(this.handle)
    }

    /// UNSAFE: Set length directly without bounds checking
    pub func set_len(this, new_len: I64) {
        text_set_len(this.handle, new_len)
        let data: *U8 = text_get_data(this.handle)
        let addr: I64 = data as I64
        if addr != 0 {
            text_set_byte(data, new_len, 0 as U8)
        }
    }

    /// Append a string
    pub func push_str(this, s: Str) {
        text_push_str_raw(this.handle, s)
    }

    /// Append an integer directly
    pub func push_i64(this, value: I64) {
        text_i64_to_str_push(this.handle, value)
    }

    /// Append formatted: prefix + integer + suffix in one call
    pub func push_formatted(this, prefix: Str, value: I64, suffix: Str) {
        text_push_str_raw(this.handle, prefix)
        text_i64_to_str_push(this.handle, value)
        text_push_str_raw(this.handle, suffix)
    }

    /// Reserve additional capacity
    pub func reserve(this, additional: I64) {
        let cur_len: I64 = text_get_len(this.handle)
        text_ensure_cap(this.handle, cur_len + additional)
    }

    /// Fill with N copies of the same byte character (batch operation)
    pub func fill_char(this, byte: I32, count: I64) {
        if count <= 0 {
            return
        }
        let cur_len: I64 = text_get_len(this.handle)
        text_ensure_cap(this.handle, cur_len + count)
        let data: *U8 = text_get_data(this.handle)
        var i: I64 = 0
        loop (i < count) {
            text_set_byte(data, cur_len + i, byte as U8)
            i = i + 1
        }
        let new_len: I64 = cur_len + count
        text_set_len(this.handle, new_len)
        text_set_byte(data, new_len, 0 as U8)
    }

    /// Append log-style message: s1 + n1 + s2 + n2 + s3 + n3 + s4
    pub func push_log(this, s1: Str, n1: I64, s2: Str, n2: I64, s3: Str, n3: I64, s4: Str) {
        text_push_str_raw(this.handle, s1)
        text_i64_to_str_push(this.handle, n1)
        text_push_str_raw(this.handle, s2)
        text_i64_to_str_push(this.handle, n2)
        text_push_str_raw(this.handle, s3)
        text_i64_to_str_push(this.handle, n3)
        text_push_str_raw(this.handle, s4)
    }

    /// Append path-style pattern: s1 + n1 + s2 + n2 + s3
    pub func push_path(this, s1: Str, n1: I64, s2: Str, n2: I64, s3: Str) {
        text_push_str_raw(this.handle, s1)
        text_i64_to_str_push(this.handle, n1)
        text_push_str_raw(this.handle, s2)
        text_i64_to_str_push(this.handle, n2)
        text_push_str_raw(this.handle, s3)
    }

    // ========================================================================
    // Search Methods
    // ========================================================================

    /// Find the index of a substring (returns -1 if not found)
    pub func index_of(this, search: Str) -> I64 {
        let haystack_len: I64 = text_get_len(this.handle)
        let needle_len: I64 = text_str_len(search)
        if needle_len == 0 { return 0 }
        if needle_len > haystack_len { return -1 }
        let data: *U8 = text_get_data(this.handle)
        let needle_addr: I64 = search as I64
        var i: I64 = 0
        loop (i <= haystack_len - needle_len) {
            var matched: Bool = true
            var j: I64 = 0
            loop (j < needle_len) {
                let a: U8 = text_byte_at_raw(data, i + j)
                let bp: *U8 = (needle_addr + j) as *U8
                let b: U8 = lowlevel { ptr_read[U8](bp) }
                if a != b {
                    matched = false
                    j = needle_len // break
                } else {
                    j = j + 1
                }
            }
            if matched { return i }
            i = i + 1
        }
        -1
    }

    /// Find the last index of a substring (returns -1 if not found)
    pub func last_index_of(this, search: Str) -> I64 {
        let haystack_len: I64 = text_get_len(this.handle)
        let needle_len: I64 = text_str_len(search)
        if needle_len == 0 { return haystack_len }
        if needle_len > haystack_len { return -1 }
        let data: *U8 = text_get_data(this.handle)
        let needle_addr: I64 = search as I64
        var i: I64 = haystack_len - needle_len
        loop (i >= 0) {
            var matched: Bool = true
            var j: I64 = 0
            loop (j < needle_len) {
                let a: U8 = text_byte_at_raw(data, i + j)
                let bp: *U8 = (needle_addr + j) as *U8
                let b: U8 = lowlevel { ptr_read[U8](bp) }
                if a != b {
                    matched = false
                    j = needle_len
                } else {
                    j = j + 1
                }
            }
            if matched { return i }
            i = i - 1
        }
        -1
    }

    /// Check if this Text starts with the given prefix
    pub func starts_with(this, prefix: Str) -> Bool {
        let slen: I64 = text_get_len(this.handle)
        let plen: I64 = text_str_len(prefix)
        if plen > slen { return false }
        if plen == 0 { return true }
        let data: *U8 = text_get_data(this.handle)
        let prefix_addr: I64 = prefix as I64
        var i: I64 = 0
        loop (i < plen) {
            let a: U8 = text_byte_at_raw(data, i)
            let bp: *U8 = (prefix_addr + i) as *U8
            let b: U8 = lowlevel { ptr_read[U8](bp) }
            if a != b { return false }
            i = i + 1
        }
        true
    }

    /// Check if this Text ends with the given suffix
    pub func ends_with(this, suffix: Str) -> Bool {
        let slen: I64 = text_get_len(this.handle)
        let suflen: I64 = text_str_len(suffix)
        if suflen > slen { return false }
        if suflen == 0 { return true }
        let data: *U8 = text_get_data(this.handle)
        let suffix_addr: I64 = suffix as I64
        let start: I64 = slen - suflen
        var i: I64 = 0
        loop (i < suflen) {
            let a: U8 = text_byte_at_raw(data, start + i)
            let bp: *U8 = (suffix_addr + i) as *U8
            let b: U8 = lowlevel { ptr_read[U8](bp) }
            if a != b { return false }
            i = i + 1
        }
        true
    }

    /// Check if this Text contains a substring
    pub func includes(this, search: Str) -> Bool {
        this.index_of(search) >= 0
    }

    /// Alias for includes (JavaScript compatibility)
    pub func contains(this, search: Str) -> Bool {
        this.includes(search)
    }

    // ========================================================================
    // Transformation Methods (return new Text)
    // ========================================================================

    /// Convert to uppercase
    pub func to_upper_case(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        let result: *Unit = text_alloc_with_cap(slen)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        var i: I64 = 0
        loop (i < slen) {
            let b: U8 = text_byte_at_raw(src, i)
            let v: I32 = b as I32
            if v >= 97 and v <= 122 {
                text_set_byte(dst, i, (v - 32) as U8)
            } else {
                text_set_byte(dst, i, b)
            }
            i = i + 1
        }
        text_set_len(result, slen)
        text_set_byte(dst, slen, 0 as U8)
        Text { handle: result }
    }

    /// Convert to lowercase
    pub func to_lower_case(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        let result: *Unit = text_alloc_with_cap(slen)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        var i: I64 = 0
        loop (i < slen) {
            let b: U8 = text_byte_at_raw(src, i)
            let v: I32 = b as I32
            if v >= 65 and v <= 90 {
                text_set_byte(dst, i, (v + 32) as U8)
            } else {
                text_set_byte(dst, i, b)
            }
            i = i + 1
        }
        text_set_len(result, slen)
        text_set_byte(dst, slen, 0 as U8)
        Text { handle: result }
    }

    /// Remove whitespace from both ends
    pub func trim(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 { return Text::new() }
        let data: *U8 = text_get_data(this.handle)
        // Find start
        var start: I64 = 0
        loop (start < slen) {
            let b: U8 = text_byte_at_raw(data, start)
            if not text_is_ws(b) { start = slen } // break
            else { start = start + 1 }
        }
        // Fixup: if we broke out, start is slen, need to go back
        if start == slen {
            // Find actual start (re-scan)
            start = 0
            loop (start < slen and text_is_ws(text_byte_at_raw(data, start))) {
                start = start + 1
            }
        }
        if start >= slen { return Text::new() }
        // Find end
        var end: I64 = slen
        loop (end > start and text_is_ws(text_byte_at_raw(data, end - 1))) {
            end = end - 1
        }
        let new_len: I64 = end - start
        let result: *Unit = text_alloc_with_cap(new_len)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, data, start, new_len)
        text_set_len(result, new_len)
        text_set_byte(dst, new_len, 0 as U8)
        Text { handle: result }
    }

    /// Remove whitespace from the start
    pub func trim_start(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 { return Text::new() }
        let data: *U8 = text_get_data(this.handle)
        var start: I64 = 0
        loop (start < slen and text_is_ws(text_byte_at_raw(data, start))) {
            start = start + 1
        }
        let new_len: I64 = slen - start
        if new_len == 0 { return Text::new() }
        let result: *Unit = text_alloc_with_cap(new_len)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, data, start, new_len)
        text_set_len(result, new_len)
        text_set_byte(dst, new_len, 0 as U8)
        Text { handle: result }
    }

    /// Remove whitespace from the end
    pub func trim_end(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 { return Text::new() }
        let data: *U8 = text_get_data(this.handle)
        var end: I64 = slen
        loop (end > 0 and text_is_ws(text_byte_at_raw(data, end - 1))) {
            end = end - 1
        }
        if end == 0 { return Text::new() }
        let result: *Unit = text_alloc_with_cap(end)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, data, 0, end)
        text_set_len(result, end)
        text_set_byte(dst, end, 0 as U8)
        Text { handle: result }
    }

    /// Get a substring from start to end (exclusive)
    pub func substring(this, start: I64, end: I64) -> Text {
        let slen: I64 = text_get_len(this.handle)
        var s: I64 = start
        var e: I64 = end
        if s < 0 { s = 0 }
        if e > slen { e = slen }
        if s >= e { return Text::new() }
        let new_len: I64 = e - s
        let result: *Unit = text_alloc_with_cap(new_len)
        let data: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, data, s, new_len)
        text_set_len(result, new_len)
        text_set_byte(dst, new_len, 0 as U8)
        Text { handle: result }
    }

    /// Alias for substring (JavaScript compatibility)
    pub func slice(this, start: I64, end: I64) -> Text {
        this.substring(start, end)
    }

    /// Repeat this Text n times
    pub func repeat(this, count: I64) -> Text {
        if count <= 0 { return Text::new() }
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 { return Text::new() }
        let total: I64 = slen * count
        let result: *Unit = text_alloc_with_cap(total)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        var i: I64 = 0
        loop (i < count) {
            text_copy_bytes(dst, i * slen, src, 0, slen)
            i = i + 1
        }
        text_set_len(result, total)
        text_set_byte(dst, total, 0 as U8)
        Text { handle: result }
    }

    /// Replace first occurrence of search with replacement
    pub func replace(this, search: Str, replacement: Str) -> Text {
        let pos: I64 = this.index_of(search)
        if pos < 0 {
            return this.clone()
        }
        let slen: I64 = text_get_len(this.handle)
        let search_len: I64 = text_str_len(search)
        let repl_len: I64 = text_str_len(replacement)
        let new_len: I64 = slen - search_len + repl_len
        let result: *Unit = text_alloc_with_cap(new_len)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        // Copy before match
        text_copy_bytes(dst, 0, src, 0, pos)
        // Copy replacement
        let repl_addr: I64 = replacement as I64
        var i: I64 = 0
        loop (i < repl_len) {
            let rp: *U8 = (repl_addr + i) as *U8
            let b: U8 = lowlevel { ptr_read[U8](rp) }
            text_set_byte(dst, pos + i, b)
            i = i + 1
        }
        // Copy after match
        let after: I64 = pos + search_len
        let remaining: I64 = slen - after
        text_copy_bytes(dst, pos + repl_len, src, after, remaining)
        text_set_len(result, new_len)
        text_set_byte(dst, new_len, 0 as U8)
        Text { handle: result }
    }

    /// Replace all occurrences of search with replacement
    pub func replace_all(this, search: Str, replacement: Str) -> Text {
        let search_len: I64 = text_str_len(search)
        if search_len == 0 { return this.clone() }
        let slen: I64 = text_get_len(this.handle)
        let repl_len: I64 = text_str_len(replacement)
        let result: *Unit = text_alloc_with_cap(slen)
        let src: *U8 = text_get_data(this.handle)
        let needle_addr: I64 = search as I64
        let repl_addr: I64 = replacement as I64
        var i: I64 = 0
        loop (i < slen) {
            // Check if search matches at position i
            var matched: Bool = true
            if i + search_len <= slen {
                var j: I64 = 0
                loop (j < search_len) {
                    let a: U8 = text_byte_at_raw(src, i + j)
                    let bp: *U8 = (needle_addr + j) as *U8
                    let b: U8 = lowlevel { ptr_read[U8](bp) }
                    if a != b {
                        matched = false
                        j = search_len
                    } else {
                        j = j + 1
                    }
                }
            } else {
                matched = false
            }
            if matched {
                // Push replacement
                var k: I64 = 0
                loop (k < repl_len) {
                    let rp: *U8 = (repl_addr + k) as *U8
                    let b: U8 = lowlevel { ptr_read[U8](rp) }
                    let cur_len: I64 = text_get_len(result)
                    text_ensure_cap(result, cur_len + 1)
                    let dst: *U8 = text_get_data(result)
                    text_set_byte(dst, cur_len, b)
                    text_set_len(result, cur_len + 1)
                    k = k + 1
                }
                i = i + search_len
            } else {
                let cur_len: I64 = text_get_len(result)
                text_ensure_cap(result, cur_len + 1)
                let dst: *U8 = text_get_data(result)
                let b: U8 = text_byte_at_raw(src, i)
                text_set_byte(dst, cur_len, b)
                text_set_len(result, cur_len + 1)
                i = i + 1
            }
        }
        // Null-terminate
        let final_len: I64 = text_get_len(result)
        let dst: *U8 = text_get_data(result)
        text_set_byte(dst, final_len, 0 as U8)
        Text { handle: result }
    }

    /// Reverse the string
    pub func reverse(this) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen == 0 { return Text::new() }
        let result: *Unit = text_alloc_with_cap(slen)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        var i: I64 = 0
        loop (i < slen) {
            let b: U8 = text_byte_at_raw(src, slen - 1 - i)
            text_set_byte(dst, i, b)
            i = i + 1
        }
        text_set_len(result, slen)
        text_set_byte(dst, slen, 0 as U8)
        Text { handle: result }
    }

    /// Pad the start to reach target length
    pub func pad_start(this, target_len: I64, pad_char: I32) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen >= target_len { return this.clone() }
        let pad_count: I64 = target_len - slen
        let result: *Unit = text_alloc_with_cap(target_len)
        let dst: *U8 = text_get_data(result)
        // Fill pad chars
        var i: I64 = 0
        loop (i < pad_count) {
            text_set_byte(dst, i, pad_char as U8)
            i = i + 1
        }
        // Copy original
        let src: *U8 = text_get_data(this.handle)
        text_copy_bytes(dst, pad_count, src, 0, slen)
        text_set_len(result, target_len)
        text_set_byte(dst, target_len, 0 as U8)
        Text { handle: result }
    }

    /// Pad the end to reach target length
    pub func pad_end(this, target_len: I64, pad_char: I32) -> Text {
        let slen: I64 = text_get_len(this.handle)
        if slen >= target_len { return this.clone() }
        let pad_count: I64 = target_len - slen
        let result: *Unit = text_alloc_with_cap(target_len)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        // Copy original
        text_copy_bytes(dst, 0, src, 0, slen)
        // Fill pad chars
        var i: I64 = 0
        loop (i < pad_count) {
            text_set_byte(dst, slen + i, pad_char as U8)
            i = i + 1
        }
        text_set_len(result, target_len)
        text_set_byte(dst, target_len, 0 as U8)
        Text { handle: result }
    }

    // ========================================================================
    // Concatenation
    // ========================================================================

    /// Concatenate with another Text
    pub func concat(this, other: ref Text) -> Text {
        let slen1: I64 = text_get_len(this.handle)
        let slen2: I64 = text_get_len(other.handle)
        let total: I64 = slen1 + slen2
        let result: *Unit = text_alloc_with_cap(total)
        let src1: *U8 = text_get_data(this.handle)
        let src2: *U8 = text_get_data(other.handle)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, src1, 0, slen1)
        text_copy_bytes(dst, slen1, src2, 0, slen2)
        text_set_len(result, total)
        text_set_byte(dst, total, 0 as U8)
        Text { handle: result }
    }

    /// Concatenate with a string
    pub func concat_str(this, s: Str) -> Text {
        let slen1: I64 = text_get_len(this.handle)
        let slen2: I64 = text_str_len(s)
        let total: I64 = slen1 + slen2
        let result: *Unit = text_alloc_with_cap(total)
        let src: *U8 = text_get_data(this.handle)
        let dst: *U8 = text_get_data(result)
        text_copy_bytes(dst, 0, src, 0, slen1)
        text_copy_str_at(dst, slen1, s, slen2)
        text_set_len(result, total)
        text_set_byte(dst, total, 0 as U8)
        Text { handle: result }
    }

    // ========================================================================
    // Comparison
    // ========================================================================

    /// Compare with another Text (-1, 0, or 1)
    pub func compare(this, other: ref Text) -> I32 {
        let len1: I64 = text_get_len(this.handle)
        let len2: I64 = text_get_len(other.handle)
        let data1: *U8 = text_get_data(this.handle)
        let data2: *U8 = text_get_data(other.handle)
        var min_len: I64 = len1
        if len2 < len1 { min_len = len2 }
        var i: I64 = 0
        loop (i < min_len) {
            let a: U8 = text_byte_at_raw(data1, i)
            let b: U8 = text_byte_at_raw(data2, i)
            if (a as I32) < (b as I32) { return -1 }
            if (a as I32) > (b as I32) { return 1 }
            i = i + 1
        }
        if len1 < len2 { return -1 }
        if len1 > len2 { return 1 }
        0
    }

    /// Check equality with another Text
    pub func equals(this, other: ref Text) -> Bool {
        let len1: I64 = text_get_len(this.handle)
        let len2: I64 = text_get_len(other.handle)
        if len1 != len2 { return false }
        let data1: *U8 = text_get_data(this.handle)
        let data2: *U8 = text_get_data(other.handle)
        var i: I64 = 0
        loop (i < len1) {
            let a: U8 = text_byte_at_raw(data1, i)
            let b: U8 = text_byte_at_raw(data2, i)
            if a != b { return false }
            i = i + 1
        }
        true
    }

    // ========================================================================
    // Output
    // ========================================================================

    /// Print the Text to stdout (no newline)
    pub func print(this) {
        let s: Str = this.as_str()
        lowlevel { print_str(s) }
    }

    /// Print the Text to stdout with a newline
    pub func println(this) {
        let s: Str = this.as_str()
        lowlevel { println_str(s) }
    }
}
