//! Iterator behaviors and types for TML.
//!
//! This module provides the core iteration infrastructure, including
//! the `Iterator` behavior and the `Range` type.
//!
//! # Main Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Iterator`] | Core iteration behavior |
//! | [`IntoIterator`] | Conversion to iterator |
//! | [`Range`] | Integer range iterator |
//!
//! # Example
//!
//! ```tml
//! use std::iter::*
//!
//! // Iterate over a range
//! let mut sum: I32 = 0
//! let r = range(1, 10)
//! loop {
//!     when r.next() {
//!         Just(n) => sum = sum + n,
//!         Nothing => break
//!     }
//! }
//! ```

/// Optional value type for iterator results.
pub type Maybe[T] {
    /// Contains a value.
    Just(T),
    /// Contains no value.
    Nothing
}

/// The core iteration behavior.
///
/// Types implementing `Iterator` can be used in loops and
/// with iterator combinators like `map`, `filter`, etc.
pub behavior Iterator {
    /// The type of elements being iterated.
    type Item

    /// Advances the iterator and returns the next value.
    ///
    /// Returns `Nothing` when iteration is complete.
    func next(mut this) -> Maybe[This::Item]
}

/// Behavior for types that can be converted into an iterator.
pub behavior IntoIterator {
    /// The type of iterator this converts into.
    type Iter

    /// Converts this value into an iterator.
    func into_iter(this) -> This::Iter
}

/// An iterator over a range of integers.
///
/// Created with [`range`], [`range_inclusive`], or [`range_step`].
///
/// # Example
///
/// ```tml
/// let r = range(0, 5)  // 0, 1, 2, 3, 4
/// let r = range_inclusive(0, 5)  // 0, 1, 2, 3, 4, 5
/// ```
pub type Range {
    current: I32,
    end: I32,
    step: I32,
    inclusive: Bool
}

impl Iterator for Range {
    type Item = I32

    pub func next(mut this) -> Maybe[I32] {
        if this.inclusive {
            if this.current <= this.end {
                let value: I32 = this.current
                this.current = this.current + this.step
                return Just(value)
            } else {
                return Nothing
            }
        } else {
            if this.current < this.end {
                let value: I32 = this.current
                this.current = this.current + this.step
                return Just(value)
            } else {
                return Nothing
            }
        }
    }
}

/// Creates a range from start to end (exclusive)
pub func range(start: I32, end: I32) -> Range {
    return Range { current: start, end: end, step: 1, inclusive: false }
}

/// Creates a range from start through end (inclusive)
pub func range_inclusive(start: I32, end: I32) -> Range {
    return Range { current: start, end: end, step: 1, inclusive: true }
}

/// Creates a range with custom step
pub func range_step(start: I32, end: I32, step: I32) -> Range {
    return Range { current: start, end: end, step: step, inclusive: false }
}

impl Range {
    /// Takes the first n elements from the iterator.
    /// Returns a new Range limited to n elements.
    pub func take(this, n: I32) -> Range {
        let actual_end: I32 = this.current + (n * this.step)
        let capped_end: I32 = if actual_end < this.end then actual_end else this.end
        return Range {
            current: this.current,
            end: capped_end,
            step: this.step,
            inclusive: false
        }
    }

    /// Skips the first n elements from the iterator.
    /// Returns a new Range starting n elements ahead.
    pub func skip(this, n: I32) -> Range {
        let new_current: I32 = this.current + (n * this.step)
        return Range {
            current: new_current,
            end: this.end,
            step: this.step,
            inclusive: this.inclusive
        }
    }

    /// Sums all elements in the iterator.
    pub func sum(mut this) -> I32 {
        let mut total: I32 = 0
        loop {
            when this.next() {
                Just(value) => total = total + value,
                Nothing => break
            }
        }
        return total
    }

    /// Counts the number of elements in the iterator.
    pub func count(mut this) -> I32 {
        let mut n: I32 = 0
        loop {
            when this.next() {
                Just(_) => n = n + 1,
                Nothing => break
            }
        }
        return n
    }

    /// Folds (reduces) the iterator using an accumulator function.
    /// Takes an initial value and a closure that combines the accumulator with each element.
    pub func fold(mut this, init: I32, f: func(I32, I32) -> I32) -> I32 {
        let mut acc: I32 = init
        loop {
            when this.next() {
                Just(value) => acc = f(acc, value),
                Nothing => break
            }
        }
        return acc
    }

    /// Tests if any element satisfies the predicate.
    /// Returns true if at least one element matches, false otherwise.
    pub func any(mut this, predicate: func(I32) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(value) => {
                    if predicate(value) {
                        return true
                    }
                },
                Nothing => break
            }
        }
        return false
    }

    /// Tests if all elements satisfy the predicate.
    /// Returns true only if all elements match, false otherwise.
    pub func all(mut this, predicate: func(I32) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(value) => {
                    if not predicate(value) {
                        return false
                    }
                },
                Nothing => break
            }
        }
        return true
    }
}
