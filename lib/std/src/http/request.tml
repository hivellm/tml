//! HTTP request builder and serializer.
//!
//! Constructs HTTP/1.1 requests with method, URL, headers, body, and
//! query parameters. Supports builder-pattern construction and
//! serialization to wire format.

use core::str
use core::fmt::helpers::i64_to_str
use std::url::Url
use std::http::method::Method
use std::http::headers::Headers
use std::http::version::HttpVersion
use std::http::error::{HttpError, HttpErrorKind}

/// An HTTP request with method, URL, headers, and body.
///
/// URL components are stored as I64 (escaped from @allocates tracking)
/// to work around a compiler bug where Str fields inside structs extracted
/// from enum variants (Maybe[Url], Outcome[Url, Str]) get freed prematurely.
pub type Request {
    req_method: Method,
    req_url: Str,
    // Parsed URL components stored as I64 to escape @allocates cleanup.
    // 0 means "not parsed" (invalid URL).
    url_scheme: I64,
    url_host: I64,
    url_port: I64,
    url_path: I64,
    url_query: I64,
    req_headers: Headers,
    req_body: Str,
    req_version: HttpVersion,
    timeout_ms: I64,
}

impl Request {
    /// Creates a new request with the given method and URL.
    pub func new(method: Method, url: Str) -> Request {
        var scheme_i64: I64 = 0
        var host_i64: I64 = 0
        var port_val: I64 = -1
        var path_i64: I64 = 0
        var query_i64: I64 = 0

        let parsed = Url::parse(url)
        when parsed {
            Ok(u) => {
                // Extract components as I64 to escape @allocates tracking.
                // The Url's string fields will be freed by the compiler when
                // the Outcome goes out of scope, so we must copy them.
                let s: Str = u.get_scheme()
                let s_len: I64 = str::len(s)
                if s_len > 0 {
                    scheme_i64 = str::substring(s, 0, s_len) as I64
                }
                let h: Str = u.get_host()
                let h_len: I64 = str::len(h)
                if h_len > 0 {
                    host_i64 = str::substring(h, 0, h_len) as I64
                }
                port_val = u.get_port()
                let p: Str = u.get_path()
                let p_len: I64 = str::len(p)
                if p_len > 0 {
                    path_i64 = str::substring(p, 0, p_len) as I64
                }
                let q: Str = u.get_query()
                let q_len: I64 = str::len(q)
                if q_len > 0 {
                    query_i64 = str::substring(q, 0, q_len) as I64
                }
            },
            Err(e) => {},
        }
        Request {
            req_method: method,
            req_url: url,
            url_scheme: scheme_i64,
            url_host: host_i64,
            url_port: port_val,
            url_path: path_i64,
            url_query: query_i64,
            req_headers: Headers::new(),
            req_body: "",
            req_version: HttpVersion::HTTP_1_1,
            timeout_ms: 0,
        }
    }

    // ── Convenience constructors ────────────────────────────

    /// Creates a GET request.
    pub func get(url: Str) -> Request { Request::new(Method::GET, url) }

    /// Creates a POST request.
    pub func post(url: Str) -> Request { Request::new(Method::POST, url) }

    /// Creates a PUT request.
    pub func put(url: Str) -> Request { Request::new(Method::PUT, url) }

    /// Creates a DELETE request.
    pub func delete(url: Str) -> Request { Request::new(Method::DELETE, url) }

    /// Creates a PATCH request.
    pub func patch(url: Str) -> Request { Request::new(Method::PATCH, url) }

    /// Creates a HEAD request.
    pub func head(url: Str) -> Request { Request::new(Method::HEAD, url) }

    /// Creates an OPTIONS request.
    pub func options(url: Str) -> Request { Request::new(Method::OPTIONS, url) }

    // ── Builder methods (return self for chaining) ──────────

    /// Sets a request header. Returns self for chaining.
    pub func header(this, key: Str, value: Str) -> Request {
        this.req_headers.set(key, value)
        return this
    }

    /// Sets the request body. Also auto-sets Content-Length.
    pub func body(this, data: Str) -> Request {
        let len: I64 = str::len(data)
        if len > 0 {
            this.req_headers.set("content-length", i64_to_str(len))
        }
        Request {
            req_method: this.req_method,
            req_url: this.req_url,
            url_scheme: this.url_scheme,
            url_host: this.url_host,
            url_port: this.url_port,
            url_path: this.url_path,
            url_query: this.url_query,
            req_headers: this.req_headers,
            req_body: data,
            req_version: this.req_version,
            timeout_ms: this.timeout_ms,
        }
    }

    /// Sets the request body as JSON (auto-sets Content-Type and Content-Length).
    pub func json(this, data: Str) -> Request {
        this.req_headers.set("content-type", "application/json")
        return this.body(data)
    }

    /// Sets the request body as form data (auto-sets Content-Type and Content-Length).
    pub func form(this, data: Str) -> Request {
        this.req_headers.set("content-type", "application/x-www-form-urlencoded")
        return this.body(data)
    }

    /// Sets the HTTP version.
    pub func version(this, v: HttpVersion) -> Request {
        Request {
            req_method: this.req_method,
            req_url: this.req_url,
            url_scheme: this.url_scheme,
            url_host: this.url_host,
            url_port: this.url_port,
            url_path: this.url_path,
            url_query: this.url_query,
            req_headers: this.req_headers,
            req_body: this.req_body,
            req_version: v,
            timeout_ms: this.timeout_ms,
        }
    }

    /// Sets the request timeout in milliseconds.
    pub func timeout(this, ms: I64) -> Request {
        Request {
            req_method: this.req_method,
            req_url: this.req_url,
            url_scheme: this.url_scheme,
            url_host: this.url_host,
            url_port: this.url_port,
            url_path: this.url_path,
            url_query: this.url_query,
            req_headers: this.req_headers,
            req_body: this.req_body,
            req_version: this.req_version,
            timeout_ms: ms,
        }
    }

    // ── Accessors ───────────────────────────────────────────

    /// Returns the HTTP method.
    pub func method(this) -> Method { this.req_method }

    /// Returns the full URL string.
    pub func url(this) -> Str { this.req_url }

    /// Returns the request headers.
    pub func headers(this) -> ref Headers { return ref this.req_headers }

    /// Returns the request body string.
    pub func body_data(this) -> Str { this.req_body }

    /// Returns the HTTP version.
    pub func http_version(this) -> HttpVersion { this.req_version }

    /// Returns the timeout in milliseconds (0 = no timeout).
    pub func get_timeout(this) -> I64 { this.timeout_ms }

    /// Returns true if the method typically carries a body.
    pub func has_body(this) -> Bool { this.req_method.has_body() }

    /// Returns true if the method is idempotent.
    pub func is_idempotent(this) -> Bool { this.req_method.is_idempotent() }

    /// Returns true if the method is safe (no side effects).
    pub func is_safe(this) -> Bool { this.req_method.is_safe() }

    /// Returns true if the URL scheme is HTTPS.
    pub func is_secure(this) -> Bool {
        if this.url_scheme == 0 { return false }
        return (this.url_scheme as Str) == "https"
    }

    /// Returns the URL scheme ("http" or "https").
    /// Returns a copy — the compiler frees Str values used in string interpolation.
    @allocates
    pub func scheme(this) -> Str {
        if this.url_scheme == 0 { return "" }
        let s: Str = this.url_scheme as Str
        return str::substring(s, 0, str::len(s))
    }

    /// Returns the host from the URL.
    /// Returns a copy — the compiler frees Str values used in string interpolation.
    @allocates
    pub func host(this) -> Str {
        if this.url_host == 0 { return "" }
        let s: Str = this.url_host as Str
        return str::substring(s, 0, str::len(s))
    }

    /// Returns the port from the URL (-1 if not specified).
    pub func port(this) -> I64 { this.url_port }

    /// Returns the path from the URL (e.g. "/api/users").
    /// Returns a copy — the compiler frees Str values used in string interpolation.
    @allocates
    pub func path(this) -> Str {
        if this.url_path == 0 { return "/" }
        let s: Str = this.url_path as Str
        return str::substring(s, 0, str::len(s))
    }

    /// Returns the query string from the URL (without leading "?").
    /// Returns a copy — the compiler frees Str values used in string interpolation.
    @allocates
    pub func query(this) -> Str {
        if this.url_query == 0 { return "" }
        let s: Str = this.url_query as Str
        return str::substring(s, 0, str::len(s))
    }

    /// Returns path + query string for the request line.
    pub func path_and_query(this) -> Str {
        let p: Str = this.path()
        let q: Str = this.query()
        if str::len(q) > 0 {
            return "{p}?{q}"
        }
        return p
    }

    /// Returns the effective host with port for the Host header.
    /// Omits the port if it's the default for the scheme.
    pub func host_header(this) -> Str {
        let h: Str = this.host()
        let p: I64 = this.url_port
        if p <= 0 or (p == 80 and this.scheme() == "http") or (p == 443 and this.scheme() == "https") {
            return h
        }
        return "{h}:{i64_to_str(p)}"
    }

    /// Returns the Content-Type header value, or "".
    pub func content_type(this) -> Str {
        return this.req_headers.content_type()
    }

    /// Returns the Content-Length as I64, or -1 if not set.
    pub func content_length(this) -> I64 {
        return this.req_headers.content_length()
    }

    // ── Serialization ───────────────────────────────────────

    /// Serializes the request to HTTP/1.1 wire format.
    pub func serialize(this) -> Str {
        let method_str: Str = this.req_method.to_string()
        let path_query: Str = this.path_and_query()
        let version_str: Str = this.req_version.to_string()

        // Request line
        var result: Str = "{method_str} {path_query} {version_str}\r\n"

        // Host header (mandatory in HTTP/1.1)
        if not this.req_headers.has("host") {
            let host_val: Str = this.host_header()
            result = "{result}Host: {host_val}\r\n"
        }

        // User-Agent (default if not set)
        if not this.req_headers.has("user-agent") {
            result = "{result}User-Agent: tml/1.0\r\n"
        }

        // Content-Length for body (if not already set)
        let body_len: I64 = str::len(this.req_body)
        if body_len > 0 and not this.req_headers.has("content-length") {
            result = "{result}Content-Length: {i64_to_str(body_len)}\r\n"
        }

        // All custom headers
        result = "{result}{this.req_headers.serialize()}"

        // Empty line separating headers from body
        result = "{result}\r\n"

        // Body
        if body_len > 0 {
            result = "{result}{this.req_body}"
        }

        return result
    }

    /// Frees internal storage.
    pub func destroy(this) {
        this.req_headers.destroy()
    }
}
