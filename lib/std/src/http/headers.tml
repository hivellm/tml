//! HTTP header map with case-insensitive keys.
//!
//! Keys are stored lowercase internally in linear arrays.
//! Uses string content comparison (not pointer equality).
//! Multi-value headers use comma-separated format per RFC 7230.

use core::str
use core::intrinsics::{ptr_read, ptr_write, mem_alloc, mem_free, copy_nonoverlapping}

/// A collection of HTTP headers with case-insensitive key lookup.
///
/// Stores headers in parallel arrays (keys[], values[]) with linear scan.
/// HTTP messages typically have <30 headers, so linear scan is efficient
/// and avoids HashMap's pointer-equality limitation for Str keys.
pub type Headers {
    handle: *Unit
}

// Internal layout at handle:
//   offset 0:  keys pointer (*Str array) — 8 bytes
//   offset 8:  values pointer (array of {ptr: I64, len: I64} pairs) — 8 bytes
//   offset 16: len (I64) — 8 bytes
//   offset 24: cap (I64) — 8 bytes
// Total header: 32 bytes
//
// Note: values array stores {pointer, length} pairs (16 bytes per entry)
// Keys are stored as Str directly in the keys array (8 bytes per entry)

impl Headers {
    /// Creates an empty header map.
    pub func new() -> Headers {
        let cap: I64 = 16
        let hdr: I64 = lowlevel { mem_alloc(32) } as I64
        let keys: I64 = lowlevel { mem_alloc(cap * 8) } as I64
        let vals: I64 = lowlevel { mem_alloc(cap * 16) } as I64  // 16 bytes per entry (ptr + len)
        lowlevel { ptr_write[I64](hdr as *I64, keys) }
        lowlevel { ptr_write[I64]((hdr + 8) as *I64, vals) }
        lowlevel { ptr_write[I64]((hdr + 16) as *I64, 0 as I64) }
        lowlevel { ptr_write[I64]((hdr + 24) as *I64, cap) }
        Headers { handle: hdr as *Unit }
    }

    /// Sets a header value, replacing any existing value for that key.
    pub func set(this, key: Str, value: Str) {
        // Cast to I64 immediately to prevent @allocates cleanup from freeing
        // the lowercased key when this function returns. We own this memory
        // and store it in the keys array — it will be freed in destroy().
        let lower_i64: I64 = str::to_lowercase(key) as I64
        let lower: Str = lower_i64 as Str

        // Allocate copy of value since input is temporary and will be freed
        let val_len: I64 = value.len() as I64
        let val_copy: I64 = lowlevel { mem_alloc(val_len) } as I64
        lowlevel { copy_nonoverlapping(value as *Unit, val_copy as *Unit, val_len) }

        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        // Check if key already exists (linear scan with string comparison)
        var i: I64 = 0
        loop (i < cur_len) {
            let existing_key: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            if existing_key == lower {
                // Overwrite value — free the duplicate key since we don't need it
                lowlevel { mem_free(lower_i64 as *Unit) }
                // Free old value pointer and store new one with length
                let old_val_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
                if old_val_ptr != 0 {
                    lowlevel { mem_free(old_val_ptr as *Unit) }
                }
                lowlevel { ptr_write[I64]((vals_addr + i * 16) as *I64, val_copy) }
                lowlevel { ptr_write[I64]((vals_addr + i * 16 + 8) as *I64, val_len) }
                return
            }
            i = i + 1
        }

        // Key not found — append
        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        if cur_len == cur_cap {
            // Grow arrays 2x
            let new_cap: I64 = cur_cap * 2
            let new_keys: I64 = lowlevel { mem_alloc(new_cap * 8) } as I64
            let new_vals: I64 = lowlevel { mem_alloc(new_cap * 16) } as I64  // 16 bytes per entry
            lowlevel { copy_nonoverlapping(keys_addr as *Unit, new_keys as *Unit, cur_cap * 8) }
            lowlevel { copy_nonoverlapping(vals_addr as *Unit, new_vals as *Unit, cur_cap * 16) }
            lowlevel { mem_free(keys_addr as *Unit) }
            lowlevel { mem_free(vals_addr as *Unit) }
            lowlevel { ptr_write[I64](hdr as *I64, new_keys) }
            lowlevel { ptr_write[I64]((hdr + 8) as *I64, new_vals) }
            lowlevel { ptr_write[I64]((hdr + 24) as *I64, new_cap) }

            lowlevel { ptr_write[I64]((new_keys + cur_len * 8) as *I64, lower_i64) }
            lowlevel { ptr_write[I64]((new_vals + cur_len * 16) as *I64, val_copy) }
            lowlevel { ptr_write[I64]((new_vals + cur_len * 16 + 8) as *I64, val_len) }
        } else {
            lowlevel { ptr_write[I64]((keys_addr + cur_len * 8) as *I64, lower_i64) }
            lowlevel { ptr_write[I64]((vals_addr + cur_len * 16) as *I64, val_copy) }
            lowlevel { ptr_write[I64]((vals_addr + cur_len * 16 + 8) as *I64, val_len) }
        }
        lowlevel { ptr_write[I64]((hdr + 16) as *I64, cur_len + 1) }
    }

    /// Gets the value for a header key, or "" if not present.
    pub func get(this, key: Str) -> Str {
        let lower: Str = str::to_lowercase(key)
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        var i: I64 = 0
        loop (i < cur_len) {
            let existing_key: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            if existing_key == lower {
                // Read pointer and length from value pair
                let val_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
                let val_len: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16 + 8) as *I64) }
                // Reconstruct Str from pointer and length
                return lowlevel { ptr_read[Str](val_ptr as *Str) }
            }
            i = i + 1
        }
        return ""
    }

    /// Returns true if the header exists.
    pub func has(this, key: Str) -> Bool {
        let lower: Str = str::to_lowercase(key)
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        var i: I64 = 0
        loop (i < cur_len) {
            let existing_key: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            if existing_key == lower {
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Removes a header by key.
    pub func remove(this, key: Str) {
        let lower: Str = str::to_lowercase(key)
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        var i: I64 = 0
        loop (i < cur_len) {
            let existing_key: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            if existing_key == lower {
                // Free the value pointer
                let val_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
                if val_ptr != 0 {
                    lowlevel { mem_free(val_ptr as *Unit) }
                }
                // Free the key
                let key_i64: I64 = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) }
                if key_i64 != 0 {
                    lowlevel { mem_free(key_i64 as *Unit) }
                }

                // Swap with last element
                let last: I64 = cur_len - 1
                if i != last {
                    let last_key: I64 = lowlevel { ptr_read[I64]((keys_addr + last * 8) as *I64) }
                    let last_val_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + last * 16) as *I64) }
                    let last_val_len: I64 = lowlevel { ptr_read[I64]((vals_addr + last * 16 + 8) as *I64) }
                    lowlevel { ptr_write[I64]((keys_addr + i * 8) as *I64, last_key) }
                    lowlevel { ptr_write[I64]((vals_addr + i * 16) as *I64, last_val_ptr) }
                    lowlevel { ptr_write[I64]((vals_addr + i * 16 + 8) as *I64, last_val_len) }
                }
                lowlevel { ptr_write[I64]((hdr + 16) as *I64, last) }
                return
            }
            i = i + 1
        }
    }

    /// Appends a value to an existing header, comma-separated per RFC 7230.
    /// If the header doesn't exist yet, behaves like set().
    pub func append(this, key: Str, value: Str) {
        let lower: Str = str::to_lowercase(key)
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        var i: I64 = 0
        loop (i < cur_len) {
            let existing_key: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            if existing_key == lower {
                // Read existing value
                let existing_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
                let existing_len: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16 + 8) as *I64) }
                let existing: Str = lowlevel { ptr_read[Str](existing_ptr as *Str) }

                // Create new appended value
                let appended: Str = "{existing}, {value}"
                let appended_len: I64 = appended.len() as I64
                let appended_copy: I64 = lowlevel { mem_alloc(appended_len) } as I64
                lowlevel { copy_nonoverlapping(appended as *Unit, appended_copy as *Unit, appended_len) }

                // Free old value
                if existing_ptr != 0 {
                    lowlevel { mem_free(existing_ptr as *Unit) }
                }

                // Store new value
                lowlevel { ptr_write[I64]((vals_addr + i * 16) as *I64, appended_copy) }
                lowlevel { ptr_write[I64]((vals_addr + i * 16 + 8) as *I64, appended_len) }
                return
            }
            i = i + 1
        }
        // Not found — set it
        this.set(lower, value)
    }

    /// Serializes all headers to HTTP/1.1 wire format.
    /// Each header becomes "Key: Value\r\n".
    pub func serialize(this) -> Str {
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        var result: Str = ""
        var i: I64 = 0
        loop (i < cur_len) {
            let k: Str = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) } as Str
            let v_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
            let v: Str = lowlevel { ptr_read[Str](v_ptr as *Str) }
            result = "{result}{k}: {v}\r\n"
            i = i + 1
        }
        return result
    }

    // ── Convenience accessors ───────────────────────────────

    /// Returns the Content-Length as I64, or -1 if not set or invalid.
    pub func content_length(this) -> I64 {
        let val: Str = this.get("content-length")
        if str::len(val) == 0 {
            return -1 as I64
        }
        let parsed: Maybe[I64] = str::parse_i64(val)
        when parsed {
            Just(n) => return n,
            Nothing => return -1 as I64,
        }
    }

    /// Returns the Content-Type header value, or "".
    pub func content_type(this) -> Str {
        return this.get("content-type")
    }

    /// Returns the Content-Encoding header value, or "".
    pub func content_encoding(this) -> Str {
        return this.get("content-encoding")
    }

    /// Returns the Transfer-Encoding header value, or "".
    pub func transfer_encoding(this) -> Str {
        return this.get("transfer-encoding")
    }

    /// Returns true if Transfer-Encoding contains "chunked".
    pub func is_chunked(this) -> Bool {
        let te: Str = this.get("transfer-encoding")
        return str::contains(te, "chunked")
    }

    /// Returns the Host header value, or "".
    pub func host(this) -> Str {
        return this.get("host")
    }

    /// Returns the Connection header value, or "".
    pub func connection(this) -> Str {
        return this.get("connection")
    }

    /// Returns true if Connection: keep-alive.
    pub func is_keep_alive(this) -> Bool {
        let conn: Str = this.get("connection")
        return str::contains(str::to_lowercase(conn), "keep-alive")
    }

    /// Returns true if Connection: close.
    pub func is_close(this) -> Bool {
        let conn: Str = this.get("connection")
        return str::contains(str::to_lowercase(conn), "close")
    }

    /// Returns the Accept header value, or "".
    pub func accept(this) -> Str {
        return this.get("accept")
    }

    /// Returns the Accept-Encoding header value, or "".
    pub func accept_encoding(this) -> Str {
        return this.get("accept-encoding")
    }

    /// Returns the Authorization header value, or "".
    pub func authorization(this) -> Str {
        return this.get("authorization")
    }

    /// Returns the Location header value, or "".
    pub func location(this) -> Str {
        return this.get("location")
    }

    /// Returns the number of headers.
    pub func len(this) -> I64 {
        let hdr: I64 = this.handle as I64
        return lowlevel { ptr_read[I64]((hdr + 16) as *I64) }
    }

    /// Returns true if no headers are set.
    pub func is_empty(this) -> Bool {
        return this.len() == 0
    }

    /// Frees internal storage.
    pub func destroy(this) {
        let hdr: I64 = this.handle as I64
        let keys_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let vals_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }

        // Free individual key and value strings
        var i: I64 = 0
        loop (i < cur_len) {
            let key_i64: I64 = lowlevel { ptr_read[I64]((keys_addr + i * 8) as *I64) }
            let val_ptr: I64 = lowlevel { ptr_read[I64]((vals_addr + i * 16) as *I64) }
            if key_i64 != 0 {
                lowlevel { mem_free(key_i64 as *Unit) }
            }
            if val_ptr != 0 {
                lowlevel { mem_free(val_ptr as *Unit) }
            }
            i = i + 1
        }

        if keys_addr != 0 {
            lowlevel { mem_free(keys_addr as *Unit) }
        }
        if vals_addr != 0 {
            lowlevel { mem_free(vals_addr as *Unit) }
        }
        lowlevel { mem_free(hdr as *Unit) }
    }
}
