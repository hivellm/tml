//! HTTP connection layer.
//!
//! Handles DNS resolution, TCP connection, and optional TLS handshake.
//! Provides write_str/read over plain or encrypted streams.

use core::str
use core::intrinsics::ptr_read
use std::net::dns
use std::net::ip::Ipv4Addr
use std::net::{SocketAddr, SocketAddrV4}
use std::net::tcp::TcpStream
use std::net::tls::{TlsContext, TlsStream, TlsVerifyMode}
use std::net::sys::RawSocket
use std::http::error::{HttpError, HttpErrorKind}

// Direct FFI for TLS I/O â€” use tml_ prefix (C runtime naming convention)
@extern("c")
func tml_tls_stream_write_str(ssl: *Unit, s: Str, len: I64) -> I64

@extern("c")
func tml_tls_stream_shutdown(ssl: *Unit) -> I32

@extern("c")
func tml_tls_stream_read(ssl: *Unit, buf: *Unit, len: I64) -> I64

/// TLS/connection metadata.
pub type ConnectionInfo {
    tls_version: Str,
    cipher: Str,
    peer_verified: Bool,
}

impl ConnectionInfo {
    pub func none() -> ConnectionInfo {
        ConnectionInfo {
            tls_version: "",
            cipher: "",
            peer_verified: false,
        }
    }

    pub func get_tls_version(this) -> Str { this.tls_version }
    pub func get_cipher(this) -> Str { this.cipher }
    pub func is_peer_verified(this) -> Bool { this.peer_verified }
}

/// A TCP (+optional TLS) connection to an HTTP server.
pub type Connection {
    tcp: TcpStream,
    ssl_ptr: *Unit,
    is_tls: Bool,
    fd: I64,
    info: ConnectionInfo,
}

impl Connection {
    /// Opens a connection to the given host and port.
    /// Uses TLS if is_https is true.
    pub func open(host: Str, port: I64, is_https: Bool) -> Outcome[Connection, HttpError] {
        // DNS resolve
        let dns_result = dns::lookup(host)
        when dns_result {
            Err(e) => return Err(HttpError::dns_failure("DNS lookup failed for {host}")),
            Ok(ip) => {
                // TCP connect
                let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(ip, port as U16))
                let tcp_result = TcpStream::connect(addr)
                when tcp_result {
                    Err(e) => return Err(HttpError::connection_failed("TCP connect failed to {host}:{port}")),
                    Ok(tcp) => {
                        let raw: RawSocket = tcp.into_raw_socket()
                        let fd: I64 = raw.handle

                        if is_https {
                            return Connection::do_tls_handshake(tcp, fd, host)
                        }

                        return Ok(Connection {
                            tcp: tcp,
                            ssl_ptr: 0 as *Unit,
                            is_tls: false,
                            fd: fd,
                            info: ConnectionInfo::none(),
                        })
                    },
                }
            },
        }
    }

    /// Performs TLS handshake on an established TCP connection.
    func do_tls_handshake(tcp: TcpStream, fd: I64, host: Str) -> Outcome[Connection, HttpError] {
        let ctx_result = TlsContext::client()
        when ctx_result {
            Err(e) => return Err(HttpError::tls_error("TLS context creation failed")),
            Ok(ctx) => {
                ctx.set_verify_mode(TlsVerifyMode::None())

                let tls_result = TlsStream::connect(ctx, fd, host)
                when tls_result {
                    Err(e) => return Err(HttpError::tls_error("TLS handshake failed with {host}")),
                    Ok(tls) => {
                        let ver: Str = tls.version()
                        let cph: Str = tls.cipher()
                        let verified: Bool = tls.peer_verified()

                        // Extract ssl_handle from TlsStream (offset 0 = *Unit)
                        let tls_addr: I64 = (ref tls) as I64
                        let handle: *Unit = lowlevel { ptr_read[I64](tls_addr as *I64) } as *Unit

                        return Ok(Connection {
                            tcp: tcp,
                            ssl_ptr: handle,
                            is_tls: true,
                            fd: fd,
                            info: ConnectionInfo {
                                tls_version: ver,
                                cipher: cph,
                                peer_verified: verified,
                            },
                        })
                    },
                }
            },
        }
    }

    /// Writes a string to the connection (TLS or plain TCP).
    pub func write_str(this, data: Str) -> Outcome[I64, HttpError] {
        if this.is_tls {
            let len: I64 = str::len(data)
            let n: I64 = tml_tls_stream_write_str(this.ssl_ptr, data, len)
            if n < 0 {
                return Err(HttpError::connection_failed("TLS write failed"))
            }
            return Ok(n)
        }
        // Plain TCP write_str
        let result = this.tcp.write_str(data)
        when result {
            Ok(n) => return Ok(n),
            Err(e) => return Err(HttpError::connection_failed("TCP write failed")),
        }
    }

    /// Reads bytes from the connection into the provided buffer.
    pub func read(this, buf: mut ref [U8]) -> Outcome[I64, HttpError] {
        if this.is_tls {
            let len: I64 = buf.len() as I64
            // buf is a fat pointer {data_ptr, len}. Extract data_ptr from it.
            let fat_addr: I64 = (mut ref buf) as I64
            let data_ptr: *Unit = lowlevel { ptr_read[I64](fat_addr as *I64) } as *Unit
            let n: I64 = tml_tls_stream_read(this.ssl_ptr, data_ptr, len)
            if n < 0 {
                return Err(HttpError::connection_failed("TLS read failed"))
            }
            return Ok(n)
        }
        // Plain TCP read
        let result = this.tcp.read(mut ref buf)
        when result {
            Ok(n) => return Ok(n),
            Err(e) => return Err(HttpError::connection_failed("TCP read failed")),
        }
    }

    /// Returns connection metadata (TLS version, cipher, etc.).
    pub func connection_info(this) -> ConnectionInfo {
        return this.info
    }

    /// Returns true if the connection is encrypted.
    pub func is_encrypted(this) -> Bool { this.is_tls }

    /// Returns the raw socket file descriptor.
    pub func get_fd(this) -> I64 { this.fd }

    /// Closes the connection.
    pub func close(this) {
        if this.is_tls and this.ssl_ptr != (0 as *Unit) {
            tml_tls_stream_shutdown(this.ssl_ptr)
        }
    }
}
