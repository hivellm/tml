//! Radix tree HTTP router — pure TML implementation.
//!
//! High-performance URL router using a compressed radix tree (one per HTTP method).
//! Inspired by find-my-way. Supports static routes, path parameters (`:param`),
//! and wildcard catch-all routes (`*`).
//!
//! # Example
//!
//! ```tml
//! use std::http::router::{Router, RouteMatch}
//!
//! let router = Router::new()
//! router.on("GET", "/users/:id", 1)
//! router.on("GET", "/users/:id/posts", 2)
//! router.on("POST", "/users", 3)
//! router.on("GET", "/files/*filepath", 4)
//!
//! let m = router.find("GET", "/users/42/posts")
//! assert(m.found)
//! assert_eq(m.handler_id, 2)
//! assert_eq(m.get_param("id"), "42")
//! m.destroy()
//! router.destroy()
//! ```

use core::intrinsics::{ptr_read, ptr_write}
use core::str
use std::collections::hashmap::HashMap
use std::collections::List

// ============================================================================
// Constants
// ============================================================================

// Node kinds
pub const NODE_STATIC: I64 = 0
pub const NODE_PARAMETRIC: I64 = 1
pub const NODE_WILDCARD: I64 = 2

// Node memory layout offsets (80 bytes total)
const OFF_PREFIX: I64 = 0
const OFF_CHILDREN_PTR: I64 = 8
const OFF_CHILDREN_COUNT: I64 = 16
const OFF_CHILDREN_CAP: I64 = 24
const OFF_PARAM_CHILD: I64 = 32
const OFF_WILDCARD_CHILD: I64 = 40
const OFF_HANDLER: I64 = 48
const OFF_PARAM_NAME: I64 = 56
const OFF_KIND: I64 = 64
const NODE_SIZE: I64 = 80

// Children array: each entry is 16 bytes (I64 key_byte + I64 node_ptr)
const CHILD_ENTRY_SIZE: I64 = 16
const INITIAL_CHILDREN_CAP: I64 = 4

// ============================================================================
// Public Types
// ============================================================================

/// The result of a route lookup.
pub type RouteMatch {
    found: Bool,
    handler_id: I64,
    param_names: List[Str],
    param_values: List[Str]
}

/// High-performance HTTP router using a radix tree per method.
pub type Router {
    methods: HashMap[Str, I64]
}

// ============================================================================
// Node Field Accessors
// ============================================================================

func node_get_prefix(node: I64) -> Str {
    let p: *I64 = (node + OFF_PREFIX) as *I64
    let val: I64 = lowlevel { ptr_read[I64](p) }
    val as Str
}

func node_set_prefix(node: I64, prefix: Str) {
    let p: *I64 = (node + OFF_PREFIX) as *I64
    lowlevel { ptr_write[I64](p, prefix as I64) }
}

func node_get_children_ptr(node: I64) -> I64 {
    let p: *I64 = (node + OFF_CHILDREN_PTR) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_children_ptr(node: I64, val: I64) {
    let p: *I64 = (node + OFF_CHILDREN_PTR) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_children_count(node: I64) -> I64 {
    let p: *I64 = (node + OFF_CHILDREN_COUNT) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_children_count(node: I64, val: I64) {
    let p: *I64 = (node + OFF_CHILDREN_COUNT) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_children_cap(node: I64) -> I64 {
    let p: *I64 = (node + OFF_CHILDREN_CAP) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_children_cap(node: I64, val: I64) {
    let p: *I64 = (node + OFF_CHILDREN_CAP) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_param_child(node: I64) -> I64 {
    let p: *I64 = (node + OFF_PARAM_CHILD) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_param_child(node: I64, val: I64) {
    let p: *I64 = (node + OFF_PARAM_CHILD) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_wildcard_child(node: I64) -> I64 {
    let p: *I64 = (node + OFF_WILDCARD_CHILD) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_wildcard_child(node: I64, val: I64) {
    let p: *I64 = (node + OFF_WILDCARD_CHILD) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_handler(node: I64) -> I64 {
    let p: *I64 = (node + OFF_HANDLER) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_handler(node: I64, val: I64) {
    let p: *I64 = (node + OFF_HANDLER) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

func node_get_param_name(node: I64) -> Str {
    let p: *I64 = (node + OFF_PARAM_NAME) as *I64
    let val: I64 = lowlevel { ptr_read[I64](p) }
    val as Str
}

func node_set_param_name(node: I64, name: Str) {
    let p: *I64 = (node + OFF_PARAM_NAME) as *I64
    lowlevel { ptr_write[I64](p, name as I64) }
}

func node_get_kind(node: I64) -> I64 {
    let p: *I64 = (node + OFF_KIND) as *I64
    lowlevel { ptr_read[I64](p) }
}

func node_set_kind(node: I64, val: I64) {
    let p: *I64 = (node + OFF_KIND) as *I64
    lowlevel { ptr_write[I64](p, val) }
}

// ============================================================================
// Node Allocation / Children Array
// ============================================================================

/// Zero-initialize a block of memory (I64-aligned, size must be multiple of 8).
func zero_memory(addr: I64, size: I64) {
    var off: I64 = 0
    loop (off < size) {
        let p: *I64 = (addr + off) as *I64
        lowlevel { ptr_write[I64](p, 0 as I64) }
        off = off + 8
    }
}

/// Allocate a new node with the given prefix and kind.
func node_new(prefix: Str, kind: I64) -> I64 {
    let mem: *Unit = lowlevel { mem_alloc(NODE_SIZE) }
    let addr: I64 = mem as I64
    zero_memory(addr, NODE_SIZE)
    node_set_prefix(addr, prefix)
    node_set_kind(addr, kind)
    // Allocate children array (not for wildcard — it's always a leaf)
    if kind != NODE_WILDCARD {
        let arr_size: I64 = INITIAL_CHILDREN_CAP * CHILD_ENTRY_SIZE
        let arr: *Unit = lowlevel { mem_alloc(arr_size) }
        zero_memory(arr as I64, arr_size)
        node_set_children_ptr(addr, arr as I64)
        node_set_children_cap(addr, INITIAL_CHILDREN_CAP)
    }
    addr
}

/// Find a static child by first byte. Returns node pointer or 0.
func children_find(node: I64, byte_key: I32) -> I64 {
    let arr: I64 = node_get_children_ptr(node)
    let count: I64 = node_get_children_count(node)
    if arr == 0 or count == 0 {
        return 0
    }
    let key_i64: I64 = byte_key as I64
    var i: I64 = 0
    loop (i < count) {
        let entry_base: I64 = arr + i * CHILD_ENTRY_SIZE
        let k_ptr: *I64 = entry_base as *I64
        let k: I64 = lowlevel { ptr_read[I64](k_ptr) }
        if k == key_i64 {
            let v_ptr: *I64 = (entry_base + 8) as *I64
            return lowlevel { ptr_read[I64](v_ptr) }
        }
        i = i + 1
    }
    return 0
}

/// Set a static child by first byte. Replaces if key exists, appends if new.
func children_set(node: I64, byte_key: I32, child_addr: I64) {
    var arr: I64 = node_get_children_ptr(node)
    let count: I64 = node_get_children_count(node)
    var cap: I64 = node_get_children_cap(node)
    let key_i64: I64 = byte_key as I64

    // Check if key already exists — replace
    var i: I64 = 0
    loop (i < count) {
        let entry_base: I64 = arr + i * CHILD_ENTRY_SIZE
        let k_ptr: *I64 = entry_base as *I64
        let k: I64 = lowlevel { ptr_read[I64](k_ptr) }
        if k == key_i64 {
            let v_ptr: *I64 = (entry_base + 8) as *I64
            lowlevel { ptr_write[I64](v_ptr, child_addr) }
            return
        }
        i = i + 1
    }

    // Grow if needed
    if count >= cap {
        let new_cap: I64 = cap * 2
        let new_size: I64 = new_cap * CHILD_ENTRY_SIZE
        let new_ptr: *Unit = lowlevel { mem_realloc(arr as *Unit, new_size) }
        arr = new_ptr as I64
        cap = new_cap
        node_set_children_ptr(node, arr)
        node_set_children_cap(node, cap)
    }

    // Append new entry
    let entry_base: I64 = arr + count * CHILD_ENTRY_SIZE
    let k_ptr: *I64 = entry_base as *I64
    lowlevel { ptr_write[I64](k_ptr, key_i64) }
    let v_ptr: *I64 = (entry_base + 8) as *I64
    lowlevel { ptr_write[I64](v_ptr, child_addr) }
    node_set_children_count(node, count + 1)
}

/// Recursively destroy a node and all its descendants.
func node_destroy(addr: I64) {
    if addr == 0 { return }

    // Destroy static children
    let arr: I64 = node_get_children_ptr(addr)
    let count: I64 = node_get_children_count(addr)
    var i: I64 = 0
    loop (i < count) {
        let entry_base: I64 = arr + i * CHILD_ENTRY_SIZE
        let v_ptr: *I64 = (entry_base + 8) as *I64
        let child: I64 = lowlevel { ptr_read[I64](v_ptr) }
        node_destroy(child)
        i = i + 1
    }
    if arr != 0 {
        lowlevel { mem_free(arr as *Unit) }
    }

    // Destroy parametric and wildcard children
    node_destroy(node_get_param_child(addr))
    node_destroy(node_get_wildcard_child(addr))

    // Free this node
    lowlevel { mem_free(addr as *Unit) }
}

// ============================================================================
// String Helpers
// ============================================================================

/// Returns the length of the longest common prefix between two strings.
func longest_common_prefix(a: Str, b: Str) -> I64 {
    let a_len: I64 = str::len(a)
    let b_len: I64 = str::len(b)
    var min_len: I64 = a_len
    if b_len < min_len { min_len = b_len }
    var i: I64 = 0
    loop (i < min_len) {
        if str::char_at(a, i) != str::char_at(b, i) {
            return i
        }
        i = i + 1
    }
    return min_len
}

/// Match `prefix` against `path` starting at position `pos`.
/// Returns how many characters of `prefix` were matched.
func match_prefix_at(path: Str, pos: I64, prefix: Str) -> I64 {
    let path_len: I64 = str::len(path)
    let prefix_len: I64 = str::len(prefix)
    var i: I64 = 0
    loop (i < prefix_len) {
        if pos + i >= path_len {
            return i
        }
        if str::char_at(path, pos + i) != str::char_at(prefix, i) {
            return i
        }
        i = i + 1
    }
    return prefix_len
}

/// Find the next '/' in path starting from `from`. Returns path_len if not found.
func find_slash(path: Str, from: I64, path_len: I64) -> I64 {
    var i: I64 = from
    loop (i < path_len) {
        if str::char_at(path, i) == 47 {
            return i
        }
        i = i + 1
    }
    return path_len
}

// ============================================================================
// Insert Algorithm
// ============================================================================

/// Insert a static prefix into the radix tree. Returns the target node.
func insert_static_child(parent: I64, text: Str) -> I64 {
    let text_len: I64 = str::len(text)
    if text_len == 0 { return parent }

    let first_byte: I32 = str::char_at(text, 0)
    let existing: I64 = children_find(parent, first_byte)

    // Case 1: No child with this first byte
    if existing == 0 {
        let new_node: I64 = node_new(text, NODE_STATIC)
        children_set(parent, first_byte, new_node)
        return new_node
    }

    // Case 2: Child exists
    let child_prefix: Str = node_get_prefix(existing)
    let child_len: I64 = str::len(child_prefix)
    let common: I64 = longest_common_prefix(text, child_prefix)

    // Case 2a: Full match on both
    if common == child_len and common == text_len {
        return existing
    }

    // Case 2b: text is longer, child prefix fully matched
    if common == child_len {
        let suffix: Str = str::substring(text, common, text_len)
        return insert_static_child(existing, suffix)
    }

    // Case 2c: Need to split (common < child_len)
    let common_prefix: Str = str::substring(text, 0, common)
    let split: I64 = node_new(common_prefix, NODE_STATIC)

    // Reparent existing child under split
    let child_remainder: Str = str::substring(child_prefix, common, child_len)
    node_set_prefix(existing, child_remainder)
    let child_new_first: I32 = str::char_at(child_remainder, 0)
    children_set(split, child_new_first, existing)

    // Replace existing in parent with split
    children_set(parent, first_byte, split)

    // Case 2c-i: text is exactly the common prefix
    if common == text_len {
        return split
    }

    // Case 2c-ii: Both have remainders
    let new_suffix: Str = str::substring(text, common, text_len)
    let new_child: I64 = node_new(new_suffix, NODE_STATIC)
    let new_first: I32 = str::char_at(new_suffix, 0)
    children_set(split, new_first, new_child)
    return new_child
}

/// Insert a route pattern into the tree rooted at `root`.
func insert(root: I64, path: Str, handler_id: I64) {
    let path_len: I64 = str::len(path)
    var current: I64 = root
    var pos: I64 = 0

    // Handle root route "/"
    if path == "/" {
        node_set_handler(root, handler_id)
        return
    }

    // Skip leading '/'
    if path_len > 0 and str::char_at(path, 0) == 47 {
        pos = 1
    }

    loop (pos < path_len) {
        let c: I32 = str::char_at(path, pos)

        if c == 58 {   // ':'
            // Parametric segment: find end
            var seg_end: I64 = pos + 1
            loop (seg_end < path_len) {
                if str::char_at(path, seg_end) == 47 { break }
                seg_end = seg_end + 1
            }
            let param_name: Str = str::substring(path, pos + 1, seg_end)

            var child: I64 = node_get_param_child(current)
            if child == 0 {
                child = node_new("", NODE_PARAMETRIC)
                node_set_param_name(child, param_name)
                node_set_param_child(current, child)
            }
            current = child
            pos = seg_end
            if pos < path_len and str::char_at(path, pos) == 47 {
                pos = pos + 1
            }
        } else if c == 42 {   // '*'
            // Wildcard segment
            var seg_end: I64 = pos + 1
            loop (seg_end < path_len) {
                if str::char_at(path, seg_end) == 47 { break }
                seg_end = seg_end + 1
            }
            var wc_name: Str = "*"
            if seg_end > pos + 1 {
                wc_name = str::substring(path, pos + 1, seg_end)
            }

            var child: I64 = node_get_wildcard_child(current)
            if child == 0 {
                child = node_new("", NODE_WILDCARD)
                node_set_param_name(child, wc_name)
                node_set_wildcard_child(current, child)
            }
            current = child
            pos = path_len
        } else {
            // Static segment: collect up to next ':' or '*'
            var seg_end: I64 = pos
            loop (seg_end < path_len) {
                let sc: I32 = str::char_at(path, seg_end)
                if sc == 58 or sc == 42 { break }
                seg_end = seg_end + 1
            }

            // Build static prefix with leading '/'
            let segment: Str = str::substring(path, pos, seg_end)
            let static_text: Str = "/" + segment
            current = insert_static_child(current, static_text)

            pos = seg_end
        }
    }

    node_set_handler(current, handler_id)
}

// ============================================================================
// Find Algorithm
// ============================================================================

/// Find a route in the tree. Returns RouteMatch.
///
/// The algorithm walks the tree character-by-character using prefix matching.
/// When a static match fails, it backtracks to try parametric/wildcard alternatives.
/// Priority: static > parametric > wildcard.
func find_in_tree(root: I64, path: Str) -> RouteMatch {
    let param_names: List[Str] = List[Str].new(4)
    let param_values: List[Str] = List[Str].new(4)
    let stack: List[I64] = List[I64].new(16)
    let path_len: I64 = str::len(path)

    var current: I64 = root
    var pos: I64 = 0
    var found_handler: I64 = 0

    // Root route check
    if path == "/" or path_len == 0 {
        let h: I64 = node_get_handler(root)
        stack.destroy()
        if h != 0 {
            return RouteMatch { found: true, handler_id: h, param_names: param_names, param_values: param_values }
        }
        return RouteMatch { found: false, handler_id: 0, param_names: param_names, param_values: param_values }
    }

    // Main search loop: walk the tree from pos=0 (including the leading '/')
    var searching: Bool = true
    loop (searching) {
        if pos >= path_len {
            // Consumed entire path — check handler
            let h: I64 = node_get_handler(current)
            if h != 0 {
                found_handler = h
                searching = false
            } else if stack.len() >= 3 {
                // Backtrack
                let saved_pc: I64 = stack.pop()
                let saved_pos: I64 = stack.pop()
                let saved_node: I64 = stack.pop()
                // Rollback params
                loop (param_names.len() > saved_pc) {
                    param_names.pop()
                    param_values.pop()
                }
                let kind: I64 = node_get_kind(saved_node)
                if kind == NODE_PARAMETRIC {
                    var capture_start: I64 = saved_pos
                    if capture_start < path_len and str::char_at(path, capture_start) == 47 {
                        capture_start = capture_start + 1
                    }
                    let seg_end: I64 = find_slash(path, capture_start, path_len)
                    param_names.push(node_get_param_name(saved_node))
                    param_values.push(str::substring(path, capture_start, seg_end))
                    current = saved_node
                    pos = seg_end
                } else if kind == NODE_WILDCARD {
                    var wc_start: I64 = saved_pos
                    if wc_start < path_len and str::char_at(path, wc_start) == 47 {
                        wc_start = wc_start + 1
                    }
                    param_names.push(node_get_param_name(saved_node))
                    param_values.push(str::substring(path, wc_start, path_len))
                    current = saved_node
                    pos = path_len
                } else {
                    searching = false
                }
            } else {
                searching = false
            }
        } else {
            // Still path to consume — push alternatives then try static

            // Push wildcard (lowest priority, popped last from LIFO stack)
            let wc: I64 = node_get_wildcard_child(current)
            if wc != 0 {
                stack.push(wc)
                stack.push(pos)
                stack.push(param_names.len())
            }
            // Push parametric (higher priority, popped before wildcard)
            let pc: I64 = node_get_param_child(current)
            if pc != 0 {
                stack.push(pc)
                stack.push(pos)
                stack.push(param_names.len())
            }

            // Try static match
            let byte_at: I32 = str::char_at(path, pos)
            let child: I64 = children_find(current, byte_at)
            var static_ok: Bool = false

            if child != 0 {
                let prefix: Str = node_get_prefix(child)
                let plen: I64 = str::len(prefix)
                let mlen: I64 = match_prefix_at(path, pos, prefix)
                if mlen == plen {
                    current = child
                    pos = pos + plen
                    static_ok = true
                }
            }

            if not static_ok {
                // Static failed — backtrack
                if stack.len() >= 3 {
                    let saved_pc: I64 = stack.pop()
                    let saved_pos: I64 = stack.pop()
                    let saved_node: I64 = stack.pop()
                    loop (param_names.len() > saved_pc) {
                        param_names.pop()
                        param_values.pop()
                    }
                    let kind: I64 = node_get_kind(saved_node)
                    if kind == NODE_PARAMETRIC {
                        var capture_start: I64 = saved_pos
                        if capture_start < path_len and str::char_at(path, capture_start) == 47 {
                            capture_start = capture_start + 1
                        }
                        let seg_end: I64 = find_slash(path, capture_start, path_len)
                        param_names.push(node_get_param_name(saved_node))
                        param_values.push(str::substring(path, capture_start, seg_end))
                        current = saved_node
                        pos = seg_end
                    } else if kind == NODE_WILDCARD {
                        var wc_start: I64 = saved_pos
                        if wc_start < path_len and str::char_at(path, wc_start) == 47 {
                            wc_start = wc_start + 1
                        }
                        param_names.push(node_get_param_name(saved_node))
                        param_values.push(str::substring(path, wc_start, path_len))
                        current = saved_node
                        pos = path_len
                    } else {
                        searching = false
                    }
                } else {
                    searching = false
                }
            }
        }
    }

    stack.destroy()
    if found_handler != 0 {
        return RouteMatch { found: true, handler_id: found_handler, param_names: param_names, param_values: param_values }
    }
    return RouteMatch { found: false, handler_id: 0, param_names: param_names, param_values: param_values }
}

// ============================================================================
// RouteMatch Implementation
// ============================================================================

impl RouteMatch {
    /// Get a parameter value by name. Returns "" if not found.
    pub func get_param(this, name: Str) -> Str {
        var i: I64 = 0
        let count: I64 = this.param_names.len()
        loop (i < count) {
            let n: Str = this.param_names.get(i)
            if n == name {
                return this.param_values.get(i)
            }
            i = i + 1
        }
        return ""
    }

    /// Get the number of extracted parameters.
    pub func param_count(this) -> I64 {
        return this.param_names.len()
    }

    /// Clean up the route match.
    /// Lists are freed automatically by Drop — this is a no-op but kept for API symmetry.
    pub func destroy(this) {
        // param_names and param_values have Drop impls that call destroy()
        // automatically when RouteMatch goes out of scope. No manual free needed.
    }
}

// ============================================================================
// Router Implementation
// ============================================================================

impl Router {
    /// Create a new HTTP router.
    pub func new() -> Router {
        let methods: HashMap[Str, I64] = HashMap::new[Str, I64](8)
        Router { methods: methods }
    }

    /// Register a route handler.
    pub func on(this, method: Str, path: Str, handler_id: I64) {
        var root: I64 = 0
        if this.methods.has(method) {
            root = this.methods.get(method)
        } else {
            root = node_new("/", NODE_STATIC)
            this.methods.set(method, root)
        }
        insert(root, path, handler_id)
    }

    /// Look up a route by method and path.
    pub func find(this, method: Str, path: Str) -> RouteMatch {
        if not this.methods.has(method) {
            let pn: List[Str] = List[Str].new(0)
            let pv: List[Str] = List[Str].new(0)
            return RouteMatch { found: false, handler_id: 0, param_names: pn, param_values: pv }
        }
        let root: I64 = this.methods.get(method)
        return find_in_tree(root, path)
    }

    /// Destroy the router and free all node trees.
    /// The HashMap itself is freed by Drop when Router goes out of scope.
    pub func destroy(this) {
        let iter = this.methods.iter()
        loop (iter.has_next()) {
            let root_addr: I64 = iter.value()
            node_destroy(root_addr)
            iter.next()
        }
        // iter and methods are freed by Drop — no manual destroy needed.
    }
}
