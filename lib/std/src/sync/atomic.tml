//! Atomic types for lock-free concurrent programming.
//!
//! This module provides atomic types that can be safely shared between threads.
//! All operations on atomic types are guaranteed to be indivisible, meaning
//! that no thread can observe a partial state.
//!
//! # Overview
//!
//! Atomic types are the foundation of lock-free concurrent programming.
//! They provide:
//!
//! - **Atomicity**: Operations complete fully or not at all
//! - **Memory ordering**: Control over how operations are observed across threads
//! - **Lock-free guarantees**: Progress is guaranteed without locks
//!
//! # Available Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`AtomicBool`] | Atomic boolean |
//! | [`AtomicI32`] | 32-bit signed atomic integer |
//! | [`AtomicI64`] | 64-bit signed atomic integer |
//! | [`AtomicU32`] | 32-bit unsigned atomic integer |
//! | [`AtomicU64`] | 64-bit unsigned atomic integer |
//! | [`AtomicIsize`] | Pointer-sized signed atomic integer |
//! | [`AtomicUsize`] | Pointer-sized unsigned atomic integer |
//! | [`AtomicPtr[T]`] | Atomic raw pointer |
//!
//! # Memory Ordering
//!
//! All atomic operations take an [`Ordering`] parameter that specifies
//! the memory ordering constraints. See the [`ordering`][super::ordering]
//! module for details.
//!
//! # Examples
//!
//! ## Simple Counter
//!
//! ```tml
//! use sync::atomic::{AtomicU64, Ordering}
//!
//! let counter = AtomicU64::new(0)
//!
//! // Thread-safe increment
//! counter.fetch_add(1, Ordering::Relaxed)
//!
//! // Read current value
//! let value = counter.load(Ordering::Relaxed)
//! ```
//!
//! ## Spin Lock
//!
//! ```tml
//! use sync::atomic::{AtomicBool, Ordering, spin_loop_hint}
//!
//! type SpinLock {
//!     locked: AtomicBool
//! }
//!
//! impl SpinLock {
//!     func new() -> SpinLock {
//!         SpinLock { locked: AtomicBool::new(false) }
//!     }
//!
//!     func lock(mut self) {
//!         loop (true) {
//!             when self.locked.compare_exchange(
//!                 false, true,
//!                 Ordering::Acquire, Ordering::Relaxed
//!             ) {
//!                 Ok(_) => break,
//!                 Err(_) => spin_loop_hint()
//!             }
//!         }
//!     }
//!
//!     func unlock(mut self) {
//!         self.locked.store(false, Ordering::Release)
//!     }
//! }
//! ```
//!
//! ## Compare-and-Swap Loop
//!
//! ```tml
//! use sync::atomic::{AtomicI32, Ordering}
//!
//! func fetch_update(a: mut ref AtomicI32, f: do(I32) -> I32) -> I32 {
//!     let mut current = a.load(Ordering::Relaxed)
//!     loop (true) {
//!         let new = f(current)
//!         when a.compare_exchange_weak(
//!             current, new,
//!             Ordering::SeqCst, Ordering::Relaxed
//!         ) {
//!             Ok(x) => return x,
//!             Err(x) => current = x
//!         }
//!     }
//! }
//! ```

use sync::ordering::Ordering

// ============================================================================
// AtomicBool
// ============================================================================

/// A boolean value which can be safely shared between threads.
///
/// This type has the same size and alignment as a [`Bool`].
///
/// # Examples
///
/// ```tml
/// use sync::atomic::{AtomicBool, Ordering}
///
/// let flag = AtomicBool::new(false)
///
/// // Set the flag
/// flag.store(true, Ordering::Release)
///
/// // Check and reset
/// let was_set = flag.swap(false, Ordering::AcqRel)
/// ```
@repr(transparent)
pub type AtomicBool {
    value: Bool
}

impl AtomicBool {
    /// Creates a new `AtomicBool` with the given initial value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::AtomicBool
    ///
    /// let flag = AtomicBool::new(true)
    /// ```
    pub func new(v: Bool) -> AtomicBool {
        return AtomicBool { value: v }
    }

    /// Loads a value from the atomic boolean.
    ///
    /// `load` takes an [`Ordering`] argument which describes the memory
    /// ordering of this operation. Possible values are [`SeqCst`],
    /// [`Acquire`] and [`Relaxed`].
    ///
    /// # Panics
    ///
    /// Panics if `order` is [`Release`] or [`AcqRel`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(true)
    /// assert(flag.load(Ordering::Relaxed))
    /// ```
    /// Atomically loads the value.
    pub func load(this, order: Ordering) -> Bool {
        lowlevel { return this.value }
    }

    /// Stores a value into the atomic boolean.
    ///
    /// `store` takes an [`Ordering`] argument which describes the memory
    /// ordering of this operation. Possible values are [`SeqCst`],
    /// [`Release`] and [`Relaxed`].
    ///
    /// # Panics
    ///
    /// Panics if `order` is [`Acquire`] or [`AcqRel`].
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(false)
    /// flag.store(true, Ordering::Release)
    /// ```
    pub func store(mut this, val: Bool, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    /// Stores a value into the atomic boolean, returning the previous value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(true)
    /// let old = flag.swap(false, Ordering::Relaxed)
    /// assert(old)
    /// assert(not flag.load(Ordering::Relaxed))
    /// ```
    pub func swap(mut this, val: Bool, order: Ordering) -> Bool {
        lowlevel {
            let old: Bool = this.value
            this.value = val
            return old
        }
    }

    /// Stores a value into the atomic boolean if the current value is the same
    /// as the `current` value.
    ///
    /// The return value is a result indicating whether the new value was
    /// written and containing the previous value. On success this value is
    /// guaranteed to be equal to `current`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(false)
    ///
    /// when flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed) {
    ///     Ok(_) => println("Successfully set to true"),
    ///     Err(_) => println("Was already true")
    /// }
    /// ```
    pub func compare_exchange(
        mut this,
        current: Bool,
        new: Bool,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Bool, Bool] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    /// Stores a value into the atomic boolean if the current value is the same
    /// as the `current` value.
    ///
    /// Unlike [`compare_exchange`][Self::compare_exchange], this function is
    /// allowed to spuriously fail even when the comparison succeeds. This can
    /// be more efficient on some platforms.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(false)
    ///
    /// let mut current = false
    /// loop (true) {
    ///     when flag.compare_exchange_weak(current, true, Ordering::SeqCst, Ordering::Relaxed) {
    ///         Ok(_) => break,
    ///         Err(actual) => current = actual
    ///     }
    /// }
    /// ```
    pub func compare_exchange_weak(
        mut this,
        current: Bool,
        new: Bool,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Bool, Bool] {
        return this.compare_exchange(current, new, success, failure)
    }

    /// Logical "and" with a boolean value.
    ///
    /// Returns the previous value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(true)
    /// let old = flag.fetch_and(false, Ordering::Relaxed)
    /// assert(old)
    /// assert(not flag.load(Ordering::Relaxed))
    /// ```
    pub func fetch_and(mut this, val: Bool, order: Ordering) -> Bool {
        lowlevel {
            let old: Bool = this.value
            this.value = this.value and val
            return old
        }
    }

    /// Logical "or" with a boolean value.
    ///
    /// Returns the previous value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(false)
    /// let old = flag.fetch_or(true, Ordering::Relaxed)
    /// assert(not old)
    /// assert(flag.load(Ordering::Relaxed))
    /// ```
    pub func fetch_or(mut this, val: Bool, order: Ordering) -> Bool {
        lowlevel {
            let old: Bool = this.value
            this.value = this.value or val
            return old
        }
    }

    /// Logical "xor" with a boolean value.
    ///
    /// Returns the previous value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// use sync::atomic::{AtomicBool, Ordering}
    ///
    /// let flag = AtomicBool::new(true)
    /// let old = flag.fetch_xor(true, Ordering::Relaxed)
    /// assert(old)
    /// assert(not flag.load(Ordering::Relaxed))
    /// ```
    pub func fetch_xor(mut this, val: Bool, order: Ordering) -> Bool {
        lowlevel {
            let old: Bool = this.value
            this.value = (this.value or val) and not (this.value and val)
            return old
        }
    }

    /// Logical "nand" with a boolean value.
    ///
    /// Returns the previous value.
    ///
    /// `fetch_nand(true)` toggles the value.
    /// `fetch_nand(false)` sets the value to `true`.
    pub func fetch_nand(mut this, val: Bool, order: Ordering) -> Bool {
        lowlevel {
            let old: Bool = this.value
            this.value = not (this.value and val)
            return old
        }
    }

    /// Returns `true` if operations on this type are lock-free.
    ///
    /// Boolean atomics are always lock-free on all supported platforms.
    pub func is_lock_free(this) -> Bool {
        return true
    }

    /// Consumes the atomic and returns the contained value.
    ///
    /// This is safe because passing `self` by value guarantees that no other
    /// threads are concurrently accessing the atomic data.
    pub func into_inner(this) -> Bool {
        return this.value
    }
}

// ============================================================================
// AtomicI32
// ============================================================================

/// A 32-bit signed integer which can be safely shared between threads.
///
/// This type has the same size and alignment as an [`I32`].
///
/// # Examples
///
/// ```tml
/// use sync::atomic::{AtomicI32, Ordering}
///
/// let counter = AtomicI32::new(0)
/// counter.fetch_add(1, Ordering::SeqCst)
/// ```
@repr(transparent)
pub type AtomicI32 {
    value: I32
}

impl AtomicI32 {
    /// Creates a new `AtomicI32` with the given initial value.
    pub func new(v: I32) -> AtomicI32 {
        return AtomicI32 { value: v }
    }

    /// Loads a value from the atomic integer.
    pub func load(this, order: Ordering) -> I32 {
        lowlevel { return this.value }
    }

    /// Stores a value into the atomic integer.
    pub func store(mut this, val: I32, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    /// Stores a value into the atomic integer, returning the previous value.
    pub func swap(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = val
            return old
        }
    }

    /// Stores a value into the atomic integer if the current value equals `current`.
    ///
    /// Returns `Ok(current)` if the exchange succeeded, `Err(actual)` otherwise.
    pub func compare_exchange(
        mut this,
        current: I32,
        new: I32,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[I32, I32] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    /// Stores a value into the atomic integer if the current value equals `current`.
    ///
    /// May spuriously fail even when comparison succeeds.
    pub func compare_exchange_weak(
        mut this,
        current: I32,
        new: I32,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[I32, I32] {
        return this.compare_exchange(current, new, success, failure)
    }

    /// Adds to the current value, returning the previous value.
    ///
    /// This operation wraps around on overflow.
    pub func fetch_add(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = this.value + val
            return old
        }
    }

    /// Subtracts from the current value, returning the previous value.
    ///
    /// This operation wraps around on overflow.
    pub func fetch_sub(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = this.value - val
            return old
        }
    }

    /// Bitwise "and" with the current value, returning the previous value.
    pub func fetch_and(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = this.value & val
            return old
        }
    }

    /// Bitwise "or" with the current value, returning the previous value.
    pub func fetch_or(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = this.value | val
            return old
        }
    }

    /// Bitwise "xor" with the current value, returning the previous value.
    pub func fetch_xor(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            this.value = this.value ^ val
            return old
        }
    }

    /// Fetches the value, and applies a function to it that returns an optional
    /// new value. Returns a `Result` of `Ok(previous_value)` if the function
    /// returned `Some(_)`, else `Err(previous_value)`.
    ///
    /// Note: This may call the function multiple times if the value has been
    /// changed from another thread in the meantime, as long as the function
    /// returns `Some(_)`, but the function will have been applied only once
    /// to the stored value.
    pub func fetch_update(
        mut this,
        set_order: Ordering,
        fetch_order: Ordering,
        f: func(I32) -> Maybe[I32]
    ) -> Outcome[I32, I32] {
        var prev: I32 = this.load(fetch_order)
        loop (true) {
            when f(prev) {
                Just(next) => {
                    when this.compare_exchange_weak(prev, next, set_order, fetch_order) {
                        Ok(x) => return Ok(x),
                        Err(next_prev) => prev = next_prev,
                    }
                },
                Nothing => return Err(prev),
            }
        }
    }

    /// Maximum with the current value, returning the previous value.
    pub func fetch_max(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    /// Minimum with the current value, returning the previous value.
    pub func fetch_min(mut this, val: I32, order: Ordering) -> I32 {
        lowlevel {
            let old: I32 = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    /// Returns `true` if operations on this type are lock-free.
    pub func is_lock_free(this) -> Bool {
        return true
    }

    /// Consumes the atomic and returns the contained value.
    pub func into_inner(this) -> I32 {
        return this.value
    }
}

// ============================================================================
// AtomicI64
// ============================================================================

/// A 64-bit signed integer which can be safely shared between threads.
@repr(transparent)
pub type AtomicI64 {
    value: I64
}

impl AtomicI64 {
    pub func new(v: I64) -> AtomicI64 {
        return AtomicI64 { value: v }
    }

    pub func load(this, order: Ordering) -> I64 {
        lowlevel { return this.value }
    }

    pub func store(mut this, val: I64, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    pub func swap(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = val
            return old
        }
    }

    pub func compare_exchange(
        mut this,
        current: I64,
        new: I64,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[I64, I64] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    pub func compare_exchange_weak(
        mut this,
        current: I64,
        new: I64,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[I64, I64] {
        return this.compare_exchange(current, new, success, failure)
    }

    pub func fetch_add(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = this.value + val
            return old
        }
    }

    pub func fetch_sub(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = this.value - val
            return old
        }
    }

    pub func fetch_and(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = this.value & val
            return old
        }
    }

    pub func fetch_or(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = this.value | val
            return old
        }
    }

    pub func fetch_xor(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            this.value = this.value ^ val
            return old
        }
    }

    pub func fetch_max(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    pub func fetch_min(mut this, val: I64, order: Ordering) -> I64 {
        lowlevel {
            let old: I64 = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    pub func is_lock_free(this) -> Bool {
        return true
    }

    pub func into_inner(this) -> I64 {
        return this.value
    }
}

// ============================================================================
// AtomicU32
// ============================================================================

/// A 32-bit unsigned integer which can be safely shared between threads.
@repr(transparent)
pub type AtomicU32 {
    value: U32
}

impl AtomicU32 {
    pub func new(v: U32) -> AtomicU32 {
        return AtomicU32 { value: v }
    }

    pub func load(this, order: Ordering) -> U32 {
        lowlevel { return this.value }
    }

    pub func store(mut this, val: U32, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    pub func swap(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = val
            return old
        }
    }

    pub func compare_exchange(
        mut this,
        current: U32,
        new: U32,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[U32, U32] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    pub func compare_exchange_weak(
        mut this,
        current: U32,
        new: U32,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[U32, U32] {
        return this.compare_exchange(current, new, success, failure)
    }

    pub func fetch_add(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = this.value + val
            return old
        }
    }

    pub func fetch_sub(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = this.value - val
            return old
        }
    }

    pub func fetch_and(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = this.value & val
            return old
        }
    }

    pub func fetch_or(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = this.value | val
            return old
        }
    }

    pub func fetch_xor(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            this.value = this.value ^ val
            return old
        }
    }

    pub func fetch_max(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    pub func fetch_min(mut this, val: U32, order: Ordering) -> U32 {
        lowlevel {
            let old: U32 = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    pub func is_lock_free(this) -> Bool {
        return true
    }

    pub func into_inner(this) -> U32 {
        return this.value
    }
}

// ============================================================================
// AtomicU64
// ============================================================================

/// A 64-bit unsigned integer which can be safely shared between threads.
@repr(transparent)
pub type AtomicU64 {
    value: U64
}

impl AtomicU64 {
    pub func new(v: U64) -> AtomicU64 {
        return AtomicU64 { value: v }
    }

    pub func load(this, order: Ordering) -> U64 {
        lowlevel { return this.value }
    }

    pub func store(mut this, val: U64, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    pub func swap(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = val
            return old
        }
    }

    pub func compare_exchange(
        mut this,
        current: U64,
        new: U64,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[U64, U64] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    pub func compare_exchange_weak(
        mut this,
        current: U64,
        new: U64,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[U64, U64] {
        return this.compare_exchange(current, new, success, failure)
    }

    pub func fetch_add(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = this.value + val
            return old
        }
    }

    pub func fetch_sub(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = this.value - val
            return old
        }
    }

    pub func fetch_and(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = this.value & val
            return old
        }
    }

    pub func fetch_or(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = this.value | val
            return old
        }
    }

    pub func fetch_xor(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            this.value = this.value ^ val
            return old
        }
    }

    pub func fetch_max(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    pub func fetch_min(mut this, val: U64, order: Ordering) -> U64 {
        lowlevel {
            let old: U64 = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    pub func is_lock_free(this) -> Bool {
        return true
    }

    pub func into_inner(this) -> U64 {
        return this.value
    }
}

// ============================================================================
// AtomicUsize
// ============================================================================

/// A pointer-sized unsigned integer which can be safely shared between threads.
///
/// This type has the same size as `Usize`: 32 bits on 32-bit platforms,
/// 64 bits on 64-bit platforms.
@repr(transparent)
pub type AtomicUsize {
    value: Usize
}

impl AtomicUsize {
    pub func new(v: Usize) -> AtomicUsize {
        return AtomicUsize { value: v }
    }

    pub func load(this, order: Ordering) -> Usize {
        lowlevel { return this.value }
    }

    pub func store(mut this, val: Usize, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    pub func swap(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = val
            return old
        }
    }

    pub func compare_exchange(
        mut this,
        current: Usize,
        new: Usize,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Usize, Usize] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    pub func compare_exchange_weak(
        mut this,
        current: Usize,
        new: Usize,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Usize, Usize] {
        return this.compare_exchange(current, new, success, failure)
    }

    pub func fetch_add(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = this.value + val
            return old
        }
    }

    pub func fetch_sub(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = this.value - val
            return old
        }
    }

    pub func fetch_and(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = this.value & val
            return old
        }
    }

    pub func fetch_or(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = this.value | val
            return old
        }
    }

    pub func fetch_xor(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            this.value = this.value ^ val
            return old
        }
    }

    pub func fetch_max(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    pub func fetch_min(mut this, val: Usize, order: Ordering) -> Usize {
        lowlevel {
            let old: Usize = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    pub func is_lock_free(this) -> Bool {
        return true
    }

    pub func into_inner(this) -> Usize {
        return this.value
    }
}

// ============================================================================
// AtomicIsize
// ============================================================================

/// A pointer-sized signed integer which can be safely shared between threads.
@repr(transparent)
pub type AtomicIsize {
    value: Isize
}

impl AtomicIsize {
    pub func new(v: Isize) -> AtomicIsize {
        return AtomicIsize { value: v }
    }

    pub func load(this, order: Ordering) -> Isize {
        lowlevel { return this.value }
    }

    pub func store(mut this, val: Isize, order: Ordering) -> Unit {
        lowlevel { this.value = val }
    }

    pub func swap(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = val
            return old
        }
    }

    pub func compare_exchange(
        mut this,
        current: Isize,
        new: Isize,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Isize, Isize] {
        lowlevel {
            if this.value == current {
                this.value = new
                return Ok(current)
            }
            return Err(this.value)
        }
    }

    pub func compare_exchange_weak(
        mut this,
        current: Isize,
        new: Isize,
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Isize, Isize] {
        return this.compare_exchange(current, new, success, failure)
    }

    pub func fetch_add(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = this.value + val
            return old
        }
    }

    pub func fetch_sub(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = this.value - val
            return old
        }
    }

    pub func fetch_and(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = this.value & val
            return old
        }
    }

    pub func fetch_or(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = this.value | val
            return old
        }
    }

    pub func fetch_xor(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            this.value = this.value ^ val
            return old
        }
    }

    pub func fetch_max(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            if val > this.value { this.value = val }
            return old
        }
    }

    pub func fetch_min(mut this, val: Isize, order: Ordering) -> Isize {
        lowlevel {
            let old: Isize = this.value
            if val < this.value { this.value = val }
            return old
        }
    }

    pub func is_lock_free(this) -> Bool {
        return true
    }

    pub func into_inner(this) -> Isize {
        return this.value
    }
}

// ============================================================================
// AtomicPtr[T]
// ============================================================================

/// A raw pointer which can be safely shared between threads.
///
/// This type has the same size and alignment as a `Ptr[T]`.
///
/// # Examples
///
/// ```tml
/// use sync::atomic::{AtomicPtr, Ordering}
///
/// let data = 42
/// let ptr = AtomicPtr::new(raw data)
///
/// let loaded = ptr.load(Ordering::SeqCst)
/// ```
@repr(transparent)
pub type AtomicPtr[T] {
    ptr: Ptr[T]
}

impl[T] AtomicPtr[T] {
    /// Creates a new `AtomicPtr` from a raw pointer.
    pub func new(p: Ptr[T]) -> AtomicPtr[T] {
        return AtomicPtr { ptr: p }
    }

    /// Creates a new null `AtomicPtr`.
    pub func new_null() -> AtomicPtr[T] {
        return AtomicPtr { ptr: null }
    }

    /// Loads a value from the atomic pointer.
    pub func load(this, order: Ordering) -> Ptr[T] {
        lowlevel { return this.ptr }
    }

    /// Stores a value into the atomic pointer.
    pub func store(mut this, val: Ptr[T], order: Ordering) -> Unit {
        lowlevel { this.ptr = val }
    }

    /// Stores a value into the atomic pointer, returning the previous value.
    pub func swap(mut this, val: Ptr[T], order: Ordering) -> Ptr[T] {
        lowlevel {
            let old: Ptr[T] = this.ptr
            this.ptr = val
            return old
        }
    }

    /// Stores a value into the atomic pointer if the current value equals `current`.
    pub func compare_exchange(
        mut this,
        current: Ptr[T],
        new: Ptr[T],
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Ptr[T], Ptr[T]] {
        lowlevel {
            if this.ptr == current {
                this.ptr = new
                return Ok(current)
            }
            return Err(this.ptr)
        }
    }

    /// Stores a value into the atomic pointer if the current value equals `current`.
    ///
    /// May spuriously fail.
    pub func compare_exchange_weak(
        mut this,
        current: Ptr[T],
        new: Ptr[T],
        success: Ordering,
        failure: Ordering
    ) -> Outcome[Ptr[T], Ptr[T]] {
        return this.compare_exchange(current, new, success, failure)
    }

    /// Returns `true` if operations on this type are lock-free.
    pub func is_lock_free(this) -> Bool {
        return true
    }

    /// Consumes the atomic and returns the contained pointer.
    pub func into_inner(this) -> Ptr[T] {
        return this.ptr
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// A hint to the processor that it is running a busy-wait spin-loop.
///
/// This function is a hint, not a command. The processor is free to ignore it.
/// This can prevent the CPU from wasting power or contending for resources.
///
/// # Examples
///
/// ```tml
/// use sync::atomic::{AtomicBool, Ordering, spin_loop_hint}
///
/// let flag = AtomicBool::new(false)
///
/// // Busy-wait with hint
/// loop (true) {
///     if flag.load(Ordering::Relaxed) {
///         break
///     }
///     spin_loop_hint()
/// }
/// ```
pub func spin_loop_hint() -> Unit {
    // Hint to processor that this is a spin loop
    // The intrinsic attribute should replace this with the actual pause instruction
}

// ============================================================================
// Send/Sync implementations for atomic types
// ============================================================================

// Atomic types are explicitly designed to be safely shared between threads.
// They use hardware-level atomic operations that guarantee thread-safety.

impl Send for AtomicBool {}
impl Sync for AtomicBool {}

impl Send for AtomicI32 {}
impl Sync for AtomicI32 {}

impl Send for AtomicI64 {}
impl Sync for AtomicI64 {}

impl Send for AtomicU32 {}
impl Sync for AtomicU32 {}

impl Send for AtomicU64 {}
impl Sync for AtomicU64 {}

impl Send for AtomicUsize {}
impl Sync for AtomicUsize {}

impl Send for AtomicIsize {}
impl Sync for AtomicIsize {}

// AtomicPtr is Send and Sync only if T is Send and Sync
// This matches Rust's semantics: the pointer operations are atomic,
// but the safety of the pointed-to data depends on T's thread safety.
impl[T: Send] Send for AtomicPtr[T] {}
impl[T: Send + Sync] Sync for AtomicPtr[T] {}
