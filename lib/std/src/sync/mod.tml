//! Synchronization primitives for concurrent programming.
//!
//! Built on top of the raw atomic intrinsics in [`core::sync`], this module
//! provides ergonomic, type-safe synchronization primitives including:
//!
//! - **Atomic types**: Lock-free primitives for simple concurrent data
//! - **Memory ordering**: Control over how operations are observed across threads
//! - **Mutex**: Mutual exclusion for protecting shared data
//! - **RwLock**: Reader-writer lock for concurrent read access
//!
//! # Atomic Types
//!
//! Atomic types are the foundation of lock-free concurrent programming.
//! They provide atomic load, store, and read-modify-write operations:
//!
//! | Type | Description |
//! |------|-------------|
//! | [`AtomicBool`] | Atomic boolean |
//! | [`AtomicI32`] | 32-bit signed atomic |
//! | [`AtomicI64`] | 64-bit signed atomic |
//! | [`AtomicU32`] | 32-bit unsigned atomic |
//! | [`AtomicU64`] | 64-bit unsigned atomic |
//! | [`AtomicIsize`] | Pointer-sized signed atomic |
//! | [`AtomicUsize`] | Pointer-sized unsigned atomic |
//! | [`AtomicPtr[T]`] | Atomic raw pointer |
//!
//! See the [`atomic`] module for details and examples.
//!
//! # Locking Primitives
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Mutex[T]`] | Mutual exclusion lock for exclusive access |
//! | [`MutexGuard[T]`] | RAII guard for Mutex |
//! | [`RwLock[T]`] | Reader-writer lock (multiple readers or one writer) |
//! | [`RwLockReadGuard[T]`] | RAII guard for RwLock read access |
//! | [`RwLockWriteGuard[T]`] | RAII guard for RwLock write access |
//!
//! # Shared Ownership
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Arc[T]`] | Atomically reference-counted pointer for thread-safe sharing |
//! | [`Weak[T]`] | Weak reference to Arc (doesn't prevent deallocation) |
//!
//! # Lock-Free Data Structures
//!
//! | Type | Description |
//! |------|-------------|
//! | [`LockFreeQueue[T]`] | Lock-free FIFO queue (Michael-Scott algorithm) |
//! | [`LockFreeStack[T]`] | Lock-free LIFO stack (Treiber algorithm) |
//!
//! # Channels
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Sender[T]`] | Sending half of MPSC channel (clonable) |
//! | [`Receiver[T]`] | Receiving half of MPSC channel (single-consumer) |
//!
//! # Memory Ordering
//!
//! The [`Ordering`] enum specifies how atomic operations synchronize with
//! other operations. See the [`ordering`] module for details.
//!
//! # Examples
//!
//! ## Atomic Counter
//!
//! ```tml
//! use sync::{AtomicU64, Ordering}
//!
//! let counter = AtomicU64::new(0)
//!
//! // Thread-safe increment
//! counter.fetch_add(1, Ordering::Relaxed)
//! ```
//!
//! ## Mutex
//!
//! ```tml
//! use sync::Mutex
//!
//! let data = Mutex::new(0)
//!
//! {
//!     let mut guard = data.lock()
//!     *guard = 42
//! }  // lock released here
//! ```
//!
//! ## RwLock
//!
//! ```tml
//! use sync::RwLock
//!
//! let data = RwLock::new(5)
//!
//! // Multiple readers
//! {
//!     let r1 = data.read()
//!     let r2 = data.read()
//!     assert_eq(*r1, 5)
//! }
//!
//! // Single writer
//! {
//!     let mut w = data.write()
//!     *w = 6
//! }
//! ```
//!
//! ## Memory Fence
//!
//! ```tml
//! use sync::{fence, Ordering}
//!
//! // Full memory barrier
//! fence(Ordering::SeqCst)
//! ```
//!
//! ## Arc (Thread-safe Shared Ownership)
//!
//! ```tml
//! use sync::{Arc, Mutex}
//!
//! // Share mutable data between threads
//! let counter = Arc::new(Mutex::new(0))
//!
//! let counter2 = counter.clone()
//! // counter and counter2 now share the same Mutex
//!
//! {
//!     let mut guard = counter.lock()
//!     *guard = *guard + 1
//! }
//! ```

// Re-export submodules
pub use std::sync::ordering
pub use std::sync::atomic
pub use std::sync::mutex
pub use std::sync::rwlock
pub use std::sync::condvar
pub use std::sync::barrier
pub use std::sync::once
pub use std::sync::arc
pub use std::sync::queue
pub use std::sync::stack
pub use std::sync::mpsc

// Re-export commonly used types at sync level
pub use std::sync::ordering::Ordering
pub use std::sync::ordering::{fence, compiler_fence}

pub use std::sync::atomic::{
    AtomicBool,
    AtomicI32,
    AtomicI64,
    AtomicU32,
    AtomicU64,
    AtomicIsize,
    AtomicUsize,
    AtomicPtr,
    spin_loop_hint,
}

pub use std::sync::mutex::{Mutex, MutexGuard, Lock}

pub use std::sync::rwlock::{
    RwLock,
    RwLockReadGuard,
    RwLockWriteGuard,
}

pub use std::sync::condvar::Condvar

pub use std::sync::barrier::{Barrier, BarrierWaitResult}

pub use std::sync::once::{Once, OnceLock}

pub use std::sync::arc::{Arc, Weak}

pub use std::sync::queue::LockFreeQueue

pub use std::sync::stack::LockFreeStack

pub use std::sync::mpsc::{Sender, Receiver, channel, SendError, RecvError, TryRecvError, RecvTimeoutError}
