//! DNS resolution module.
//!
//! Provides hostname-to-IP and IP-to-hostname resolution using the OS resolver
//! (getaddrinfo/getnameinfo). Modeled after Node.js's `dns` module.
//!
//! # Examples
//!
//! ```tml
//! use std::net::dns
//!
//! // Resolve hostname to IPv4
//! let result = dns::lookup("localhost")
//! when result {
//!     Ok(addr) => print("Resolved: {addr}\n"),
//!     Err(e) => print("Error: {e.message()}\n"),
//! }
//! ```

use std::net::ip::{Ipv4Addr, Ipv6Addr, IpAddr}

// ============================================================================
// DNS Error Types
// ============================================================================

/// The kind of DNS error that occurred.
pub type DnsErrorKind {
    value: I32,
}

impl DnsErrorKind {
    /// Hostname not found (EAI_NONAME).
    pub func NotFound() -> DnsErrorKind { DnsErrorKind { value: 1 } }
    /// DNS query succeeded but no results (EAI_NODATA).
    pub func NoData() -> DnsErrorKind { DnsErrorKind { value: 2 } }
    /// DNS server failure.
    pub func ServerFailure() -> DnsErrorKind { DnsErrorKind { value: 3 } }
    /// Invalid hostname (EAI_FAIL).
    pub func BadName() -> DnsErrorKind { DnsErrorKind { value: 4 } }
    /// Unsupported address family (EAI_FAMILY).
    pub func BadFamily() -> DnsErrorKind { DnsErrorKind { value: 5 } }
    /// Query timed out.
    pub func Timeout() -> DnsErrorKind { DnsErrorKind { value: 6 } }
    /// DNS query refused.
    pub func Refused() -> DnsErrorKind { DnsErrorKind { value: 7 } }
    /// Out of memory (EAI_MEMORY).
    pub func NoMemory() -> DnsErrorKind { DnsErrorKind { value: 8 } }
    /// Unknown error.
    pub func Other() -> DnsErrorKind { DnsErrorKind { value: 99 } }

    /// Maps a platform EAI_* error code to a DnsErrorKind.
    pub func from_eai(code: I32) -> DnsErrorKind {
        // Windows EAI constants
        if code == 11001 { return DnsErrorKind::NotFound() }
        if code == 11002 { return DnsErrorKind::ServerFailure() }
        if code == 11003 { return DnsErrorKind::ServerFailure() }
        if code == 11004 { return DnsErrorKind::NoData() }
        if code == 10047 { return DnsErrorKind::BadFamily() }

        // POSIX EAI constants (negative values)
        if code == -2 { return DnsErrorKind::NotFound() }
        if code == -5 { return DnsErrorKind::NoData() }
        if code == -4 { return DnsErrorKind::BadName() }
        if code == -6 { return DnsErrorKind::BadFamily() }
        if code == -10 { return DnsErrorKind::NoMemory() }
        if code == -3 { return DnsErrorKind::ServerFailure() }

        // Platform-neutral fallback
        if code == 7 { return DnsErrorKind::NoData() }
        if code == 8 { return DnsErrorKind::NotFound() }

        DnsErrorKind::Other()
    }

    /// Returns the raw discriminant value.
    pub func raw(this) -> I32 {
        this.value
    }

    /// Checks if this is a not-found error.
    pub func is_not_found(this) -> Bool {
        this.value == 1
    }

    /// Checks if this is a no-data error.
    pub func is_no_data(this) -> Bool {
        this.value == 2
    }
}

/// An error from a DNS operation.
pub type DnsError {
    error_kind: DnsErrorKind,
    eai_code: I32,
}

impl DnsError {
    /// Creates a new DNS error from an EAI error code.
    pub func from_eai(code: I32) -> DnsError {
        DnsError {
            error_kind: DnsErrorKind::from_eai(code),
            eai_code: code,
        }
    }

    /// Creates a new DNS error with a specific kind.
    pub func new(kind: DnsErrorKind) -> DnsError {
        DnsError {
            error_kind: kind,
            eai_code: 0,
        }
    }

    /// Returns the error kind.
    pub func kind(this) -> DnsErrorKind {
        this.error_kind
    }

    /// Returns the raw EAI error code.
    pub func raw_code(this) -> I32 {
        this.eai_code
    }

    /// Returns a human-readable error message.
    pub func message(this) -> Str {
        if this.error_kind.value == 1 { return "DNS lookup failed: hostname not found" }
        if this.error_kind.value == 2 { return "DNS lookup failed: no data for hostname" }
        if this.error_kind.value == 3 { return "DNS lookup failed: server failure" }
        if this.error_kind.value == 4 { return "DNS lookup failed: invalid hostname" }
        if this.error_kind.value == 5 { return "DNS lookup failed: unsupported address family" }
        if this.error_kind.value == 6 { return "DNS lookup failed: query timed out" }
        if this.error_kind.value == 7 { return "DNS lookup failed: query refused" }
        if this.error_kind.value == 8 { return "DNS lookup failed: out of memory" }
        "DNS lookup failed: unknown error"
    }
}

// ============================================================================
// Lookup Result
// ============================================================================

/// Result of a multi-address DNS lookup.
pub type LookupResult {
    /// IPv4 addresses resolved.
    v4_addrs: [Ipv4Addr; 16],
    /// IPv6 addresses resolved.
    v6_addrs: [Ipv6Addr; 16],
    /// Number of IPv4 results.
    v4_count: I32,
    /// Number of IPv6 results.
    v6_count: I32,
}

impl LookupResult {
    /// Creates an empty lookup result.
    pub func empty() -> LookupResult {
        LookupResult {
            v4_addrs: [Ipv4Addr::UNSPECIFIED(); 16],
            v6_addrs: [Ipv6Addr::UNSPECIFIED(); 16],
            v4_count: 0,
            v6_count: 0,
        }
    }

    /// Returns the total number of resolved addresses.
    pub func count(this) -> I32 {
        this.v4_count + this.v6_count
    }

    /// Returns the number of IPv4 addresses.
    pub func ipv4_count(this) -> I32 {
        this.v4_count
    }

    /// Returns the number of IPv6 addresses.
    pub func ipv6_count(this) -> I32 {
        this.v6_count
    }

    /// Returns the first resolved address as IpAddr, or Nothing.
    pub func first(this) -> Maybe[IpAddr] {
        if this.v4_count > 0 {
            return Just(IpAddr::V4(this.v4_addrs[0]))
        }
        if this.v6_count > 0 {
            return Just(IpAddr::V6(this.v6_addrs[0]))
        }
        Nothing
    }

    /// Returns the IPv4 address at the given index, or Nothing.
    pub func get_v4(this, index: I32) -> Maybe[Ipv4Addr] {
        if index >= 0 and index < this.v4_count {
            Just(this.v4_addrs[index])
        } else {
            Nothing
        }
    }

    /// Returns the IPv6 address at the given index, or Nothing.
    pub func get_v6(this, index: I32) -> Maybe[Ipv6Addr] {
        if index >= 0 and index < this.v6_count {
            Just(this.v6_addrs[index])
        } else {
            Nothing
        }
    }
}

// ============================================================================
// FFI Functions (extern declarations - return-value based, no output pointers)
// ============================================================================

/// Lookup hostname → first IPv4 address.
/// Returns IPv4 as I64 (low 32 bits = address in host byte order), or -1 on error.
@extern("tml_sys_dns_lookup4")
func sys_dns_lookup4(hostname: Str) -> I64

/// Lookup hostname → first IPv6 high 8 bytes. Returns -1 on error.
/// Must call sys_dns_lookup6_lo() after success to get low 8 bytes.
@extern("tml_sys_dns_lookup6_hi")
func sys_dns_lookup6_hi(hostname: Str) -> I64

/// Get low 8 bytes of last IPv6 lookup result.
@extern("tml_sys_dns_lookup6_lo")
func sys_dns_lookup6_lo() -> I64

/// Lookup hostname → all addresses stored in thread-local buffers.
/// Returns count of results, or -1 on error. Access via result accessor functions.
@extern("tml_sys_dns_lookup_all")
func sys_dns_lookup_all(hostname: Str, family_hint: I32, max_results: I32) -> I32

/// Get address family of result at index. Returns 2 (IPv4) or 23 (IPv6), or -1.
@extern("tml_sys_dns_result_family")
func sys_dns_result_family(index: I32) -> I32

/// Get IPv4 address of result at index as I64 (low 32 bits).
@extern("tml_sys_dns_result_v4")
func sys_dns_result_v4(index: I32) -> I64

/// Get IPv6 high 8 bytes of result at index.
@extern("tml_sys_dns_result_v6_hi")
func sys_dns_result_v6_hi(index: I32) -> I64

/// Get IPv6 low 8 bytes of result at index.
@extern("tml_sys_dns_result_v6_lo")
func sys_dns_result_v6_lo(index: I32) -> I64

/// Reverse DNS for IPv4 address → hostname string (or null on error).
@extern("tml_sys_dns_reverse4")
func sys_dns_reverse4(a: I32, b: I32, c: I32, d: I32) -> Str

/// Reverse DNS for IPv6 address → hostname string (or null on error).
@extern("tml_sys_dns_reverse6")
func sys_dns_reverse6(hi: I64, lo: I64) -> Str

/// Returns the last DNS error code (EAI_*).
@extern("tml_sys_dns_get_last_error")
func sys_dns_get_last_error() -> I32

// ============================================================================
// Internal Helpers
// ============================================================================

/// Convert I64 with high 8 bytes + I64 with low 8 bytes → Ipv6Addr
func ipv6_from_halves(hi: I64, lo: I64) -> Ipv6Addr {
    let s0: U16 = ((hi shr 48) & 0xFFFF) as U16
    let s1: U16 = ((hi shr 32) & 0xFFFF) as U16
    let s2: U16 = ((hi shr 16) & 0xFFFF) as U16
    let s3: U16 = (hi & 0xFFFF) as U16
    let s4: U16 = ((lo shr 48) & 0xFFFF) as U16
    let s5: U16 = ((lo shr 32) & 0xFFFF) as U16
    let s6: U16 = ((lo shr 16) & 0xFFFF) as U16
    let s7: U16 = (lo & 0xFFFF) as U16
    Ipv6Addr::new(s0, s1, s2, s3, s4, s5, s6, s7)
}

// ============================================================================
// Public API
// ============================================================================

/// Resolves a hostname to its first IPv4 address.
///
/// This is equivalent to Node.js `dns.lookup(hostname, { family: 4 })`.
///
/// # Examples
///
/// ```tml
/// use std::net::dns
///
/// let addr = dns::lookup("localhost")
/// assert(addr.is_ok())
/// ```
pub func lookup(hostname: Str) -> Outcome[Ipv4Addr, DnsError] {
    let result: I64 = sys_dns_lookup4(hostname)
    if result < 0 {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }
    Ok(Ipv4Addr::from_bits(result as U32))
}

/// Resolves a hostname to its first IPv6 address.
///
/// This is equivalent to Node.js `dns.lookup(hostname, { family: 6 })`.
pub func lookup6(hostname: Str) -> Outcome[Ipv6Addr, DnsError] {
    let hi: I64 = sys_dns_lookup6_hi(hostname)
    if hi < 0 {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }
    let lo: I64 = sys_dns_lookup6_lo()
    Ok(ipv6_from_halves(hi, lo))
}

/// Resolves a hostname to its first IP address (either IPv4 or IPv6).
///
/// Prefers IPv4 if available.
///
/// This is equivalent to Node.js `dns.lookup(hostname)`.
pub func lookup_ip(hostname: Str) -> Outcome[IpAddr, DnsError] {
    // Try IPv4 first
    let v4_result = lookup(hostname)
    when v4_result {
        Ok(addr) => return Ok(IpAddr::V4(addr)),
        Err(_) => {}
    }
    // Fall back to IPv6
    let v6_result = lookup6(hostname)
    when v6_result {
        Ok(addr) => Ok(IpAddr::V6(addr)),
        Err(e) => Err(e),
    }
}

/// Resolves a hostname to all IP addresses (up to `max_results`).
///
/// This is equivalent to Node.js `dns.lookup(hostname, { all: true })`.
pub func lookup_all(hostname: Str, max_results: I32) -> Outcome[LookupResult, DnsError] {
    let count: I32 = sys_dns_lookup_all(hostname, 0, max_results)
    if count < 0 {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }

    let mut result = LookupResult::empty()
    let mut i: I32 = 0
    loop (i < count) {
        let family: I32 = sys_dns_result_family(i)
        if family == 2 {
            let bits: I64 = sys_dns_result_v4(i)
            let addr = Ipv4Addr::from_bits(bits as U32)
            result.v4_addrs[result.v4_count] = addr
            result.v4_count = result.v4_count + 1
        } else if family == 23 {
            let hi: I64 = sys_dns_result_v6_hi(i)
            let lo: I64 = sys_dns_result_v6_lo(i)
            let addr = ipv6_from_halves(hi, lo)
            result.v6_addrs[result.v6_count] = addr
            result.v6_count = result.v6_count + 1
        }
        i = i + 1
    }

    Ok(result)
}

/// Resolves a hostname to all IPv4 addresses.
pub func lookup_all4(hostname: Str, max_results: I32) -> Outcome[LookupResult, DnsError] {
    let count: I32 = sys_dns_lookup_all(hostname, 2, max_results)
    if count < 0 {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }

    let mut result = LookupResult::empty()
    let mut i: I32 = 0
    loop (i < count) {
        let bits: I64 = sys_dns_result_v4(i)
        let addr = Ipv4Addr::from_bits(bits as U32)
        result.v4_addrs[result.v4_count] = addr
        result.v4_count = result.v4_count + 1
        i = i + 1
    }

    Ok(result)
}

/// Resolves a hostname to all IPv6 addresses.
pub func lookup_all6(hostname: Str, max_results: I32) -> Outcome[LookupResult, DnsError] {
    let count: I32 = sys_dns_lookup_all(hostname, 23, max_results)
    if count < 0 {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }

    let mut result = LookupResult::empty()
    let mut i: I32 = 0
    loop (i < count) {
        let hi: I64 = sys_dns_result_v6_hi(i)
        let lo: I64 = sys_dns_result_v6_lo(i)
        let addr = ipv6_from_halves(hi, lo)
        result.v6_addrs[result.v6_count] = addr
        result.v6_count = result.v6_count + 1
        i = i + 1
    }

    Ok(result)
}

/// Reverse DNS lookup: resolves an IP address to a hostname.
///
/// This is equivalent to Node.js `dns.reverse(ip)`.
pub func reverse(addr: IpAddr) -> Outcome[Str, DnsError] {
    when addr {
        IpAddr::V4(v4) => reverse4(v4),
        IpAddr::V6(v6) => reverse6(v6),
    }
}

/// Reverse DNS lookup for an IPv4 address.
pub func reverse4(addr: Ipv4Addr) -> Outcome[Str, DnsError] {
    let octs: [U8; 4] = addr.octets()
    let hostname: Str = sys_dns_reverse4(
        octs[0] as I32, octs[1] as I32, octs[2] as I32, octs[3] as I32
    )
    if hostname == "" {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }
    Ok(hostname)
}

/// Reverse DNS lookup for an IPv6 address.
pub func reverse6(addr: Ipv6Addr) -> Outcome[Str, DnsError] {
    let segs: [U16; 8] = addr.segments()
    // Pack segments into two I64 values (big-endian)
    let hi: I64 = ((segs[0] as I64) shl 48) | ((segs[1] as I64) shl 32) |
                  ((segs[2] as I64) shl 16) | (segs[3] as I64)
    let lo: I64 = ((segs[4] as I64) shl 48) | ((segs[5] as I64) shl 32) |
                  ((segs[6] as I64) shl 16) | (segs[7] as I64)
    let hostname: Str = sys_dns_reverse6(hi, lo)
    if hostname == "" {
        let eai: I32 = sys_dns_get_last_error()
        return Err(DnsError::from_eai(eai))
    }
    Ok(hostname)
}
