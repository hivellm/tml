//! Non-blocking UDP networking primitives.
//!
//! This module provides non-blocking versions of UDP socket types for
//! event-driven I/O operations, including integration with the EventLoop.
//!
//! # Types
//!
//! - [`AsyncUdpSocket`] - Non-blocking UDP socket for datagrams
//! - [`UdpHandle`] - High-level async UDP handle integrated with EventLoop

use std::net::{SocketAddr, Ipv4Addr, Ipv6Addr}
use std::net::error::{NetError, NetErrorKind}
use std::net::sys::{RawSocket, SocketType, SocketProtocol, AddressFamily}
use std::net::udp::UdpSocket
use std::aio::event_loop::EventLoop
use std::aio::poller::READABLE
use core::mem::{mem_alloc, mem_free}
use core::intrinsics::{ptr_read, ptr_write}

// ============================================================================
// AsyncUdpSocket
// ============================================================================

/// A non-blocking UDP socket for sending and receiving datagrams.
///
/// This is the non-blocking equivalent of `UdpSocket`. It uses non-blocking I/O
/// and returns immediately if an operation would block.
pub type AsyncUdpSocket {
    /// The underlying non-blocking socket
    socket: RawSocket,
    /// Whether connected to a specific address
    connected: Bool,
}

impl AsyncUdpSocket {
    /// Creates a non-blocking UDP socket bound to the given address.
    pub func bind(addr: SocketAddr) -> Outcome[AsyncUdpSocket, NetError] {
        let family: AddressFamily = AddressFamily::from_addr(ref addr)
        var socket: RawSocket = RawSocket::new_with_family(family, SocketType::Datagram, SocketProtocol::Udp)!
        socket.bind(ref addr)!
        socket.set_nonblocking(true)!

        let async_socket: AsyncUdpSocket = AsyncUdpSocket { socket: socket, connected: false }
        Ok(async_socket)
    }

    /// Creates a non-blocking socket from a synchronous one.
    pub func from_std(udp: UdpSocket) -> Outcome[AsyncUdpSocket, NetError] {
        let connected: Bool = udp.is_connected()
        let socket: RawSocket = udp.into_raw_socket()
        var async_socket: AsyncUdpSocket = AsyncUdpSocket {
            socket: socket,
            connected: connected,
        }
        async_socket.socket.set_nonblocking(true)!
        Ok(async_socket)
    }

    /// Connects to a remote address.
    pub func connect(mut this, addr: SocketAddr) -> Outcome[(), NetError] {
        this.socket.connect(ref addr)!
        this.connected = true
        Ok(())
    }

    /// Tries to send data to the given address without blocking.
    ///
    /// Returns `Ok(Just(n))` if data was sent, `Ok(Nothing)` if it would block.
    pub func try_send_to(this, buf: ref [U8], addr: SocketAddr) -> Outcome[Maybe[I64], NetError] {
        when this.socket.send_to(buf, ref addr) {
            Ok(n) => Ok(Just(n))
            Err(e) => {
                if e.is_would_block() {
                    Ok(Nothing)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Tries to receive data without blocking.
    ///
    /// Returns `Ok(Just((n, addr)))` if data was received, `Ok(Nothing)` if it would block.
    pub func try_recv_from(this, buf: mut ref [U8]) -> Outcome[Maybe[(I64, SocketAddr)], NetError] {
        when this.socket.recv_from(buf) {
            Ok(result) => Ok(Just(result))
            Err(e) => {
                if e.is_would_block() {
                    Ok(Nothing)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Sends data to the given address, spinning until complete.
    pub func send_to(this, buf: ref [U8], addr: SocketAddr) -> Outcome[I64, NetError] {
        loop (true) {
            when this.try_send_to(buf, addr)! {
                Just(n) => return Ok(n)
                Nothing => {}
            }
        }
    }

    /// Receives data and sender address, spinning until available.
    pub func recv_from(this, buf: mut ref [U8]) -> Outcome[(I64, SocketAddr), NetError] {
        loop (true) {
            when this.try_recv_from(buf)! {
                Just(result) => return Ok(result)
                Nothing => {}
            }
        }
    }

    /// Tries to send data on a connected socket without blocking.
    pub func try_send(this, buf: ref [U8]) -> Outcome[Maybe[I64], NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected()))
        }
        when this.socket.send(buf) {
            Ok(n) => Ok(Just(n))
            Err(e) => {
                if e.is_would_block() {
                    Ok(Nothing)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Tries to receive data on a connected socket without blocking.
    pub func try_recv(this, buf: mut ref [U8]) -> Outcome[Maybe[I64], NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected()))
        }
        when this.socket.recv(buf) {
            Ok(n) => Ok(Just(n))
            Err(e) => {
                if e.is_would_block() {
                    Ok(Nothing)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Sends data on a connected socket, spinning until complete.
    pub func send(this, buf: ref [U8]) -> Outcome[I64, NetError] {
        loop (true) {
            when this.try_send(buf)! {
                Just(n) => return Ok(n)
                Nothing => {}
            }
        }
    }

    /// Receives data on a connected socket, spinning until available.
    pub func recv(this, buf: mut ref [U8]) -> Outcome[I64, NetError] {
        loop (true) {
            when this.try_recv(buf)! {
                Just(n) => return Ok(n)
                Nothing => {}
            }
        }
    }

    /// Returns the local address.
    pub func local_addr(this) -> Outcome[SocketAddr, NetError] {
        this.socket.local_addr()
    }

    /// Returns the peer address (if connected).
    pub func peer_addr(this) -> Outcome[SocketAddr, NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected()))
        }
        this.socket.peer_addr()
    }

    /// Sets broadcast mode.
    pub func set_broadcast(this, broadcast: Bool) -> Outcome[(), NetError] {
        this.socket.set_broadcast(broadcast)
    }

    /// Returns whether connected.
    pub func is_connected(this) -> Bool {
        this.connected
    }

    /// Returns a reference to the underlying raw socket.
    pub func as_raw_socket(this) -> ref RawSocket {
        ref this.socket
    }

    /// Consumes the socket and returns the underlying raw socket.
    pub func into_raw_socket(this) -> RawSocket {
        this.socket
    }
}

// Extension for UdpSocket
impl UdpSocket {
    /// Creates a UdpSocket from a raw socket.
    pub func from_raw_socket(socket: RawSocket) -> UdpSocket {
        UdpSocket {
            socket: socket,
            connected: false,
        }
    }
}

// ============================================================================
// EventLoop Integration (Phase 4)
// ============================================================================

impl AsyncUdpSocket {
    /// Register this UDP socket with an event loop for async message events.
    ///
    /// Returns the token used to identify this socket's events.
    ///
    /// # Arguments
    /// * `el` — the event loop to register with
    /// * `interests` — bitmask of interests (1=READABLE, 2=WRITABLE, 3=BOTH)
    pub func register_with_loop(this, el: mut ref EventLoop, interests: U32) -> Outcome[U32, Str] {
        let socket_handle: I64 = this.socket.handle
        let token: U32 = el.register(socket_handle, interests)
        return Ok(token)
    }

    /// Unregister this UDP socket from the event loop.
    pub func unregister_from_loop(this, el: mut ref EventLoop, token: U32) {
        el.deregister(token)
    }

    /// Get the raw socket handle for use with an event loop.
    pub func socket_handle(this) -> I64 {
        return this.socket.handle
    }
}

// ============================================================================
// UdpHandle - High-level async UDP with EventLoop integration
// ============================================================================

/// A UDP socket integrated with the event loop.
///
/// Provides callback-based async UDP operations via the EventLoop for
/// handling multiple datagram sources efficiently.
///
/// # Examples
///
/// ```tml
/// use std::aio::EventLoop
/// use std::net::UdpHandle
/// use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr}
///
/// let mut loop: EventLoop = EventLoop::new()
/// let ip: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1)
/// let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(ip, 8000))
/// let mut handle: UdpHandle = UdpHandle::bind(loop as I64, addr)!
/// handle.set_on_message(on_message_fn as I64)
/// handle.register(ref loop)
/// loop.run()
/// handle.close(ref loop)
/// loop.destroy()
/// ```
pub type UdpHandle {
    /// The underlying async UDP socket.
    socket: AsyncUdpSocket,
    /// Reference to the event loop (stored as I64 for callback passing).
    loop_ptr: I64,
    /// Token assigned by the event loop.
    token: U32,
    /// Callback invoked when data is available: func(handle_ptr: I64, data_ptr: I64, len: I64, addr_ptr: I64)
    on_message: I64,
    /// Callback invoked on error: func(handle_ptr: I64, error_code: I64)
    on_error: I64,
}

impl UdpHandle {
    /// Creates a new UDP handle bound to the given address on the event loop.
    pub func bind(loop_ptr: I64, addr: SocketAddr) -> Outcome[UdpHandle, I64] {
        let socket: AsyncUdpSocket = AsyncUdpSocket::bind(ref addr)!

        let token: U32 = 0
        let handle: UdpHandle = UdpHandle {
            socket: socket,
            loop_ptr: loop_ptr,
            token: token,
            on_message: 0,
            on_error: 0,
        }

        Ok(handle)
    }

    /// Registers this UDP handle with the event loop.
    /// Called after construction to activate I/O monitoring.
    pub func register(mut this, loop_ref: ref EventLoop) -> U32 {
        let socket_handle: I64 = this.socket.socket.as_raw() as I64
        let token: U32 = loop_ref.register(socket_handle, READABLE)
        this.token = token

        let state: *Unit = mem_alloc(16)
        let state_i64: I64 = state as I64
        lowlevel { ptr_write[I64](state_i64 as *I64, this as I64) }
        lowlevel { ptr_write[I64]((state_i64 + 8) as *I64, this.loop_ptr) }

        loop_ref.set_user_data(token, state_i64)

        token
    }

    /// Sets the message callback (called when data arrives).
    pub func set_on_message(mut this, callback: I64) {
        this.on_message = callback
    }

    /// Sets the error callback (called on I/O errors).
    pub func set_on_error(mut this, callback: I64) {
        this.on_error = callback
    }

    /// Sends data to the specified address without blocking.
    /// Returns true if sent, false if it would block.
    pub func send_to(this, data: ref [U8], addr: SocketAddr) -> Bool {
        let result = this.socket.try_send_to(data, addr)
        when result {
            Ok(sent) => {
                when sent {
                    Just(_) => true
                    Nothing => false
                }
            }
            Err(_) => false
        }
    }

    /// Closes the UDP handle and deregisters from the event loop.
    pub func close(mut this, loop_ref: ref EventLoop) {
        loop_ref.deregister(this.token)
        this.socket.close()
    }

    /// Closes and deallocates the UDP handle.
    pub func destroy(mut this) {
        this.socket.close()
    }
}
