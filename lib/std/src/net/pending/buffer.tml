//! Buffer management for network I/O operations.
//!
//! This module provides efficient buffer types for network communication:
//!
//! - [`Buffer`] - A growable byte buffer with capacity management
//! - [`BufferView`] - A zero-copy view into a buffer or byte slice
//! - [`BufferPool`] - A pool of pre-allocated buffers for reuse
//!
//! # Performance
//!
//! These types are designed for high-performance network I/O:
//!
//! - `Buffer` uses contiguous memory for cache-friendly access
//! - `BufferView` enables zero-copy reads without allocation
//! - `BufferPool` eliminates allocation overhead in hot paths
//!
//! # Example
//!
//! ```tml
//! use std::net::buffer::{Buffer, BufferPool}
//!
//! // Create a buffer pool
//! let pool = BufferPool::new(16, 4096)  // 16 buffers of 4KB each
//!
//! // Get a buffer from the pool
//! let mut buf = pool.get()
//!
//! // Write data
//! buf.write_bytes(b"Hello, World!")
//!
//! // Read as a view (zero-copy)
//! let view = buf.as_view()
//!
//! // Return buffer to pool for reuse
//! pool.put(buf)
//! ```

use core::alloc::{Layout, AllocError}
use core::mem::size_of

// ============================================================================
// Buffer - Growable byte buffer
// ============================================================================

/// A growable byte buffer for network I/O operations.
///
/// `Buffer` provides efficient append-only writes with automatic growth
/// and zero-copy reads via `BufferView`.
///
/// # Memory Layout
///
/// ```text
/// +----------+----------+-------------+
/// |  data    | len      | capacity    |
/// | (bytes)  | (used)   | (allocated) |
/// +----------+----------+-------------+
/// ```
pub type Buffer {
    /// Pointer to the data
    data: I64,
    /// Number of bytes written
    len: I64,
    /// Total allocated capacity
    capacity: I64,
}

impl Buffer {
    /// Creates a new buffer with the specified initial capacity.
    ///
    /// # Arguments
    ///
    /// * `capacity` - Initial capacity in bytes (minimum 64)
    ///
    /// # Example
    ///
    /// ```tml
    /// let buf = Buffer::new(4096)  // 4KB buffer
    /// ```
    pub func new(capacity: I64) -> Buffer {
        let cap: I64 = if capacity < 64 { 64 } else { capacity }
        let data: I64 = lowlevel { malloc(cap) } as I64

        Buffer {
            data: data,
            len: 0,
            capacity: if data != 0 { cap } else { 0 },
        }
    }

    /// Creates an empty buffer with no allocation.
    pub func empty() -> Buffer {
        Buffer {
            data: 0,
            len: 0,
            capacity: 0,
        }
    }

    /// Creates a buffer with default 4KB capacity.
    pub func default() -> Buffer {
        Buffer::new(4096)
    }

    /// Creates a buffer with 64KB capacity (suitable for network packets).
    pub func large() -> Buffer {
        Buffer::new(65536)
    }

    /// Returns the number of bytes in the buffer.
    pub func len(this) -> I64 {
        this.len
    }

    /// Returns true if the buffer is empty.
    pub func is_empty(this) -> Bool {
        this.len == 0
    }

    /// Returns the total capacity of the buffer.
    pub func capacity(this) -> I64 {
        this.capacity
    }

    /// Returns the remaining space in the buffer.
    pub func remaining(this) -> I64 {
        this.capacity - this.len
    }

    /// Returns a pointer to the data.
    pub func as_ptr(this) -> Ptr[U8] {
        this.data as Ptr[U8]
    }

    /// Returns a mutable pointer to the data.
    pub func as_mut_ptr(mut this) -> Ptr[U8] {
        this.data as Ptr[U8]
    }

    /// Returns a view of the entire buffer contents.
    pub func as_view(this) -> BufferView {
        BufferView::new(this.data, this.len)
    }

    /// Returns a view of a slice of the buffer.
    ///
    /// # Arguments
    ///
    /// * `start` - Start offset (inclusive)
    /// * `end` - End offset (exclusive)
    pub func view_range(this, start: I64, end: I64) -> BufferView {
        let s: I64 = if start < 0 { 0 } else { start }
        let e: I64 = if end > this.len { this.len } else { end }
        let actual_len: I64 = if e > s { e - s } else { 0 }
        BufferView::new(this.data + s, actual_len)
    }

    /// Writes a single byte to the buffer.
    ///
    /// Returns true if successful, false if allocation failed.
    pub func write_byte(mut this, byte: U8) -> Bool {
        if this.len >= this.capacity {
            if not this.grow(this.capacity * 2) {
                return false
            }
        }
        lowlevel { (this.data as Ptr[U8])[this.len] = byte }
        this.len = this.len + 1
        true
    }

    /// Writes bytes from a slice to the buffer.
    ///
    /// # Returns
    ///
    /// Number of bytes written.
    pub func write_bytes(mut this, bytes: ref [U8]) -> I64 {
        let count: I64 = bytes.len()
        if count == 0 {
            return 0
        }

        // Ensure capacity
        let required: I64 = this.len + count
        if required > this.capacity {
            let new_cap: I64 = max_i64(required, this.capacity * 2)
            if not this.grow(new_cap) {
                return 0
            }
        }

        // Copy bytes
        var i: I64 = 0
        loop {
            if i >= count { break }
            lowlevel { (this.data as Ptr[U8])[this.len + i] = bytes[i] }
            i = i + 1
        }

        this.len = this.len + count
        count
    }

    /// Writes bytes from a view to the buffer.
    pub func write_from_view(mut this, view: ref BufferView) -> I64 {
        if view.len() == 0 {
            return 0
        }

        let count: I64 = view.len()
        let required: I64 = this.len + count
        if required > this.capacity {
            let new_cap: I64 = max_i64(required, this.capacity * 2)
            if not this.grow(new_cap) {
                return 0
            }
        }

        // Copy from view
        var i: I64 = 0
        loop {
            if i >= count { break }
            let byte: U8 = view.get(i)
            lowlevel { (this.data as Ptr[U8])[this.len + i] = byte }
            i = i + 1
        }

        this.len = this.len + count
        count
    }

    /// Reads bytes into a destination slice.
    ///
    /// # Arguments
    ///
    /// * `offset` - Start position in the buffer
    /// * `dest` - Destination slice
    ///
    /// # Returns
    ///
    /// Number of bytes read.
    pub func read_into(this, offset: I64, dest: mut ref [U8]) -> I64 {
        if offset >= this.len {
            return 0
        }

        let available: I64 = this.len - offset
        let count: I64 = min_i64(available, dest.len())

        var i: I64 = 0
        loop {
            if i >= count { break }
            dest[i] = lowlevel { (this.data as Ptr[U8])[offset + i] }
            i = i + 1
        }

        count
    }

    /// Gets a byte at the specified index.
    pub func get(this, index: I64) -> Maybe[U8] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        Just(lowlevel { (this.data as Ptr[U8])[index] })
    }

    /// Sets a byte at the specified index.
    pub func set(mut this, index: I64, value: U8) -> Bool {
        if index < 0 or index >= this.len {
            return false
        }
        lowlevel { (this.data as Ptr[U8])[index] = value }
        true
    }

    /// Clears the buffer without deallocating memory.
    pub func clear(mut this) {
        this.len = 0
    }

    /// Resets the buffer and zeroes all memory.
    pub func reset(mut this) {
        if this.data != 0 and this.capacity > 0 {
            var i: I64 = 0
            loop {
                if i >= this.capacity { break }
                lowlevel { (this.data as Ptr[U8])[i] = 0 }
                i = i + 1
            }
        }
        this.len = 0
    }

    /// Truncates the buffer to the specified length.
    pub func truncate(mut this, new_len: I64) {
        if new_len < this.len {
            this.len = if new_len < 0 { 0 } else { new_len }
        }
    }

    /// Reserves additional capacity.
    ///
    /// # Arguments
    ///
    /// * `additional` - Number of additional bytes to reserve
    ///
    /// # Returns
    ///
    /// True if reservation succeeded.
    pub func reserve(mut this, additional: I64) -> Bool {
        let required: I64 = this.len + additional
        if required <= this.capacity {
            return true
        }
        this.grow(required)
    }

    /// Grows the buffer to at least the specified capacity.
    func grow(mut this, min_capacity: I64) -> Bool {
        let new_cap: I64 = if min_capacity < 64 { 64 } else { min_capacity }

        if this.data == 0 {
            // First allocation
            let new_data: I64 = lowlevel { malloc(new_cap) } as I64
            if new_data == 0 {
                return false
            }
            this.data = new_data
            this.capacity = new_cap
            return true
        }

        // Reallocate
        let new_data: I64 = lowlevel { realloc(this.data as Ptr[U8], new_cap) } as I64
        if new_data == 0 {
            return false
        }
        this.data = new_data
        this.capacity = new_cap
        true
    }

    /// Frees the buffer memory.
    pub func free(mut this) {
        if this.data != 0 {
            lowlevel { free(this.data as Ptr[U8]) }
            this.data = 0
            this.len = 0
            this.capacity = 0
        }
    }
}

impl Drop for Buffer {
    func drop(mut this) {
        this.free()
    }
}

// ============================================================================
// BufferView - Zero-copy view into byte data
// ============================================================================

/// A zero-copy view into a byte buffer or slice.
///
/// `BufferView` provides read-only access to byte data without
/// copying, enabling efficient data handling in network protocols.
///
/// # Safety
///
/// The view does not own the underlying data. The source buffer
/// must outlive the view.
pub type BufferView {
    /// Pointer to the data
    data: I64,
    /// Length of the view in bytes
    len: I64,
}

impl BufferView {
    /// Creates a new view from a pointer and length.
    pub func new(data: I64, len: I64) -> BufferView {
        BufferView {
            data: data,
            len: if len < 0 { 0 } else { len },
        }
    }

    /// Creates an empty view.
    pub func empty() -> BufferView {
        BufferView { data: 0, len: 0 }
    }

    /// Creates a view from a byte slice.
    pub func from_slice(slice: ref [U8]) -> BufferView {
        BufferView {
            data: slice.as_ptr() as I64,
            len: slice.len(),
        }
    }

    /// Returns the length of the view.
    pub func len(this) -> I64 {
        this.len
    }

    /// Returns true if the view is empty.
    pub func is_empty(this) -> Bool {
        this.len == 0
    }

    /// Gets a byte at the specified index.
    pub func get(this, index: I64) -> U8 {
        if index < 0 or index >= this.len {
            return 0
        }
        lowlevel { (this.data as Ptr[U8])[index] }
    }

    /// Gets a byte at the specified index, with bounds checking.
    pub func get_checked(this, index: I64) -> Maybe[U8] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        Just(lowlevel { (this.data as Ptr[U8])[index] })
    }

    /// Returns a subview of this view.
    ///
    /// # Arguments
    ///
    /// * `start` - Start offset (inclusive)
    /// * `end` - End offset (exclusive)
    pub func slice(this, start: I64, end: I64) -> BufferView {
        let s: I64 = if start < 0 { 0 } else { start }
        let e: I64 = if end > this.len { this.len } else { end }
        let new_len: I64 = if e > s { e - s } else { 0 }
        BufferView::new(this.data + s, new_len)
    }

    /// Returns a view starting from offset.
    pub func skip(this, offset: I64) -> BufferView {
        this.slice(offset, this.len)
    }

    /// Returns a view of the first n bytes.
    pub func take(this, n: I64) -> BufferView {
        this.slice(0, n)
    }

    /// Copies the view contents into a destination slice.
    ///
    /// # Returns
    ///
    /// Number of bytes copied.
    pub func copy_to(this, dest: mut ref [U8]) -> I64 {
        let count: I64 = min_i64(this.len, dest.len())
        var i: I64 = 0
        loop {
            if i >= count { break }
            dest[i] = lowlevel { (this.data as Ptr[U8])[i] }
            i = i + 1
        }
        count
    }

    /// Compares this view with another view for equality.
    pub func equals(this, other: ref BufferView) -> Bool {
        if this.len != other.len {
            return false
        }

        var i: I64 = 0
        loop {
            if i >= this.len { break }
            if this.get(i) != other.get(i) {
                return false
            }
            i = i + 1
        }
        true
    }

    /// Finds the first occurrence of a byte.
    pub func find_byte(this, byte: U8) -> Maybe[I64] {
        var i: I64 = 0
        loop {
            if i >= this.len { break }
            if this.get(i) == byte {
                return Just(i)
            }
            i = i + 1
        }
        Nothing
    }

    /// Checks if the view starts with the given prefix.
    pub func starts_with(this, prefix: ref BufferView) -> Bool {
        if prefix.len > this.len {
            return false
        }
        this.take(prefix.len).equals(prefix)
    }

    /// Checks if the view ends with the given suffix.
    pub func ends_with(this, suffix: ref BufferView) -> Bool {
        if suffix.len > this.len {
            return false
        }
        this.skip(this.len - suffix.len).equals(suffix)
    }

    /// Returns true if all bytes are ASCII.
    pub func is_ascii(this) -> Bool {
        var i: I64 = 0
        loop {
            if i >= this.len { break }
            if this.get(i) > 127 {
                return false
            }
            i = i + 1
        }
        true
    }
}

impl Copy for BufferView {}

impl Duplicate for BufferView {
    func duplicate(this) -> BufferView {
        BufferView { data: this.data, len: this.len }
    }
}

impl PartialEq for BufferView {
    func eq(this, other: ref BufferView) -> Bool {
        this.equals(other)
    }
}

impl Eq for BufferView {}

// ============================================================================
// BufferPool - Pre-allocated buffer pool
// ============================================================================

/// A pool of pre-allocated buffers for efficient reuse.
///
/// `BufferPool` eliminates allocation overhead in hot paths by
/// maintaining a set of reusable buffers. When a buffer is needed,
/// it's taken from the pool; when done, it's returned for reuse.
///
/// # Thread Safety
///
/// This implementation is NOT thread-safe. Use one pool per thread
/// or wrap in a mutex for multi-threaded access.
///
/// # Example
///
/// ```tml
/// let pool = BufferPool::new(8, 4096)  // 8 buffers of 4KB
///
/// // Get a buffer
/// let buf = pool.get()
///
/// // Use it...
/// buf.write_bytes(data)
///
/// // Return to pool
/// pool.put(buf)
/// ```
pub type BufferPool {
    /// Available buffers
    buffers: List[Buffer],
    /// Buffer capacity for new buffers
    buffer_capacity: I64,
    /// Maximum number of buffers to keep
    max_buffers: I64,
    /// Statistics
    stats: BufferPoolStats,
}

/// Statistics for buffer pool usage.
pub type BufferPoolStats {
    /// Total number of get() calls
    pub gets: I64,
    /// Number of buffers returned from pool
    pub hits: I64,
    /// Number of new allocations
    pub misses: I64,
    /// Total number of put() calls
    pub puts: I64,
    /// Number of buffers discarded (pool full)
    pub discards: I64,
}

impl BufferPoolStats {
    /// Creates empty statistics.
    pub func new() -> BufferPoolStats {
        BufferPoolStats {
            gets: 0,
            hits: 0,
            misses: 0,
            puts: 0,
            discards: 0,
        }
    }

    /// Returns the hit rate as a percentage (0-100).
    pub func hit_rate(this) -> F64 {
        if this.gets == 0 {
            return 0.0
        }
        (this.hits as F64 / this.gets as F64) * 100.0
    }
}

impl BufferPool {
    /// Creates a new buffer pool.
    ///
    /// # Arguments
    ///
    /// * `max_buffers` - Maximum number of buffers to keep in pool
    /// * `buffer_capacity` - Capacity for each buffer
    ///
    /// # Example
    ///
    /// ```tml
    /// let pool = BufferPool::new(16, 4096)  // 16 buffers of 4KB
    /// ```
    pub func new(max_buffers: I64, buffer_capacity: I64) -> BufferPool {
        BufferPool {
            buffers: [],
            buffer_capacity: if buffer_capacity < 64 { 64 } else { buffer_capacity },
            max_buffers: if max_buffers < 1 { 1 } else { max_buffers },
            stats: BufferPoolStats::new(),
        }
    }

    /// Creates a pool with default settings (16 buffers of 4KB).
    pub func default() -> BufferPool {
        BufferPool::new(16, 4096)
    }

    /// Creates a small pool (8 buffers of 1KB).
    pub func small() -> BufferPool {
        BufferPool::new(8, 1024)
    }

    /// Creates a large pool (32 buffers of 64KB).
    pub func large() -> BufferPool {
        BufferPool::new(32, 65536)
    }

    /// Pre-allocates buffers to warm up the pool.
    ///
    /// # Arguments
    ///
    /// * `count` - Number of buffers to pre-allocate
    pub func warm_up(mut this, count: I64) {
        let n: I64 = min_i64(count, this.max_buffers)
        var i: I64 = 0
        loop {
            if i >= n { break }
            if this.buffers.len() >= this.max_buffers { break }
            this.buffers.push(Buffer::new(this.buffer_capacity))
            i = i + 1
        }
    }

    /// Gets a buffer from the pool.
    ///
    /// Returns a pooled buffer if available, otherwise allocates a new one.
    pub func get(mut this) -> Buffer {
        this.stats.gets = this.stats.gets + 1

        when this.buffers.pop() {
            Just(buf) => {
                this.stats.hits = this.stats.hits + 1
                return buf
            }
            Nothing => {
                this.stats.misses = this.stats.misses + 1
                return Buffer::new(this.buffer_capacity)
            }
        }
    }

    /// Returns a buffer to the pool.
    ///
    /// The buffer is cleared before being added to the pool.
    /// If the pool is full, the buffer is discarded.
    pub func put(mut this, mut buf: Buffer) {
        this.stats.puts = this.stats.puts + 1

        if this.buffers.len() >= this.max_buffers {
            // Pool is full, discard the buffer
            this.stats.discards = this.stats.discards + 1
            buf.free()
            return
        }

        // Clear and return to pool
        buf.clear()
        this.buffers.push(buf)
    }

    /// Returns the number of available buffers in the pool.
    pub func available(this) -> I64 {
        this.buffers.len()
    }

    /// Returns the maximum pool size.
    pub func max_size(this) -> I64 {
        this.max_buffers
    }

    /// Returns pool statistics.
    pub func stats(this) -> BufferPoolStats {
        this.stats
    }

    /// Clears all buffers from the pool.
    pub func clear(mut this) {
        loop {
            when this.buffers.pop() {
                Just(mut buf) => buf.free()
                Nothing => break
            }
        }
    }

    /// Shrinks the pool to the specified size.
    pub func shrink_to(mut this, size: I64) {
        loop {
            if this.buffers.len() <= size { break }
            when this.buffers.pop() {
                Just(mut buf) => buf.free()
                Nothing => break
            }
        }
    }
}

impl Drop for BufferPool {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// Helper functions
// ============================================================================

/// Returns the maximum of two I64 values.
func max_i64(a: I64, b: I64) -> I64 {
    if a > b {
        return a
    } else {
        return b
    }
}

/// Returns the minimum of two I64 values.
func min_i64(a: I64, b: I64) -> I64 {
    if a < b {
        return a
    } else {
        return b
    }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_buffer_creation() {
    let buf: Buffer = Buffer::new(1024)
    assert_eq(buf.capacity(), 1024)
    assert_eq(buf.len(), 0)
    assert(buf.is_empty())
}

@test
func test_buffer_write_byte() {
    var buf: Buffer = Buffer::new(64)

    assert(buf.write_byte(0x48 as U8))  // 'H'
    assert(buf.write_byte(0x69 as U8))  // 'i'

    assert_eq(buf.len(), 2)
    assert_eq(buf.get(0), Just(0x48 as U8))
    assert_eq(buf.get(1), Just(0x69 as U8))
}

@test
func test_buffer_write_bytes() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 5] = [0x48 as U8, 0x65 as U8, 0x6c as U8, 0x6c as U8, 0x6f as U8]  // "Hello"

    let written: I64 = buf.write_bytes(ref data)
    assert_eq(written, 5)
    assert_eq(buf.len(), 5)
}

@test
func test_buffer_read_into() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 5] = [0x48 as U8, 0x65 as U8, 0x6c as U8, 0x6c as U8, 0x6f as U8]
    buf.write_bytes(ref data)

    var dest: [U8; 10] = [0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8, 0 as U8]
    let read: I64 = buf.read_into(0, mut ref dest)

    assert_eq(read, 5)
    assert_eq(dest[0], 0x48 as U8)
    assert_eq(dest[4], 0x6f as U8)
}

@test
func test_buffer_growth() {
    var buf: Buffer = Buffer::new(64)

    // Write more than initial capacity
    var i: I64 = 0
    loop {
        if i >= 200 { break }
        buf.write_byte((i and 0xFF) as U8)
        i = i + 1
    }

    assert_eq(buf.len(), 200)
    assert(buf.capacity() >= 200)
}

@test
func test_buffer_view_creation() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 5] = [1 as U8, 2 as U8, 3 as U8, 4 as U8, 5 as U8]
    buf.write_bytes(ref data)

    let view: BufferView = buf.as_view()
    assert_eq(view.len(), 5)
    assert_eq(view.get(0), 1 as U8)
    assert_eq(view.get(4), 5 as U8)
}

@test
func test_buffer_view_slice() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 10] = [0 as U8, 1 as U8, 2 as U8, 3 as U8, 4 as U8, 5 as U8, 6 as U8, 7 as U8, 8 as U8, 9 as U8]
    buf.write_bytes(ref data)

    let view: BufferView = buf.as_view()
    let sub: BufferView = view.slice(2, 7)

    assert_eq(sub.len(), 5)
    assert_eq(sub.get(0), 2 as U8)
    assert_eq(sub.get(4), 6 as U8)
}

@test
func test_buffer_view_find_byte() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 5] = [0x48 as U8, 0x65 as U8, 0x6c as U8, 0x6c as U8, 0x6f as U8]  // "Hello"
    buf.write_bytes(ref data)

    let view: BufferView = buf.as_view()

    assert_eq(view.find_byte(0x6c as U8), Just(2 as I64))  // First 'l'
    assert_eq(view.find_byte(0x78 as U8), Nothing)  // 'x' not found
}

@test
func test_buffer_pool_basic() {
    var pool: BufferPool = BufferPool::new(4, 1024)

    // Get a buffer
    var buf1: Buffer = pool.get()
    assert_eq(buf1.capacity(), 1024)

    // Return it
    buf1.write_byte(0x42 as U8)
    pool.put(buf1)

    assert_eq(pool.available(), 1)

    // Get again - should be from pool
    let buf2: Buffer = pool.get()
    assert_eq(buf2.capacity(), 1024)
    assert_eq(buf2.len(), 0)  // Should be cleared

    assert_eq(pool.stats().hits, 1)
}

@test
func test_buffer_pool_overflow() {
    var pool: BufferPool = BufferPool::new(2, 1024)

    // Fill the pool
    pool.put(Buffer::new(1024))
    pool.put(Buffer::new(1024))

    // Pool is full, this should be discarded
    pool.put(Buffer::new(1024))

    assert_eq(pool.available(), 2)
    assert_eq(pool.stats().discards, 1)
}

@test
func test_buffer_pool_warm_up() {
    var pool: BufferPool = BufferPool::new(8, 1024)

    pool.warm_up(4)
    assert_eq(pool.available(), 4)

    // Getting should be hits
    let _b1: Buffer = pool.get()
    let _b2: Buffer = pool.get()

    assert_eq(pool.stats().hits, 2)
    assert_eq(pool.stats().misses, 0)
}

@test
func test_buffer_clear_and_reset() {
    var buf: Buffer = Buffer::new(64)
    let data: [U8; 5] = [1 as U8, 2 as U8, 3 as U8, 4 as U8, 5 as U8]
    buf.write_bytes(ref data)

    buf.clear()
    assert_eq(buf.len(), 0)
    assert_eq(buf.capacity(), 64)  // Capacity unchanged

    buf.write_bytes(ref data)
    buf.reset()
    assert_eq(buf.len(), 0)
}

@test
func test_buffer_view_equality() {
    var buf1: Buffer = Buffer::new(64)
    var buf2: Buffer = Buffer::new(64)
    let data: [U8; 5] = [1 as U8, 2 as U8, 3 as U8, 4 as U8, 5 as U8]

    buf1.write_bytes(ref data)
    buf2.write_bytes(ref data)

    let view1: BufferView = buf1.as_view()
    let view2: BufferView = buf2.as_view()

    assert(view1.equals(ref view2))
    assert(view1 == view2)
}
