//! Async TCP networking primitives.
//!
//! This module provides async versions of TCP socket types for non-blocking,
//! event-driven I/O operations.
//!
//! # Types
//!
//! - [`AsyncTcpListener`] - Async listener for incoming TCP connections
//! - [`AsyncTcpStream`] - Async connected TCP socket
//!
//! # Event Loop Integration
//!
//! These types are designed to work with an async runtime/event loop.
//! They use non-blocking I/O and return `Poll` results that indicate
//! whether an operation is ready or would block.
//!
//! # Example: Async Echo Server
//!
//! ```tml
//! use std::net::async_tcp::{AsyncTcpListener, AsyncTcpStream}
//! use std::net::{SocketAddr, Ipv4Addr}
//!
//! async func echo_server() -> Outcome[(), NetError] {
//!     let addr = SocketAddr::new(Ipv4Addr::LOCALHOST, 8080)
//!     let listener = AsyncTcpListener::bind(addr).await!
//!
//!     loop {
//!         let (stream, peer) = listener.accept().await!
//!         spawn(handle_client(stream))
//!     }
//! }
//!
//! async func handle_client(mut stream: AsyncTcpStream) {
//!     var buf: [U8; 1024] = [0; 1024]
//!     loop {
//!         let n = stream.read(mut ref buf).await!
//!         if n == 0 { break }
//!         stream.write_all(ref buf[0..n]).await!
//!     }
//! }
//! ```

use std::net::{SocketAddr, SocketAddrV4, SocketAddrV6, IpAddr, Ipv4Addr}
use std::net::error::{NetError, NetErrorKind}
use std::net::sys::{RawSocket, SocketType, SocketProtocol, AddressFamily, ShutdownMode}
use std::net::tcp::{Shutdown, TcpStream, TcpListener}
use core::time::Duration
use core::task::Poll

// ============================================================================
// Simplified Waker and Context
// ============================================================================
// Note: These are simplified versions for basic async I/O use.
// For full async runtime integration, use core::task::{Waker, Context}
// which require implementing RawWaker vtables.

/// A simplified waker handle for basic async operations.
///
/// This is a simplified version that doesn't require the full
/// RawWaker vtable implementation needed by core::task::Waker.
pub type Waker {
    /// Opaque pointer to waker implementation
    data: I64,
    /// Wake function pointer
    wake_fn: I64,
}

impl Waker {
    /// Creates a no-op waker (does nothing when woken).
    pub func noop() -> Waker {
        Waker { data: 0, wake_fn: 0 }
    }

    /// Wakes the associated task.
    pub func wake(this) {
        if this.wake_fn != 0 {
            // In a full implementation, this would call through the function pointer
        }
    }

    /// Wakes the associated task by reference.
    pub func wake_by_ref(this) {
        this.wake()
    }
}

impl Duplicate for Waker {
    func duplicate(this) -> Waker {
        Waker { data: this.data, wake_fn: this.wake_fn }
    }
}

/// A simplified context for async operations.
///
/// Provides access to the waker for the current task.
pub type Context {
    waker: Waker,
}

impl Context {
    /// Creates a new context with the given waker.
    pub func new(waker: Waker) -> Context {
        Context { waker: waker }
    }

    /// Returns the waker for this context.
    pub func waker(this) -> Waker {
        this.waker
    }
}

// ============================================================================
// AsyncTcpListener
// ============================================================================

/// An async TCP socket server, listening for connections.
///
/// This is the async equivalent of `TcpListener`. It uses non-blocking I/O
/// and integrates with an async runtime for efficient event-driven operation.
///
/// # Examples
///
/// ```tml
/// let listener = AsyncTcpListener::bind("127.0.0.1:8080".parse()?).await!
///
/// loop {
///     let (stream, addr) = listener.accept().await!
///     spawn(handle_connection(stream))
/// }
/// ```
pub type AsyncTcpListener {
    /// The underlying non-blocking socket
    socket: RawSocket,
}

impl AsyncTcpListener {
    /// Creates a new async `TcpListener` bound to the specified address.
    ///
    /// The socket is set to non-blocking mode automatically.
    pub func bind(addr: SocketAddr) -> Outcome[AsyncTcpListener, NetError] {
        let family: AddressFamily = AddressFamily::from_addr(ref addr)
        var socket: RawSocket = RawSocket::new_with_family(family, SocketType::Stream, SocketProtocol::Tcp)!

        socket.set_reuse_addr(true)!
        socket.bind(ref addr)!
        socket.listen(128)!
        socket.set_nonblocking(true)!

        let listener: AsyncTcpListener = AsyncTcpListener { socket: socket }
        Ok(listener)
    }

    /// Creates an async listener from a synchronous one.
    ///
    /// The socket is set to non-blocking mode.
    pub func from_std(mut listener: TcpListener) -> Outcome[AsyncTcpListener, NetError] {
        let socket: RawSocket = listener.into_raw_socket()
        var async_listener: AsyncTcpListener = AsyncTcpListener {
            socket: socket,
        }
        async_listener.socket.set_nonblocking(true)!
        Ok(async_listener)
    }

    /// Polls for an incoming connection.
    ///
    /// Returns `Poll::Ready` when a connection is available, or
    /// `Poll::Pending` if no connection is ready.
    pub func poll_accept(this, cx: mut ref Context) -> Poll[Outcome[(AsyncTcpStream, SocketAddr), NetError]] {
        when this.socket.accept() {
            Ok(result) => {
                var stream_socket: RawSocket = result.0
                let peer_addr: SocketAddr = result.1
                // Set the new socket to non-blocking
                when stream_socket.set_nonblocking(true) {
                    Ok(()) => {}
                    Err(e) => return Poll::Ready(Err(e))
                }
                let stream: AsyncTcpStream = AsyncTcpStream { socket: stream_socket }
                Poll::Ready(Ok((stream, peer_addr)))
            }
            Err(e) => {
                if e.is_would_block() {
                    // Register interest in readability with the event loop
                    // In a real implementation, we would register the socket
                    // with the reactor and store the waker
                    Poll::Pending
                } else {
                    Poll::Ready(Err(e))
                }
            }
        }
    }

    /// Accepts a new incoming connection (async).
    ///
    /// This is the async equivalent of `TcpListener::accept()`.
    pub async func accept(this) -> Outcome[(AsyncTcpStream, SocketAddr), NetError] {
        // In a real async implementation, this would:
        // 1. Try poll_accept
        // 2. If Pending, yield to the runtime
        // 3. When woken, try again

        // For now, we spin-poll (not ideal but functional)
        loop {
            when this.poll_accept(mut ref Context::new(Waker::noop())) {
                Poll::Ready(result) => return result
                Poll::Pending => {
                    // Yield to runtime - in real impl, this would suspend
                    // For now, just continue polling
                }
            }
        }
    }

    /// Returns the local socket address.
    pub func local_addr(this) -> Outcome[SocketAddr, NetError] {
        this.socket.local_addr()
    }

    /// Sets the value of `SO_REUSEADDR`.
    pub func set_reuse_addr(this, reuse: Bool) -> Outcome[(), NetError] {
        this.socket.set_reuse_addr(reuse)
    }

    /// Converts to a synchronous listener.
    pub func into_std(this) -> TcpListener {
        // Note: caller should set blocking mode if needed
        TcpListener::from_raw_socket(this.socket)
    }
}

// ============================================================================
// AsyncTcpStream
// ============================================================================

/// An async TCP stream between a local and a remote socket.
///
/// This is the async equivalent of `TcpStream`. It uses non-blocking I/O
/// for efficient event-driven operation.
///
/// # Examples
///
/// ```tml
/// let mut stream = AsyncTcpStream::connect("127.0.0.1:8080".parse()?).await!
///
/// stream.write_all(b"hello").await!
/// let n = stream.read(mut ref buf).await!
/// ```
pub type AsyncTcpStream {
    /// The underlying non-blocking socket
    socket: RawSocket,
}

impl AsyncTcpStream {
    /// Opens an async TCP connection to a remote host.
    pub func connect(addr: SocketAddr) -> Outcome[AsyncTcpStream, NetError] {
        let family: AddressFamily = AddressFamily::from_addr(ref addr)
        var socket: RawSocket = RawSocket::new_with_family(family, SocketType::Stream, SocketProtocol::Tcp)!

        socket.set_nonblocking(true)!

        // Non-blocking connect
        when socket.connect(ref addr) {
            Ok(()) => {
                // Connected immediately
                let stream: AsyncTcpStream = AsyncTcpStream { socket: socket }
                Ok(stream)
            }
            Err(e) => {
                if e.is_would_block() {
                    // Connection in progress
                    // In a real implementation, we would wait for writability
                    let stream: AsyncTcpStream = AsyncTcpStream { socket: socket }
                    Ok(stream)
                } else {
                    Err(e)
                }
            }
        }
    }

    /// Creates an async stream from a synchronous one.
    pub func from_std(mut stream: TcpStream) -> Outcome[AsyncTcpStream, NetError] {
        let socket: RawSocket = stream.into_raw_socket()
        var async_stream: AsyncTcpStream = AsyncTcpStream {
            socket: socket,
        }
        async_stream.socket.set_nonblocking(true)!
        Ok(async_stream)
    }

    /// Polls for read readiness.
    pub func poll_read(this, cx: mut ref Context, buf: mut ref [U8]) -> Poll[Outcome[I64, NetError]] {
        when this.socket.recv(buf) {
            Ok(n) => Poll::Ready(Ok(n))
            Err(e) => {
                if e.is_would_block() {
                    // Register interest in readability
                    Poll::Pending
                } else {
                    Poll::Ready(Err(e))
                }
            }
        }
    }

    /// Polls for write readiness.
    pub func poll_write(this, cx: mut ref Context, buf: ref [U8]) -> Poll[Outcome[I64, NetError]] {
        when this.socket.send(buf) {
            Ok(n) => Poll::Ready(Ok(n))
            Err(e) => {
                if e.is_would_block() {
                    // Register interest in writability
                    Poll::Pending
                } else {
                    Poll::Ready(Err(e))
                }
            }
        }
    }

    /// Reads data from the stream (async).
    pub async func read(this, buf: mut ref [U8]) -> Outcome[I64, NetError] {
        loop {
            when this.poll_read(mut ref Context::new(Waker::noop()), buf) {
                Poll::Ready(result) => return result
                Poll::Pending => {
                    // Yield to runtime
                }
            }
        }
    }

    /// Reads exactly `buf.len()` bytes (async).
    pub async func read_exact(this, buf: mut ref [U8]) -> Outcome[(), NetError] {
        var total: I64 = 0
        let len: I64 = buf.len()

        loop {
            if total >= len { break }

            var slice: mut ref [U8] = buf.slice_mut(total, len)
            let n: I64 = this.read(slice).await!

            if n == 0 {
                return Err(NetError::new(NetErrorKind::UnexpectedEof))
            }
            total = total + n
        }
        Ok(())
    }

    /// Writes data to the stream (async).
    pub async func write(this, buf: ref [U8]) -> Outcome[I64, NetError] {
        loop {
            when this.poll_write(mut ref Context::new(Waker::noop()), buf) {
                Poll::Ready(result) => return result
                Poll::Pending => {
                    // Yield to runtime
                }
            }
        }
    }

    /// Writes all data to the stream (async).
    pub async func write_all(this, buf: ref [U8]) -> Outcome[(), NetError] {
        var total: I64 = 0
        let len: I64 = buf.len()

        loop {
            if total >= len { break }

            let slice: ref [U8] = buf.slice(total, len)
            let n: I64 = this.write(slice).await!

            if n == 0 {
                return Err(NetError::new(NetErrorKind::ConnectionReset))
            }
            total = total + n
        }
        Ok(())
    }

    /// Flushes the stream (async).
    pub async func flush(this) -> Outcome[(), NetError] {
        // TCP sends immediately, no buffering
        Ok(())
    }

    /// Shuts down the stream.
    pub func shutdown(this, how: Shutdown) -> Outcome[(), NetError] {
        let mode: ShutdownMode = when how {
            Shutdown::Read => ShutdownMode::Read
            Shutdown::Write => ShutdownMode::Write
            Shutdown::Both => ShutdownMode::Both
        }
        this.socket.shutdown(mode)
    }

    /// Returns the peer address.
    pub func peer_addr(this) -> Outcome[SocketAddr, NetError] {
        this.socket.peer_addr()
    }

    /// Returns the local address.
    pub func local_addr(this) -> Outcome[SocketAddr, NetError] {
        this.socket.local_addr()
    }

    /// Sets TCP_NODELAY option.
    pub func set_nodelay(this, nodelay: Bool) -> Outcome[(), NetError] {
        this.socket.set_nodelay(nodelay)
    }

    /// Sets SO_KEEPALIVE option.
    pub func set_keepalive(this, keepalive: Bool) -> Outcome[(), NetError] {
        this.socket.set_keepalive(keepalive)
    }

    /// Converts to a synchronous stream.
    pub func into_std(this) -> TcpStream {
        // Note: caller should set blocking mode if needed
        TcpStream::from_raw_socket(this.socket)
    }
}

// ============================================================================
// TcpListener extension for from_raw_socket
// ============================================================================

impl TcpListener {
    /// Creates a TcpListener from a raw socket.
    pub func from_raw_socket(socket: RawSocket) -> TcpListener {
        TcpListener {
            socket: socket,
        }
    }
}

impl TcpStream {
    /// Creates a TcpStream from a raw socket.
    pub func from_raw_socket(socket: RawSocket) -> TcpStream {
        TcpStream {
            socket: socket,
        }
    }
}

// ============================================================================
// AsyncRead and AsyncWrite behaviors
// ============================================================================

/// Async read behavior.
pub behavior AsyncRead {
    async func read(mut self, buf: mut ref [U8]) -> Outcome[I64, IoError]
}

/// Async write behavior.
pub behavior AsyncWrite {
    async func write(mut self, buf: ref [U8]) -> Outcome[I64, IoError]
    async func flush(mut self) -> Outcome[(), IoError]
}

/// I/O error type (bridge to NetError).
pub type IoError {
    inner: NetError,
}

impl IoError {
    pub func from_net_error(e: NetError) -> IoError {
        IoError { inner: e }
    }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_poll_enum() {
    let ready: Poll[I32] = Poll::Ready(42)
    let pending: Poll[I32] = Poll::Pending

    assert(ready.is_ready())
    assert(not ready.is_pending())

    // Extract value using pattern matching
    when ready {
        Poll::Ready(v) => assert_eq(v, 42)
        Poll::Pending => assert(false)
    }

    assert(pending.is_pending())
    assert(not pending.is_ready())
}

@test
func test_poll_ready_method() {
    let ready: Poll[I32] = Poll::Ready(10)
    let pending: Poll[I32] = Poll::Pending

    // Test ready() method which returns Maybe[T]
    when ready.ready() {
        Just(v) => assert_eq(v, 10)
        Nothing => assert(false)
    }

    when pending.ready() {
        Just(_) => assert(false)
        Nothing => assert(true)
    }
}

@test
func test_waker_creation() {
    let waker: Waker = Waker::noop()
    waker.wake()  // Should not crash
    waker.wake_by_ref()  // Should not crash
}

@test
func test_context_creation() {
    let waker: Waker = Waker::noop()
    let ctx: Context = Context::new(waker)
    let w: Waker = ctx.waker()
    w.wake()  // Should not crash
}
