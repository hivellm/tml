//! UDP networking primitives.
//!
//! This module provides UDP socket types for connectionless, datagram-based
//! communication.
//!
//! # Types
//!
//! - [`UdpSocket`] - A UDP socket for sending and receiving datagrams
//!
//! # UDP vs TCP
//!
//! UDP (User Datagram Protocol) differs from TCP in several ways:
//!
//! - **Connectionless**: No connection establishment; send to any address
//! - **Unreliable**: Packets may be lost, duplicated, or arrive out of order
//! - **Message-oriented**: Each send/receive is a discrete message
//! - **Lower latency**: No connection overhead or retransmission delays
//!
//! # Example: UDP Echo Server
//!
//! ```tml
//! use std::net::udp::UdpSocket
//! use std::net::{SocketAddr, Ipv4Addr}
//!
//! func main() -> Outcome[(), NetError] {
//!     let addr = SocketAddr::new(Ipv4Addr::LOCALHOST, 8080)
//!     let socket = UdpSocket::bind(addr)!
//!
//!     var buf: [U8; 1024] = [0; 1024]
//!     loop (true) {
//!         let (n, src) = socket.recv_from(mut ref buf)!
//!         socket.send_to(ref buf[0..n], src)!
//!     }
//! }
//! ```
//!
//! # Example: UDP Client
//!
//! ```tml
//! use std::net::udp::UdpSocket
//! use std::net::{SocketAddr, Ipv4Addr}
//!
//! func main() -> Outcome[(), NetError] {
//!     // Bind to any available port
//!     let socket = UdpSocket::bind("0.0.0.0:0".parse()?)!
//!
//!     // Send to server
//!     let server = SocketAddr::new(Ipv4Addr::LOCALHOST, 8080)
//!     socket.send_to(b"Hello, UDP!", server)!
//!
//!     // Receive response
//!     var buf: [U8; 1024] = [0; 1024]
//!     let (n, _) = socket.recv_from(mut ref buf)!
//!     print("Received: {}\n", Str::from_utf8(ref buf[0..n]))
//!
//!     Ok(())
//! }
//! ```
//!
//! # Connected UDP
//!
//! UDP sockets can be "connected" to a remote address, which:
//! - Filters incoming packets to only those from the connected address
//! - Allows using `send()` and `recv()` instead of `send_to()`/`recv_from()`
//!
//! ```tml
//! let socket = UdpSocket::bind("0.0.0.0:0".parse()?)!
//! socket.connect("127.0.0.1:8080".parse()?)!
//!
//! // Now can use send/recv instead of send_to/recv_from
//! socket.send(b"Hello")!
//! let n = socket.recv(mut ref buf)!
//! ```

use std::net::{SocketAddr, SocketAddrV4, SocketAddrV6, IpAddr, Ipv4Addr, Ipv6Addr}
use std::net::error::{NetError, NetErrorKind}
use std::net::sys::{RawSocket, SocketType, SocketProtocol, AddressFamily}
use core::time::Duration

// ============================================================================
// UdpSocket
// ============================================================================

/// A UDP socket.
///
/// UDP sockets can send and receive datagrams to/from any address.
/// They can optionally be "connected" to a specific remote address.
///
/// # Examples
///
/// ```tml
/// use std::net::udp::UdpSocket
///
/// // Create a UDP socket bound to localhost:8080
/// let socket = UdpSocket::bind("127.0.0.1:8080".parse()?)!
///
/// // Send a datagram
/// socket.send_to(b"hello", "127.0.0.1:9000".parse()?)!
///
/// // Receive a datagram
/// var buf: [U8; 1024] = [0; 1024]
/// let (n, src) = socket.recv_from(mut ref buf)!
/// ```
pub type UdpSocket {
    /// The underlying socket
    socket: RawSocket,
    /// Whether the socket is connected to a specific address
    connected: Bool,
}

impl UdpSocket {
    /// Creates a UDP socket from the given address.
    ///
    /// This function binds a UDP socket to the specified local address.
    /// The socket is ready to send and receive datagrams.
    ///
    /// # Arguments
    ///
    /// * `addr` - The address to bind to
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Bind to a specific address and port
    /// let socket = UdpSocket::bind("127.0.0.1:8080".parse()?)!
    ///
    /// // Bind to any available port
    /// let socket = UdpSocket::bind("0.0.0.0:0".parse()?)!
    /// ```
    pub func bind(addr: SocketAddr) -> Outcome[UdpSocket, NetError] {
        let family: AddressFamily = AddressFamily::from_addr(ref addr)
        let socket: RawSocket = RawSocket::new_with_family(family, SocketType::Datagram, SocketProtocol::Udp)!
        socket.bind(ref addr)!

        let udp_socket: UdpSocket = UdpSocket { socket: socket, connected: false }
        Ok(udp_socket)
    }

    /// Connects the UDP socket to a remote address.
    ///
    /// After connecting, the socket will only receive datagrams from the
    /// specified address, and `send()` and `recv()` can be used instead
    /// of `send_to()` and `recv_from()`.
    ///
    /// # Arguments
    ///
    /// * `addr` - The remote address to connect to
    ///
    /// # Examples
    ///
    /// ```tml
    /// let socket = UdpSocket::bind("0.0.0.0:0".parse()?)!
    /// socket.connect("127.0.0.1:8080".parse()?)!
    ///
    /// // Now send/recv can be used
    /// socket.send(b"hello")!
    /// ```
    pub func connect(mut this, addr: SocketAddr) -> Outcome[(), NetError] {
        this.socket.connect(ref addr)!
        this.connected = true
        Ok(())
    }

    /// Sends data to the specified address.
    ///
    /// # Arguments
    ///
    /// * `buf` - The data to send
    /// * `addr` - The destination address
    ///
    /// # Returns
    ///
    /// The number of bytes sent.
    ///
    /// # Examples
    ///
    /// ```tml
    /// socket.send_to(b"hello", "127.0.0.1:8080".parse()?)!
    /// ```
    pub func send_to(this, buf: ref [U8], addr: SocketAddr) -> Outcome[I64, NetError] {
        this.socket.send_to(buf, ref addr)
    }

    /// Receives a single datagram and returns the sender's address.
    ///
    /// # Arguments
    ///
    /// * `buf` - Buffer to receive into
    ///
    /// # Returns
    ///
    /// A tuple of (bytes received, sender address).
    ///
    /// # Examples
    ///
    /// ```tml
    /// var buf: [U8; 1024] = [0; 1024]
    /// let (n, src) = socket.recv_from(mut ref buf)!
    /// print("Received {} bytes from {}\n", n, src)
    /// ```
    pub func recv_from(this, buf: mut ref [U8]) -> Outcome[(I64, SocketAddr), NetError] {
        this.socket.recv_from(buf)
    }

    /// Sends data on a connected socket.
    ///
    /// This method can only be used after `connect()` has been called.
    ///
    /// # Arguments
    ///
    /// * `buf` - The data to send
    ///
    /// # Returns
    ///
    /// The number of bytes sent.
    pub func send(this, buf: ref [U8]) -> Outcome[I64, NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected))
        }
        this.socket.send(buf)
    }

    /// Receives data on a connected socket.
    ///
    /// This method can only be used after `connect()` has been called.
    ///
    /// # Arguments
    ///
    /// * `buf` - Buffer to receive into
    ///
    /// # Returns
    ///
    /// The number of bytes received.
    pub func recv(this, buf: mut ref [U8]) -> Outcome[I64, NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected))
        }
        this.socket.recv(buf)
    }

    /// Returns the local address that this socket is bound to.
    pub func local_addr(this) -> Outcome[SocketAddr, NetError] {
        this.socket.local_addr()
    }

    /// Returns the remote address that this socket is connected to.
    ///
    /// Returns an error if the socket is not connected.
    pub func peer_addr(this) -> Outcome[SocketAddr, NetError] {
        if not this.connected {
            return Err(NetError::new(NetErrorKind::NotConnected))
        }
        this.socket.peer_addr()
    }

    /// Sets the read timeout.
    pub func set_read_timeout(this, dur: Maybe[Duration]) -> Outcome[(), NetError] {
        when dur {
            Just(d) => this.socket.set_recv_timeout(d.as_millis())
            Nothing => this.socket.set_recv_timeout(0)
        }
    }

    /// Sets the write timeout.
    pub func set_write_timeout(this, dur: Maybe[Duration]) -> Outcome[(), NetError] {
        when dur {
            Just(d) => this.socket.set_send_timeout(d.as_millis())
            Nothing => this.socket.set_send_timeout(0)
        }
    }

    /// Gets the read timeout.
    pub func read_timeout(this) -> Outcome[Maybe[Duration], NetError] {
        let millis: I64 = this.socket.get_recv_timeout()!
        if millis == 0 {
            Ok(Nothing)
        } else {
            Ok(Just(Duration::from_millis(millis)))
        }
    }

    /// Gets the write timeout.
    pub func write_timeout(this) -> Outcome[Maybe[Duration], NetError] {
        let millis: I64 = this.socket.get_send_timeout()!
        if millis == 0 {
            Ok(Nothing)
        } else {
            Ok(Just(Duration::from_millis(millis)))
        }
    }

    /// Sets the value of the `SO_BROADCAST` option.
    ///
    /// When enabled, this socket can send packets to a broadcast address.
    pub func set_broadcast(this, broadcast: Bool) -> Outcome[(), NetError] {
        this.socket.set_broadcast(broadcast)
    }

    /// Gets the value of the `SO_BROADCAST` option.
    pub func broadcast(this) -> Outcome[Bool, NetError] {
        this.socket.get_broadcast()
    }

    /// Sets the value of the `IP_TTL` option.
    pub func set_ttl(this, ttl: I32) -> Outcome[(), NetError] {
        this.socket.set_ttl(ttl)
    }

    /// Gets the value of the `IP_TTL` option.
    pub func ttl(this) -> Outcome[I32, NetError] {
        this.socket.get_ttl()
    }

    /// Moves this UDP socket into or out of non-blocking mode.
    pub func set_nonblocking(mut this, nonblocking: Bool) -> Outcome[(), NetError] {
        this.socket.set_nonblocking(nonblocking)
    }

    // ========================================================================
    // Multicast
    // ========================================================================

    /// Joins a multicast group on the specified interface.
    ///
    /// # Arguments
    ///
    /// * `multiaddr` - The multicast group address
    /// * `interface` - The local interface address (use `Ipv4Addr::UNSPECIFIED` for default)
    pub func join_multicast_v4(this, multiaddr: Ipv4Addr, iface: Ipv4Addr) -> Outcome[(), NetError] {
        // IP_ADD_MEMBERSHIP requires a struct with multicast addr + interface addr
        // For now, we use the multicast address only (interface = INADDR_ANY)
        // A full implementation would need a lowlevel func with the struct
        Ok(())  // Placeholder - full implementation needs lowlevel multicast struct
    }

    /// Leaves a multicast group on the specified interface.
    pub func leave_multicast_v4(this, multiaddr: Ipv4Addr, iface: Ipv4Addr) -> Outcome[(), NetError] {
        // IP_DROP_MEMBERSHIP requires a struct with multicast addr + interface addr
        Ok(())  // Placeholder - full implementation needs lowlevel multicast struct
    }

    /// Joins an IPv6 multicast group.
    pub func join_multicast_v6(this, multiaddr: Ipv6Addr, iface_index: U32) -> Outcome[(), NetError] {
        // IPV6_JOIN_GROUP requires a struct with multicast addr + interface index
        Ok(())  // Placeholder - full implementation needs lowlevel multicast struct
    }

    /// Leaves an IPv6 multicast group.
    pub func leave_multicast_v6(this, multiaddr: Ipv6Addr, iface_index: U32) -> Outcome[(), NetError] {
        // IPV6_LEAVE_GROUP requires a struct with multicast addr + interface index
        Ok(())  // Placeholder - full implementation needs lowlevel multicast struct
    }

    /// Sets the value of the `IP_MULTICAST_LOOP` option.
    ///
    /// When enabled, multicast packets sent from this socket will be
    /// looped back to the local socket.
    pub func set_multicast_loop_v4(this, enabled: Bool) -> Outcome[(), NetError] {
        this.socket.set_multicast_loop_v4(enabled)
    }

    /// Gets the value of the `IP_MULTICAST_LOOP` option.
    pub func multicast_loop_v4(this) -> Outcome[Bool, NetError] {
        this.socket.get_multicast_loop_v4()
    }

    /// Sets the value of the `IPV6_MULTICAST_LOOP` option.
    pub func set_multicast_loop_v6(this, enabled: Bool) -> Outcome[(), NetError] {
        // IPV6_MULTICAST_LOOP uses different socket level
        Ok(())  // Placeholder - needs IPV6 level setsockopt
    }

    /// Gets the value of the `IPV6_MULTICAST_LOOP` option.
    pub func multicast_loop_v6(this) -> Outcome[Bool, NetError] {
        Ok(true)  // Placeholder - needs IPV6 level getsockopt
    }

    /// Sets the value of the `IP_MULTICAST_TTL` option.
    pub func set_multicast_ttl_v4(this, ttl: I32) -> Outcome[(), NetError] {
        this.socket.set_multicast_ttl_v4(ttl)
    }

    /// Gets the value of the `IP_MULTICAST_TTL` option.
    pub func multicast_ttl_v4(this) -> Outcome[I32, NetError] {
        this.socket.get_multicast_ttl_v4()
    }

    // ========================================================================
    // Raw socket access
    // ========================================================================

    /// Returns a reference to the underlying raw socket.
    pub func as_raw_socket(this) -> ref RawSocket {
        ref this.socket
    }

    /// Consumes the socket and returns the underlying raw socket.
    pub func into_raw_socket(this) -> RawSocket {
        this.socket
    }

    /// Returns whether this socket is connected.
    pub func is_connected(this) -> Bool {
        this.connected
    }
}

// ============================================================================
// UdpBuilder - Builder pattern for UDP sockets
// ============================================================================

/// A builder for creating UDP sockets with custom options.
pub type UdpBuilder {
    broadcast: Bool,
    ttl: Maybe[I32],
    multicast_loop: Bool,
    multicast_ttl: Maybe[I32],
    recv_buffer_size: Maybe[I32],
    send_buffer_size: Maybe[I32],
}

impl UdpBuilder {
    /// Creates a new UDP builder with default options.
    pub func new() -> UdpBuilder {
        UdpBuilder {
            broadcast: false,
            ttl: Nothing,
            multicast_loop: true,
            multicast_ttl: Nothing,
            recv_buffer_size: Nothing,
            send_buffer_size: Nothing,
        }
    }

    /// Enables or disables broadcast.
    pub func broadcast(mut this, broadcast: Bool) -> UdpBuilder {
        this.broadcast = broadcast
        this
    }

    /// Sets the TTL.
    pub func ttl(mut this, ttl: I32) -> UdpBuilder {
        this.ttl = Just(ttl)
        this
    }

    /// Enables or disables multicast loopback.
    pub func multicast_loop(mut this, enabled: Bool) -> UdpBuilder {
        this.multicast_loop = enabled
        this
    }

    /// Sets the multicast TTL.
    pub func multicast_ttl(mut this, ttl: I32) -> UdpBuilder {
        this.multicast_ttl = Just(ttl)
        this
    }

    /// Sets the receive buffer size.
    pub func recv_buffer_size(mut this, size: I32) -> UdpBuilder {
        this.recv_buffer_size = Just(size)
        this
    }

    /// Sets the send buffer size.
    pub func send_buffer_size(mut this, size: I32) -> UdpBuilder {
        this.send_buffer_size = Just(size)
        this
    }

    /// Binds to an address and creates a UdpSocket.
    pub func bind(this, addr: SocketAddr) -> Outcome[UdpSocket, NetError] {
        var socket: UdpSocket = UdpSocket::bind(addr)!

        if this.broadcast {
            socket.set_broadcast(true)!
        }
        when this.ttl {
            Just(t) => socket.set_ttl(t)!
            Nothing => {}
        }
        socket.set_multicast_loop_v4(this.multicast_loop)!
        when this.multicast_ttl {
            Just(t) => socket.set_multicast_ttl_v4(t)!
            Nothing => {}
        }
        when this.recv_buffer_size {
            Just(size) => socket.socket.set_recv_buffer_size(size)!
            Nothing => {}
        }
        when this.send_buffer_size {
            Just(size) => socket.socket.set_send_buffer_size(size)!
            Nothing => {}
        }

        Ok(socket)
    }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_udp_socket_types() {
    // Test that types can be constructed
    var builder: UdpBuilder = UdpBuilder::new()
    builder = builder.broadcast(true)
    builder = builder.ttl(64)
    builder = builder.multicast_loop(false)

    assert(builder.broadcast)
    assert_eq(builder.ttl, Just(64))
    assert(not builder.multicast_loop)
}

@test
func test_udp_builder_defaults() {
    let builder: UdpBuilder = UdpBuilder::new()

    assert(not builder.broadcast)
    assert_eq(builder.ttl, Nothing)
    assert(builder.multicast_loop)
    assert_eq(builder.multicast_ttl, Nothing)
}

@test
func test_udp_builder_chain() {
    var builder: UdpBuilder = UdpBuilder::new()
    builder = builder.broadcast(true)
    builder = builder.ttl(128)
    builder = builder.multicast_loop(true)
    builder = builder.multicast_ttl(32)
    builder = builder.recv_buffer_size(65536)
    builder = builder.send_buffer_size(65536)

    assert(builder.broadcast)
    assert_eq(builder.ttl, Just(128))
    assert(builder.multicast_loop)
    assert_eq(builder.multicast_ttl, Just(32))
    assert_eq(builder.recv_buffer_size, Just(65536))
    assert_eq(builder.send_buffer_size, Just(65536))
}
