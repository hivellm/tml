//! Collection types for common data structures.
//!
//! This module provides collection types following standard patterns.
//!
//! # Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`ArrayList[T]`] | Dynamic array with indexed access |
//! | [`HashSet[T]`] | Hash-based set for unique elements |
//! | [`Queue[T]`] | FIFO queue |
//! | [`Stack[T]`] | LIFO stack |
//! | [`LinkedList[T]`] | Doubly-linked list |
//!
//! # Example
//!
//! ```tml
//! use std::collections::class_collections::*
//!
//! let list: ArrayList[I32] = ArrayList::create[I32]()
//! list.add(1)
//! list.add(2)
//! list.add(3)
//! print(list.count().to_string())  // 3
//! ```

use std::collections::List

// ============================================================================
// ArrayList[T] - Dynamic array
// ============================================================================

/// A dynamic array with indexed access.
///
/// `ArrayList[T]` provides a growable array with O(1) indexed access.
///
/// # Example
///
/// ```tml
/// let list: ArrayList[I64] = ArrayList::create[I64]()
/// list.add(10)
/// list.add(20)
/// print(list.get(0).to_string())  // 10
/// ```
pub type ArrayList[T] {
    data: List[T],
    length: I64
}

impl[T] ArrayList[T] {
    /// Creates a new empty ArrayList.
    pub func create() -> ArrayList[T] {
        let list: List[T] = List[T].new(16)
        return ArrayList {
            data: list,
            length: 0,
        }
    }

    /// Creates an ArrayList with specified initial capacity.
    pub func with_capacity(capacity: I64) -> ArrayList[T] {
        let list: List[T] = List[T].new(capacity)
        return ArrayList {
            data: list,
            length: 0,
        }
    }

    /// Returns the number of elements.
    pub func count(this) -> I64 {
        return this.length
    }

    /// Returns true if empty.
    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    /// Adds an element to the end.
    pub func add(mut this, item: T) {
        this.data.push(item)
        this.length = this.length + 1
    }

    /// Removes all elements.
    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Destroys the list and frees all associated memory.
    pub func destroy(this) {
        this.data.destroy()
    }

    /// Gets the element at the specified index.
    pub func get(this, index: I64) -> T {
        return this.data.get(index)
    }

    /// Sets the element at the specified index.
    pub func set(mut this, index: I64, value: T) {
        this.data.set(index, value)
    }

    /// Inserts an item at the specified index.
    pub func insert(mut this, index: I64, item: T) {
        if index < 0 or index > this.length {
            return
        }

        // Shift elements right
        this.data.push(item) // Ensure capacity
        var i: I64 = this.length
        loop (i > index) {
            this.data.set(i, this.data.get(i - 1))
            i = i - 1
        }
        this.data.set(index, item)
        this.length = this.length + 1
    }

    /// Removes the element at the specified index.
    pub func remove_at(mut this, index: I64) {
        if index < 0 or index >= this.length {
            return
        }

        // Shift elements left
        var i: I64 = index
        loop (i < this.length - 1) {
            this.data.set(i, this.data.get(i + 1))
            i = i + 1
        }
        this.length = this.length - 1
    }

    /// Adds all elements from another list.
    pub func add_range(mut this, items: ref ArrayList[T]) {
        var i: I64 = 0
        loop (i < items.length) {
            this.add(items.get(i))
            i = i + 1
        }
    }

    /// Reverses the list in place.
    pub func reverse(mut this) {
        var left: I64 = 0
        var right: I64 = this.length - 1
        loop (left < right) {
            let temp: T = this.data.get(left)
            this.data.set(left, this.data.get(right))
            this.data.set(right, temp)
            left = left + 1
            right = right - 1
        }
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] ArrayList[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                this.remove_at(i)
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the list contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns the index of the item, or -1 if not found.
    pub func index_of(this, item: T) -> I64 {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return i
            }
            i = i + 1
        }
        return -1
    }
}

// ============================================================================
// HashSet[T] - Hash-based set
// ============================================================================

/// A hash-based set for storing unique elements.
///
/// Note: This is a simplified implementation. For production use,
/// consider using a proper hash map from the standard library.
///
/// # Example
///
/// ```tml
/// let set: HashSet[I64] = HashSet::create[I64]()
/// set.add(10)
/// set.add(20)
/// print(set.count().to_string())  // 2
/// ```
pub type HashSet[T] {
    /// Flat storage of all elements
    data: List[T],
    /// Number of elements
    length: I64
}

impl[T] HashSet[T] {
    /// Creates a new empty HashSet.
    pub func create() -> HashSet[T] {
        let list: List[T] = List[T].new(16)
        return HashSet {
            data: list,
            length: 0,
        }
    }

    /// Creates a HashSet with specified initial capacity.
    pub func with_capacity(capacity: I64) -> HashSet[T] {
        let list: List[T] = List[T].new(capacity)
        return HashSet {
            data: list,
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Destroys the set and frees all associated memory.
    pub func destroy(this) {
        this.data.destroy()
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] HashSet[T] {
    /// Adds an element to the set if not already present.
    /// Returns true if the element was added.
    pub func add(mut this, item: T) -> Bool {
        // Check if already present
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return false
            }
            i = i + 1
        }
        this.data.push(item)
        this.length = this.length + 1
        return true
    }

    /// Removes an element from the set.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                // Swap with last and remove
                this.data.set(i, this.data.get(this.length - 1))
                this.length = this.length - 1
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the set contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return true
            }
            i = i + 1
        }
        return false
    }
}

// ============================================================================
// Queue[T] - FIFO queue
// ============================================================================

/// A first-in-first-out (FIFO) queue.
///
/// `Queue[T]` provides enqueue and dequeue operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let queue: Queue[Str] = Queue::create[Str]()
/// queue.enqueue("first")
/// queue.enqueue("second")
/// queue.enqueue("third")
/// print(queue.dequeue().unwrap())  // "first"
/// ```
pub type Queue[T] {
    /// Internal storage
    data: List[T],
    /// Head index (front of queue)
    head: I64,
    /// Tail index (back of queue)
    tail: I64,
    /// Number of elements
    length: I64,
    /// Capacity
    capacity: I64
}

impl[T] Queue[T] {
    /// Creates a new empty Queue.
    pub func create() -> Queue[T] {
        let initial_capacity: I64 = 16
        let list: List[T] = List[T].new(initial_capacity)
        return Queue {
            data: list,
            head: 0,
            tail: 0,
            length: 0,
            capacity: initial_capacity,
        }
    }

    /// Creates a Queue with specified initial capacity.
    pub func with_capacity(cap: I64) -> Queue[T] {
        let list: List[T] = List[T].new(cap)
        return Queue {
            data: list,
            head: 0,
            tail: 0,
            length: 0,
            capacity: cap,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.enqueue(item)
    }

    pub func clear(mut this) {
        this.data.clear()
        this.head = 0
        this.tail = 0
        this.length = 0
    }

    /// Destroys the queue and frees all associated memory.
    pub func destroy(this) {
        this.data.destroy()
    }

    /// Adds an item to the back of the queue.
    pub func enqueue(mut this, item: T) {
        if this.length >= this.capacity {
            this.grow()
        }

        let idx: I64 = this.tail % this.capacity
        // Always push to grow the data array as needed
        this.data.push(item)
        this.tail = this.tail + 1
        this.length = this.length + 1
    }

    /// Removes and returns the item at the front of the queue.
    pub func dequeue(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx: I64 = this.head % this.capacity
        let item: T = this.data.get(idx)
        this.head = this.head + 1
        this.length = this.length - 1

        // Normalize indices when queue is empty
        if this.length == 0 {
            this.head = 0
            this.tail = 0
        }

        return Just(item)
    }

    /// Returns the item at the front without removing it.
    pub func peek(this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx: I64 = this.head % this.capacity
        return Just(this.data.get(idx))
    }

    /// Grows the queue capacity.
    pub func grow(mut this) {
        let new_capacity: I64 = this.capacity * 2
        var new_data: List[T] = List[T].new(new_capacity)

        // Copy elements in order
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            new_data.push(this.data.get(idx))
            i = i + 1
            cnt = cnt + 1
        }

        this.data.destroy()
        this.data = new_data
        this.head = 0
        this.tail = this.length
        this.capacity = new_capacity
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] Queue[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            if this.data.get(idx) == item {
                // Shift elements to fill the gap
                var j: I64 = cnt
                loop (j < this.length - 1) {
                    let curr_idx: I64 = (this.head + j) % this.capacity
                    let next_idx: I64 = (this.head + j + 1) % this.capacity
                    this.data.set(curr_idx, this.data.get(next_idx))
                    j = j + 1
                }
                this.tail = this.tail - 1
                this.length = this.length - 1
                return true
            }
            i = i + 1
            cnt = cnt + 1
        }
        return false
    }

    /// Returns true if the queue contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            if this.data.get(idx) == item {
                return true
            }
            i = i + 1
            cnt = cnt + 1
        }
        return false
    }
}

// ============================================================================
// Stack[T] - LIFO stack
// ============================================================================

/// A last-in-first-out (LIFO) stack.
///
/// `Stack[T]` provides push and pop operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let stack: Stack[I32] = Stack::create[I32]()
/// stack.push(1)
/// stack.push(2)
/// stack.push(3)
/// print(stack.pop().unwrap().to_string())  // 3
/// ```
pub type Stack[T] {
    /// Internal storage
    data: List[T],
    /// Length
    length: I64
}

impl[T] Stack[T] {
    /// Creates a new empty Stack.
    pub func create() -> Stack[T] {
        let list: List[T] = List[T].new(16)
        return Stack {
            data: list,
            length: 0,
        }
    }

    /// Creates a Stack with specified initial capacity.
    pub func with_capacity(capacity: I64) -> Stack[T] {
        let list: List[T] = List[T].new(capacity)
        return Stack {
            data: list,
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.push(item)
    }

    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Destroys the stack and frees all associated memory.
    pub func destroy(this) {
        this.data.destroy()
    }

    /// Pushes an item onto the stack.
    pub func push(mut this, item: T) {
        this.data.push(item)
        this.length = this.length + 1
    }

    /// Pops an item from the stack.
    pub func pop(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }
        this.length = this.length - 1
        return Just(this.data.get(this.length))
    }

    /// Returns the item at the top without removing it.
    pub func peek(this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }
        return Just(this.data.get(this.length - 1))
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] Stack[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                // Shift elements down
                var j: I64 = i
                loop (j < this.length - 1) {
                    this.data.set(j, this.data.get(j + 1))
                    j = j + 1
                }
                this.length = this.length - 1
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the stack contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return true
            }
            i = i + 1
        }
        return false
    }
}

// ============================================================================
// LinkedListNode[T] - Node for doubly-linked list
// ============================================================================

/// A node in a doubly-linked list.
pub type LinkedListNode[T] {
    value: T,
    prev: I64,  // Index to previous node
    next: I64   // Index to next node
}

// ============================================================================
// LinkedList[T] - Doubly-linked list (simplified array-based)
// ============================================================================

/// A doubly-linked list for efficient insertion and removal.
///
/// Note: This is a simplified implementation using indices into an array
/// rather than raw pointers.
///
/// # Example
///
/// ```tml
/// let list: LinkedList[I32] = LinkedList::create[I32]()
/// list.add_last(1)
/// list.add_last(2)
/// list.add_last(3)
/// // List: 1 <-> 2 <-> 3
/// print(list.remove_first().unwrap().to_string())  // 1
/// ```
pub type LinkedList[T] {
    /// Nodes storage
    nodes: List[LinkedListNode[T]],
    /// Number of nodes in storage
    node_count: I64,
    /// Head index (-1 for empty)
    head: I64,
    /// Tail index (-1 for empty)
    tail: I64,
    /// Number of elements
    length: I64
}

impl[T] LinkedList[T] {
    /// Creates a new empty LinkedList.
    pub func create() -> LinkedList[T] {
        let nodes: List[LinkedListNode[T]] = List[LinkedListNode[T]].new(16)
        return LinkedList {
            nodes: nodes,
            node_count: 0,
            head: -1,
            tail: -1,
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.add_last(item)
    }

    pub func clear(mut this) {
        this.nodes.clear()
        this.node_count = 0
        this.head = -1
        this.tail = -1
        this.length = 0
    }

    /// Destroys the list and frees all associated memory.
    pub func destroy(this) {
        this.nodes.destroy()
    }

    /// Adds an item at the beginning of the list.
    pub func add_first(mut this, item: T) {
        let node_idx: I64 = this.node_count
        let node: LinkedListNode[T] = LinkedListNode {
            value: item,
            prev: -1,
            next: this.head,
        }
        this.nodes.push(node)
        this.node_count = this.node_count + 1

        if this.head >= 0 {
            var head_node: LinkedListNode[T] = this.nodes.get(this.head)
            head_node.prev = node_idx
            this.nodes.set(this.head, head_node)
        }

        this.head = node_idx

        if this.tail < 0 {
            this.tail = node_idx
        }

        this.length = this.length + 1
    }

    /// Adds an item at the end of the list.
    pub func add_last(mut this, item: T) {
        let node_idx: I64 = this.node_count
        let node: LinkedListNode[T] = LinkedListNode {
            value: item,
            prev: this.tail,
            next: -1,
        }
        this.nodes.push(node)
        this.node_count = this.node_count + 1

        if this.tail >= 0 {
            var tail_node: LinkedListNode[T] = this.nodes.get(this.tail)
            tail_node.next = node_idx
            this.nodes.set(this.tail, tail_node)
        }

        this.tail = node_idx

        if this.head < 0 {
            this.head = node_idx
        }

        this.length = this.length + 1
    }

    /// Removes and returns the first item.
    pub func remove_first(mut this) -> Maybe[T] {
        if this.head < 0 {
            return Nothing
        }

        let head_node: LinkedListNode[T] = this.nodes.get(this.head)
        let value: T = head_node.value
        let next: I64 = head_node.next

        if next >= 0 {
            var next_node: LinkedListNode[T] = this.nodes.get(next)
            next_node.prev = -1
            this.nodes.set(next, next_node)
        } else {
            this.tail = -1
        }

        this.head = next
        this.length = this.length - 1

        return Just(value)
    }

    /// Removes and returns the last item.
    pub func remove_last(mut this) -> Maybe[T] {
        if this.tail < 0 {
            return Nothing
        }

        let tail_node: LinkedListNode[T] = this.nodes.get(this.tail)
        let value: T = tail_node.value
        let prev: I64 = tail_node.prev

        if prev >= 0 {
            var prev_node: LinkedListNode[T] = this.nodes.get(prev)
            prev_node.next = -1
            this.nodes.set(prev, prev_node)
        } else {
            this.head = -1
        }

        this.tail = prev
        this.length = this.length - 1

        return Just(value)
    }

    /// Returns the first item without removing it.
    pub func first(this) -> Maybe[T] {
        if this.head < 0 {
            return Nothing
        }
        return Just(this.nodes.get(this.head).value)
    }

    /// Returns the last item without removing it.
    pub func last(this) -> Maybe[T] {
        if this.tail < 0 {
            return Nothing
        }
        return Just(this.nodes.get(this.tail).value)
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] LinkedList[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var idx: I64 = this.head
        loop (idx >= 0) {
            let current: LinkedListNode[T] = this.nodes.get(idx)
            if current.value == item {
                let prev_idx: I64 = current.prev
                let next_idx: I64 = current.next

                // Update previous node's next pointer
                if prev_idx >= 0 {
                    var prev_node: LinkedListNode[T] = this.nodes.get(prev_idx)
                    prev_node.next = next_idx
                    this.nodes.set(prev_idx, prev_node)
                } else {
                    this.head = next_idx
                }

                // Update next node's prev pointer
                if next_idx >= 0 {
                    var next_node: LinkedListNode[T] = this.nodes.get(next_idx)
                    next_node.prev = prev_idx
                    this.nodes.set(next_idx, next_node)
                } else {
                    this.tail = prev_idx
                }

                this.length = this.length - 1
                return true
            }
            idx = current.next
        }
        return false
    }

    /// Returns true if the list contains the element.
    pub func contains(this, item: T) -> Bool {
        var idx: I64 = this.head
        loop (idx >= 0) {
            let current: LinkedListNode[T] = this.nodes.get(idx)
            if current.value == item {
                return true
            }
            idx = current.next
        }
        return false
    }
}

// ============================================================================
// Vec[T] - Rust-style dynamic array alias
// ============================================================================

/// A dynamic array with Rust-standard naming conventions.
///
/// `Vec[T]` wraps `List[T]` and provides `push`, `pop`, `len`, `get`, `set`.
///
/// # Example
///
/// ```tml
/// let v: Vec[I32] = Vec::new[I32]()
/// v.push(1)
/// v.push(2)
/// print(v.len().to_string())  // 2
/// ```
pub type Vec[T] {
    data: List[T],
    length: I64
}

impl[T] Vec[T] {
    /// Creates a new empty Vec.
    pub func new() -> Vec[T] {
        let list: List[T] = List[T].new(8)
        return Vec { data: list, length: 0 }
    }

    /// Creates a Vec with the specified initial capacity.
    pub func with_capacity(cap: I64) -> Vec[T] {
        let list: List[T] = List[T].new(cap)
        return Vec { data: list, length: 0 }
    }

    /// Appends an element to the back.
    pub func push(mut this, value: T) {
        this.data.push(value)
        this.length = this.length + 1
    }

    /// Removes and returns the last element.
    pub func pop(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }
        this.length = this.length - 1
        return Just(this.data.get(this.length))
    }

    /// Returns the number of elements.
    pub func len(this) -> I64 {
        return this.length
    }

    /// Returns true if the Vec has no elements.
    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    /// Returns the element at the given index.
    pub func get(this, index: I64) -> T {
        if index < 0 or index >= this.length {
            panic("Vec::get index out of bounds")
        }
        return this.data.get(index)
    }

    /// Sets the element at the given index.
    pub func set(mut this, index: I64, value: T) {
        if index < 0 or index >= this.length {
            panic("Vec::set index out of bounds")
        }
        this.data.set(index, value)
    }

    /// Removes all elements.
    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Destroys the Vec and frees all associated memory.
    pub func destroy(this) {
        this.data.destroy()
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] Vec[T] {
    /// Returns true if the Vec contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data.get(i) == item {
                return true
            }
            i = i + 1
        }
        return false
    }
}

// ============================================================================
// Helper functions
// ============================================================================

func max_i64(a: I64, b: I64) -> I64 {
    if a > b {
        return a
    } else {
        return b
    }
}

// ============================================================================
// Tests
// ============================================================================

use test

@test
func test_array_list_basic() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()

    list.add(10)
    list.add(20)
    list.add(30)

    assert_eq(list.count(), 3 as I64, "count should be 3")
    assert_eq(list.get(0), 10 as I64, "first element")
    assert_eq(list.get(1), 20 as I64, "second element")
    assert_eq(list.get(2), 30 as I64, "third element")

    list.set(1, 25)
    assert_eq(list.get(1), 25 as I64, "after set")
    list.destroy()
    return 0
}

@test
func test_array_list_insert_remove() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()

    list.add(1)
    list.add(3)
    list.insert(1, 2)  // Insert 2 at index 1

    assert_eq(list.count(), 3 as I64, "count after insert")
    assert_eq(list.get(0), 1 as I64, "element 0")
    assert_eq(list.get(1), 2 as I64, "element 1")
    assert_eq(list.get(2), 3 as I64, "element 2")

    list.remove_at(1)  // Remove index 1

    assert_eq(list.count(), 2 as I64, "count after remove")
    assert_eq(list.get(0), 1 as I64, "element 0 after remove")
    assert_eq(list.get(1), 3 as I64, "element 1 after remove")
    list.destroy()
    return 0
}

@test
func test_queue_basic() -> I32 {
    var queue: Queue[I64] = Queue::create[I64]()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)

    assert_eq(queue.count(), 3 as I64, "count should be 3")

    let v1: Maybe[I64] = queue.dequeue()
    assert(v1 == Just(1 as I64), "dequeue should return 1")

    let v2: Maybe[I64] = queue.dequeue()
    assert(v2 == Just(2 as I64), "dequeue should return 2")

    assert_eq(queue.count(), 1 as I64, "count should be 1")

    let v3: Maybe[I64] = queue.peek()
    assert(v3 == Just(3 as I64), "peek should return 3")

    let v4: Maybe[I64] = queue.dequeue()
    assert(v4 == Just(3 as I64), "dequeue should return 3")

    let v5: Maybe[I64] = queue.dequeue()
    assert(v5 == Nothing, "dequeue on empty should return Nothing")
    queue.destroy()
    return 0
}

@test
func test_stack_basic() -> I32 {
    var stack: Stack[I64] = Stack::create[I64]()

    stack.push(1)
    stack.push(2)
    stack.push(3)

    assert_eq(stack.count(), 3 as I64, "count should be 3")

    let p1: Maybe[I64] = stack.peek()
    assert(p1 == Just(3 as I64), "peek should return 3")

    let v1: Maybe[I64] = stack.pop()
    assert(v1 == Just(3 as I64), "pop should return 3")

    let v2: Maybe[I64] = stack.pop()
    assert(v2 == Just(2 as I64), "pop should return 2")

    assert_eq(stack.count(), 1 as I64, "count should be 1")

    let v3: Maybe[I64] = stack.pop()
    assert(v3 == Just(1 as I64), "pop should return 1")

    let v4: Maybe[I64] = stack.pop()
    assert(v4 == Nothing, "pop on empty should return Nothing")
    stack.destroy()
    return 0
}

@test
func test_linked_list_basic() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()

    list.add_first(2)
    list.add_first(1)
    list.add_last(3)

    assert_eq(list.count(), 3 as I64, "count should be 3")

    let f: Maybe[I64] = list.first()
    assert(f == Just(1 as I64), "first should be 1")

    let l: Maybe[I64] = list.last()
    assert(l == Just(3 as I64), "last should be 3")

    let r1: Maybe[I64] = list.remove_first()
    assert(r1 == Just(1 as I64), "remove_first should return 1")

    let r2: Maybe[I64] = list.remove_last()
    assert(r2 == Just(3 as I64), "remove_last should return 3")

    assert_eq(list.count(), 1 as I64, "count should be 1")
    list.destroy()
    return 0
}

@test
func test_hash_set_basic() -> I32 {
    var set: HashSet[I64] = HashSet::create[I64]()

    set.add(10)
    set.add(20)
    set.add(10)  // Duplicate - should be ignored

    // Note: Due to placeholder hash function, count may not reflect true behavior
    assert(set.count() >= 1 as I64, "count should be at least 1")
    set.destroy()
    return 0
}
