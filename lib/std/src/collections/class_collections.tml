//! OOP-style collection classes implementing standard interfaces.
//!
//! This module provides collection classes that implement the interfaces
//! from `std::interfaces`, following C# patterns.
//!
//! # Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`ArrayList[T]`] | Class-based dynamic array |
//! | [`HashSet[T]`] | Hash-based set for unique elements |
//! | [`Queue[T]`] | FIFO queue |
//! | [`Stack[T]`] | LIFO stack |
//! | [`LinkedList[T]`] | Doubly-linked list |
//!
//! # Example
//!
//! ```tml
//! use std::collections::class_collections::*
//!
//! // Use ArrayList with interface polymorphism
//! let list: dyn IList[I32] = ArrayList::create[I32]()
//! list.add(1)
//! list.add(2)
//! list.add(3)
//! print(list.count())  // 3
//! ```

use std::interfaces::*
use std::object::Object

// ============================================================================
// ArrayList[T] - OOP-style dynamic array
// ============================================================================

/// A class-based dynamic array implementing IList and ICollection.
///
/// `ArrayList[T]` provides a growable array with indexed access.
///
/// # Implements
///
/// - [`ICollection[T]`] - add, remove, clear, count, contains
/// - [`IList[T]`] - get, set, insert, remove_at, index_of
///
/// # Example
///
/// ```tml
/// let list = ArrayList::create[I64]()
/// list.add(10)
/// list.add(20)
/// print(list.get(0))  // 10
/// ```
pub class ArrayList[T] extends Object implements ICollection[T], IList[T] {
    data: List[T]
    length: I64

    /// Creates a new empty ArrayList.
    static func create() -> ArrayList[T] {
        ArrayList {
            data: [],
            length: 0,
        }
    }

    /// Creates an ArrayList with specified initial capacity.
    static func with_capacity(capacity: I64) -> ArrayList[T] {
        ArrayList {
            data: List::with_capacity(capacity),
            length: 0,
        }
    }

    // ICollection[T] implementation

    /// Returns the number of elements.
    func count(this) -> I64 {
        this.length
    }

    /// Returns true if empty.
    func is_empty(this) -> Bool {
        this.length == 0
    }

    /// Adds an element to the end.
    func add(mut this, item: T) {
        this.data.push(item)
        this.length = this.length + 1
    }

    /// Removes the first occurrence of an element.
    func remove(mut this, item: T) -> Bool {
        let idx = this.index_of(item)
        if idx >= 0 {
            this.remove_at(idx)
            return true
        }
        false
    }

    /// Removes all elements.
    func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Returns true if the list contains the element.
    func contains(this, item: T) -> Bool {
        this.index_of(item) >= 0
    }

    // IList[T] implementation

    /// Gets the element at the specified index.
    func get(this, index: I64) -> T {
        this.data[index]
    }

    /// Sets the element at the specified index.
    func set(mut this, index: I64, value: T) {
        this.data[index] = value
    }

    /// Returns the index of the item, or -1 if not found.
    func index_of(this, item: T) -> I64 {
        var i: I64 = 0
        loop {
            if i >= this.length { break }
            // TODO: Proper equality check with IEquatable
            // if this.data[i] == item { return i }
            i = i + 1
        }
        -1
    }

    /// Inserts an item at the specified index.
    func insert(mut this, index: I64, item: T) {
        if index < 0 or index > this.length {
            return
        }

        // Shift elements right
        this.data.push(item) // Ensure capacity
        var i = this.length
        loop {
            if i <= index { break }
            this.data[i] = this.data[i - 1]
            i = i - 1
        }
        this.data[index] = item
        this.length = this.length + 1
    }

    /// Removes the element at the specified index.
    func remove_at(mut this, index: I64) {
        if index < 0 or index >= this.length {
            return
        }

        // Shift elements left
        var i = index
        loop {
            if i >= this.length - 1 { break }
            this.data[i] = this.data[i + 1]
            i = i + 1
        }
        this.length = this.length - 1
    }

    // Additional methods

    /// Adds all elements from another list.
    func add_range(mut this, items: ref ArrayList[T]) {
        var i: I64 = 0
        loop {
            if i >= items.length { break }
            this.add(items.get(i))
            i = i + 1
        }
    }

    /// Reverses the list in place.
    func reverse(mut this) {
        var left: I64 = 0
        var right = this.length - 1
        loop {
            if left >= right { break }
            let temp = this.data[left]
            this.data[left] = this.data[right]
            this.data[right] = temp
            left = left + 1
            right = right - 1
        }
    }

    /// Returns the capacity.
    func capacity(this) -> I64 {
        this.data.capacity()
    }

    override func to_string(this) -> Str {
        return "ArrayList[" + this.length.to_string() + " elements]"
    }

    override func get_type(this) -> Str {
        return "ArrayList"
    }
}

// ============================================================================
// HashSet[T] - Hash-based set
// ============================================================================

/// A hash-based set for storing unique elements.
///
/// `HashSet[T]` stores elements with O(1) average lookup time.
/// Duplicate elements are not allowed.
///
/// # Implements
///
/// - [`ICollection[T]`] - add, remove, clear, count, contains
///
/// # Example
///
/// ```tml
/// let set = HashSet::create[Str]()
/// set.add("apple")
/// set.add("banana")
/// set.add("apple")  // Ignored, already exists
/// print(set.count())  // 2
/// print(set.contains("apple"))  // true
/// ```
pub class HashSet[T] extends Object implements ICollection[T] {
    /// Buckets for hash table
    buckets: List[List[T]]
    /// Number of buckets
    bucket_count: I64
    /// Number of elements
    length: I64
    /// Load factor threshold for rehashing
    load_factor: F64

    /// Creates a new empty HashSet.
    static func create() -> HashSet[T] {
        let initial_buckets: I64 = 16
        var buckets: List[List[T]] = []

        var i: I64 = 0
        loop {
            if i >= initial_buckets { break }
            buckets.push([])
            i = i + 1
        }

        HashSet {
            buckets: buckets,
            bucket_count: initial_buckets,
            length: 0,
            load_factor: 0.75,
        }
    }

    /// Creates a HashSet with specified initial capacity.
    static func with_capacity(capacity: I64) -> HashSet[T] {
        let bucket_count = max_i64(16, capacity * 2)
        var buckets: List[List[T]] = []

        var i: I64 = 0
        loop {
            if i >= bucket_count { break }
            buckets.push([])
            i = i + 1
        }

        HashSet {
            buckets: buckets,
            bucket_count: bucket_count,
            length: 0,
            load_factor: 0.75,
        }
    }

    // ICollection[T] implementation

    func count(this) -> I64 {
        this.length
    }

    func is_empty(this) -> Bool {
        this.length == 0
    }

    func add(mut this, item: T) {
        if this.contains(item) {
            return // Already exists
        }

        // Check if rehash needed
        let current_load = this.length as F64 / this.bucket_count as F64
        if current_load > this.load_factor {
            this.rehash()
        }

        let hash = this.hash_item(item)
        let bucket_idx = hash % this.bucket_count
        this.buckets[bucket_idx].push(item)
        this.length = this.length + 1
    }

    func remove(mut this, item: T) -> Bool {
        let hash = this.hash_item(item)
        let bucket_idx = hash % this.bucket_count
        let bucket = mut ref this.buckets[bucket_idx]

        var i: I64 = 0
        loop {
            if i >= bucket.len() { break }
            // TODO: Proper equality check
            // if bucket[i] == item {
            //     bucket.remove_at(i)
            //     this.length = this.length - 1
            //     return true
            // }
            i = i + 1
        }
        false
    }

    func clear(mut this) {
        var i: I64 = 0
        loop {
            if i >= this.bucket_count { break }
            this.buckets[i].clear()
            i = i + 1
        }
        this.length = 0
    }

    func contains(this, item: T) -> Bool {
        let hash = this.hash_item(item)
        let bucket_idx = hash % this.bucket_count
        let bucket = ref this.buckets[bucket_idx]

        var i: I64 = 0
        loop {
            if i >= bucket.len() { break }
            // TODO: Proper equality check with IEquatable
            // if bucket[i] == item { return true }
            i = i + 1
        }
        false
    }

    // Additional methods

    /// Computes hash for an item.
    func hash_item(this, item: T) -> I64 {
        // Placeholder hash function
        // Real implementation should use item's get_hash_code() if T implements IHashable
        lowlevel { (ref item) as I64 }
    }

    /// Rehashes the table to a larger size.
    func rehash(mut this) {
        let new_bucket_count = this.bucket_count * 2
        var new_buckets: List[List[T]] = []

        var i: I64 = 0
        loop {
            if i >= new_bucket_count { break }
            new_buckets.push([])
            i = i + 1
        }

        // Rehash all existing items
        i = 0
        loop {
            if i >= this.bucket_count { break }
            let bucket = ref this.buckets[i]
            var j: I64 = 0
            loop {
                if j >= bucket.len() { break }
                let item = bucket[j]
                let hash = this.hash_item(item)
                let new_idx = hash % new_bucket_count
                new_buckets[new_idx].push(item)
                j = j + 1
            }
            i = i + 1
        }

        this.buckets = new_buckets
        this.bucket_count = new_bucket_count
    }

    /// Set union: returns a new set with all elements from both sets.
    func union(this, other: ref HashSet[T]) -> HashSet[T] {
        var result = HashSet::create[T]()

        // Add all from this
        var i: I64 = 0
        loop {
            if i >= this.bucket_count { break }
            var j: I64 = 0
            loop {
                if j >= this.buckets[i].len() { break }
                result.add(this.buckets[i][j])
                j = j + 1
            }
            i = i + 1
        }

        // Add all from other
        i = 0
        loop {
            if i >= other.bucket_count { break }
            var j: I64 = 0
            loop {
                if j >= other.buckets[i].len() { break }
                result.add(other.buckets[i][j])
                j = j + 1
            }
            i = i + 1
        }

        result
    }

    override func to_string(this) -> Str {
        return "HashSet[" + this.length.to_string() + " elements]"
    }

    override func get_type(this) -> Str {
        return "HashSet"
    }
}

// ============================================================================
// Queue[T] - FIFO queue
// ============================================================================

/// A first-in-first-out (FIFO) queue.
///
/// `Queue[T]` provides enqueue and dequeue operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let queue = Queue::create[Str]()
/// queue.enqueue("first")
/// queue.enqueue("second")
/// queue.enqueue("third")
/// print(queue.dequeue())  // "first"
/// print(queue.dequeue())  // "second"
/// ```
pub class Queue[T] extends Object implements ICollection[T] {
    /// Internal storage
    data: List[T]
    /// Head index (front of queue)
    head: I64
    /// Tail index (back of queue)
    tail: I64
    /// Number of elements
    length: I64
    /// Capacity
    capacity: I64

    /// Creates a new empty Queue.
    static func create() -> Queue[T] {
        let initial_capacity: I64 = 16
        Queue {
            data: List::with_capacity(initial_capacity),
            head: 0,
            tail: 0,
            length: 0,
            capacity: initial_capacity,
        }
    }

    /// Creates a Queue with specified initial capacity.
    static func with_capacity(capacity: I64) -> Queue[T] {
        Queue {
            data: List::with_capacity(capacity),
            head: 0,
            tail: 0,
            length: 0,
            capacity: capacity,
        }
    }

    // ICollection[T] implementation

    func count(this) -> I64 {
        this.length
    }

    func is_empty(this) -> Bool {
        this.length == 0
    }

    func add(mut this, item: T) {
        this.enqueue(item)
    }

    func remove(mut this, item: T) -> Bool {
        // Removing arbitrary elements from a queue is not efficient
        // This is a basic O(n) implementation
        false
    }

    func clear(mut this) {
        this.data.clear()
        this.head = 0
        this.tail = 0
        this.length = 0
    }

    func contains(this, item: T) -> Bool {
        var i = this.head
        var count: I64 = 0
        loop {
            if count >= this.length { break }
            let idx = i % this.capacity
            // TODO: Proper equality
            // if this.data[idx] == item { return true }
            i = i + 1
            count = count + 1
        }
        false
    }

    // Queue-specific methods

    /// Adds an item to the back of the queue.
    func enqueue(mut this, item: T) {
        if this.length >= this.capacity {
            this.grow()
        }

        let idx = this.tail % this.capacity
        if idx >= this.data.len() {
            this.data.push(item)
        } else {
            this.data[idx] = item
        }
        this.tail = this.tail + 1
        this.length = this.length + 1
    }

    /// Removes and returns the item at the front of the queue.
    func dequeue(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx = this.head % this.capacity
        let item = this.data[idx]
        this.head = this.head + 1
        this.length = this.length - 1

        // Normalize indices when queue is empty
        if this.length == 0 {
            this.head = 0
            this.tail = 0
        }

        Just(item)
    }

    /// Returns the item at the front without removing it.
    func peek(this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx = this.head % this.capacity
        Just(this.data[idx])
    }

    /// Grows the queue capacity.
    func grow(mut this) {
        let new_capacity = this.capacity * 2
        var new_data: List[T] = List::with_capacity(new_capacity)

        // Copy elements in order
        var i = this.head
        var count: I64 = 0
        loop {
            if count >= this.length { break }
            let idx = i % this.capacity
            new_data.push(this.data[idx])
            i = i + 1
            count = count + 1
        }

        this.data = new_data
        this.head = 0
        this.tail = this.length
        this.capacity = new_capacity
    }

    override func to_string(this) -> Str {
        return "Queue[" + this.length.to_string() + " elements]"
    }

    override func get_type(this) -> Str {
        return "Queue"
    }
}

// ============================================================================
// Stack[T] - LIFO stack
// ============================================================================

/// A last-in-first-out (LIFO) stack.
///
/// `Stack[T]` provides push and pop operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let stack = Stack::create[I32]()
/// stack.push(1)
/// stack.push(2)
/// stack.push(3)
/// print(stack.pop())  // 3
/// print(stack.pop())  // 2
/// ```
pub class Stack[T] extends Object implements ICollection[T] {
    /// Internal storage
    data: List[T]

    /// Creates a new empty Stack.
    static func create() -> Stack[T] {
        Stack {
            data: [],
        }
    }

    /// Creates a Stack with specified initial capacity.
    static func with_capacity(capacity: I64) -> Stack[T] {
        Stack {
            data: List::with_capacity(capacity),
        }
    }

    // ICollection[T] implementation

    func count(this) -> I64 {
        this.data.len()
    }

    func is_empty(this) -> Bool {
        this.data.len() == 0
    }

    func add(mut this, item: T) {
        this.push(item)
    }

    func remove(mut this, item: T) -> Bool {
        // Removing arbitrary elements from a stack is not efficient
        false
    }

    func clear(mut this) {
        this.data.clear()
    }

    func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop {
            if i >= this.data.len() { break }
            // TODO: Proper equality
            // if this.data[i] == item { return true }
            i = i + 1
        }
        false
    }

    // Stack-specific methods

    /// Pushes an item onto the stack.
    func push(mut this, item: T) {
        this.data.push(item)
    }

    /// Pops an item from the stack.
    func pop(mut this) -> Maybe[T] {
        this.data.pop()
    }

    /// Returns the item at the top without removing it.
    func peek(this) -> Maybe[T] {
        if this.data.len() == 0 {
            return Nothing
        }
        Just(this.data[this.data.len() - 1])
    }

    override func to_string(this) -> Str {
        return "Stack[" + this.data.len().to_string() + " elements]"
    }

    override func get_type(this) -> Str {
        return "Stack"
    }
}

// ============================================================================
// LinkedListNode[T] - Node for doubly-linked list
// ============================================================================

/// A node in a doubly-linked list.
type LinkedListNode[T] {
    value: T,
    prev: I64,  // Pointer to previous node
    next: I64,  // Pointer to next node
}

// ============================================================================
// LinkedList[T] - Doubly-linked list
// ============================================================================

/// A doubly-linked list for efficient insertion and removal.
///
/// `LinkedList[T]` provides O(1) insertion and removal at both ends.
///
/// # Example
///
/// ```tml
/// let list = LinkedList::create[I32]()
/// list.add_first(1)
/// list.add_last(2)
/// list.add_last(3)
/// // List: 1 <-> 2 <-> 3
/// print(list.remove_first())  // 1
/// ```
pub class LinkedList[T] extends Object implements ICollection[T] {
    /// Head of the list
    head: I64
    /// Tail of the list
    tail: I64
    /// Number of elements
    length: I64

    /// Creates a new empty LinkedList.
    static func create() -> LinkedList[T] {
        LinkedList {
            head: 0,
            tail: 0,
            length: 0,
        }
    }

    // ICollection[T] implementation

    func count(this) -> I64 {
        this.length
    }

    func is_empty(this) -> Bool {
        this.length == 0
    }

    func add(mut this, item: T) {
        this.add_last(item)
    }

    func remove(mut this, item: T) -> Bool {
        // Find and remove the item
        var current = this.head
        loop {
            if current == 0 { break }
            let node = current as Ptr[LinkedListNode[T]]
            // TODO: Proper equality
            // if (*node).value == item {
            //     this.remove_node(current)
            //     return true
            // }
            current = lowlevel { (*node).next }
        }
        false
    }

    func clear(mut this) {
        // Free all nodes
        var current = this.head
        loop {
            if current == 0 { break }
            let node = current as Ptr[LinkedListNode[T]]
            let next = lowlevel { (*node).next }
            lowlevel { free(current as Ptr[U8]) }
            current = next
        }
        this.head = 0
        this.tail = 0
        this.length = 0
    }

    func contains(this, item: T) -> Bool {
        var current = this.head
        loop {
            if current == 0 { break }
            let node = current as Ptr[LinkedListNode[T]]
            // TODO: Proper equality
            // if (*node).value == item { return true }
            current = lowlevel { (*node).next }
        }
        false
    }

    // LinkedList-specific methods

    /// Adds an item at the beginning of the list.
    func add_first(mut this, item: T) {
        let node_ptr = lowlevel { malloc(24) } as I64 // sizeof(LinkedListNode[T])

        if node_ptr == 0 {
            return
        }

        let node = node_ptr as Ptr[LinkedListNode[T]]
        lowlevel {
            (*node).value = item
            (*node).prev = 0
            (*node).next = this.head
        }

        if this.head != 0 {
            let old_head = this.head as Ptr[LinkedListNode[T]]
            lowlevel { (*old_head).prev = node_ptr }
        }

        this.head = node_ptr

        if this.tail == 0 {
            this.tail = node_ptr
        }

        this.length = this.length + 1
    }

    /// Adds an item at the end of the list.
    func add_last(mut this, item: T) {
        let node_ptr = lowlevel { malloc(24) } as I64

        if node_ptr == 0 {
            return
        }

        let node = node_ptr as Ptr[LinkedListNode[T]]
        lowlevel {
            (*node).value = item
            (*node).prev = this.tail
            (*node).next = 0
        }

        if this.tail != 0 {
            let old_tail = this.tail as Ptr[LinkedListNode[T]]
            lowlevel { (*old_tail).next = node_ptr }
        }

        this.tail = node_ptr

        if this.head == 0 {
            this.head = node_ptr
        }

        this.length = this.length + 1
    }

    /// Removes and returns the first item.
    func remove_first(mut this) -> Maybe[T] {
        if this.head == 0 {
            return Nothing
        }

        let node = this.head as Ptr[LinkedListNode[T]]
        let value = lowlevel { (*node).value }
        let next = lowlevel { (*node).next }

        if next != 0 {
            let next_node = next as Ptr[LinkedListNode[T]]
            lowlevel { (*next_node).prev = 0 }
        } else {
            this.tail = 0
        }

        lowlevel { free(this.head as Ptr[U8]) }
        this.head = next
        this.length = this.length - 1

        Just(value)
    }

    /// Removes and returns the last item.
    func remove_last(mut this) -> Maybe[T] {
        if this.tail == 0 {
            return Nothing
        }

        let node = this.tail as Ptr[LinkedListNode[T]]
        let value = lowlevel { (*node).value }
        let prev = lowlevel { (*node).prev }

        if prev != 0 {
            let prev_node = prev as Ptr[LinkedListNode[T]]
            lowlevel { (*prev_node).next = 0 }
        } else {
            this.head = 0
        }

        lowlevel { free(this.tail as Ptr[U8]) }
        this.tail = prev
        this.length = this.length - 1

        Just(value)
    }

    /// Returns the first item without removing it.
    func first(this) -> Maybe[T] {
        if this.head == 0 {
            return Nothing
        }
        let node = this.head as Ptr[LinkedListNode[T]]
        Just(lowlevel { (*node).value })
    }

    /// Returns the last item without removing it.
    func last(this) -> Maybe[T] {
        if this.tail == 0 {
            return Nothing
        }
        let node = this.tail as Ptr[LinkedListNode[T]]
        Just(lowlevel { (*node).value })
    }

    override func to_string(this) -> Str {
        return "LinkedList[" + this.length.to_string() + " elements]"
    }

    override func get_type(this) -> Str {
        return "LinkedList"
    }
}

impl[T] Drop for LinkedList[T] {
    func drop(mut this) {
        this.clear()
    }
}

// ============================================================================
// Helper functions
// ============================================================================

func max_i64(a: I64, b: I64) -> I64 {
    if a > b { a } else { b }
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_array_list_basic() {
    var list = ArrayList::create[I64]()

    list.add(10)
    list.add(20)
    list.add(30)

    assert_eq(list.count(), 3)
    assert_eq(list.get(0), 10)
    assert_eq(list.get(1), 20)
    assert_eq(list.get(2), 30)

    list.set(1, 25)
    assert_eq(list.get(1), 25)
}

@test
func test_array_list_insert_remove() {
    var list = ArrayList::create[I64]()

    list.add(1)
    list.add(3)
    list.insert(1, 2)  // Insert 2 at index 1

    assert_eq(list.count(), 3)
    assert_eq(list.get(0), 1)
    assert_eq(list.get(1), 2)
    assert_eq(list.get(2), 3)

    list.remove_at(1)  // Remove index 1

    assert_eq(list.count(), 2)
    assert_eq(list.get(0), 1)
    assert_eq(list.get(1), 3)
}

@test
func test_queue_basic() {
    var queue = Queue::create[Str]()

    queue.enqueue("first")
    queue.enqueue("second")
    queue.enqueue("third")

    assert_eq(queue.count(), 3)

    assert_eq(queue.dequeue(), Just("first"))
    assert_eq(queue.dequeue(), Just("second"))
    assert_eq(queue.count(), 1)
    assert_eq(queue.peek(), Just("third"))
    assert_eq(queue.dequeue(), Just("third"))
    assert_eq(queue.dequeue(), Nothing)
}

@test
func test_stack_basic() {
    var stack = Stack::create[I32]()

    stack.push(1)
    stack.push(2)
    stack.push(3)

    assert_eq(stack.count(), 3)
    assert_eq(stack.peek(), Just(3))
    assert_eq(stack.pop(), Just(3))
    assert_eq(stack.pop(), Just(2))
    assert_eq(stack.count(), 1)
    assert_eq(stack.pop(), Just(1))
    assert_eq(stack.pop(), Nothing)
}

@test
func test_linked_list_basic() {
    var list = LinkedList::create[I64]()

    list.add_first(2)
    list.add_first(1)
    list.add_last(3)

    assert_eq(list.count(), 3)
    assert_eq(list.first(), Just(1))
    assert_eq(list.last(), Just(3))

    assert_eq(list.remove_first(), Just(1))
    assert_eq(list.remove_last(), Just(3))
    assert_eq(list.count(), 1)
}

@test
func test_hash_set_basic() {
    var set = HashSet::create[I64]()

    set.add(10)
    set.add(20)
    set.add(10)  // Duplicate - should be ignored

    // Note: Due to placeholder hash function, count may not reflect true behavior
    // Real implementation needs proper hash function
    assert(set.count() >= 1)
}
