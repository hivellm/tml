//! Collection types for common data structures.
//!
//! This module provides collection types following standard patterns.
//!
//! # Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`ArrayList[T]`] | Dynamic array with indexed access |
//! | [`HashSet[T]`] | Hash-based set for unique elements |
//! | [`Queue[T]`] | FIFO queue |
//! | [`Stack[T]`] | LIFO stack |
//! | [`LinkedList[T]`] | Doubly-linked list |
//!
//! # Example
//!
//! ```tml
//! use std::collections::class_collections::*
//!
//! let list: ArrayList[I32] = ArrayList::create[I32]()
//! list.add(1)
//! list.add(2)
//! list.add(3)
//! print(list.count().to_string())  // 3
//! ```

// ============================================================================
// ArrayList[T] - Dynamic array
// ============================================================================

/// A dynamic array with indexed access.
///
/// `ArrayList[T]` provides a growable array with O(1) indexed access.
///
/// # Example
///
/// ```tml
/// let list: ArrayList[I64] = ArrayList::create[I64]()
/// list.add(10)
/// list.add(20)
/// print(list.get(0).to_string())  // 10
/// ```
pub type ArrayList[T] {
    data: [T],
    length: I64
}

impl[T] ArrayList[T] {
    /// Creates a new empty ArrayList.
    pub func create() -> ArrayList[T] {
        return ArrayList {
            data: [],
            length: 0,
        }
    }

    /// Creates an ArrayList with specified initial capacity.
    pub func with_capacity(capacity: I64) -> ArrayList[T] {
        return ArrayList {
            data: [],
            length: 0,
        }
    }

    /// Returns the number of elements.
    pub func count(this) -> I64 {
        return this.length
    }

    /// Returns true if empty.
    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    /// Adds an element to the end.
    pub func add(mut this, item: T) {
        this.data.push(item)
        this.length = this.length + 1
    }

    /// Removes all elements.
    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Gets the element at the specified index.
    pub func get(this, index: I64) -> T {
        return this.data[index]
    }

    /// Sets the element at the specified index.
    pub func set(mut this, index: I64, value: T) {
        this.data[index] = value
    }

    /// Inserts an item at the specified index.
    pub func insert(mut this, index: I64, item: T) {
        if index < 0 or index > this.length {
            return
        }

        // Shift elements right
        this.data.push(item) // Ensure capacity
        var i: I64 = this.length
        loop (i > index) {
            this.data[i] = this.data[i - 1]
            i = i - 1
        }
        this.data[index] = item
        this.length = this.length + 1
    }

    /// Removes the element at the specified index.
    pub func remove_at(mut this, index: I64) {
        if index < 0 or index >= this.length {
            return
        }

        // Shift elements left
        var i: I64 = index
        loop (i < this.length - 1) {
            this.data[i] = this.data[i + 1]
            i = i + 1
        }
        this.length = this.length - 1
    }

    /// Adds all elements from another list.
    pub func add_range(mut this, items: ref ArrayList[T]) {
        var i: I64 = 0
        loop (i < items.length) {
            this.add(items.get(i))
            i = i + 1
        }
    }

    /// Reverses the list in place.
    pub func reverse(mut this) {
        var left: I64 = 0
        var right: I64 = this.length - 1
        loop (left < right) {
            let temp: T = this.data[left]
            this.data[left] = this.data[right]
            this.data[right] = temp
            left = left + 1
            right = right - 1
        }
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] ArrayList[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                this.remove_at(i)
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the list contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns the index of the item, or -1 if not found.
    pub func index_of(this, item: T) -> I64 {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                return i
            }
            i = i + 1
        }
        return -1
    }
}

// ============================================================================
// HashSet[T] - Hash-based set
// ============================================================================

/// A hash-based set for storing unique elements.
///
/// Note: This is a simplified implementation. For production use,
/// consider using a proper hash map from the standard library.
///
/// # Example
///
/// ```tml
/// let set: HashSet[I64] = HashSet::create[I64]()
/// set.add(10)
/// set.add(20)
/// print(set.count().to_string())  // 2
/// ```
pub type HashSet[T] {
    /// Flat storage of all elements
    data: [T],
    /// Number of elements
    length: I64
}

impl[T] HashSet[T] {
    /// Creates a new empty HashSet.
    pub func create() -> HashSet[T] {
        return HashSet {
            data: [],
            length: 0,
        }
    }

    /// Creates a HashSet with specified initial capacity.
    pub func with_capacity(capacity: I64) -> HashSet[T] {
        return HashSet {
            data: [],
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] HashSet[T] {
    /// Adds an element to the set if not already present.
    /// Returns true if the element was added.
    pub func add(mut this, item: T) -> Bool {
        // Check if already present
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                return false
            }
            i = i + 1
        }
        this.data.push(item)
        this.length = this.length + 1
        return true
    }

    /// Removes an element from the set.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                // Swap with last and remove
                this.data[i] = this.data[this.length - 1]
                this.length = this.length - 1
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the set contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                return true
            }
            i = i + 1
        }
        return false
    }
}

// ============================================================================
// Queue[T] - FIFO queue
// ============================================================================

/// A first-in-first-out (FIFO) queue.
///
/// `Queue[T]` provides enqueue and dequeue operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let queue: Queue[Str] = Queue::create[Str]()
/// queue.enqueue("first")
/// queue.enqueue("second")
/// queue.enqueue("third")
/// print(queue.dequeue().unwrap())  // "first"
/// ```
pub type Queue[T] {
    /// Internal storage
    data: [T],
    /// Head index (front of queue)
    head: I64,
    /// Tail index (back of queue)
    tail: I64,
    /// Number of elements
    length: I64,
    /// Capacity
    capacity: I64
}

impl[T] Queue[T] {
    /// Creates a new empty Queue.
    pub func create() -> Queue[T] {
        let initial_capacity: I64 = 16
        return Queue {
            data: [],
            head: 0,
            tail: 0,
            length: 0,
            capacity: initial_capacity,
        }
    }

    /// Creates a Queue with specified initial capacity.
    pub func with_capacity(cap: I64) -> Queue[T] {
        return Queue {
            data: [],
            head: 0,
            tail: 0,
            length: 0,
            capacity: cap,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.enqueue(item)
    }

    pub func clear(mut this) {
        this.data.clear()
        this.head = 0
        this.tail = 0
        this.length = 0
    }

    /// Adds an item to the back of the queue.
    pub func enqueue(mut this, item: T) {
        if this.length >= this.capacity {
            this.grow()
        }

        let idx: I64 = this.tail % this.capacity
        // Always push to grow the data array as needed
        this.data.push(item)
        this.tail = this.tail + 1
        this.length = this.length + 1
    }

    /// Removes and returns the item at the front of the queue.
    pub func dequeue(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx: I64 = this.head % this.capacity
        let item: T = this.data[idx]
        this.head = this.head + 1
        this.length = this.length - 1

        // Normalize indices when queue is empty
        if this.length == 0 {
            this.head = 0
            this.tail = 0
        }

        return Just(item)
    }

    /// Returns the item at the front without removing it.
    pub func peek(this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }

        let idx: I64 = this.head % this.capacity
        return Just(this.data[idx])
    }

    /// Grows the queue capacity.
    func grow(mut this) {
        let new_capacity: I64 = this.capacity * 2
        var new_data: [T] = []

        // Copy elements in order
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            new_data.push(this.data[idx])
            i = i + 1
            cnt = cnt + 1
        }

        this.data = new_data
        this.head = 0
        this.tail = this.length
        this.capacity = new_capacity
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] Queue[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            if this.data[idx] == item {
                // Shift elements to fill the gap
                var j: I64 = cnt
                loop (j < this.length - 1) {
                    let curr_idx: I64 = (this.head + j) % this.capacity
                    let next_idx: I64 = (this.head + j + 1) % this.capacity
                    this.data[curr_idx] = this.data[next_idx]
                    j = j + 1
                }
                this.tail = this.tail - 1
                this.length = this.length - 1
                return true
            }
            i = i + 1
            cnt = cnt + 1
        }
        return false
    }

    /// Returns true if the queue contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = this.head
        var cnt: I64 = 0
        loop (cnt < this.length) {
            let idx: I64 = i % this.capacity
            if this.data[idx] == item {
                return true
            }
            i = i + 1
            cnt = cnt + 1
        }
        return false
    }
}

// ============================================================================
// Stack[T] - LIFO stack
// ============================================================================

/// A last-in-first-out (LIFO) stack.
///
/// `Stack[T]` provides push and pop operations with O(1) complexity.
///
/// # Example
///
/// ```tml
/// let stack: Stack[I32] = Stack::create[I32]()
/// stack.push(1)
/// stack.push(2)
/// stack.push(3)
/// print(stack.pop().unwrap().to_string())  // 3
/// ```
pub type Stack[T] {
    /// Internal storage
    data: [T],
    /// Length
    length: I64
}

impl[T] Stack[T] {
    /// Creates a new empty Stack.
    pub func create() -> Stack[T] {
        return Stack {
            data: [],
            length: 0,
        }
    }

    /// Creates a Stack with specified initial capacity.
    pub func with_capacity(capacity: I64) -> Stack[T] {
        return Stack {
            data: [],
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.push(item)
    }

    pub func clear(mut this) {
        this.data.clear()
        this.length = 0
    }

    /// Pushes an item onto the stack.
    pub func push(mut this, item: T) {
        this.data.push(item)
        this.length = this.length + 1
    }

    /// Pops an item from the stack.
    pub func pop(mut this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }
        this.length = this.length - 1
        return Just(this.data[this.length])
    }

    /// Returns the item at the top without removing it.
    pub func peek(this) -> Maybe[T] {
        if this.length == 0 {
            return Nothing
        }
        return Just(this.data[this.length - 1])
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] Stack[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                // Shift elements down
                var j: I64 = i
                loop (j < this.length - 1) {
                    this.data[j] = this.data[j + 1]
                    j = j + 1
                }
                this.length = this.length - 1
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns true if the stack contains the element.
    pub func contains(this, item: T) -> Bool {
        var i: I64 = 0
        loop (i < this.length) {
            if this.data[i] == item {
                return true
            }
            i = i + 1
        }
        return false
    }
}

// ============================================================================
// LinkedListNode[T] - Node for doubly-linked list
// ============================================================================

/// A node in a doubly-linked list.
pub type LinkedListNode[T] {
    value: T,
    prev: I64,  // Index to previous node
    next: I64   // Index to next node
}

// ============================================================================
// LinkedList[T] - Doubly-linked list (simplified array-based)
// ============================================================================

/// A doubly-linked list for efficient insertion and removal.
///
/// Note: This is a simplified implementation using indices into an array
/// rather than raw pointers.
///
/// # Example
///
/// ```tml
/// let list: LinkedList[I32] = LinkedList::create[I32]()
/// list.add_last(1)
/// list.add_last(2)
/// list.add_last(3)
/// // List: 1 <-> 2 <-> 3
/// print(list.remove_first().unwrap().to_string())  // 1
/// ```
pub type LinkedList[T] {
    /// Nodes storage
    nodes: [LinkedListNode[T]],
    /// Number of nodes in storage
    node_count: I64,
    /// Head index (-1 for empty)
    head: I64,
    /// Tail index (-1 for empty)
    tail: I64,
    /// Number of elements
    length: I64
}

impl[T] LinkedList[T] {
    /// Creates a new empty LinkedList.
    pub func create() -> LinkedList[T] {
        return LinkedList {
            nodes: [],
            node_count: 0,
            head: -1,
            tail: -1,
            length: 0,
        }
    }

    pub func count(this) -> I64 {
        return this.length
    }

    pub func is_empty(this) -> Bool {
        return this.length == 0
    }

    pub func add(mut this, item: T) {
        this.add_last(item)
    }

    pub func clear(mut this) {
        this.nodes.clear()
        this.node_count = 0
        this.head = -1
        this.tail = -1
        this.length = 0
    }

    /// Adds an item at the beginning of the list.
    pub func add_first(mut this, item: T) {
        let node_idx: I64 = this.node_count
        let node: LinkedListNode[T] = LinkedListNode {
            value: item,
            prev: -1,
            next: this.head,
        }
        this.nodes.push(node)
        this.node_count = this.node_count + 1

        if this.head >= 0 {
            this.nodes[this.head].prev = node_idx
        }

        this.head = node_idx

        if this.tail < 0 {
            this.tail = node_idx
        }

        this.length = this.length + 1
    }

    /// Adds an item at the end of the list.
    pub func add_last(mut this, item: T) {
        let node_idx: I64 = this.node_count
        let node: LinkedListNode[T] = LinkedListNode {
            value: item,
            prev: this.tail,
            next: -1,
        }
        this.nodes.push(node)
        this.node_count = this.node_count + 1

        if this.tail >= 0 {
            this.nodes[this.tail].next = node_idx
        }

        this.tail = node_idx

        if this.head < 0 {
            this.head = node_idx
        }

        this.length = this.length + 1
    }

    /// Removes and returns the first item.
    pub func remove_first(mut this) -> Maybe[T] {
        if this.head < 0 {
            return Nothing
        }

        let value: T = this.nodes[this.head].value
        let next: I64 = this.nodes[this.head].next

        if next >= 0 {
            this.nodes[next].prev = -1
        } else {
            this.tail = -1
        }

        this.head = next
        this.length = this.length - 1

        return Just(value)
    }

    /// Removes and returns the last item.
    pub func remove_last(mut this) -> Maybe[T] {
        if this.tail < 0 {
            return Nothing
        }

        let value: T = this.nodes[this.tail].value
        let prev: I64 = this.nodes[this.tail].prev

        if prev >= 0 {
            this.nodes[prev].next = -1
        } else {
            this.head = -1
        }

        this.tail = prev
        this.length = this.length - 1

        return Just(value)
    }

    /// Returns the first item without removing it.
    pub func first(this) -> Maybe[T] {
        if this.head < 0 {
            return Nothing
        }
        return Just(this.nodes[this.head].value)
    }

    /// Returns the last item without removing it.
    pub func last(this) -> Maybe[T] {
        if this.tail < 0 {
            return Nothing
        }
        return Just(this.nodes[this.tail].value)
    }
}

/// Methods that require element equality comparison.
impl[T: PartialEq] LinkedList[T] {
    /// Removes the first occurrence of an element.
    /// Returns true if the element was found and removed.
    pub func remove(mut this, item: T) -> Bool {
        var idx: I64 = this.head
        loop (idx >= 0) {
            if this.nodes[idx].value == item {
                let prev_idx: I64 = this.nodes[idx].prev
                let next_idx: I64 = this.nodes[idx].next

                // Update previous node's next pointer
                if prev_idx >= 0 {
                    this.nodes[prev_idx].next = next_idx
                } else {
                    this.head = next_idx
                }

                // Update next node's prev pointer
                if next_idx >= 0 {
                    this.nodes[next_idx].prev = prev_idx
                } else {
                    this.tail = prev_idx
                }

                this.length = this.length - 1
                return true
            }
            idx = this.nodes[idx].next
        }
        return false
    }

    /// Returns true if the list contains the element.
    pub func contains(this, item: T) -> Bool {
        var idx: I64 = this.head
        loop (idx >= 0) {
            if this.nodes[idx].value == item {
                return true
            }
            idx = this.nodes[idx].next
        }
        return false
    }
}

// ============================================================================
// Helper functions
// ============================================================================

func max_i64(a: I64, b: I64) -> I64 {
    if a > b {
        return a
    } else {
        return b
    }
}

// ============================================================================
// Tests
// ============================================================================

use test

@test
func test_array_list_basic() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()

    list.add(10)
    list.add(20)
    list.add(30)

    assert_eq(list.count(), 3 as I64, "count should be 3")
    assert_eq(list.get(0), 10 as I64, "first element")
    assert_eq(list.get(1), 20 as I64, "second element")
    assert_eq(list.get(2), 30 as I64, "third element")

    list.set(1, 25)
    assert_eq(list.get(1), 25 as I64, "after set")
    return 0
}

@test
func test_array_list_insert_remove() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()

    list.add(1)
    list.add(3)
    list.insert(1, 2)  // Insert 2 at index 1

    assert_eq(list.count(), 3 as I64, "count after insert")
    assert_eq(list.get(0), 1 as I64, "element 0")
    assert_eq(list.get(1), 2 as I64, "element 1")
    assert_eq(list.get(2), 3 as I64, "element 2")

    list.remove_at(1)  // Remove index 1

    assert_eq(list.count(), 2 as I64, "count after remove")
    assert_eq(list.get(0), 1 as I64, "element 0 after remove")
    assert_eq(list.get(1), 3 as I64, "element 1 after remove")
    return 0
}

@test
func test_queue_basic() -> I32 {
    var queue: Queue[I64] = Queue::create[I64]()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)

    assert_eq(queue.count(), 3 as I64, "count should be 3")

    let v1: Maybe[I64] = queue.dequeue()
    assert(v1 == Just(1 as I64), "dequeue should return 1")

    let v2: Maybe[I64] = queue.dequeue()
    assert(v2 == Just(2 as I64), "dequeue should return 2")

    assert_eq(queue.count(), 1 as I64, "count should be 1")

    let v3: Maybe[I64] = queue.peek()
    assert(v3 == Just(3 as I64), "peek should return 3")

    let v4: Maybe[I64] = queue.dequeue()
    assert(v4 == Just(3 as I64), "dequeue should return 3")

    let v5: Maybe[I64] = queue.dequeue()
    assert(v5 == Nothing, "dequeue on empty should return Nothing")
    return 0
}

@test
func test_stack_basic() -> I32 {
    var stack: Stack[I64] = Stack::create[I64]()

    stack.push(1)
    stack.push(2)
    stack.push(3)

    assert_eq(stack.count(), 3 as I64, "count should be 3")

    let p1: Maybe[I64] = stack.peek()
    assert(p1 == Just(3 as I64), "peek should return 3")

    let v1: Maybe[I64] = stack.pop()
    assert(v1 == Just(3 as I64), "pop should return 3")

    let v2: Maybe[I64] = stack.pop()
    assert(v2 == Just(2 as I64), "pop should return 2")

    assert_eq(stack.count(), 1 as I64, "count should be 1")

    let v3: Maybe[I64] = stack.pop()
    assert(v3 == Just(1 as I64), "pop should return 1")

    let v4: Maybe[I64] = stack.pop()
    assert(v4 == Nothing, "pop on empty should return Nothing")
    return 0
}

@test
func test_linked_list_basic() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()

    list.add_first(2)
    list.add_first(1)
    list.add_last(3)

    assert_eq(list.count(), 3 as I64, "count should be 3")

    let f: Maybe[I64] = list.first()
    assert(f == Just(1 as I64), "first should be 1")

    let l: Maybe[I64] = list.last()
    assert(l == Just(3 as I64), "last should be 3")

    let r1: Maybe[I64] = list.remove_first()
    assert(r1 == Just(1 as I64), "remove_first should return 1")

    let r2: Maybe[I64] = list.remove_last()
    assert(r2 == Just(3 as I64), "remove_last should return 3")

    assert_eq(list.count(), 1 as I64, "count should be 1")
    return 0
}

@test
func test_hash_set_basic() -> I32 {
    var set: HashSet[I64] = HashSet::create[I64]()

    set.add(10)
    set.add(20)
    set.add(10)  // Duplicate - should be ignored

    // Note: Due to placeholder hash function, count may not reflect true behavior
    assert(set.count() >= 1 as I64, "count should be at least 1")
    return 0
}
