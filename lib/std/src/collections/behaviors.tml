//! Behavior implementations for collection types.
//!
//! This module provides behavior implementations for the collection types
//! [`List[T]`] and [`HashMap[K, V]`] defined in this crate.
//!
//! # List[T] Implementations
//!
//! [`List`] implements the following behaviors:
//!
//! | Behavior | Constraint | Description |
//! |----------|------------|-------------|
//! | [`Duplicate`] | `T: Duplicate` | Deep clone of the list |
//! | [`PartialEq`] | `T: PartialEq` | Equality comparison |
//! | [`Eq`] | `T: Eq` | Reflexive equality |
//! | [`PartialOrd`] | `T: PartialOrd` | Lexicographic ordering |
//! | [`Ord`] | `T: Ord` | Total lexicographic ordering |
//! | [`Default`] | - | Creates empty list |
//! | [`Display`] | `T: Display` | String representation |
//! | [`Debug`] | `T: Debug` | Debug representation |
//! | [`Hash`] | `T: Hash` | Hash of all elements |
//! | [`Index`] | - | Index access with `list[i]` |
//! | [`FromIterator`] | - | Build from iterator |
//! | [`IntoIterator`] | - | Iterate over elements |
//!
//! # HashMap[K, V] Implementations
//!
//! [`HashMap`] implements:
//!
//! | Behavior | Description |
//! |----------|-------------|
//! | [`Default`] | Creates empty map |
//! | [`Display`] | String representation |
//! | [`Debug`] | Debug representation |
//! | [`Index`] | Key access with `map[key]` |
//!
//! # Examples
//!
//! ## List Operations
//!
//! ```tml
//! use std::collections::List
//!
//! let list = List::from([1, 2, 3])
//!
//! // Equality
//! assert(list == List::from([1, 2, 3]))
//!
//! // Ordering (lexicographic)
//! assert(List::from([1, 2]) < List::from([1, 3]))
//!
//! // Display
//! println(list.to_string())  // "[1, 2, 3]"
//!
//! // Iteration
//! for item in list {
//!     println(item.to_string())
//! }
//! ```
//!
//! ## HashMap Operations
//!
//! ```tml
//! use std::collections::HashMap
//!
//! let map: HashMap[Str, I64] = HashMap::default()
//! map.insert("key", 42)
//!
//! // Index access
//! let value = map["key"]  // 42
//! ```

use std::collections::{List, HashMap, HashMapIter}

// ============================================================================
// List[T] - Duplicate (Clone)
// ============================================================================

/// Deep clones a list, duplicating each element.
impl[T: Duplicate] Duplicate for List[T] {
    pub func duplicate(this) -> List[T] {
        let result: List[T] = List::new(this.capacity())
        let mut i: I64 = 0
        loop (i < this.len()) {
            result.push(this.get(i).duplicate())
            i = i + 1
        }
        return result
    }
}

// ============================================================================
// List[T] - PartialEq, Eq
// ============================================================================

/// Element-wise equality comparison for lists.
///
/// Two lists are equal if they have the same length and all corresponding
/// elements are equal.
impl[T: PartialEq] PartialEq for List[T] {
    pub func eq(this, other: ref List[T]) -> Bool {
        if this.len() != other.len() {
            return false
        }
        let mut i: I64 = 0
        loop (i < this.len()) {
            if this.get(i).ne(ref other.get(i)) {
                return false
            }
            i = i + 1
        }
        return true
    }
}

impl[T: Eq] Eq for List[T] {}

// ============================================================================
// List[T] - PartialOrd, Ord (Lexicographic)
// ============================================================================

/// Lexicographic ordering for lists.
///
/// Lists are compared element by element from the start. The first differing
/// element determines the ordering. If all compared elements are equal, the
/// shorter list is considered "less than" the longer one.
///
/// # Examples
///
/// ```tml
/// assert([1, 2] < [1, 3])      // 2 < 3
/// assert([1, 2] < [1, 2, 3])   // Shorter is less
/// assert([2] > [1, 2, 3])      // 2 > 1
/// ```
impl[T: PartialOrd] PartialOrd for List[T] {
    pub func partial_cmp(this, other: ref List[T]) -> Maybe[Ordering] {
        let min_len: I64 = if this.len() < other.len() then this.len() else other.len()
        let mut i: I64 = 0
        loop (i < min_len) {
            when this.get(i).partial_cmp(ref other.get(i)) {
                Just(ord) => {
                    when ord {
                        Less => return Just(Less),
                        Greater => return Just(Greater),
                        Equal => {}
                    }
                },
                Nothing => return Nothing
            }
            i = i + 1
        }
        // All compared elements are equal, compare lengths
        if this.len() < other.len() {
            return Just(Less)
        }
        if this.len() > other.len() {
            return Just(Greater)
        }
        return Just(Equal)
    }
}

impl[T: Ord] Ord for List[T] {
    pub func cmp(this, other: ref List[T]) -> Ordering {
        let min_len: I64 = if this.len() < other.len() then this.len() else other.len()
        let mut i: I64 = 0
        loop (i < min_len) {
            when this.get(i).cmp(ref other.get(i)) {
                Less => return Less,
                Greater => return Greater,
                Equal => {}
            }
            i = i + 1
        }
        // All compared elements are equal, compare lengths
        if this.len() < other.len() {
            return Less
        }
        if this.len() > other.len() {
            return Greater
        }
        return Equal
    }
}

// ============================================================================
// List[T] - Default
// ============================================================================

/// Creates an empty list with default initial capacity.
impl[T] Default for List[T] {
    pub func default() -> List[T] {
        return List::new(8)
    }
}

// ============================================================================
// List[T] - Display, Debug
// ============================================================================

/// Formats a list as `[elem1, elem2, elem3]`.
impl[T: Display] Display for List[T] {
    pub func to_string(this) -> Str {
        let mut result: Str = "["
        let mut i: I64 = 0
        loop (i < this.len()) {
            if i > 0 {
                result = result + ", "
            }
            result = result + this.get(i).to_string()
            i = i + 1
        }
        return result + "]"
    }
}

/// Formats a list with type info as `List[elem1, elem2, elem3]`.
impl[T: Debug] Debug for List[T] {
    pub func debug_string(this) -> Str {
        let mut result: Str = "List["
        let mut i: I64 = 0
        loop (i < this.len()) {
            if i > 0 {
                result = result + ", "
            }
            result = result + this.get(i).debug_string()
            i = i + 1
        }
        return result + "]"
    }
}

// ============================================================================
// List[T] - Hash
// ============================================================================

/// Hashes a list by combining the hashes of all elements.
impl[T: Hash] Hash for List[T] {
    pub func hash(this) -> I64 {
        let mut h: I64 = 0
        let mut i: I64 = 0
        loop (i < this.len()) {
            h = combine_hashes(h, this.get(i).hash())
            i = i + 1
        }
        return h
    }
}

// ============================================================================
// List[T] - Index
// ============================================================================

/// Enables `list[index]` syntax for element access.
impl[T] Index[I64] for List[T] {
    type Output = T

    pub func index(this, idx: I64) -> T {
        return this.get(idx)
    }
}

/// Enables `list[index] = value` syntax for mutable access.
impl[T] IndexMut[I64] for List[T] {
    pub func index_mut(mut this, idx: I64) -> mut ref T {
        return lowlevel { list_get_mut(this.handle, idx) }
    }
}

// ============================================================================
// List[T] - FromIterator
// ============================================================================

/// Builds a list by collecting elements from an iterator.
///
/// # Examples
///
/// ```tml
/// let list: List[I64] = (1 to 5).collect()
/// assert(list.len() == 5)
/// ```
impl[T] FromIterator[T] for List[T] {
    pub func from_iter[I: Iterator](iter: I) -> List[T] where I::Item = T {
        let result: List[T] = List::new(8)
        var it: I = iter
        loop (true) {
            when it.next() {
                Just(item) => result.push(item),
                Nothing => break
            }
        }
        return result
    }
}

// ============================================================================
// List[T] - Extend
// ============================================================================

/// Extends the list with elements from an iterator.
impl[T] Extend[T] for List[T] {
    pub func extend[I: Iterator](mut this, iter: I) where I::Item = T {
        var it: I = iter
        loop (true) {
            when it.next() {
                Just(item) => this.push(item),
                Nothing => break
            }
        }
    }
}

// ============================================================================
// List[T] - IntoIterator
// ============================================================================

/// An iterator over elements of a [`List`].
///
/// This struct is created by the [`into_iter`](IntoIterator::into_iter) method
/// on [`List`]. See its documentation for more.
pub type ListIter[T] {
    list: List[T],
    index: I64
}

impl[T] Iterator for ListIter[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        if this.index >= this.list.len() {
            return Nothing
        }
        let item: T = this.list.get(this.index)
        this.index = this.index + 1
        return Just(item)
    }
}

/// Enables using a list in `for` loops.
impl[T] IntoIterator for List[T] {
    type Item = T
    type IntoIter = ListIter[T]

    pub func into_iter(this) -> ListIter[T] {
        return ListIter { list: this, index: 0 }
    }
}

impl[T] List[T] {
    /// Returns an iterator over the list.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let list = List::from([1, 2, 3])
    /// for item in list.iter() {
    ///     println(item.to_string())
    /// }
    /// ```
    pub func iter(this) -> ListIter[T] {
        return ListIter { list: this, index: 0 }
    }
}

// ============================================================================
// HashMap[K, V] - Default
// ============================================================================

/// Creates an empty hash map with default initial capacity.
impl[K, V] Default for HashMap[K, V] {
    pub func default() -> HashMap[K, V] {
        return HashMap::new(16)
    }
}

// ============================================================================
// HashMap[K, V] - Duplicate (Clone)
// ============================================================================

/// Duplicates a hash map by iterating over all entries.
impl[K: Duplicate + Hash, V: Duplicate] Duplicate for HashMap[K, V] {
    pub func duplicate(this) -> HashMap[K, V] {
        let result: HashMap[K, V] = HashMap::new(this.len() * 2)
        let iter = this.iter()
        loop (iter.has_next()) {
            result.set(iter.key().duplicate(), iter.value().duplicate())
            iter.next()
        }
        iter.destroy()
        return result
    }
}

// ============================================================================
// HashMap[K, V] - Display, Debug
// ============================================================================

/// Displays the map as `{key1: value1, key2: value2, ...}`.
impl[K: Display, V: Display] Display for HashMap[K, V] {
    pub func to_string(this) -> Str {
        let mut result: Str = "{"
        let iter = this.iter()
        let mut first: Bool = true
        loop (iter.has_next()) {
            if not first {
                result = result + ", "
            }
            first = false
            result = result + iter.key().to_string() + ": " + iter.value().to_string()
            iter.next()
        }
        iter.destroy()
        return result + "}"
    }
}

/// Displays debug info as `HashMap{key1: value1, key2: value2, ...}`.
impl[K: Debug, V: Debug] Debug for HashMap[K, V] {
    pub func debug_string(this) -> Str {
        let mut result: Str = "HashMap{"
        let iter = this.iter()
        let mut first: Bool = true
        loop (iter.has_next()) {
            if not first {
                result = result + ", "
            }
            first = false
            result = result + iter.key().debug_string() + ": " + iter.value().debug_string()
            iter.next()
        }
        iter.destroy()
        return result + "}"
    }
}

// ============================================================================
// HashMap[K, V] - Index
// ============================================================================

/// Enables `map[key]` syntax for value access.
///
/// # Panics
///
/// Panics if the key is not present in the map.
impl[K, V] Index[K] for HashMap[K, V] {
    type Output = V

    pub func index(this, key: K) -> V {
        return this.get(key)
    }
}
