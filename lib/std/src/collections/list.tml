//! Dynamic array collection type — pure TML implementation.
//!
//! `List[T]` is a generic collection that stores elements of type `T`
//! contiguously in memory and grows as needed.
//!
//! Elements are stored at their natural size using `size_of[T]()`.
//! This correctly handles scalar types (I32, I64, Str) as well as
//! multi-field struct types (LinkedListNode, Bm25Result, etc.).
//!
//! # Example
//!
//! ```tml
//! let nums = List[I32]::new(8)
//! nums.push(10)
//! nums.push(20)
//! let first = nums.get(0)  // 10
//! nums.destroy()
//! ```

use core::intrinsics::{ptr_read, ptr_write}

/// A dynamic array that grows automatically.
///
/// `List[T]` stores elements contiguously in a heap-allocated buffer.
/// Each element occupies `size_of[T]()` bytes.
///
/// # Type Parameters
///
/// * `T` - The type of elements stored in the list
pub type List[T] {
    handle: *Unit
}

// Internal layout of the list header (stored at handle):
//   offset 0:  data pointer (*Unit) — 8 bytes
//   offset 8:  len (I64) — 8 bytes
//   offset 16: capacity (I64) — 8 bytes
//   offset 24: stride (I64) — 8 bytes  (cached size_of[T])
// Total header: 32 bytes

impl[T] List[T] {
    /// Creates a new list with the specified initial capacity.
    pub func new(initial_capacity: I64) -> List[T] {
        // Ensure minimum capacity of 4
        var cap: I64 = initial_capacity
        if cap < 4 {
            cap = 4
        }

        // Get element size
        let stride: I64 = lowlevel { sizeof_type[T]() }
        // Minimum stride of 8 for scalar types stored as I64
        var elem_size: I64 = stride
        if elem_size < 8 {
            elem_size = 8
        }

        // Allocate header (32 bytes: ptr + len + capacity + stride)
        let header: *Unit = lowlevel { mem_alloc(32) }
        let hdr: I64 = header as I64

        // Allocate data buffer (cap * elem_size bytes)
        let data_size: I64 = cap * elem_size
        let data: *Unit = lowlevel { mem_alloc(data_size) }

        // Store data pointer at offset 0
        let p_data: *I64 = hdr as *I64
        lowlevel { ptr_write[I64](p_data, data as I64) }

        // Store len (0) at offset 8
        let p_len: *I64 = (hdr + 8) as *I64
        lowlevel { ptr_write[I64](p_len, 0 as I64) }

        // Store capacity at offset 16
        let p_cap: *I64 = (hdr + 16) as *I64
        lowlevel { ptr_write[I64](p_cap, cap) }

        // Store stride at offset 24
        let p_stride: *I64 = (hdr + 24) as *I64
        lowlevel { ptr_write[I64](p_stride, elem_size) }

        List[T] { handle: header }
    }

    /// Creates a new list with default capacity (8).
    pub func default() -> List[T] {
        List[T].new(8)
    }

    /// Appends an element to the back of the list.
    pub func push(this, value: T) {
        let hdr: I64 = this.handle as I64

        // Read current len, capacity and stride
        let p_len: *I64 = (hdr + 8) as *I64
        let p_cap: *I64 = (hdr + 16) as *I64
        let p_stride: *I64 = (hdr + 24) as *I64
        let cur_len: I64 = lowlevel { ptr_read[I64](p_len) }
        let cur_cap: I64 = lowlevel { ptr_read[I64](p_cap) }
        let stride: I64 = lowlevel { ptr_read[I64](p_stride) }

        // Grow if needed
        if cur_len >= cur_cap {
            let new_cap: I64 = cur_cap * 2
            let new_size: I64 = new_cap * stride

            // Read current data pointer
            let p_data: *I64 = hdr as *I64
            let old_data_addr: I64 = lowlevel { ptr_read[I64](p_data) }
            let old_data: *Unit = old_data_addr as *Unit

            // Reallocate
            let new_data: *Unit = lowlevel { mem_realloc(old_data, new_size) }

            // Update header
            lowlevel { ptr_write[I64](p_data, new_data as I64) }
            lowlevel { ptr_write[I64](p_cap, new_cap) }
        }

        // Read (possibly updated) data pointer
        let p_data2: *I64 = hdr as *I64
        let data_addr: I64 = lowlevel { ptr_read[I64](p_data2) }

        // Write value at data[len] using T-sized stride
        let elem_ptr: *T = (data_addr + cur_len * stride) as *T
        lowlevel { ptr_write[T](elem_ptr, value) }

        // Increment len
        lowlevel { ptr_write[I64](p_len, cur_len + 1) }
    }

    /// Removes the last element from the list and returns it.
    pub func pop(this) -> T {
        let hdr: I64 = this.handle as I64
        let p_len: *I64 = (hdr + 8) as *I64
        let p_stride: *I64 = (hdr + 24) as *I64
        let cur_len: I64 = lowlevel { ptr_read[I64](p_len) }
        let stride: I64 = lowlevel { ptr_read[I64](p_stride) }

        // Read data pointer
        let p_data: *I64 = hdr as *I64
        let data_addr: I64 = lowlevel { ptr_read[I64](p_data) }

        // Read element at data[len-1]
        let new_len: I64 = cur_len - 1
        let elem_ptr: *T = (data_addr + new_len * stride) as *T
        let val: T = lowlevel { ptr_read[T](elem_ptr) }

        // Decrement len
        lowlevel { ptr_write[I64](p_len, new_len) }

        val
    }

    /// Returns the element at the given index.
    pub func get(this, index: I64) -> T {
        let hdr: I64 = this.handle as I64
        let p_stride: *I64 = (hdr + 24) as *I64
        let stride: I64 = lowlevel { ptr_read[I64](p_stride) }

        // Read data pointer
        let p_data: *I64 = hdr as *I64
        let data_addr: I64 = lowlevel { ptr_read[I64](p_data) }

        // Read element at data[index]
        let elem_ptr: *T = (data_addr + index * stride) as *T
        let val: T = lowlevel { ptr_read[T](elem_ptr) }
        val
    }

    /// Sets the element at the given index.
    pub func set(this, index: I64, value: T) {
        let hdr: I64 = this.handle as I64
        let p_stride: *I64 = (hdr + 24) as *I64
        let stride: I64 = lowlevel { ptr_read[I64](p_stride) }

        // Read data pointer
        let p_data: *I64 = hdr as *I64
        let data_addr: I64 = lowlevel { ptr_read[I64](p_data) }

        // Write value at data[index]
        let elem_ptr: *T = (data_addr + index * stride) as *T
        lowlevel { ptr_write[T](elem_ptr, value) }
    }

    /// Returns the number of elements in the list.
    pub func len(this) -> I64 {
        let hdr: I64 = this.handle as I64
        let p_len: *I64 = (hdr + 8) as *I64
        lowlevel { ptr_read[I64](p_len) }
    }

    /// Returns the current capacity of the list.
    pub func capacity(this) -> I64 {
        let hdr: I64 = this.handle as I64
        let p_cap: *I64 = (hdr + 16) as *I64
        lowlevel { ptr_read[I64](p_cap) }
    }

    /// Returns `true` if the list contains no elements.
    pub func is_empty(this) -> Bool {
        this.len() == 0
    }

    /// Returns the first element of the list.
    pub func first(this) -> T {
        this.get(0)
    }

    /// Returns the last element of the list.
    pub func last(this) -> T {
        this.get(this.len() - 1)
    }

    /// Removes all elements from the list.
    pub func clear(this) {
        let hdr: I64 = this.handle as I64
        let p_len: *I64 = (hdr + 8) as *I64
        lowlevel { ptr_write[I64](p_len, 0 as I64) }
    }

    /// Destroys the list and frees all associated memory.
    /// Safe to call multiple times — subsequent calls are no-ops.
    pub func destroy(mut this) {
        if this.handle == (0 as *Unit) {
            return
        }
        let hdr: I64 = this.handle as I64

        // Free data buffer
        let p_data: *I64 = hdr as *I64
        let data_addr: I64 = lowlevel { ptr_read[I64](p_data) }
        let data: *Unit = data_addr as *Unit
        lowlevel { mem_free(data) }

        // Free header
        lowlevel { mem_free(this.handle) }
        this.handle = 0 as *Unit
    }
}

impl[T] Drop for List[T] {
    func drop(mut this) {
        this.destroy()
    }
}
