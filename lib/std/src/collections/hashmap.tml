//! Hash-based key-value collection type — pure TML implementation.
//!
//! `HashMap[K, V]` stores key-value pairs with O(1) average lookup time.
//! Uses open-addressing with linear probing, FNV-1a hashing, and Swiss Table-style
//! control bytes for fast probe filtering.
//!
//! All keys and values are stored internally as I64 (type-erased).
//! For integer types, the value is sign-extended. For pointer types
//! (Str, *T), the pointer address is stored directly.
//!
//! # Example
//!
//! ```tml
//! let scores = HashMap[Str, I32]::new(16)
//! scores.set("Alice", 100)
//! scores.set("Bob", 85)
//! let alice_score = scores.get("Alice")  // 100
//! scores.destroy()
//! ```

use core::intrinsics::{ptr_read, ptr_write}

/// A hash-based key-value collection.
///
/// `HashMap[K, V]` stores key-value pairs with O(1) average lookup time.
/// Uses open-addressing with linear probing and Swiss Table-style control bytes.
///
/// # Type Parameters
///
/// * `K` - The type of keys
/// * `V` - The type of values
pub type HashMap[K, V] {
    handle: *Unit
}

// Internal layout of the hashmap header (stored at handle):
//   offset 0:  entries pointer (*Unit) — 8 bytes
//   offset 8:  ctrl pointer (*Unit) — 8 bytes
//   offset 16: len (I64) — 8 bytes
//   offset 24: capacity (I64) — 8 bytes
// Total header: 32 bytes
//
// Each entry (16 bytes):
//   offset 0:  key (I64) — 8 bytes
//   offset 8:  value (I64) — 8 bytes
//
// Control bytes (1 byte per slot, separate dense array):
//   -1   (0xFF) = EMPTY — slot has never been used
//   -128 (0x80) = DELETED — slot was removed (tombstone)
//   0..127      = h2 fingerprint — slot is occupied

impl[K, V] HashMap[K, V] {
    /// Creates a new hashmap with the specified initial capacity.
    pub func new(initial_capacity: I64) -> HashMap[K, V] {
        var cap: I64 = initial_capacity
        if cap < 16 {
            cap = 16
        }

        // Allocate header (32 bytes)
        let header: *Unit = lowlevel { mem_alloc(32) }
        let hdr: I64 = header as I64

        // Allocate entries array (cap * 16 bytes)
        let entries: *Unit = lowlevel { mem_alloc(cap * 16) }

        // Allocate control byte array (cap bytes), init to EMPTY (-1 = 0xFF)
        let ctrl: *Unit = lowlevel { mem_alloc(cap) }
        lowlevel { write_bytes[I8](ctrl, -1 as I8, cap) }

        // Store entries pointer at offset 0
        lowlevel { ptr_write[I64](hdr as *I64, entries as I64) }
        // Store ctrl pointer at offset 8
        lowlevel { ptr_write[I64]((hdr + 8) as *I64, ctrl as I64) }
        // Store len (0) at offset 16
        lowlevel { ptr_write[I64]((hdr + 16) as *I64, 0 as I64) }
        // Store capacity at offset 24
        lowlevel { ptr_write[I64]((hdr + 24) as *I64, cap) }

        HashMap[K, V] { handle: header }
    }

    /// Creates a new hashmap with default capacity (16).
    pub func default() -> HashMap[K, V] {
        HashMap[K, V].new(16)
    }

    /// Inserts a key-value pair into the hashmap.
    /// If the key already exists, the value is updated.
    pub func set(this, key: K, value: V) {
        let hdr: I64 = this.handle as I64
        let p_len: *I64 = (hdr + 16) as *I64
        let p_cap: *I64 = (hdr + 24) as *I64
        var cur_len: I64 = lowlevel { ptr_read[I64](p_len) }
        var cur_cap: I64 = lowlevel { ptr_read[I64](p_cap) }

        // Check load factor: resize if len * 10 > capacity * 7
        if cur_len * 10 > cur_cap * 7 {
            let new_cap: I64 = cur_cap * 2
            let new_mask: I64 = new_cap - 1

            // Allocate new entries and ctrl arrays
            let new_entries: *Unit = lowlevel { mem_alloc(new_cap * 16) }
            let new_ctrl: *Unit = lowlevel { mem_alloc(new_cap) }
            lowlevel { write_bytes[I8](new_ctrl, -1 as I8, new_cap) }
            let new_entries_addr: I64 = new_entries as I64
            let new_ctrl_addr: I64 = new_ctrl as I64

            // Read old pointers
            let old_entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
            let old_ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

            // Rehash all occupied entries (ctrl >= 0 means occupied)
            var i: I64 = 0
            loop (i < cur_cap) {
                let c: I8 = lowlevel { ptr_read[I8]((old_ctrl_addr + i) as *I8) }
                if c >= (0 as I8) {
                    let old_base: I64 = old_entries_addr + i * 16
                    let e_key: I64 = lowlevel { ptr_read[I64](old_base as *I64) }
                    let e_val: I64 = lowlevel { ptr_read[I64]((old_base + 8) as *I64) }

                    let hash: I64 = HashMap[K, V].hash_key(e_key)
                    var h: I64 = hash & new_mask
                    let h2: I8 = HashMap[K, V].h2(hash)

                    // Probe for empty slot (fresh table has no DELETED)
                    loop (lowlevel { ptr_read[I8]((new_ctrl_addr + h) as *I8) } >= (0 as I8)) {
                        h = (h + 1) & new_mask
                    }

                    // Write entry and ctrl
                    let new_base: I64 = new_entries_addr + h * 16
                    lowlevel { ptr_write[I64](new_base as *I64, e_key) }
                    lowlevel { ptr_write[I64]((new_base + 8) as *I64, e_val) }
                    lowlevel { ptr_write[I8]((new_ctrl_addr + h) as *I8, h2) }
                }
                i = i + 1
            }

            // Free old arrays
            lowlevel { mem_free(old_entries_addr as *Unit) }
            lowlevel { mem_free(old_ctrl_addr as *Unit) }

            // Update header
            lowlevel { ptr_write[I64](hdr as *I64, new_entries_addr) }
            lowlevel { ptr_write[I64]((hdr + 8) as *I64, new_ctrl_addr) }
            lowlevel { ptr_write[I64](p_cap, new_cap) }
            cur_cap = new_cap
        }

        // Read current pointers
        let entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        let key_i64: I64 = key as I64
        let mask: I64 = cur_cap - 1
        let hash: I64 = HashMap[K, V].hash_key(key_i64)
        var h: I64 = hash & mask
        let h2: I8 = HashMap[K, V].h2(hash)
        let start: I64 = h

        // Probe: find existing key or first available slot
        var insert_slot: I64 = -1
        var cont: Bool = true
        loop (cont) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + h) as *I8) }

            if c == (-1 as I8) {
                // EMPTY: key not in table — stop probing
                if insert_slot == -1 {
                    insert_slot = h
                }
                cont = false
            } else {
                if c == (-128 as I8) {
                    // DELETED: remember first deleted slot for insertion
                    if insert_slot == -1 {
                        insert_slot = h
                    }
                } else {
                    // OCCUPIED: check if h2 fingerprint matches
                    if c == h2 {
                        let e_key: I64 = lowlevel { ptr_read[I64]((entries_addr + h * 16) as *I64) }
                        if e_key == key_i64 {
                            // Key exists: update value in place
                            lowlevel { ptr_write[I64]((entries_addr + h * 16 + 8) as *I64, value as I64) }
                            return
                        }
                    }
                }
                h = (h + 1) & mask
                if h == start {
                    cont = false
                }
            }
        }

        // Insert new entry
        let slot_base: I64 = entries_addr + insert_slot * 16
        lowlevel { ptr_write[I64](slot_base as *I64, key_i64) }
        lowlevel { ptr_write[I64]((slot_base + 8) as *I64, value as I64) }
        lowlevel { ptr_write[I8]((ctrl_addr + insert_slot) as *I8, h2) }

        cur_len = cur_len + 1
        lowlevel { ptr_write[I64](p_len, cur_len) }
    }

    /// Returns the value associated with the given key.
    /// Returns the zero value of V if the key is not found.
    // NOTE: SSE2 SIMD probing works for non-generic functions (4ns/op vs 9ns scalar)
    // but generic instantiation has codegen bugs with SIMD intrinsics inside lowlevel blocks.
    // Reverted to scalar until generic+SIMD codegen is fixed.
    pub func get(this, key: K) -> V {
        let hdr: I64 = this.handle as I64
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }
        if cur_len == 0 {
            return 0 as V
        }

        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        let entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        let key_i64: I64 = key as I64
        let mask: I64 = cur_cap - 1
        let hash: I64 = HashMap[K, V].hash_key(key_i64)
        var h: I64 = hash & mask
        let h2: I8 = HashMap[K, V].h2(hash)
        let start: I64 = h

        loop (true) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + h) as *I8) }
            if c == (-1 as I8) { return 0 as V }
            if c == h2 {
                let e_key: I64 = lowlevel { ptr_read[I64]((entries_addr + h * 16) as *I64) }
                if e_key == key_i64 {
                    return lowlevel { ptr_read[I64]((entries_addr + h * 16 + 8) as *I64) } as V
                }
            }
            h = (h + 1) & mask
            if h == start { return 0 as V }
        }
    }

    /// Returns `true` if the hashmap contains the given key.
    pub func has(this, key: K) -> Bool {
        let hdr: I64 = this.handle as I64
        let cur_len: I64 = lowlevel { ptr_read[I64]((hdr + 16) as *I64) }
        if cur_len == 0 {
            return false
        }

        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        let entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        let key_i64: I64 = key as I64
        let mask: I64 = cur_cap - 1
        let hash: I64 = HashMap[K, V].hash_key(key_i64)
        var h: I64 = hash & mask
        let h2: I8 = HashMap[K, V].h2(hash)
        let start: I64 = h

        loop (true) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + h) as *I8) }
            if c == (-1 as I8) { return false }
            if c == h2 {
                let e_key: I64 = lowlevel { ptr_read[I64]((entries_addr + h * 16) as *I64) }
                if e_key == key_i64 { return true }
            }
            h = (h + 1) & mask
            if h == start { return false }
        }
    }

    /// Removes a key-value pair from the hashmap.
    /// Returns `true` if the key was found and removed.
    pub func remove(this, key: K) -> Bool {
        let hdr: I64 = this.handle as I64
        let p_len: *I64 = (hdr + 16) as *I64
        let cur_len: I64 = lowlevel { ptr_read[I64](p_len) }
        if cur_len == 0 {
            return false
        }

        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        let entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        let key_i64: I64 = key as I64
        let mask: I64 = cur_cap - 1
        let hash: I64 = HashMap[K, V].hash_key(key_i64)
        var h: I64 = hash & mask
        let h2: I8 = HashMap[K, V].h2(hash)
        let start: I64 = h

        loop (true) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + h) as *I8) }
            if c == (-1 as I8) { return false }
            if c == h2 {
                let e_key: I64 = lowlevel { ptr_read[I64]((entries_addr + h * 16) as *I64) }
                if e_key == key_i64 {
                    lowlevel { ptr_write[I8]((ctrl_addr + h) as *I8, -128 as I8) }
                    lowlevel { ptr_write[I64](p_len, cur_len - 1) }
                    return true
                }
            }
            h = (h + 1) & mask
            if h == start { return false }
        }
    }

    /// Returns the number of key-value pairs in the hashmap.
    pub func len(this) -> I64 {
        let hdr: I64 = this.handle as I64
        lowlevel { ptr_read[I64]((hdr + 16) as *I64) }
    }

    /// Removes all key-value pairs from the hashmap.
    pub func clear(this) {
        let hdr: I64 = this.handle as I64
        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        // Reset all control bytes to EMPTY
        lowlevel { write_bytes[I8](ctrl_addr as *Unit, -1 as I8, cur_cap) }

        // Reset len
        lowlevel { ptr_write[I64]((hdr + 16) as *I64, 0 as I64) }
    }

    /// Destroys the hashmap and frees all associated memory.
    /// Safe to call multiple times — subsequent calls are no-ops.
    pub func destroy(mut this) {
        if this.handle == (0 as *Unit) {
            return
        }
        let hdr: I64 = this.handle as I64

        // Free entries array
        let entries_addr: I64 = lowlevel { ptr_read[I64](hdr as *I64) }
        lowlevel { mem_free(entries_addr as *Unit) }

        // Free ctrl array
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }
        lowlevel { mem_free(ctrl_addr as *Unit) }

        // Free header
        lowlevel { mem_free(this.handle) }
        this.handle = 0 as *Unit
    }

    /// Creates an iterator over the hashmap entries.
    pub func iter(this) -> HashMapIter[K, V] {
        let hdr: I64 = this.handle as I64
        let cur_cap: I64 = lowlevel { ptr_read[I64]((hdr + 24) as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((hdr + 8) as *I64) }

        // Allocate iterator (16 bytes: map_handle + index)
        let iter_mem: *Unit = lowlevel { mem_alloc(16) }
        let iter_addr: I64 = iter_mem as I64

        // Store map handle at offset 0
        lowlevel { ptr_write[I64](iter_addr as *I64, this.handle as I64) }

        // Find first occupied entry (ctrl >= 0)
        var first_idx: I64 = -1
        var i: I64 = 0
        loop (i < cur_cap) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + i) as *I8) }
            if c >= (0 as I8) {
                first_idx = i
                i = cur_cap  // break
            }
            i = i + 1
        }

        // Store index at offset 8
        lowlevel { ptr_write[I64]((iter_addr + 8) as *I64, first_idx) }

        HashMapIter[K, V] { handle: iter_mem }
    }

    // Private: FNV-1a hash of an I64 key.
    // Result may be negative; callers use & mask to get valid index.
    // Uses unsigned arithmetic to avoid signed overflow panic.
    func hash_key(key: I64) -> I64 {
        var h: U64 = 14695981039346656037 as U64  // FNV offset basis
        h = h ^ (key as U64)
        h = h * (1099511628211 as U64)            // FNV prime
        h as I64
    }

    // Private: extract h2 fingerprint (top 7 bits) from hash.
    // Returns 0..127, stored in ctrl byte for occupied slots.
    // Uncorrelated with h1 (low bits) for optimal filtering.
    func h2(hash: I64) -> I8 {
        ((hash >> 57) & 127) as I8
    }
}

/// An iterator over HashMap entries.
///
/// Created by calling `iter()` on a HashMap.
pub type HashMapIter[K, V] {
    handle: *Unit
}

// Iterator layout (16 bytes at handle):
//   offset 0:  map_handle (I64 → *Unit) — pointer to parent HashMap header
//   offset 8:  index (I64) — current position in entries array (-1 = exhausted)

impl[K, V] HashMapIter[K, V] {
    /// Returns `true` if there are more entries to iterate.
    pub func has_next(this) -> Bool {
        let iter_addr: I64 = this.handle as I64
        let idx: I64 = lowlevel { ptr_read[I64]((iter_addr + 8) as *I64) }
        idx >= 0
    }

    /// Advances the iterator to the next entry.
    pub func next(this) {
        let iter_addr: I64 = this.handle as I64
        let cur_idx: I64 = lowlevel { ptr_read[I64]((iter_addr + 8) as *I64) }
        if cur_idx < 0 {
            return
        }

        // Read map handle to access ctrl array
        let map_handle_addr: I64 = lowlevel { ptr_read[I64](iter_addr as *I64) }
        let cur_cap: I64 = lowlevel { ptr_read[I64]((map_handle_addr + 24) as *I64) }
        let ctrl_addr: I64 = lowlevel { ptr_read[I64]((map_handle_addr + 8) as *I64) }

        // Scan forward for next occupied entry (ctrl >= 0)
        var i: I64 = cur_idx + 1
        var found: Bool = false
        loop (i < cur_cap) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + i) as *I8) }
            if c >= (0 as I8) {
                lowlevel { ptr_write[I64]((iter_addr + 8) as *I64, i) }
                found = true
                i = cur_cap  // break
            }
            i = i + 1
        }

        if not found {
            lowlevel { ptr_write[I64]((iter_addr + 8) as *I64, -1 as I64) }
        }
    }

    /// Returns the key of the current entry.
    pub func key(this) -> K {
        let iter_addr: I64 = this.handle as I64
        let cur_idx: I64 = lowlevel { ptr_read[I64]((iter_addr + 8) as *I64) }
        if cur_idx < 0 {
            return 0 as K
        }

        let map_handle_addr: I64 = lowlevel { ptr_read[I64](iter_addr as *I64) }
        let entries_addr: I64 = lowlevel { ptr_read[I64](map_handle_addr as *I64) }

        let key_i64: I64 = lowlevel { ptr_read[I64]((entries_addr + cur_idx * 16) as *I64) }
        key_i64 as K
    }

    /// Returns the value of the current entry.
    pub func value(this) -> V {
        let iter_addr: I64 = this.handle as I64
        let cur_idx: I64 = lowlevel { ptr_read[I64]((iter_addr + 8) as *I64) }
        if cur_idx < 0 {
            return 0 as V
        }

        let map_handle_addr: I64 = lowlevel { ptr_read[I64](iter_addr as *I64) }
        let entries_addr: I64 = lowlevel { ptr_read[I64](map_handle_addr as *I64) }

        let val_i64: I64 = lowlevel { ptr_read[I64]((entries_addr + cur_idx * 16 + 8) as *I64) }
        val_i64 as V
    }

    /// Destroys the iterator and frees all associated memory.
    /// Safe to call multiple times — subsequent calls are no-ops.
    pub func destroy(mut this) {
        if this.handle == (0 as *Unit) {
            return
        }
        lowlevel { mem_free(this.handle) }
        this.handle = 0 as *Unit
    }
}

impl[K, V] Drop for HashMap[K, V] {
    func drop(mut this) {
        this.destroy()
    }
}

impl[K, V] Drop for HashMapIter[K, V] {
    func drop(mut this) {
        this.destroy()
    }
}
