//! UTC date and time from Unix timestamps.
//!
//! This module provides [`DateTime`] for converting between Unix epoch
//! seconds and human-readable date/time components (year, month, day,
//! hour, minute, second). UTC only — no timezone support.
//!
//! # Example
//!
//! ```tml
//! use std::datetime::DateTime
//!
//! let dt: DateTime = DateTime::now()
//! let year: I64 = dt.year()
//! ```

use std::time::SystemTime

/// A UTC date and time, decomposed into components.
///
/// Created from Unix epoch seconds via [`from_timestamp`] or from the
/// current wall clock via [`now`].
pub type DateTime {
    _year: I64,
    _month: I64,
    _day: I64,
    _hour: I64,
    _minute: I64,
    _second: I64,
    _timestamp: I64
}

impl DateTime {
    /// Returns the current UTC date and time.
    pub func now() -> DateTime {
        let st: SystemTime = SystemTime::now()
        return DateTime::from_timestamp(st.as_secs())
    }

    /// Creates a DateTime from a Unix timestamp (seconds since epoch).
    pub func from_timestamp(ts: I64) -> DateTime {
        // Civil date from epoch seconds using the algorithm from
        // Howard Hinnant's chrono-compatible date library.
        var secs: I64 = ts
        let second: I64 = secs % 60
        secs = secs / 60
        let minute: I64 = secs % 60
        secs = secs / 60
        let hour: I64 = secs % 24
        let days: I64 = secs / 24

        // Convert day count to civil date (days since 1970-01-01).
        // Shift epoch from 1970-01-01 to 0000-03-01 for easier math.
        let z: I64 = days + 719468
        let era: I64 = (if z >= 0 { z } else { z - 146096 }) / 146097
        let doe: I64 = z - era * 146097  // day of era [0, 146096]
        let yoe: I64 = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365
        let y: I64 = yoe + era * 400
        let doy: I64 = doe - (365 * yoe + yoe / 4 - yoe / 100)  // day of year [0, 365]
        let mp: I64 = (5 * doy + 2) / 153  // [0, 11]
        let d: I64 = doy - (153 * mp + 2) / 5 + 1  // day [1, 31]
        let m_raw: I64 = if mp < 10 { mp + 3 } else { mp - 9 }
        let y_final: I64 = if m_raw <= 2 { y + 1 } else { y }

        return DateTime {
            _year: y_final,
            _month: m_raw,
            _day: d,
            _hour: hour,
            _minute: minute,
            _second: second,
            _timestamp: ts
        }
    }

    /// Creates a DateTime from components (UTC).
    ///
    /// No validation is performed — the caller must provide valid values.
    pub func from_parts(year: I64, month: I64, day: I64,
                        hour: I64, minute: I64, second: I64) -> DateTime {
        // Convert civil date back to epoch seconds.
        let ts: I64 = civil_to_epoch(year, month, day, hour, minute, second)
        return DateTime {
            _year: year,
            _month: month,
            _day: day,
            _hour: hour,
            _minute: minute,
            _second: second,
            _timestamp: ts
        }
    }

    /// Returns the year component.
    pub func year(this) -> I64 { return this._year }

    /// Returns the month component (1–12).
    pub func month(this) -> I64 { return this._month }

    /// Returns the day of the month (1–31).
    pub func day(this) -> I64 { return this._day }

    /// Returns the hour component (0–23).
    pub func hour(this) -> I64 { return this._hour }

    /// Returns the minute component (0–59).
    pub func minute(this) -> I64 { return this._minute }

    /// Returns the second component (0–59).
    pub func second(this) -> I64 { return this._second }

    /// Returns the Unix timestamp (seconds since epoch).
    pub func timestamp(this) -> I64 { return this._timestamp }

    /// Returns the day of the week (0 = Monday, 6 = Sunday).
    pub func weekday(this) -> I64 {
        // 1970-01-01 was Thursday (3).
        var d: I64 = this._timestamp / 86400
        d = (d + 3) % 7
        if d < 0 {
            d = d + 7
        }
        return d
    }

    /// Returns the day of the year (1–366).
    pub func day_of_year(this) -> I64 {
        let jan1_ts: I64 = civil_to_epoch(this._year, 1, 1, 0, 0, 0)
        return (this._timestamp - jan1_ts) / 86400 + 1
    }

    /// Returns true if the year is a leap year.
    pub func is_leap_year(this) -> Bool {
        return is_leap(this._year)
    }

    /// Returns ISO 8601 formatted string: `YYYY-MM-DDThh:mm:ssZ`.
    @allocates
    pub func to_iso8601(this) -> Str {
        return pad4(this._year) + "-" + pad2(this._month) + "-" + pad2(this._day)
             + "T" + pad2(this._hour) + ":" + pad2(this._minute) + ":" + pad2(this._second) + "Z"
    }

    /// Returns date-only string: `YYYY-MM-DD`.
    @allocates
    pub func to_date_string(this) -> Str {
        return pad4(this._year) + "-" + pad2(this._month) + "-" + pad2(this._day)
    }

    /// Returns time-only string: `hh:mm:ss`.
    @allocates
    pub func to_time_string(this) -> Str {
        return pad2(this._hour) + ":" + pad2(this._minute) + ":" + pad2(this._second)
    }

    /// Returns RFC 2822 formatted string: `Thu, 01 Jan 1970 00:00:00 +0000`.
    @allocates
    pub func to_rfc2822(this) -> Str {
        let wd: I64 = this.weekday()
        let day_name: Str = weekday_short(wd)
        let mon_name: Str = month_short(this._month)
        return day_name + ", " + pad2(this._day) + " " + mon_name + " "
             + pad4(this._year) + " " + pad2(this._hour) + ":"
             + pad2(this._minute) + ":" + pad2(this._second) + " +0000"
    }

    /// Returns `Display`-friendly string: `YYYY-MM-DD hh:mm:ss UTC`.
    @allocates
    pub func to_string(this) -> Str {
        return pad4(this._year) + "-" + pad2(this._month) + "-" + pad2(this._day)
             + " " + pad2(this._hour) + ":" + pad2(this._minute) + ":" + pad2(this._second) + " UTC"
    }

    /// Returns debug representation.
    @allocates
    pub func debug_string(this) -> Str {
        return "DateTime(" + this.to_iso8601() + ")"
    }

    /// Parses an ISO 8601 string: `YYYY-MM-DDThh:mm:ssZ` or `YYYY-MM-DDThh:mm:ss`.
    ///
    /// Returns a DateTime on success. On malformed input, returns epoch (1970-01-01).
    pub func parse_iso8601(s: Str) -> DateTime {
        let slen: I64 = s.len()
        // Minimum: "YYYY-MM-DDThh:mm:ss" = 19 chars
        if slen < 19 {
            return DateTime::from_timestamp(0)
        }
        let year: I64 = parse_int_slice(s, 0, 4)
        let month: I64 = parse_int_slice(s, 5, 7)
        let day: I64 = parse_int_slice(s, 8, 10)
        let hour: I64 = parse_int_slice(s, 11, 13)
        let minute: I64 = parse_int_slice(s, 14, 16)
        let second: I64 = parse_int_slice(s, 17, 19)
        if year < 0 or month < 0 or day < 0 or hour < 0 or minute < 0 or second < 0 {
            return DateTime::from_timestamp(0)
        }
        return DateTime::from_parts(year, month, day, hour, minute, second)
    }

    /// Parses a date string: `YYYY-MM-DD`.
    ///
    /// Time components default to 00:00:00. Returns epoch on malformed input.
    pub func parse_date(s: Str) -> DateTime {
        let slen: I64 = s.len()
        if slen < 10 {
            return DateTime::from_timestamp(0)
        }
        let year: I64 = parse_int_slice(s, 0, 4)
        let month: I64 = parse_int_slice(s, 5, 7)
        let day: I64 = parse_int_slice(s, 8, 10)
        if year < 0 or month < 0 or day < 0 {
            return DateTime::from_timestamp(0)
        }
        return DateTime::from_parts(year, month, day, 0, 0, 0)
    }

    /// Parses a display string: `YYYY-MM-DD hh:mm:ss` (with or without trailing ` UTC`).
    ///
    /// Returns epoch on malformed input.
    pub func parse(s: Str) -> DateTime {
        let slen: I64 = s.len()
        if slen < 19 {
            return DateTime::from_timestamp(0)
        }
        let year: I64 = parse_int_slice(s, 0, 4)
        let month: I64 = parse_int_slice(s, 5, 7)
        let day: I64 = parse_int_slice(s, 8, 10)
        let hour: I64 = parse_int_slice(s, 11, 13)
        let minute: I64 = parse_int_slice(s, 14, 16)
        let second: I64 = parse_int_slice(s, 17, 19)
        if year < 0 or month < 0 or day < 0 or hour < 0 or minute < 0 or second < 0 {
            return DateTime::from_timestamp(0)
        }
        return DateTime::from_parts(year, month, day, hour, minute, second)
    }
}

// ============================================================================
// Internal helpers
// ============================================================================

/// Convert civil date to epoch seconds.
func civil_to_epoch(year: I64, month: I64, day: I64,
                    hour: I64, minute: I64, second: I64) -> I64 {
    // Inverse of the Hinnant algorithm.
    let y: I64 = if month <= 2 { year - 1 } else { year }
    let era: I64 = (if y >= 0 { y } else { y - 399 }) / 400
    let yoe: I64 = y - era * 400
    let m: I64 = if month > 2 { month - 3 } else { month + 9 }
    let doy: I64 = (153 * m + 2) / 5 + day - 1
    let doe: I64 = yoe * 365 + yoe / 4 - yoe / 100 + doy
    let days: I64 = era * 146097 + doe - 719468
    return days * 86400 + hour * 3600 + minute * 60 + second
}

/// Check if a year is a leap year.
func is_leap(year: I64) -> Bool {
    return (year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0))
}

/// Zero-pad an integer to 2 digits.
@allocates
func pad2(n: I64) -> Str {
    if n < 10 {
        return "0" + n.to_string()
    }
    return n.to_string()
}

/// Zero-pad an integer to 4 digits (for year).
@allocates
func pad4(n: I64) -> Str {
    if n < 10 {
        return "000" + n.to_string()
    }
    if n < 100 {
        return "00" + n.to_string()
    }
    if n < 1000 {
        return "0" + n.to_string()
    }
    return n.to_string()
}

/// Short weekday name (Mon–Sun). Input: 0=Monday, 6=Sunday.
func weekday_short(wd: I64) -> Str {
    if wd == 0 { return "Mon" }
    if wd == 1 { return "Tue" }
    if wd == 2 { return "Wed" }
    if wd == 3 { return "Thu" }
    if wd == 4 { return "Fri" }
    if wd == 5 { return "Sat" }
    return "Sun"
}

/// Short month name (Jan–Dec). Input: 1–12.
func month_short(m: I64) -> Str {
    if m == 1 { return "Jan" }
    if m == 2 { return "Feb" }
    if m == 3 { return "Mar" }
    if m == 4 { return "Apr" }
    if m == 5 { return "May" }
    if m == 6 { return "Jun" }
    if m == 7 { return "Jul" }
    if m == 8 { return "Aug" }
    if m == 9 { return "Sep" }
    if m == 10 { return "Oct" }
    if m == 11 { return "Nov" }
    return "Dec"
}

/// Parse an unsigned integer from a substring of `s` at [start, end).
/// Returns -1 on any non-digit character.
func parse_int_slice(s: Str, start: I64, end: I64) -> I64 {
    var result: I64 = 0
    var i: I64 = start
    loop (i < end) {
        let c: I32 = s.char_at(i)
        // '0' = 48, '9' = 57
        if c < 48 or c > 57 { return -1 }
        let d: I64 = (c - 48) as I64
        result = result * 10 + d
        i = i + 1
    }
    return result
}
