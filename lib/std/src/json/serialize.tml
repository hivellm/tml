//! JSON Serialization Behaviors
//!
//! This module provides `ToJson` and `FromJson` behaviors that allow
//! any type to be serialized to and deserialized from JSON.
//!
//! # Example
//!
//! ```tml
//! use std::json::{Json, ToJson, FromJson}
//! use std::json::builder::object
//!
//! type Person {
//!     name: Str,
//!     age: I32,
//! }
//!
//! impl Person with ToJson {
//!     func to_json(this) -> Json {
//!         let b = object()
//!         b.ks("name", this.name)
//!         b.kn32("age", this.age)
//!         b.end_obj()
//!         return Json::from_handle(json_parse_fast(b.build()))
//!     }
//! }
//!
//! impl Person with FromJson {
//!     func from_json(json: Json) -> Outcome[Person, Str] {
//!         if not json.is_object() {
//!             return Err("Expected JSON object")
//!         }
//!
//!         var name: Str = ""
//!         var age: I32 = 0
//!
//!         when json.get_string("name") {
//!             Just(n) => name = n,
//!             Nothing => {}
//!         }
//!
//!         when json.get_i64("age") {
//!             Just(a) => age = a as I32,
//!             Nothing => {}
//!         }
//!
//!         return Ok(Person { name: name, age: age })
//!     }
//! }
//! ```

use std::json::types::Json

// FFI function for creating JSON values
@extern("tml_json_parse_fast")
func json_parse_fast(s: Str) -> I64

// ============================================================================
// ToJson Behavior
// ============================================================================

/// Behavior for types that can be serialized to JSON.
///
/// Implement this behavior to enable JSON serialization for your types.
pub behavior ToJson {
    /// Convert this value to a Json representation
    func to_json(this) -> Json
}

// ============================================================================
// FromJson Behavior
// ============================================================================

/// Behavior for types that can be deserialized from JSON.
///
/// Implement this behavior to enable JSON deserialization for your types.
pub behavior FromJson {
    /// Attempt to create an instance from a Json value
    func from_json(json: Json) -> Outcome[Self, Str]
}

// ============================================================================
// ToJson Implementations for Primitive Types
// ============================================================================

impl ToJson for Bool {
    func to_json(this) -> Json {
        return Json::new_bool(this)
    }
}

impl ToJson for I8 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for I16 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for I32 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for I64 {
    func to_json(this) -> Json {
        return Json::int(this)
    }
}

impl ToJson for U8 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for U16 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for U32 {
    func to_json(this) -> Json {
        return Json::int(this as I64)
    }
}

impl ToJson for U64 {
    func to_json(this) -> Json {
        // Note: Large U64 values may lose precision as JSON numbers
        return Json::int(this as I64)
    }
}

impl ToJson for F32 {
    func to_json(this) -> Json {
        return Json::float(this as F64)
    }
}

impl ToJson for F64 {
    func to_json(this) -> Json {
        return Json::float(this)
    }
}

impl ToJson for Str {
    func to_json(this) -> Json {
        return Json::string(this)
    }
}

// ============================================================================
// FromJson Implementations for Primitive Types
// ============================================================================

impl FromJson for Bool {
    func from_json(json: Json) -> Outcome[Bool, Str] {
        when json.as_bool() {
            Just(b) => Ok(b),
            Nothing => Err("Expected boolean"),
        }
    }
}

impl FromJson for I32 {
    func from_json(json: Json) -> Outcome[I32, Str] {
        when json.as_i64() {
            Just(n) => Ok(n as I32),
            Nothing => Err("Expected number"),
        }
    }
}

impl FromJson for I64 {
    func from_json(json: Json) -> Outcome[I64, Str] {
        when json.as_i64() {
            Just(n) => Ok(n),
            Nothing => Err("Expected number"),
        }
    }
}

impl FromJson for F64 {
    func from_json(json: Json) -> Outcome[F64, Str] {
        when json.as_f64() {
            Just(n) => Ok(n),
            Nothing => Err("Expected number"),
        }
    }
}

impl FromJson for Str {
    func from_json(json: Json) -> Outcome[Str, Str] {
        when json.as_str() {
            Just(s) => Ok(s),
            Nothing => Err("Expected string"),
        }
    }
}

// ============================================================================
// ToJson/FromJson for Collection Types
// ============================================================================

use std::collections::List

/// ToJson implementation for List[T] where T implements ToJson.
///
/// Serializes a List to a JSON array.
///
/// # Example
///
/// ```tml
/// let nums = List[I64]::new(8)
/// nums.push(1)
/// nums.push(2)
/// nums.push(3)
/// let json = nums.to_json()  // [1, 2, 3]
/// ```
impl[T: ToJson] ToJson for List[T] {
    func to_json(this) -> Json {
        use std::json::builder::{Builder, array}

        let b: Builder = array()
        var i: I64 = 0
        let length: I64 = this.len()
        loop (i < length) {
            let elem: T = this.get(i)
            let elem_json: Json = elem.to_json()
            // Add the raw JSON string representation
            b.raw(elem_json.to_string())
            i = i + 1
        }
        b.end_arr()
        let h: I64 = json_parse_fast(b.build())
        b.drop()
        return Json::from_handle(h)
    }
}

/// FromJson implementation for List[T] where T implements FromJson.
///
/// Deserializes a JSON array to a List.
///
/// # Example
///
/// ```tml
/// let json = parse_or_panic("[1, 2, 3]")
/// when List[I64]::from_json(json) {
///     Ok(nums) => {
///         // nums contains [1, 2, 3]
///     },
///     Err(e) => panic(e),
/// }
/// ```
impl[T: FromJson] FromJson for List[T] {
    func from_json(json: Json) -> Outcome[List[T], Str] {
        if not json.is_array() {
            return Err("Expected JSON array")
        }

        let length: I64 = json.len()
        let list: List[T] = List[T]::new(length)

        var i: I64 = 0
        loop (i < length) {
            when json.at(i) {
                Just(elem_json) => {
                    when T::from_json(elem_json) {
                        Ok(elem) => list.push(elem),
                        Err(e) => return Err("Failed to deserialize element at index " + i.to_string() + ": " + e),
                    }
                },
                Nothing => return Err("Failed to get element at index " + i.to_string()),
            }
            i = i + 1
        }

        return Ok(list)
    }
}

// ============================================================================
// ToJson/FromJson for HashMap Types
// ============================================================================

use std::collections::{HashMap, HashMapIter}

/// ToJson implementation for HashMap[I64, V] where V implements ToJson.
///
/// Serializes a HashMap to a JSON object with string keys (I64 converted to string).
///
/// # Example
///
/// ```tml
/// let map = HashMap[I64, I64]::new(16)
/// map.set(1, 100)
/// map.set(2, 200)
/// let json = map.to_json()  // {"1": 100, "2": 200}
/// ```
impl[V: ToJson] ToJson for HashMap[I64, V] {
    func to_json(this) -> Json {
        use std::json::builder::{Builder, object}

        let b: Builder = object()
        let iter = this.iter()
        loop (iter.has_next()) {
            let key: I64 = iter.key()
            let value: V = iter.value()
            let value_json: Json = value.to_json()
            // Use key as string and value as raw JSON
            b.k(key.to_string())
            b.raw(value_json.to_string())
            iter.next()
        }
        iter.destroy()
        b.end_obj()
        let h: I64 = json_parse_fast(b.build())
        b.drop()
        return Json::from_handle(h)
    }
}

/// FromJson implementation for HashMap[I64, V] where V implements FromJson.
///
/// Deserializes a JSON object to a HashMap (string keys parsed as I64).
///
/// # Example
///
/// ```tml
/// let json = parse_or_panic("{\"1\": 100, \"2\": 200}")
/// when HashMap[I64, I64]::from_json(json) {
///     Ok(map) => {
///         // map contains {1: 100, 2: 200}
///     },
///     Err(e) => panic(e),
/// }
/// ```
impl[V: FromJson] FromJson for HashMap[I64, V] {
    func from_json(json: Json) -> Outcome[HashMap[I64, V], Str] {
        if not json.is_object() {
            return Err("Expected JSON object")
        }

        let length: I64 = json.len()
        let map: HashMap[I64, V] = HashMap[I64, V]::new(length * 2)

        var i: I64 = 0
        loop (i < length) {
            when json.key_at(i) {
                Just(key_str) => {
                    // Parse key as I64
                    when I64::parse(key_str) {
                        Just(key) => {
                            when json.value_at(i) {
                                Just(value_json) => {
                                    when V::from_json(value_json) {
                                        Ok(value) => map.set(key, value),
                                        Err(e) => return Err("Failed to deserialize value for key " + key_str + ": " + e),
                                    }
                                },
                                Nothing => return Err("Failed to get value at index " + i.to_string()),
                            }
                        },
                        Nothing => return Err("Key is not a valid I64: " + key_str),
                    }
                },
                Nothing => return Err("Failed to get key at index " + i.to_string()),
            }
            i = i + 1
        }

        return Ok(map)
    }
}

// Note: HashMap[Str, V] serialization requires a runtime that stores
// original string keys, not just their hashes. The current runtime
// stores I64 keys only. Consider using the OOP-style StringMap class
// from class_collections for string-keyed maps with full serialization.
