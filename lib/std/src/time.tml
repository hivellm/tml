//! Time measurement types.
//!
//! This module provides [`Instant`] for measuring elapsed time using a
//! monotonic clock, built on top of [`core::time::Duration`].
//!
//! # Examples
//!
//! ```tml
//! use std::time::Instant
//!
//! let start = Instant::now()
//! // ... do work ...
//! let elapsed = start.elapsed()
//! ```

use core::time::Duration

// FFI declarations for time primitives (C runtime)
@extern("c")
func time_ns() -> I64

@extern("c")
func sleep_ms(ms: I32)

/// A measurement of a monotonically nondecreasing clock.
///
/// Instants are opaque and useful only with [`Duration`]. An instant
/// can be subtracted from another to get a duration, or you can call
/// [`elapsed`] to get the time since the instant was created.
///
/// # Examples
///
/// ```tml
/// use std::time::Instant
/// use core::time::Duration
///
/// let start = Instant::now()
/// // ... do some work ...
/// let duration = start.elapsed()
/// ```
pub type Instant {
    nanos: I64,
    _padding: I64
}

impl Instant {
    /// Returns an instant corresponding to "now".
    pub func now() -> Instant {
        return Instant { nanos: time_ns(), _padding: 0 }
    }

    /// Returns the amount of time elapsed since this instant was created.
    pub func elapsed(this) -> Duration {
        let now_nanos = time_ns()
        let diff = now_nanos - this.nanos
        return Duration::from_nanos(diff)
    }

    /// Returns the amount of time elapsed from another instant to this one.
    ///
    /// # Panics
    ///
    /// Panics if `earlier` is later than `this`.
    pub func duration_since(this, earlier: Instant) -> Duration {
        let diff = this.nanos - earlier.nanos
        if diff < 0 {
            panic("earlier instant is later than self")
        }
        return Duration::from_nanos(diff)
    }

    /// Returns the raw nanosecond timestamp (for internal use).
    pub func as_nanos(this) -> I64 {
        return this.nanos
    }

    /// Checked addition of a duration to this instant.
    /// Returns `Nothing` if the result would overflow.
    pub func checked_add(this, dur: Duration) -> Maybe[Instant] {
        let dur_nanos: I64 = dur.as_nanos()

        // Check for overflow
        if this.nanos > 9223372036854775807 - dur_nanos {
            return Nothing
        }

        let new_nanos: I64 = this.nanos + dur_nanos
        return Just(Instant { nanos: new_nanos, _padding: 0 })
    }

    /// Checked subtraction of a duration from this instant.
    /// Returns `Nothing` if the result would be negative.
    pub func checked_sub(this, dur: Duration) -> Maybe[Instant] {
        let dur_nanos: I64 = dur.as_nanos()

        // Check for underflow
        if this.nanos < dur_nanos {
            return Nothing
        }

        let new_nanos: I64 = this.nanos - dur_nanos
        return Just(Instant { nanos: new_nanos, _padding: 0 })
    }
}

// ============================================================================
// SystemTime - Wall clock
// ============================================================================

@extern("tml_os_system_time_secs")
func ffi_system_time_secs() -> I64

@extern("tml_os_system_time_nanos")
func ffi_system_time_nanos() -> I64

/// A measurement of the system clock (wall clock time).
///
/// Unlike [`Instant`], `SystemTime` corresponds to "real world" time
/// and can be converted to seconds since the Unix epoch.
///
/// # Examples
///
/// ```tml
/// use std::time::SystemTime
///
/// let now: SystemTime = SystemTime::now()
/// let secs: I64 = now.as_secs()
/// ```
pub type SystemTime {
    secs: I64,
    nanos: I64
}

impl SystemTime {
    /// The Unix epoch (January 1, 1970 00:00:00 UTC).
    pub func unix_epoch() -> SystemTime {
        return SystemTime { secs: 0, nanos: 0 }
    }

    /// Returns the current system time.
    pub func now() -> SystemTime {
        let total_nanos: I64 = ffi_system_time_nanos()
        let s: I64 = total_nanos / 1000000000
        let n: I64 = total_nanos % 1000000000
        return SystemTime { secs: s, nanos: n }
    }

    /// Returns the number of seconds since the Unix epoch.
    pub func as_secs(this) -> I64 {
        return this.secs
    }

    /// Returns the sub-second nanosecond component.
    pub func subsec_nanos(this) -> I64 {
        return this.nanos
    }

    /// Returns the elapsed time since this SystemTime was created.
    pub func elapsed(this) -> Duration {
        let now_nanos: I64 = ffi_system_time_nanos()
        let self_nanos: I64 = this.secs * 1000000000 + this.nanos
        let diff: I64 = now_nanos - self_nanos
        if diff < 0 {
            return Duration::from_nanos(0)
        }
        return Duration::from_nanos(diff)
    }

    /// Returns the duration since the Unix epoch.
    pub func duration_since_epoch(this) -> Duration {
        let total: I64 = this.secs * 1000000000 + this.nanos
        return Duration::from_nanos(total)
    }
}

// ============================================================================
// Sleep
// ============================================================================

/// Puts the current thread to sleep for the specified duration.
///
/// # Examples
///
/// ```tml
/// use std::time
/// use core::time::Duration
///
/// time::sleep(Duration::from_millis(100))
/// ```
pub func sleep(duration: Duration) -> Unit {
    let millis = duration.as_millis()
    sleep_ms(millis as I32)
}
