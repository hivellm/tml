//! UUID generation and parsing per RFC 9562.
//!
//! Provides UUID v4 (random) and v7 (time-ordered) generation,
//! parsing from string, and formatting.
//!
//! # Examples
//!
//! ```tml
//! use std::uuid::Uuid
//!
//! let id = Uuid::v4()
//! print("{id.to_string()}\n")
//! ```

use core::str
use core::encoding::hex
use std::random::Rng
use std::time::time_ns

/// A universally unique identifier (128 bits stored as two I64 values).
///
/// The `hi` field contains bits 127-64 and `lo` contains bits 63-0.
pub type Uuid {
    hi: I64,
    lo: I64
}

/// Helper: extract a 4-bit nibble from a 64-bit value.
/// Position 0 is the least significant nibble.
func nibble_at(val: I64, pos: I32) -> I32 {
    let shift: I32 = pos * 4
    return ((val >> (shift as I64)) & (15 as I64)) as I32
}

// hex_char and parse_hex replaced by core::encoding::hex

impl Uuid {
    /// The nil UUID (all zeros): 00000000-0000-0000-0000-000000000000
    pub func nil() -> Uuid {
        return Uuid { hi: 0, lo: 0 }
    }

    /// The max UUID (all ones): ffffffff-ffff-ffff-ffff-ffffffffffff
    pub func max() -> Uuid {
        return Uuid { hi: -1, lo: -1 }
    }

    /// Generate a random UUID (version 4, RFC 9562).
    ///
    /// Uses xoshiro256** PRNG seeded from monotonic clock.
    pub func v4() -> Uuid {
        var rng: Rng = Rng::new()
        var hi: I64 = rng.next_i64()
        var lo: I64 = rng.next_i64()

        // Set version to 4 (bits 76-79 in hi, which is bits 12-15 of the upper half)
        // Clear bits 76-79 and set to 0100
        hi = hi & (-61441 as I64)  // ~0xF000 for bits 12-15 = 0xFFFF_FFFF_FFFF_0FFF
        hi = hi | (16384 as I64)   // 0x4000

        // Set variant to 10 (bits 62-63 in lo, which is the top 2 bits)
        // Clear top 2 bits and set to 10
        lo = lo & (4611686018427387903 as I64)   // 0x3FFF_FFFF_FFFF_FFFF
        lo = lo | (-9223372036854775808 as I64)  // 0x8000_0000_0000_0000

        return Uuid { hi: hi, lo: lo }
    }

    /// Generate a time-ordered UUID (version 7, RFC 9562).
    ///
    /// Upper 48 bits are Unix epoch milliseconds, then version 7,
    /// then 12 random bits, variant 10, and 62 random bits.
    pub func v7() -> Uuid {
        var rng: Rng = Rng::new()
        let now: I64 = time_ns() / 1000000  // nanoseconds to milliseconds

        // hi: [48-bit timestamp] [4-bit version=0111] [12-bit random]
        var hi: I64 = (now << 16) | (7 << 12) as I64 | (rng.next_i64() & (4095 as I64))

        // lo: [2-bit variant=10] [62-bit random]
        var lo: I64 = rng.next_i64()
        lo = lo & (4611686018427387903 as I64)   // 0x3FFF_FFFF_FFFF_FFFF
        lo = lo | (-9223372036854775808 as I64)  // 0x8000_0000_0000_0000

        return Uuid { hi: hi, lo: lo }
    }

    /// Returns the UUID version (4 or 7 for UUIDs generated by this module).
    pub func version(this) -> I32 {
        return ((this.hi >> 12) & (15 as I64)) as I32
    }

    /// Returns the UUID variant (2 for RFC 9562 UUIDs).
    pub func variant(this) -> I32 {
        let top_bits: I32 = ((this.lo >> 62) & (3 as I64)) as I32
        if top_bits >= 2 {
            return 2  // RFC variant (10xx)
        }
        return top_bits
    }

    /// Check if this is the nil UUID.
    pub func is_nil(this) -> Bool {
        return this.hi == 0 and this.lo == 0
    }

    /// Check equality with another UUID.
    pub func eq(this, other: Uuid) -> Bool {
        return this.hi == other.hi and this.lo == other.lo
    }

    /// Format as standard string: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    ///
    /// The 36-character canonical form with lowercase hex and hyphens.
    pub func to_string(this) -> Str {
        // Output: 8-4-4-4-12 = 36 chars + null
        let buf: *Unit = lowlevel { mem_alloc(37 as I64) }
        let dst: I64 = buf as I64
        var pos: I64 = 0

        // Group 1: 8 hex chars from hi bits 63-32
        var i: I32 = 15
        loop (i >= 8) {
            lowlevel { ptr_write[U8]((dst + pos) as *U8, hex::nibble_to_lower(nibble_at(this.hi, i))) }
            pos = pos + 1
            i = i - 1
        }

        // Hyphen
        lowlevel { ptr_write[U8]((dst + pos) as *U8, 45 as U8) }
        pos = pos + 1

        // Group 2: 4 hex chars from hi bits 31-16
        i = 7
        loop (i >= 4) {
            lowlevel { ptr_write[U8]((dst + pos) as *U8, hex::nibble_to_lower(nibble_at(this.hi, i))) }
            pos = pos + 1
            i = i - 1
        }

        // Hyphen
        lowlevel { ptr_write[U8]((dst + pos) as *U8, 45 as U8) }
        pos = pos + 1

        // Group 3: 4 hex chars from hi bits 15-0
        i = 3
        loop (i >= 0) {
            lowlevel { ptr_write[U8]((dst + pos) as *U8, hex::nibble_to_lower(nibble_at(this.hi, i))) }
            pos = pos + 1
            i = i - 1
        }

        // Hyphen
        lowlevel { ptr_write[U8]((dst + pos) as *U8, 45 as U8) }
        pos = pos + 1

        // Group 4: 4 hex chars from lo bits 63-48
        i = 15
        loop (i >= 12) {
            lowlevel { ptr_write[U8]((dst + pos) as *U8, hex::nibble_to_lower(nibble_at(this.lo, i))) }
            pos = pos + 1
            i = i - 1
        }

        // Hyphen
        lowlevel { ptr_write[U8]((dst + pos) as *U8, 45 as U8) }
        pos = pos + 1

        // Group 5: 12 hex chars from lo bits 47-0
        i = 11
        loop (i >= 0) {
            lowlevel { ptr_write[U8]((dst + pos) as *U8, hex::nibble_to_lower(nibble_at(this.lo, i))) }
            pos = pos + 1
            i = i - 1
        }

        // Null terminate
        lowlevel { ptr_write[U8]((dst + pos) as *U8, 0 as U8) }
        return buf as Str
    }

    /// Format as URN: "urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    pub func to_urn(this) -> Str {
        let uuid_str: Str = this.to_string()
        return "urn:uuid:" + uuid_str
    }

    /// Parse a UUID from its string representation.
    ///
    /// Accepts both forms:
    /// - "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" (36 chars with hyphens)
    /// - "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" (32 chars without hyphens)
    pub func parse(s: Str) -> Outcome[Uuid, Str] {
        let slen: I64 = str::len(s)

        if slen == 36 {
            return parse_hyphenated(s)
        }
        if slen == 32 {
            return parse_bare(s)
        }
        return Err("uuid: invalid length (expected 32 or 36)")
    }
}

/// Parse 32 hex characters (no hyphens) into a UUID.
func parse_bare(s: Str) -> Outcome[Uuid, Str] {
    var hi: I64 = 0
    var lo: I64 = 0
    var i: I64 = 0

    // First 16 hex chars -> hi
    loop (i < 16) {
        let c: I32 = str::char_at(s, i)
        let v: I32 = hex::char_to_nibble(c)
        if v == -1 {
            return Err("uuid: invalid hex character")
        }
        hi = (hi << 4) | (v as I64)
        i = i + 1
    }

    // Next 16 hex chars -> lo
    loop (i < 32) {
        let c: I32 = str::char_at(s, i)
        let v: I32 = hex::char_to_nibble(c)
        if v == -1 {
            return Err("uuid: invalid hex character")
        }
        lo = (lo << 4) | (v as I64)
        i = i + 1
    }

    return Ok(Uuid { hi: hi, lo: lo })
}

/// Parse 36-char hyphenated UUID string.
func parse_hyphenated(s: Str) -> Outcome[Uuid, Str] {
    // Validate hyphens at positions 8, 13, 18, 23
    if str::char_at(s, 8) != 45 or str::char_at(s, 13) != 45 or
       str::char_at(s, 18) != 45 or str::char_at(s, 23) != 45 {
        return Err("uuid: invalid hyphen positions")
    }

    var hi: I64 = 0
    var lo: I64 = 0
    var i: I64 = 0
    var hex_count: I32 = 0

    loop (i < 36) {
        let c: I32 = str::char_at(s, i)
        if c == 45 {
            // Skip hyphens
            i = i + 1
        } else {
            let v: I32 = hex::char_to_nibble(c)
            if v == -1 {
                return Err("uuid: invalid hex character")
            }
            if hex_count < 16 {
                hi = (hi << 4) | (v as I64)
            } else {
                lo = (lo << 4) | (v as I64)
            }
            hex_count = hex_count + 1
            i = i + 1
        }
    }

    return Ok(Uuid { hi: hi, lo: lo })
}
