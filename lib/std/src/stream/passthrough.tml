//! PassThrough stream — identity transform.
//!
//! A `PassThroughStream` passes all data written to its writable side
//! directly to its readable side without any transformation. Useful for
//! stream composition, testing, and as a simple buffer between producers
//! and consumers.
//!
//! # Example
//!
//! ```tml
//! use std::stream::passthrough::PassThroughStream
//!
//! var pt = PassThroughStream::new()
//! pt.write("hello")
//! let data: Str = pt.read(5)
//! assert_eq(data, "hello")
//! pt.destroy()
//! ```

use std::stream::writable_stream::WritableStream
use std::stream::duplex::DuplexStream

/// A stream that passes data through unchanged.
pub type PassThroughStream {
    duplex: DuplexStream
}

impl PassThroughStream {
    /// Creates a new PassThroughStream with default highWaterMark.
    pub func new() -> PassThroughStream {
        PassThroughStream {
            duplex: DuplexStream::new()
        }
    }

    /// Creates a new PassThroughStream with custom highWaterMarks.
    pub func with_options(read_hwm: I64, write_hwm: I64) -> PassThroughStream {
        PassThroughStream {
            duplex: DuplexStream::with_options(read_hwm, write_hwm)
        }
    }

    // ================================================================
    // Writable side (write goes directly to readable)
    // ================================================================

    /// Write data — passes directly to the readable side.
    pub func write(mut this, data: Str) -> Bool {
        this.duplex.push(data)
    }

    /// End the stream.
    pub func end(mut this) {
        this.duplex.push_eof()
        this.duplex.end()
    }

    /// End with final data.
    pub func end_with_data(mut this, data: Str) {
        this.duplex.push(data)
        this.duplex.push_eof()
        this.duplex.end()
    }

    pub func cork(mut this) {
        this.duplex.cork()
    }

    pub func uncork(mut this) {
        this.duplex.uncork()
    }

    pub func writable(this) -> Bool {
        this.duplex.writable()
    }

    pub func writable_length(this) -> I64 {
        this.duplex.writable_length()
    }

    pub func writable_finished(this) -> Bool {
        this.duplex.writable_finished()
    }

    pub func writable_ended(this) -> Bool {
        this.duplex.writable_ended()
    }

    pub func writable_corked(this) -> Bool {
        this.duplex.writable_corked()
    }

    pub func writable_corked_count(this) -> I64 {
        this.duplex.writable_corked_count()
    }

    pub func writable_high_water_mark(this) -> I64 {
        this.duplex.writable_high_water_mark()
    }

    pub func writable_needs_drain(this) -> Bool {
        this.duplex.writable_needs_drain()
    }

    // ================================================================
    // Readable side
    // ================================================================

    @allocates
    pub func read(mut this, size: I64) -> Str {
        this.duplex.read(size)
    }

    @allocates
    pub func read_all(mut this) -> Str {
        this.duplex.read_all()
    }

    pub func readable(this) -> Bool {
        this.duplex.readable()
    }

    pub func readable_length(this) -> I64 {
        this.duplex.readable_length()
    }

    pub func readable_flowing(this) -> Bool {
        this.duplex.readable_flowing()
    }

    pub func readable_ended(this) -> Bool {
        this.duplex.readable_ended()
    }

    pub func readable_high_water_mark(this) -> I64 {
        this.duplex.readable_high_water_mark()
    }

    pub func readable_did_read(this) -> Bool {
        this.duplex.readable_did_read()
    }

    pub func is_paused(this) -> Bool {
        this.duplex.is_paused()
    }

    pub func pause(mut this) {
        this.duplex.pause()
    }

    pub func resume(mut this) {
        this.duplex.resume()
    }

    pub func unshift(mut this, data: Str) {
        this.duplex.unshift(data)
    }

    pub func pipe(mut this, dest: mut ref WritableStream) {
        this.duplex.pipe(mut ref dest)
    }

    pub func unpipe(mut this, dest: mut ref WritableStream) {
        this.duplex.unpipe(mut ref dest)
    }

    pub func unpipe_all(mut this) {
        this.duplex.unpipe_all()
    }

    // ================================================================
    // Shared
    // ================================================================

    pub func on(mut this, event: Str, listener: I64) {
        this.duplex.on(event, listener)
    }

    pub func once(mut this, event: Str, listener: I64) {
        this.duplex.once(event, listener)
    }

    pub func off(mut this, event: Str, listener: I64) -> Bool {
        this.duplex.off(event, listener)
    }

    pub func emit(mut this, event: Str, data: I64) -> Bool {
        this.duplex.emit(event, data)
    }

    pub func closed(this) -> Bool {
        this.duplex.closed()
    }

    pub func destroyed(this) -> Bool {
        this.duplex.destroyed()
    }

    pub func errored(this) -> Bool {
        this.duplex.errored()
    }

    @allocates
    pub func error_message(this) -> Str {
        this.duplex.error_message()
    }

    pub func destroy(mut this) {
        this.duplex.destroy()
    }

    pub func destroy_with_error(mut this, err: Str) {
        this.duplex.destroy_with_error(err)
    }
}
