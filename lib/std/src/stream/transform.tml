//! Transform stream — reads input, transforms it, pushes to output.
//!
//! A `TransformStream` wraps a `DuplexStream`. Data written to the writable
//! side is passed through a user-provided `_transform` callback, which pushes
//! results to the readable side.
//!
//! This is the base for compression, encryption, parsing, and other
//! data-transforming pipelines.
//!
//! # Example
//!
//! ```tml
//! use std::stream::transform::TransformStream
//! use std::stream::duplex::DuplexStream
//!
//! func my_transform(data: I64, duplex_ptr: I64) {
//!     let chunk: Str = data as Str
//!     let ds: mut ref DuplexStream = duplex_ptr as mut ref DuplexStream
//!     ds.push(chunk)
//! }
//!
//! var ts = TransformStream::new()
//! ts.set_transform(my_transform as I64)
//! ts.write("hello")
//! let out: Str = ts.read(5)
//! ts.destroy()
//! ```

use std::stream::readable_stream::ReadableStream
use std::stream::writable_stream::WritableStream
use std::stream::duplex::DuplexStream

/// A stream that transforms data written to its writable side
/// and pushes results to its readable side.
pub type TransformStream {
    duplex: DuplexStream,
    transform_fn: I64,
    flush_fn: I64
}

impl TransformStream {
    /// Creates a new TransformStream with default highWaterMark.
    pub func new() -> TransformStream {
        TransformStream {
            duplex: DuplexStream::new(),
            transform_fn: 0,
            flush_fn: 0
        }
    }

    /// Creates a new TransformStream with custom highWaterMarks.
    pub func with_options(read_hwm: I64, write_hwm: I64) -> TransformStream {
        TransformStream {
            duplex: DuplexStream::with_options(read_hwm, write_hwm),
            transform_fn: 0,
            flush_fn: 0
        }
    }

    /// Set the transform callback.
    ///
    /// Signature: `func(data: I64, duplex_ptr: I64)`.
    /// `data` is a Str pointer. `duplex_ptr` is a `mut ref DuplexStream`
    /// pointer — call `ds.push(chunk)` to push transformed data.
    pub func set_transform(mut this, f: I64) {
        this.transform_fn = f
    }

    /// Set the flush callback, called when the writable side ends.
    ///
    /// Signature: `func(duplex_ptr: I64)`.
    /// Allows pushing final data before the readable side ends.
    pub func set_flush(mut this, f: I64) {
        this.flush_fn = f
    }

    // ================================================================
    // Readable side
    // ================================================================

    @allocates
    pub func read(mut this, size: I64) -> Str {
        this.duplex.read(size)
    }

    @allocates
    pub func read_all(mut this) -> Str {
        this.duplex.read_all()
    }

    pub func readable(this) -> Bool {
        this.duplex.readable()
    }

    pub func readable_length(this) -> I64 {
        this.duplex.readable_length()
    }

    pub func readable_flowing(this) -> Bool {
        this.duplex.readable_flowing()
    }

    pub func readable_ended(this) -> Bool {
        this.duplex.readable_ended()
    }

    pub func readable_high_water_mark(this) -> I64 {
        this.duplex.readable_high_water_mark()
    }

    pub func readable_did_read(this) -> Bool {
        this.duplex.readable_did_read()
    }

    pub func is_paused(this) -> Bool {
        this.duplex.is_paused()
    }

    pub func pause(mut this) {
        this.duplex.pause()
    }

    pub func resume(mut this) {
        this.duplex.resume()
    }

    pub func unshift(mut this, data: Str) {
        this.duplex.unshift(data)
    }

    pub func pipe(mut this, dest: mut ref WritableStream) {
        this.duplex.pipe(mut ref dest)
    }

    pub func unpipe(mut this, dest: mut ref WritableStream) {
        this.duplex.unpipe(mut ref dest)
    }

    pub func unpipe_all(mut this) {
        this.duplex.unpipe_all()
    }

    // ================================================================
    // Writable side (intercepts write, delegates rest)
    // ================================================================

    /// Write data to the transform.
    ///
    /// If a transform function is set, data is passed through it and the
    /// result is pushed to the readable side. Otherwise, data passes through
    /// unchanged (like PassThrough).
    pub func write(mut this, data: Str) -> Bool {
        if this.transform_fn != 0 {
            let f: func(I64, I64) = this.transform_fn as func(I64, I64)
            f(data as I64, (mut ref this.duplex) as I64)
            return true
        }
        // No transform — pass through to readable side directly
        this.duplex.push(data)
    }

    pub func writable(this) -> Bool {
        this.duplex.writable()
    }

    pub func writable_length(this) -> I64 {
        this.duplex.writable_length()
    }

    pub func writable_finished(this) -> Bool {
        this.duplex.writable_finished()
    }

    pub func writable_ended(this) -> Bool {
        this.duplex.writable_ended()
    }

    pub func writable_corked(this) -> Bool {
        this.duplex.writable_corked()
    }

    pub func writable_corked_count(this) -> I64 {
        this.duplex.writable_corked_count()
    }

    pub func writable_high_water_mark(this) -> I64 {
        this.duplex.writable_high_water_mark()
    }

    pub func writable_needs_drain(this) -> Bool {
        this.duplex.writable_needs_drain()
    }

    pub func cork(mut this) {
        this.duplex.cork()
    }

    pub func uncork(mut this) {
        this.duplex.uncork()
    }

    /// End the writable side.
    ///
    /// If a flush callback is set, it's called before ending the readable side.
    pub func end(mut this) {
        if this.flush_fn != 0 {
            let f: func(I64) = this.flush_fn as func(I64)
            f((mut ref this.duplex) as I64)
        }
        this.duplex.push_eof()
        this.duplex.end()
    }

    /// Write final data, then end.
    pub func end_with_data(mut this, data: Str) {
        this.write(data)
        this.end()
    }

    // ================================================================
    // Shared
    // ================================================================

    pub func on(mut this, event: Str, listener: I64) {
        this.duplex.on(event, listener)
    }

    pub func once(mut this, event: Str, listener: I64) {
        this.duplex.once(event, listener)
    }

    pub func off(mut this, event: Str, listener: I64) -> Bool {
        this.duplex.off(event, listener)
    }

    pub func emit(mut this, event: Str, data: I64) -> Bool {
        this.duplex.emit(event, data)
    }

    pub func closed(this) -> Bool {
        this.duplex.closed()
    }

    pub func destroyed(this) -> Bool {
        this.duplex.destroyed()
    }

    pub func errored(this) -> Bool {
        this.duplex.errored()
    }

    @allocates
    pub func error_message(this) -> Str {
        this.duplex.error_message()
    }

    pub func destroy(mut this) {
        this.duplex.destroy()
    }

    pub func destroy_with_error(mut this, err: Str) {
        this.duplex.destroy_with_error(err)
    }
}
