//! Event-driven readable stream (Node.js-style).
//!
//! `ReadableStream` is a push-based byte source that emits events when data
//! is available. It supports two modes:
//!
//! - **Flowing mode**: Data is emitted via `"data"` events as soon as it arrives.
//! - **Paused mode**: Data accumulates in an internal buffer; call `read()` to pull.
//!
//! # Events
//!
//! | Event | Data | Description |
//! |-------|------|-------------|
//! | `"data"` | Str pointer as I64 | Chunk of data available |
//! | `"end"` | 0 | No more data will be produced |
//! | `"error"` | Str pointer as I64 | An error occurred |
//! | `"close"` | 0 | Stream resources released |
//! | `"readable"` | 0 | Data available to pull (paused mode) |
//! | `"pause"` | 0 | Stream paused |
//! | `"resume"` | 0 | Stream resumed |
//!
//! # Example
//!
//! ```tml
//! use std::stream::readable_stream::ReadableStream
//!
//! func on_data(data: I64) {
//!     let chunk: Str = data as Str
//!     print("got: {chunk}\n")
//! }
//!
//! var rs = ReadableStream::new()
//! rs.on("data", on_data as I64)   // Switches to flowing mode
//! rs.push("hello")                 // Emits "data" event
//! rs.push_eof()                    // Emits "end" event
//! rs.destroy()
//! ```

use core::intrinsics::{ptr_read, ptr_write}
use std::events::emitter::EventEmitter

// ============================================================================
// Memory helpers
// ============================================================================

func rs_alloc(size: I64) -> *Unit {
    lowlevel { mem_alloc(size) }
}

func rs_free(ptr: *Unit) {
    lowlevel { mem_free(ptr) }
}

func rs_realloc(ptr: *Unit, size: I64) -> *Unit {
    lowlevel { mem_realloc(ptr, size) }
}

func rs_rd(addr: I64) -> I64 {
    lowlevel { ptr_read[I64](addr as *I64) }
}

func rs_wr(addr: I64, val: I64) {
    lowlevel { ptr_write[I64](addr as *I64, val) }
}

func rs_rd_u8(addr: I64) -> U8 {
    lowlevel { ptr_read[U8](addr as *U8) }
}

func rs_wr_u8(addr: I64, val: U8) {
    lowlevel { ptr_write[U8](addr as *U8, val) }
}

// ============================================================================
// State constants
// ============================================================================

/// Stream is null/initial — no "data" listener attached yet.
pub const RS_STATE_NULL: I64 = 0
/// Data flows automatically via "data" events.
pub const RS_STATE_FLOWING: I64 = 1
/// Data accumulates in buffer; use read() to pull.
pub const RS_STATE_PAUSED: I64 = 2

// ============================================================================
// Internal buffer (simple growable byte array)
// ============================================================================

// Buffer layout (24 bytes):
//   offset 0: data_ptr (I64) — pointer to byte data
//   offset 8: len (I64)      — current byte count
//   offset 16: cap (I64)     — allocated capacity

func rbuf_new(cap: I64) -> I64 {
    let h: *Unit = rs_alloc(24)
    let addr: I64 = h as I64
    let data: *Unit = rs_alloc(cap)
    rs_wr(addr, data as I64)
    rs_wr(addr + 8, 0)
    rs_wr(addr + 16, cap)
    addr
}

func rbuf_destroy(h: I64) {
    if h == 0 { return }
    let data: *Unit = rs_rd(h) as *Unit
    rs_free(data)
    rs_free(h as *Unit)
}

func rbuf_len(h: I64) -> I64 {
    rs_rd(h + 8)
}

func rbuf_ensure(h: I64, needed: I64) {
    let len: I64 = rs_rd(h + 8)
    let cap: I64 = rs_rd(h + 16)
    if len + needed <= cap { return }
    var new_cap: I64 = cap * 2
    loop (new_cap < len + needed) {
        new_cap = new_cap * 2
    }
    let old: *Unit = rs_rd(h) as *Unit
    let new_data: *Unit = rs_realloc(old, new_cap)
    rs_wr(h, new_data as I64)
    rs_wr(h + 16, new_cap)
}

func rbuf_append_str(h: I64, s: Str) {
    let slen: I64 = s.len()
    if slen == 0 { return }
    rbuf_ensure(h, slen)
    let len: I64 = rs_rd(h + 8)
    let data: I64 = rs_rd(h)
    let src: I64 = s as I64
    var i: I64 = 0
    loop (i < slen) {
        rs_wr_u8(data + len + i, rs_rd_u8(src + i))
        i = i + 1
    }
    rs_wr(h + 8, len + slen)
}

// Prepend string bytes to front of buffer (for unshift)
func rbuf_prepend_str(h: I64, s: Str) {
    let slen: I64 = s.len()
    if slen == 0 { return }
    let len: I64 = rs_rd(h + 8)
    rbuf_ensure(h, slen)
    let data: I64 = rs_rd(h)
    // Shift existing bytes right by slen
    var i: I64 = len - 1
    loop (i >= 0) {
        rs_wr_u8(data + slen + i, rs_rd_u8(data + i))
        i = i - 1
    }
    // Copy new data to front
    let src: I64 = s as I64
    var j: I64 = 0
    loop (j < slen) {
        rs_wr_u8(data + j, rs_rd_u8(src + j))
        j = j + 1
    }
    rs_wr(h + 8, len + slen)
}

// Read N bytes from front as Str, shifting remaining left. Returns "" if empty.
@allocates
func rbuf_read(h: I64, size: I64) -> Str {
    let len: I64 = rs_rd(h + 8)
    if len == 0 { return "" }
    var n: I64 = size
    if n <= 0 or n > len { n = len }
    let data: I64 = rs_rd(h)
    // Create string
    let str_buf: *Unit = rs_alloc(n + 1)
    let str_addr: I64 = str_buf as I64
    var i: I64 = 0
    loop (i < n) {
        rs_wr_u8(str_addr + i, rs_rd_u8(data + i))
        i = i + 1
    }
    rs_wr_u8(str_addr + n, 0 as U8) // null terminator
    // Shift remaining bytes left
    let remaining: I64 = len - n
    var j: I64 = 0
    loop (j < remaining) {
        rs_wr_u8(data + j, rs_rd_u8(data + n + j))
        j = j + 1
    }
    rs_wr(h + 8, remaining)
    str_buf as Str
}

// Read all bytes as Str
@allocates
func rbuf_read_all(h: I64) -> Str {
    let len: I64 = rs_rd(h + 8)
    if len == 0 { return "" }
    rbuf_read(h, len)
}

func rbuf_clear(h: I64) {
    rs_wr(h + 8, 0)
}

// ============================================================================
// ReadableStream state layout
// ============================================================================

// Handle layout (80 bytes) — emitter is a struct field, not in handle:
//   offset 0:  buffer (I64)          — pointer to internal rbuf
//   offset 8:  state (I64)           — RS_STATE_NULL / FLOWING / PAUSED
//   offset 16: high_water_mark (I64) — backpressure threshold
//   offset 24: read_fn (I64)         — user _read callback
//   offset 32: ended (I64)           — 1 if push_eof called
//   offset 40: destroyed (I64)       — 1 if destroyed
//   offset 48: errored (I64)         — 1 if error emitted
//   offset 56: pipe_dest (I64)       — pointer to piped WritableStream
//   offset 64: error_ptr (I64)       — pointer to error Str (0 if none)
//   offset 72: did_read (I64)        — 1 if "data" event was ever emitted

const OFFSET_BUFFER: I64 = 0
const OFFSET_STATE: I64 = 8
const OFFSET_HWM: I64 = 16
const OFFSET_READ_FN: I64 = 24
const OFFSET_ENDED: I64 = 32
const OFFSET_DESTROYED: I64 = 40
const OFFSET_ERRORED: I64 = 48
const OFFSET_PIPE_DEST: I64 = 56
const OFFSET_ERROR_PTR: I64 = 64
const OFFSET_DID_READ: I64 = 72
const RS_HANDLE_SIZE: I64 = 80

// ============================================================================
// ReadableStream type
// ============================================================================

/// An event-driven readable stream.
///
/// Data is pushed into the stream via `push()` and consumed either through
/// `"data"` events (flowing mode) or `read()` calls (paused mode).
pub type ReadableStream {
    emitter: EventEmitter,
    handle: *Unit
}

impl ReadableStream {
    /// Creates a new ReadableStream with default highWaterMark (16384 bytes).
    pub func new() -> ReadableStream {
        ReadableStream::with_options(16384)
    }

    /// Creates a new ReadableStream with a custom highWaterMark.
    pub func with_options(high_water_mark: I64) -> ReadableStream {
        var hwm: I64 = high_water_mark
        if hwm <= 0 { hwm = 16384 }

        let h: *Unit = rs_alloc(RS_HANDLE_SIZE)
        let addr: I64 = h as I64

        let buf: I64 = rbuf_new(hwm)

        rs_wr(addr + OFFSET_BUFFER, buf)
        rs_wr(addr + OFFSET_STATE, RS_STATE_NULL)
        rs_wr(addr + OFFSET_HWM, hwm)
        rs_wr(addr + OFFSET_READ_FN, 0)
        rs_wr(addr + OFFSET_ENDED, 0)
        rs_wr(addr + OFFSET_DESTROYED, 0)
        rs_wr(addr + OFFSET_ERRORED, 0)
        rs_wr(addr + OFFSET_PIPE_DEST, 0)
        rs_wr(addr + OFFSET_ERROR_PTR, 0)
        rs_wr(addr + OFFSET_DID_READ, 0)

        ReadableStream {
            emitter: EventEmitter::new(),
            handle: h
        }
    }

    // ---- Internal accessors ----

    pub func get_buf(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_BUFFER)
    }

    pub func get_state(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_STATE)
    }

    pub func set_state(mut this, state: I64) {
        rs_wr(this.handle as I64 + OFFSET_STATE, state)
    }

    pub func get_hwm(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_HWM)
    }

    pub func get_read_fn(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_READ_FN)
    }

    pub func is_ended(this) -> Bool {
        rs_rd(this.handle as I64 + OFFSET_ENDED) != 0
    }

    pub func set_ended(mut this) {
        rs_wr(this.handle as I64 + OFFSET_ENDED, 1)
    }

    pub func is_destroyed_internal(this) -> Bool {
        if this.handle == (0 as *Unit) { return true }
        rs_rd(this.handle as I64 + OFFSET_DESTROYED) != 0
    }

    pub func set_destroyed_flag(mut this) {
        rs_wr(this.handle as I64 + OFFSET_DESTROYED, 1)
    }

    pub func is_errored_internal(this) -> Bool {
        rs_rd(this.handle as I64 + OFFSET_ERRORED) != 0
    }

    pub func set_errored_flag(mut this) {
        rs_wr(this.handle as I64 + OFFSET_ERRORED, 1)
    }

    pub func get_pipe_dest(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_PIPE_DEST)
    }

    pub func set_pipe_dest(mut this, dest: I64) {
        rs_wr(this.handle as I64 + OFFSET_PIPE_DEST, dest)
    }

    pub func get_error_ptr(this) -> I64 {
        rs_rd(this.handle as I64 + OFFSET_ERROR_PTR)
    }

    pub func set_error_ptr(mut this, ptr: I64) {
        rs_wr(this.handle as I64 + OFFSET_ERROR_PTR, ptr)
    }

    pub func get_did_read(this) -> Bool {
        rs_rd(this.handle as I64 + OFFSET_DID_READ) != 0
    }

    pub func set_did_read(mut this) {
        rs_wr(this.handle as I64 + OFFSET_DID_READ, 1)
    }

    // ---- Internal emitter helpers ----

    pub func emitter_on(mut this, event: Str, listener: I64) {
        this.emitter.on(event, listener)
    }

    pub func emitter_once(mut this, event: Str, listener: I64) {
        this.emitter.once(event, listener)
    }

    pub func emitter_off(mut this, event: Str, listener: I64) -> Bool {
        this.emitter.off(event, listener)
    }

    pub func emitter_emit(mut this, event: Str, data: I64) -> Bool {
        this.emitter.emit(event, data)
    }

    pub func emitter_has_listeners(this, event: Str) -> Bool {
        this.emitter.has_listeners(event)
    }

    pub func emitter_destroy(mut this) {
        this.emitter.destroy()
    }

    // ================================================================
    // Public API: Event registration
    // ================================================================

    /// Register a listener for an event.
    ///
    /// Attaching a `"data"` listener switches the stream to flowing mode.
    pub func on(mut this, event: Str, listener: I64) {
        if this.is_destroyed_internal() { return }
        this.emitter_on(event, listener)
        // Attaching "data" listener switches to flowing mode
        if event == "data" {
            if this.get_state() == RS_STATE_NULL or this.get_state() == RS_STATE_PAUSED {
                this.resume()
            }
        }
    }

    /// Register a one-time listener for an event.
    pub func once(mut this, event: Str, listener: I64) {
        if this.is_destroyed_internal() { return }
        this.emitter_once(event, listener)
        if event == "data" {
            if this.get_state() == RS_STATE_NULL or this.get_state() == RS_STATE_PAUSED {
                this.resume()
            }
        }
    }

    /// Remove a listener.
    pub func off(mut this, event: Str, listener: I64) -> Bool {
        if this.is_destroyed_internal() { return false }
        this.emitter_off(event, listener)
    }

    /// Emit an event directly.
    pub func emit(mut this, event: Str, data: I64) -> Bool {
        this.emitter_emit(event, data)
    }

    /// Returns the number of listeners for a given event.
    pub func listener_count(this, event: Str) -> I64 {
        this.emitter.listener_count(event)
    }

    // ================================================================
    // Public API: Push data into the stream (producer side)
    // ================================================================

    /// Push a chunk of data into the stream.
    ///
    /// In flowing mode, emits `"data"` immediately.
    /// In paused mode, buffers the data and emits `"readable"`.
    ///
    /// Returns `true` if the internal buffer is below highWaterMark
    /// (safe to push more), `false` if backpressure should be applied.
    pub func push(mut this, data: Str) -> Bool {
        if this.is_destroyed_internal() { return false }
        if this.is_ended() { return false }

        let dlen: I64 = data.len()
        if dlen == 0 { return true }

        let state: I64 = this.get_state()

        if state == RS_STATE_FLOWING {
            // Emit data event immediately — mark did_read
            this.set_did_read()
            this.emitter_emit("data", data as I64)

            // If piped, write to destination
            let pipe_dest: I64 = this.get_pipe_dest()
            if pipe_dest != 0 {
                let ws: mut ref WritableStream = pipe_dest as mut ref WritableStream
                let ok: Bool = ws.write(data)
                if not ok {
                    // Backpressure from dest — pause ourselves
                    this.pause()
                }
            }

            return true
        }

        // Paused or null — buffer the data
        let buf: I64 = this.get_buf()
        rbuf_append_str(buf, data)

        if state == RS_STATE_PAUSED or state == RS_STATE_NULL {
            this.emitter_emit("readable", 0)
        }

        // Return backpressure signal
        let buf_len: I64 = rbuf_len(buf)
        let hwm: I64 = this.get_hwm()
        buf_len < hwm
    }

    /// Signal that no more data will be pushed.
    ///
    /// Emits `"end"` after all buffered data is consumed.
    pub func push_eof(mut this) {
        if this.is_destroyed_internal() { return }
        if this.is_ended() { return }
        this.set_ended()

        let state: I64 = this.get_state()
        let buf: I64 = this.get_buf()
        let buf_len: I64 = rbuf_len(buf)

        // If buffer is empty, emit end immediately
        if buf_len == 0 {
            this.emitter_emit("end", 0)
            // If piped, end the destination too
            let pipe_dest: I64 = this.get_pipe_dest()
            if pipe_dest != 0 {
                let ws: mut ref WritableStream = pipe_dest as mut ref WritableStream
                ws.end()
            }
        }
        // Otherwise end will be emitted when buffer is drained via read()
    }

    // ================================================================
    // Public API: Read data from the stream (consumer side)
    // ================================================================

    /// Pull up to `size` bytes from the internal buffer.
    ///
    /// Returns the data as a string. Returns `""` if no data is available.
    /// When the buffer is drained and EOF was signaled, emits `"end"`.
    @allocates
    pub func read(mut this, size: I64) -> Str {
        if this.is_destroyed_internal() { return "" }

        let buf: I64 = this.get_buf()
        let buf_len: I64 = rbuf_len(buf)

        if buf_len == 0 {
            if this.is_ended() {
                this.emitter_emit("end", 0)
            }
            return ""
        }

        let result: Str = rbuf_read(buf, size)
        this.set_did_read()

        // Check if we should emit "end" after draining
        let remaining: I64 = rbuf_len(buf)
        if remaining == 0 and this.is_ended() {
            this.emitter_emit("end", 0)
        }

        // If we have a _read callback and buffer is below hwm, request more
        let read_fn: I64 = this.get_read_fn()
        if read_fn != 0 and remaining < this.get_hwm() {
            let f: func(I64, I64) = read_fn as func(I64, I64)
            f(this.get_hwm() - remaining, this.handle as I64)
        }

        result
    }

    /// Pull all buffered data.
    @allocates
    pub func read_all(mut this) -> Str {
        if this.is_destroyed_internal() { return "" }
        let buf: I64 = this.get_buf()
        let buf_len: I64 = rbuf_len(buf)
        if buf_len == 0 {
            if this.is_ended() {
                this.emitter_emit("end", 0)
            }
            return ""
        }
        let result: Str = rbuf_read_all(buf)
        this.set_did_read()
        if this.is_ended() {
            this.emitter_emit("end", 0)
        }
        result
    }

    /// Set the `_read` callback, called when the stream needs more data.
    ///
    /// The callback signature is `func(size: I64, stream_ptr: I64)`.
    /// `size` is the number of bytes the stream would like.
    /// `stream_ptr` is a pointer to this ReadableStream's handle.
    pub func set_read_fn(mut this, f: I64) {
        rs_wr(this.handle as I64 + OFFSET_READ_FN, f)
    }

    // ================================================================
    // Public API: Flow control
    // ================================================================

    /// Switch to paused mode. Data will accumulate in the buffer.
    ///
    /// Emits `"pause"` event.
    pub func pause(mut this) {
        if this.is_destroyed_internal() { return }
        let was: I64 = this.get_state()
        this.set_state(RS_STATE_PAUSED)
        if was != RS_STATE_PAUSED {
            this.emitter_emit("pause", 0)
        }
    }

    /// Switch to flowing mode. Buffered data is emitted via `"data"` events.
    ///
    /// Emits `"resume"` event.
    pub func resume(mut this) {
        if this.is_destroyed_internal() { return }
        let was: I64 = this.get_state()
        this.set_state(RS_STATE_FLOWING)

        if was != RS_STATE_FLOWING {
            this.emitter_emit("resume", 0)
        }

        // Flush any buffered data as "data" events
        let buf: I64 = this.get_buf()
        let buf_len: I64 = rbuf_len(buf)
        if buf_len > 0 {
            let data: Str = rbuf_read_all(buf)
            this.set_did_read()
            this.emitter_emit("data", data as I64)
        }

        // If ended and buffer now empty, emit "end"
        if this.is_ended() and rbuf_len(buf) == 0 {
            this.emitter_emit("end", 0)
        }
    }

    /// Returns true if the stream is in paused mode.
    pub func is_paused(this) -> Bool {
        this.get_state() == RS_STATE_PAUSED
    }

    /// Push data back to the front of the internal buffer.
    pub func unshift(mut this, data: Str) {
        if this.is_destroyed_internal() { return }
        let buf: I64 = this.get_buf()
        rbuf_prepend_str(buf, data)
    }

    // ================================================================
    // Public API: Pipe
    // ================================================================

    /// Pipe all data from this readable to a writable destination.
    ///
    /// Returns the destination for chaining.
    /// Emits `"pipe"` on the destination and `"resume"` on this stream.
    /// When this stream ends, the destination is ended too.
    /// Backpressure is handled: if dest returns false from write(),
    /// this stream pauses until dest emits "drain".
    pub func pipe(mut this, dest: mut ref WritableStream) {
        if this.is_destroyed_internal() { return }

        // Store pipe destination
        this.set_pipe_dest((mut ref dest) as I64)

        // Emit "pipe" on destination
        dest.emit("pipe", (mut ref this) as I64)

        // Switch to flowing mode — this will flush buffered data
        if this.get_state() != RS_STATE_FLOWING {
            this.resume()
        }
    }

    /// Remove the pipe to a writable destination.
    ///
    /// Emits `"unpipe"` on the destination.
    pub func unpipe(mut this, dest: mut ref WritableStream) {
        if this.is_destroyed_internal() { return }
        let pipe_dest: I64 = this.get_pipe_dest()
        if pipe_dest == 0 { return }

        // Only unpipe if it matches
        if pipe_dest == (mut ref dest) as I64 {
            this.set_pipe_dest(0)
            dest.emit("unpipe", (mut ref this) as I64)
        }
    }

    /// Remove all pipes.
    pub func unpipe_all(mut this) {
        if this.is_destroyed_internal() { return }
        let pipe_dest: I64 = this.get_pipe_dest()
        if pipe_dest == 0 { return }
        let ws: mut ref WritableStream = pipe_dest as mut ref WritableStream
        ws.emit("unpipe", (mut ref this) as I64)
        this.set_pipe_dest(0)
    }

    // ================================================================
    // Public API: State queries
    // ================================================================

    /// Returns true if the stream has data to read or hasn't ended.
    pub func readable(this) -> Bool {
        if this.is_destroyed_internal() { return false }
        not this.is_ended() or rbuf_len(this.get_buf()) > 0
    }

    /// Returns the number of bytes in the internal buffer.
    pub func readable_length(this) -> I64 {
        if this.handle == (0 as *Unit) { return 0 as I64 }
        rbuf_len(this.get_buf())
    }

    /// Returns true if the stream is in flowing mode.
    pub func readable_flowing(this) -> Bool {
        if this.handle == (0 as *Unit) { return false }
        this.get_state() == RS_STATE_FLOWING
    }

    /// Returns true if push_eof() has been called.
    pub func readable_ended(this) -> Bool {
        if this.handle == (0 as *Unit) { return true }
        this.is_ended()
    }

    /// Returns the highWaterMark value.
    pub func readable_high_water_mark(this) -> I64 {
        if this.handle == (0 as *Unit) { return 0 as I64 }
        this.get_hwm()
    }

    /// Returns true if a "data" event has been emitted at least once.
    pub func readable_did_read(this) -> Bool {
        if this.handle == (0 as *Unit) { return false }
        this.get_did_read()
    }

    /// Returns true if the stream was destroyed before "end" was emitted.
    pub func readable_aborted(this) -> Bool {
        if this.handle == (0 as *Unit) { return false }
        this.is_destroyed_internal() and not this.is_ended()
    }

    /// Returns true if the stream has been destroyed.
    pub func closed(this) -> Bool {
        this.is_destroyed_internal()
    }

    /// Returns true if the stream has been destroyed.
    pub func destroyed(this) -> Bool {
        this.is_destroyed_internal()
    }

    /// Returns true if an error was emitted.
    pub func errored(this) -> Bool {
        if this.handle == (0 as *Unit) { return false }
        this.is_errored_internal()
    }

    /// Returns the error string, or "" if no error.
    @allocates
    pub func error_message(this) -> Str {
        if this.handle == (0 as *Unit) { return "" }
        let ptr: I64 = this.get_error_ptr()
        if ptr == 0 { return "" }
        ptr as Str
    }

    // ================================================================
    // Public API: Lifecycle
    // ================================================================

    /// Destroy the stream and release all resources.
    ///
    /// Emits `"close"` event.
    pub func destroy(mut this) {
        if this.is_destroyed_internal() { return }
        this.set_destroyed_flag()

        // Unpipe if piped
        let pipe_dest: I64 = this.get_pipe_dest()
        if pipe_dest != 0 {
            let ws: mut ref WritableStream = pipe_dest as mut ref WritableStream
            ws.emit("unpipe", (mut ref this) as I64)
            this.set_pipe_dest(0)
        }

        this.emitter_emit("close", 0)
        // Free internal buffer
        let buf: I64 = this.get_buf()
        rbuf_destroy(buf)
        // Free emitter
        this.emitter_destroy()
        // Free handle
        rs_free(this.handle)
        this.handle = 0 as *Unit
    }

    /// Destroy the stream with an error.
    ///
    /// Emits `"error"` then `"close"`.
    pub func destroy_with_error(mut this, err: Str) {
        if this.is_destroyed_internal() { return }
        this.set_errored_flag()
        this.set_error_ptr(err as I64)
        this.emitter_emit("error", err as I64)
        this.destroy()
    }
}

// Forward declaration reference — WritableStream is used in pipe()
use std::stream::writable_stream::WritableStream
