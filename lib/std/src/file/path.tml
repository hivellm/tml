//! Path manipulation utilities.
//!
//! Provides the [`Path`] type for querying and manipulating
//! file system paths.
//!
//! # Example
//!
//! ```tml
//! use std::file::Path
//!
//! if Path::exists("data.json") {
//!     let dir = Path::parent("data.json")
//!     let name = Path::filename("data.json")
//! }
//! ```

// FFI declarations for C runtime path operations
@extern("path_exists")
func ffi_path_exists(path: Str) -> Bool

@extern("path_is_file")
func ffi_path_is_file(path: Str) -> Bool

@extern("path_is_dir")
func ffi_path_is_dir(path: Str) -> Bool

@extern("path_create_dir")
func ffi_path_create_dir(path: Str) -> Bool

@extern("path_create_dir_all")
func ffi_path_create_dir_all(path: Str) -> Bool

@extern("path_remove")
func ffi_path_remove(path: Str) -> Bool

@extern("path_remove_dir")
func ffi_path_remove_dir(path: Str) -> Bool

@extern("path_rename")
func ffi_path_rename(src_path: Str, dst_path: Str) -> Bool

@extern("path_copy")
func ffi_path_copy(src_path: Str, dst_path: Str) -> Bool

@allocates
@extern("path_join")
func ffi_path_join(base_path: Str, child_path: Str) -> Str

@allocates
@extern("path_parent")
func ffi_path_parent(path: Str) -> Str

@allocates
@extern("path_filename")
func ffi_path_filename(path: Str) -> Str

@allocates
@extern("path_extension")
func ffi_path_extension(path: Str) -> Str

@allocates
@extern("path_absolute")
func ffi_path_absolute(path: Str) -> Str

/// Path manipulation utilities.
///
/// `Path` provides static methods for working with file system paths:
/// checking existence, joining paths, extracting components, etc.
///
/// # Example
///
/// ```tml
/// let full = Path::join("output", "data.txt")
/// let ext = Path::extension("file.txt")  // ".txt"
/// ```
pub type Path {
    dummy: I32
}

impl Path {
    /// Check if a path exists
    pub func exists(path: Str) -> Bool {
        return ffi_path_exists(path)
    }

    /// Check if path is a file
    pub func is_file(path: Str) -> Bool {
        return ffi_path_is_file(path)
    }

    /// Check if path is a directory
    pub func is_dir(path: Str) -> Bool {
        return ffi_path_is_dir(path)
    }

    /// Remove a file
    pub func remove(path: Str) -> Bool {
        return ffi_path_remove(path)
    }

    /// Rename/move a file or directory
    pub func rename(src_path: Str, dst_path: Str) -> Bool {
        return ffi_path_rename(src_path, dst_path)
    }

    /// Copy a file
    pub func copy(src_path: Str, dst_path: Str) -> Bool {
        return ffi_path_copy(src_path, dst_path)
    }

    /// Join two path components
    pub func join(base_path: Str, child_path: Str) -> Str {
        return ffi_path_join(base_path, child_path)
    }

    /// Get the parent directory of a path
    pub func parent(path: Str) -> Str {
        return ffi_path_parent(path)
    }

    /// Get the filename from a path
    pub func filename(path: Str) -> Str {
        return ffi_path_filename(path)
    }

    /// Get the file extension (including dot)
    pub func extension(path: Str) -> Str {
        return ffi_path_extension(path)
    }

    /// Get the absolute path
    pub func absolute(path: Str) -> Str {
        return ffi_path_absolute(path)
    }

    /// Create a directory
    pub func create_dir(path: Str) -> Bool {
        return ffi_path_create_dir(path)
    }

    /// Create a directory and all parent directories
    pub func create_dir_all(path: Str) -> Bool {
        return ffi_path_create_dir_all(path)
    }

    /// Remove a directory
    pub func remove_dir(path: Str) -> Bool {
        return ffi_path_remove_dir(path)
    }

    /// Check if a path is absolute (starts with / on Unix, C:\ on Windows)
    pub func is_absolute(path: Str) -> Bool {
        if path.len() == 0 {
            return false
        }

        // Unix absolute path
        let first_char: Str = path.slice(0, 1)
        if first_char == "/" {
            return true
        }

        // Windows absolute path (e.g., C:\, D:\)
        if path.len() >= 3 {
            let second_char: Str = path.slice(1, 2)
            let third_char: Str = path.slice(2, 3)
            if second_char == ":" and third_char == "\\" {
                return true
            }
            // Also allow forward slashes on Windows
            if second_char == ":" and third_char == "/" {
                return true
            }
        }

        return false
    }

    /// Check if a path is relative (not absolute)
    pub func is_relative(path: Str) -> Bool {
        return not Path::is_absolute(path)
    }

    /// Get the filename without extension (file stem)
    pub func file_stem(path: Str) -> Str {
        let filename: Str = Path::filename(path)
        let ext: Str = Path::extension(path)

        if ext.len() == 0 {
            return filename
        }

        // Remove the extension (including the dot)
        let stem_len: I64 = filename.len() - ext.len()
        if stem_len <= 0 {
            return filename
        }

        return filename.slice(0, stem_len)
    }

    /// Replace the file extension with a new one
    pub func with_extension(path: Str, new_ext: Str) -> Str {
        let parent: Str = Path::parent(path)
        let filename: Str = Path::filename(path)
        let stem: Str = Path::file_stem(path)

        // Build new filename with new extension
        let new_filename: Str = if new_ext.len() == 0 {
            stem
        } else if new_ext.slice(0, 1) == "." {
            stem + new_ext
        } else {
            stem + "." + new_ext
        }

        // Join parent with new filename
        return Path::join(parent, new_filename)
    }
}
