//! Elliptic Curve Diffie-Hellman (ECDH) key exchange.
//!
//! ECDH provides the same security as classic DH with much smaller key sizes,
//! making it faster and more efficient.
//!
//! # Supported Curves
//!
//! | Curve | Size | Security Level | Notes |
//! |-------|------|----------------|-------|
//! | prime256v1 (P-256) | 256 bits | 128-bit | NIST, widely used |
//! | secp384r1 (P-384) | 384 bits | 192-bit | NIST |
//! | secp521r1 (P-521) | 521 bits | 256-bit | NIST |
//! | secp256k1 | 256 bits | 128-bit | Bitcoin/Ethereum |
//! | X25519 | 256 bits | 128-bit | Modern, recommended |
//! | X448 | 448 bits | 224-bit | Higher security |
//!
//! # Recommendations
//!
//! - For general use: **X25519** (fastest, constant-time)
//! - For higher security: **X448** or **P-384**
//! - For compatibility: **P-256** (widest support)
//! - For blockchain: **secp256k1**
//!
//! # Examples
//!
//! ## X25519 Key Exchange (Recommended)
//!
//! ```tml
//! use std::crypto::{create_ecdh, EcCurve}
//!
//! // Alice
//! let alice = create_ecdh(EcCurve::X25519)?
//! alice.generate_keys()
//! let alice_public = alice.public_key()
//!
//! // Bob
//! let bob = create_ecdh(EcCurve::X25519)?
//! bob.generate_keys()
//! let bob_public = bob.public_key()
//!
//! // Compute shared secrets
//! let alice_secret = alice.compute_secret(bob_public)?
//! let bob_secret = bob.compute_secret(alice_public)?
//!
//! // alice_secret == bob_secret
//! ```
//!
//! ## NIST P-256 Key Exchange
//!
//! ```tml
//! use std::crypto::{create_ecdh, EcCurve}
//!
//! let ecdh = create_ecdh(EcCurve::P256)?
//! ecdh.generate_keys()
//!
//! let public_key = ecdh.public_key()  // Send to peer
//! let shared_secret = ecdh.compute_secret(peer_public_key)?
//! ```
//!
//! ## Derive Encryption Key from Shared Secret
//!
//! ```tml
//! use std::crypto::{create_ecdh, EcCurve, hkdf, HashAlgorithm}
//!
//! let ecdh = create_ecdh(EcCurve::X25519)?
//! ecdh.generate_keys()
//!
//! let shared_secret = ecdh.compute_secret(peer_public_key)?
//!
//! // Derive encryption key using HKDF
//! let salt = random_bytes(32)
//! let key = hkdf(HashAlgorithm::Sha256, shared_secret, salt, "encryption", 32)?
//! ```

use std::crypto::error::{CryptoError, CryptoResult}
use std::collections::{Buffer, List}

@extern("crypto_ecdh_create")
func crypto_ecdh_create(curve_name: Str) -> *Unit
@extern("crypto_ecdh_generate_keys")
func crypto_ecdh_generate_keys(handle: *Unit)
@extern("crypto_ecdh_get_public_key")
func crypto_ecdh_get_public_key(handle: *Unit, format: Str) -> *Unit
@extern("crypto_ecdh_get_private_key")
func crypto_ecdh_get_private_key(handle: *Unit) -> *Unit
@extern("crypto_ecdh_set_public_key")
func crypto_ecdh_set_public_key(handle: *Unit, key_handle: *Unit) -> Bool
@extern("crypto_ecdh_set_private_key")
func crypto_ecdh_set_private_key(handle: *Unit, key_handle: *Unit) -> Bool
@extern("crypto_ecdh_compute_secret")
func crypto_ecdh_compute_secret(handle: *Unit, other_handle: *Unit) -> *Unit
@extern("crypto_ecdh_destroy")
func crypto_ecdh_destroy(handle: *Unit)
@extern("crypto_ecdh_convert_key")
func crypto_ecdh_convert_key(key_handle: *Unit, curve_name: Str, from_format: Str, to_format: Str) -> *Unit
@extern("crypto_x25519")
func crypto_x25519(private_handle: *Unit, public_handle: *Unit) -> *Unit
@extern("crypto_x448")
func crypto_x448(private_handle: *Unit, public_handle: *Unit) -> *Unit
@extern("crypto_x25519_generate_private")
func crypto_x25519_generate_private() -> *Unit
@extern("crypto_x25519_public_from_private")
func crypto_x25519_public_from_private(private_handle: *Unit) -> *Unit
@extern("crypto_x448_generate_private")
func crypto_x448_generate_private() -> *Unit
@extern("crypto_x448_public_from_private")
func crypto_x448_public_from_private(private_handle: *Unit) -> *Unit
@extern("crypto_is_curve_supported")
func crypto_is_curve_supported(curve_name: Str) -> Bool

/// Supported elliptic curves for ECDH.
pub type EcCurve {
    /// NIST P-256 (secp256r1, prime256v1)
    P256,
    /// NIST P-384 (secp384r1)
    P384,
    /// NIST P-521 (secp521r1)
    P521,
    /// Bitcoin/Ethereum curve (secp256k1)
    Secp256k1,
    /// Curve25519 for X25519 key exchange
    X25519,
    /// Curve448 for X448 key exchange
    X448,
    /// Brainpool P-256
    BrainpoolP256r1,
    /// Brainpool P-384
    BrainpoolP384r1,
    /// Brainpool P-512
    BrainpoolP512r1,
}

impl EcCurve {
    /// Returns the curve name as used by OpenSSL.
    pub func name(this) -> Str {
        when this {
            EcCurve::P256 => return "prime256v1"
            EcCurve::P384 => return "secp384r1"
            EcCurve::P521 => return "secp521r1"
            EcCurve::Secp256k1 => return "secp256k1"
            EcCurve::X25519 => return "X25519"
            EcCurve::X448 => return "X448"
            EcCurve::BrainpoolP256r1 => return "brainpoolP256r1"
            EcCurve::BrainpoolP384r1 => return "brainpoolP384r1"
            EcCurve::BrainpoolP512r1 => return "brainpoolP512r1"
        }
    }

    /// Returns the key size in bits.
    pub func key_bits(this) -> I64 {
        when this {
            EcCurve::P256 => return 256
            EcCurve::P384 => return 384
            EcCurve::P521 => return 521
            EcCurve::Secp256k1 => return 256
            EcCurve::X25519 => return 256
            EcCurve::X448 => return 448
            EcCurve::BrainpoolP256r1 => return 256
            EcCurve::BrainpoolP384r1 => return 384
            EcCurve::BrainpoolP512r1 => return 512
        }
    }

    /// Returns the shared secret size in bytes.
    pub func shared_secret_size(this) -> I64 {
        when this {
            EcCurve::P256 => return 32
            EcCurve::P384 => return 48
            EcCurve::P521 => return 66
            EcCurve::Secp256k1 => return 32
            EcCurve::X25519 => return 32
            EcCurve::X448 => return 56
            EcCurve::BrainpoolP256r1 => return 32
            EcCurve::BrainpoolP384r1 => return 48
            EcCurve::BrainpoolP512r1 => return 64
        }
    }

    /// Returns true if this is a modern curve (X25519/X448).
    pub func is_modern(this) -> Bool {
        when this {
            EcCurve::X25519 => return true
            EcCurve::X448 => return true
            _ => return false
        }
    }

    /// Parses a curve from its name.
    pub func from_name(name: Str) -> Maybe[EcCurve] {
        when name {
            "prime256v1" => return Just(EcCurve::P256)
            "P-256" => return Just(EcCurve::P256)
            "secp256r1" => return Just(EcCurve::P256)
            "secp384r1" => return Just(EcCurve::P384)
            "P-384" => return Just(EcCurve::P384)
            "secp521r1" => return Just(EcCurve::P521)
            "P-521" => return Just(EcCurve::P521)
            "secp256k1" => return Just(EcCurve::Secp256k1)
            "X25519" => return Just(EcCurve::X25519)
            "x25519" => return Just(EcCurve::X25519)
            "X448" => return Just(EcCurve::X448)
            "x448" => return Just(EcCurve::X448)
            "brainpoolP256r1" => return Just(EcCurve::BrainpoolP256r1)
            "brainpoolP384r1" => return Just(EcCurve::BrainpoolP384r1)
            "brainpoolP512r1" => return Just(EcCurve::BrainpoolP512r1)
            _ => return Nothing
        }
    }
}

/// Public key point format for ECDH.
pub type EcPointFormat {
    /// Uncompressed point (04 || x || y)
    Uncompressed,
    /// Compressed point (02/03 || x)
    Compressed,
    /// Hybrid point
    Hybrid,
}

impl EcPointFormat {
    pub func name(this) -> Str {
        when this {
            EcPointFormat::Uncompressed => return "uncompressed"
            EcPointFormat::Compressed => return "compressed"
            EcPointFormat::Hybrid => return "hybrid"
        }
    }
}

/// Elliptic Curve Diffie-Hellman key exchange object.
pub type Ecdh {
    handle: *Unit
    curve: EcCurve
}

impl Ecdh {
    /// Creates an ECDH object for the specified curve.
    pub func new(curve: EcCurve) -> CryptoResult[Ecdh] {
        let handle: *Unit = crypto_ecdh_create(curve.name())
        if handle == null {
            return Err(CryptoError::unsupported_algorithm("unsupported curve: {curve.name()}"))
        }
        return Ok(Ecdh { handle: handle, curve: curve })
    }

    /// Generates the public/private key pair.
    pub func generate_keys(mut this) {
        crypto_ecdh_generate_keys(this.handle)
    }

    /// Returns the public key in the specified format.
    pub func public_key_format(this, format: EcPointFormat) -> Buffer {
        let handle: *Unit = crypto_ecdh_get_public_key(this.handle, format.name())
        return Buffer { handle: handle }
    }

    /// Returns the public key (uncompressed format by default).
    pub func public_key(this) -> Buffer {
        return this.public_key_format(EcPointFormat::Uncompressed)
    }

    /// Returns the private key.
    pub func private_key(this) -> Buffer {
        let handle: *Unit = crypto_ecdh_get_private_key(this.handle)
        return Buffer { handle: handle }
    }

    /// Sets the public key.
    pub func set_public_key(mut this, key: ref Buffer) -> CryptoResult[Unit] {
        let success: Bool = crypto_ecdh_set_public_key(this.handle, key.handle)
        if not success {
            return Err(CryptoError::invalid_key("invalid key"))
        }
        return Ok(())
    }

    /// Sets the private key.
    pub func set_private_key(mut this, key: ref Buffer) -> CryptoResult[Unit] {
        let success: Bool = crypto_ecdh_set_private_key(this.handle, key.handle)
        if not success {
            return Err(CryptoError::invalid_key("invalid key"))
        }
        return Ok(())
    }

    /// Computes the shared secret using the other party's public key.
    pub func compute_secret(this, other_public_key: ref Buffer) -> CryptoResult[Buffer] {
        let handle: *Unit = crypto_ecdh_compute_secret(this.handle, other_public_key.handle)
        if handle == null {
            return Err(CryptoError::operation_failed("key exchange failed"))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Returns the curve being used.
    pub func curve(this) -> EcCurve {
        return this.curve
    }

    /// Frees the ECDH resources.
    pub func destroy(mut this) {
        if this.handle != null {
            crypto_ecdh_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// Convenience functions
// ============================================================================

/// Creates an ECDH object for the specified curve.
pub func create_ecdh(curve: EcCurve) -> CryptoResult[Ecdh] {
    return Ecdh::new(curve)
}

/// Converts an EC public key between formats.
///
/// Useful for interoperability with systems using different point formats.
pub func convert_ec_key(
    key: ref Buffer,
    curve: EcCurve,
    from_format: EcPointFormat,
    to_format: EcPointFormat,
) -> CryptoResult[Buffer] {
    let handle: *Unit = crypto_ecdh_convert_key(key.handle, curve.name(), from_format.name(), to_format.name())
    if handle == null {
        return Err(CryptoError::invalid_key("invalid key"))
    }
    return Ok(Buffer { handle: handle })
}

/// Performs X25519 key exchange.
///
/// Convenience function for the most common ECDH operation.
pub func x25519(private_key: ref Buffer, public_key: ref Buffer) -> CryptoResult[Buffer] {
    if private_key.len() != 32 {
        return Err(CryptoError::invalid_key("X25519 private key must be 32 bytes"))
    }
    if public_key.len() != 32 {
        return Err(CryptoError::invalid_key("X25519 public key must be 32 bytes"))
    }

    let handle: *Unit = crypto_x25519(private_key.handle, public_key.handle)
    if handle == null {
        return Err(CryptoError::operation_failed("key exchange failed"))
    }
    return Ok(Buffer { handle: handle })
}

/// Performs X448 key exchange.
pub func x448(private_key: ref Buffer, public_key: ref Buffer) -> CryptoResult[Buffer] {
    if private_key.len() != 56 {
        return Err(CryptoError::invalid_key("X448 private key must be 56 bytes"))
    }
    if public_key.len() != 56 {
        return Err(CryptoError::invalid_key("X448 public key must be 56 bytes"))
    }

    let handle: *Unit = crypto_x448(private_key.handle, public_key.handle)
    if handle == null {
        return Err(CryptoError::operation_failed("key exchange failed"))
    }
    return Ok(Buffer { handle: handle })
}

/// Generates an X25519 key pair.
///
/// Returns (private_key, public_key).
pub func generate_x25519_keypair() -> (Buffer, Buffer) {
    let private_handle: *Unit = crypto_x25519_generate_private()
    let public_handle: *Unit = crypto_x25519_public_from_private(private_handle)
    return (Buffer { handle: private_handle }, Buffer { handle: public_handle })
}

/// Generates an X448 key pair.
///
/// Returns (private_key, public_key).
pub func generate_x448_keypair() -> (Buffer, Buffer) {
    let private_handle: *Unit = crypto_x448_generate_private()
    let public_handle: *Unit = crypto_x448_public_from_private(private_handle)
    return (Buffer { handle: private_handle }, Buffer { handle: public_handle })
}

/// Derives the public key from an X25519 private key.
pub func x25519_public_from_private(private_key: ref Buffer) -> CryptoResult[Buffer] {
    if private_key.len() != 32 {
        return Err(CryptoError::invalid_key("X25519 private key must be 32 bytes"))
    }
    let handle: *Unit = crypto_x25519_public_from_private(private_key.handle)
    return Ok(Buffer { handle: handle })
}

/// Derives the public key from an X448 private key.
pub func x448_public_from_private(private_key: ref Buffer) -> CryptoResult[Buffer] {
    if private_key.len() != 56 {
        return Err(CryptoError::invalid_key("X448 private key must be 56 bytes"))
    }
    let handle: *Unit = crypto_x448_public_from_private(private_key.handle)
    return Ok(Buffer { handle: handle })
}

// ============================================================================
// Curve information
// ============================================================================

/// Returns a list of all supported curve names.
pub func get_curves() -> List[Str] {
    let list: List[Str] = List[Str]::new(9)
    list.push("prime256v1")
    list.push("secp384r1")
    list.push("secp521r1")
    list.push("secp256k1")
    list.push("X25519")
    list.push("X448")
    list.push("brainpoolP256r1")
    list.push("brainpoolP384r1")
    list.push("brainpoolP512r1")
    return list
}

/// Returns true if the specified curve is supported.
pub func is_curve_supported(curve_name: Str) -> Bool {
    let result: Bool = crypto_is_curve_supported(curve_name)
    return result
}

impl Drop for Ecdh {
    func drop(mut this) {
        this.destroy()
    }
}