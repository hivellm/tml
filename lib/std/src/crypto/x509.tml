//! X.509 Certificate handling.
//!
//! This module provides functionality for parsing, validating, and working
//! with X.509 certificates, which are the standard format for public key
//! certificates used in TLS/SSL.
//!
//! # Features
//!
//! - Parse certificates from PEM or DER format
//! - Verify certificate signatures
//! - Check validity period
//! - Validate hostname/IP/email
//! - Certificate chain verification
//! - Access certificate fields (subject, issuer, extensions)

use std::crypto::error::{CryptoError, CryptoErrorKind, CryptoResult}
use std::crypto::key::{PublicKey, KeyType}
use std::collections::{Buffer, List}

// ============================================================================
// FFI declarations for crypto_x509.c functions
// ============================================================================

// Certificate parsing
@extern("crypto_x509_from_pem")
func ffi_x509_from_pem(pem: Str) -> *Unit

@extern("crypto_x509_from_der")
func ffi_x509_from_der(buf_handle: *Unit) -> *Unit

// Subject field extraction
@extern("crypto_x509_get_subject")
func ffi_x509_get_subject(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_cn")
func ffi_x509_get_subject_cn(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_o")
func ffi_x509_get_subject_o(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_ou")
func ffi_x509_get_subject_ou(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_c")
func ffi_x509_get_subject_c(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_st")
func ffi_x509_get_subject_st(handle: *Unit) -> Str

@extern("crypto_x509_get_subject_l")
func ffi_x509_get_subject_l(handle: *Unit) -> Str

// Issuer field extraction
@extern("crypto_x509_get_issuer")
func ffi_x509_get_issuer(handle: *Unit) -> Str

@extern("crypto_x509_get_issuer_cn")
func ffi_x509_get_issuer_cn(handle: *Unit) -> Str

@extern("crypto_x509_get_issuer_o")
func ffi_x509_get_issuer_o(handle: *Unit) -> Str

// Serial, dates
@extern("crypto_x509_get_serial")
func ffi_x509_get_serial(handle: *Unit) -> Str

@extern("crypto_x509_get_not_before")
func ffi_x509_get_not_before(handle: *Unit) -> Str

@extern("crypto_x509_get_not_after")
func ffi_x509_get_not_after(handle: *Unit) -> Str

@extern("crypto_x509_get_not_before_ts")
func ffi_x509_get_not_before_ts(handle: *Unit) -> I64

@extern("crypto_x509_get_not_after_ts")
func ffi_x509_get_not_after_ts(handle: *Unit) -> I64

// Fingerprints
@extern("crypto_x509_fingerprint_sha1")
func ffi_x509_fingerprint_sha1(handle: *Unit) -> Str

@extern("crypto_x509_fingerprint_sha256")
func ffi_x509_fingerprint_sha256(handle: *Unit) -> Str

@extern("crypto_x509_fingerprint_sha512")
func ffi_x509_fingerprint_sha512(handle: *Unit) -> Str

// Public key, signature, CA, key usage
@extern("crypto_x509_get_public_key")
func ffi_x509_get_public_key(handle: *Unit) -> *Unit

@extern("crypto_x509_get_sig_alg")
func ffi_x509_get_sig_alg(handle: *Unit) -> Str

@extern("crypto_x509_is_ca")
func ffi_x509_is_ca(handle: *Unit) -> Bool

@extern("crypto_x509_get_key_usage")
func ffi_x509_get_key_usage(handle: *Unit) -> I64

@extern("crypto_x509_get_san")
func ffi_x509_get_san(handle: *Unit) -> *Unit

// Verification
@extern("crypto_x509_verify")
func ffi_x509_verify(cert_handle: *Unit, key_handle: *Unit) -> Bool

@extern("crypto_x509_check_issued")
func ffi_x509_check_issued(cert_handle: *Unit, issuer_handle: *Unit) -> Bool

@extern("crypto_x509_check_host")
func ffi_x509_check_host(handle: *Unit, hostname: Str) -> Bool

@extern("crypto_x509_check_email")
func ffi_x509_check_email(handle: *Unit, email: Str) -> Bool

@extern("crypto_x509_check_ip")
func ffi_x509_check_ip(handle: *Unit, ip: Str) -> Bool

@extern("crypto_x509_check_private_key")
func ffi_x509_check_private_key(cert_handle: *Unit, key_handle: *Unit) -> Bool

@extern("crypto_x509_is_valid_now")
func ffi_x509_is_valid_now(handle: *Unit) -> Bool

// Export
@extern("crypto_x509_to_pem")
func ffi_x509_to_pem(handle: *Unit) -> Str

@extern("crypto_x509_to_der")
func ffi_x509_to_der(handle: *Unit) -> *Unit

@extern("crypto_x509_to_text")
func ffi_x509_to_text(handle: *Unit) -> Str

// Destroy
@extern("crypto_x509_destroy")
func ffi_x509_destroy(handle: *Unit)

// Store operations
@extern("crypto_x509_store_create")
func ffi_x509_store_create() -> *Unit

@extern("crypto_x509_store_system")
func ffi_x509_store_system() -> *Unit

@extern("crypto_x509_store_add_cert")
func ffi_x509_store_add_cert(store: *Unit, cert: *Unit) -> Bool

@extern("crypto_x509_store_add_pem_file")
func ffi_x509_store_add_pem_file(store: *Unit, path: Str) -> I64

@extern("crypto_x509_store_verify")
func ffi_x509_store_verify(store: *Unit, cert: *Unit) -> Bool

@extern("crypto_x509_store_verify_chain")
func ffi_x509_store_verify_chain(store: *Unit, cert: *Unit, chain: *Unit) -> Bool

@extern("crypto_x509_store_destroy")
func ffi_x509_store_destroy(store: *Unit)

// PEM bundle helpers
@extern("crypto_x509_count_pem_certs")
func ffi_x509_count_pem_certs(pem: Str) -> I64

@extern("crypto_x509_extract_pem_cert")
func ffi_x509_extract_pem_cert(pem: Str, index: I64) -> Str

// List operations (from collections.c)
@extern("list_new")
func ffi_list_new(capacity: I64) -> *Unit

@extern("list_push")
func ffi_list_push(handle: *Unit, value: I64)

@extern("list_get")
func ffi_list_get(handle: *Unit, index: I64) -> I64

@extern("list_len")
func ffi_list_len(handle: *Unit) -> I64

@extern("list_destroy")
func ffi_list_destroy(handle: *Unit)

// Key type helper (from crypto_key.c or crypto.c)
@extern("crypto_key_get_type")
func ffi_key_get_type(handle: *Unit) -> Str

// ============================================================================
// Types
// ============================================================================

/// X.509 Distinguished Name (subject or issuer).
pub type X509Name {
    /// Common Name (CN)
    pub common_name: Maybe[Str]
    /// Organization (O)
    pub organization: Maybe[Str]
    /// Organizational Unit (OU)
    pub organizational_unit: Maybe[Str]
    /// Country (C)
    pub country: Maybe[Str]
    /// State/Province (ST)
    pub state: Maybe[Str]
    /// Locality (L)
    pub locality: Maybe[Str]
    /// Email address
    pub email: Maybe[Str]
    /// Serial number
    pub serial_number: Maybe[Str]
    /// Full distinguished name string
    pub dn: Str
}

impl X509Name {
    /// Returns the common name or empty string.
    pub func cn(this) -> Str {
        when this.common_name {
            Just(name) => return name
            Nothing => return ""
        }
    }

    /// Returns the organization or empty string.
    pub func org(this) -> Str {
        when this.organization {
            Just(org) => return org
            Nothing => return ""
        }
    }
}

/// X.509 key usage flags.
pub type KeyUsage {
    pub digital_signature: Bool
    pub non_repudiation: Bool
    pub key_encipherment: Bool
    pub data_encipherment: Bool
    pub key_agreement: Bool
    pub key_cert_sign: Bool
    pub crl_sign: Bool
    pub encipher_only: Bool
    pub decipher_only: Bool
}

impl KeyUsage {
    /// Creates an empty KeyUsage (all false).
    pub func empty() -> KeyUsage {
        return KeyUsage {
            digital_signature: false,
            non_repudiation: false,
            key_encipherment: false,
            data_encipherment: false,
            key_agreement: false,
            key_cert_sign: false,
            crl_sign: false,
            encipher_only: false,
            decipher_only: false,
        }
    }
}

/// Extended key usage OIDs.
pub type ExtKeyUsage {
    /// Server authentication (TLS server)
    pub server_auth: Bool
    /// Client authentication (TLS client)
    pub client_auth: Bool
    /// Code signing
    pub code_signing: Bool
    /// Email protection (S/MIME)
    pub email_protection: Bool
    /// Time stamping
    pub time_stamping: Bool
    /// OCSP signing
    pub ocsp_signing: Bool
}

/// X.509 extension.
pub type X509Extension {
    pub oid: Str
    pub critical: Bool
    pub value: Buffer
}

// ============================================================================
// X509Certificate
// ============================================================================

/// X.509 certificate.
pub type X509Certificate {
    handle: *Unit
}

impl X509Certificate {
    /// Parses a certificate from PEM format.
    pub func from_pem(pem: Str) -> CryptoResult[X509Certificate] {
        let handle: *Unit = ffi_x509_from_pem(pem)
        if handle == null {
            return Err(CryptoError::new("certificate parsing failed"))
        }
        return Ok(X509Certificate { handle: handle })
    }

    /// Parses a certificate from DER format.
    pub func from_der(der: ref Buffer) -> CryptoResult[X509Certificate] {
        let handle: *Unit = ffi_x509_from_der(der.handle)
        if handle == null {
            return Err(CryptoError::new("certificate parsing failed"))
        }
        return Ok(X509Certificate { handle: handle })
    }

    /// Returns the certificate subject.
    pub func subject(this) -> X509Name {
        let dn: Str = ffi_x509_get_subject(this.handle)
        let cn: Str = ffi_x509_get_subject_cn(this.handle)
        let org: Str = ffi_x509_get_subject_o(this.handle)
        let ou: Str = ffi_x509_get_subject_ou(this.handle)
        let country: Str = ffi_x509_get_subject_c(this.handle)
        let state: Str = ffi_x509_get_subject_st(this.handle)
        let locality: Str = ffi_x509_get_subject_l(this.handle)

        let maybe_cn: Maybe[Str] = cn != "" ? Just(cn) : Nothing
        let maybe_org: Maybe[Str] = org != "" ? Just(org) : Nothing
        let maybe_ou: Maybe[Str] = ou != "" ? Just(ou) : Nothing
        let maybe_country: Maybe[Str] = country != "" ? Just(country) : Nothing
        let maybe_state: Maybe[Str] = state != "" ? Just(state) : Nothing
        let maybe_locality: Maybe[Str] = locality != "" ? Just(locality) : Nothing

        return X509Name {
            common_name: maybe_cn,
            organization: maybe_org,
            organizational_unit: maybe_ou,
            country: maybe_country,
            state: maybe_state,
            locality: maybe_locality,
            email: Nothing,
            serial_number: Nothing,
            dn: dn,
        }
    }

    /// Returns the certificate issuer.
    pub func issuer(this) -> X509Name {
        let dn: Str = ffi_x509_get_issuer(this.handle)
        let cn: Str = ffi_x509_get_issuer_cn(this.handle)
        let org: Str = ffi_x509_get_issuer_o(this.handle)

        let maybe_cn: Maybe[Str] = cn != "" ? Just(cn) : Nothing
        let maybe_org: Maybe[Str] = org != "" ? Just(org) : Nothing

        return X509Name {
            common_name: maybe_cn,
            organization: maybe_org,
            organizational_unit: Nothing,
            country: Nothing,
            state: Nothing,
            locality: Nothing,
            email: Nothing,
            serial_number: Nothing,
            dn: dn,
        }
    }

    /// Returns the serial number as a hex string.
    pub func serial_number(this) -> Str {
        return ffi_x509_get_serial(this.handle)
    }

    /// Returns the "not before" date as ISO 8601 string.
    pub func valid_from(this) -> Str {
        return ffi_x509_get_not_before(this.handle)
    }

    /// Returns the "not after" date as ISO 8601 string.
    pub func valid_to(this) -> Str {
        return ffi_x509_get_not_after(this.handle)
    }

    /// Returns the "not before" date as Unix timestamp.
    pub func valid_from_date(this) -> I64 {
        return ffi_x509_get_not_before_ts(this.handle)
    }

    /// Returns the "not after" date as Unix timestamp.
    pub func valid_to_date(this) -> I64 {
        return ffi_x509_get_not_after_ts(this.handle)
    }

    /// Returns the SHA-1 fingerprint as hex string.
    pub func fingerprint(this) -> Str {
        return ffi_x509_fingerprint_sha1(this.handle)
    }

    /// Returns the SHA-256 fingerprint as hex string.
    pub func fingerprint256(this) -> Str {
        return ffi_x509_fingerprint_sha256(this.handle)
    }

    /// Returns the SHA-512 fingerprint as hex string.
    pub func fingerprint512(this) -> Str {
        return ffi_x509_fingerprint_sha512(this.handle)
    }

    /// Returns the public key from the certificate.
    pub func public_key(this) -> PublicKey {
        let pk_handle: *Unit = ffi_x509_get_public_key(this.handle)
        let key_type_str: Str = ffi_key_get_type(pk_handle)
        let key_type = KeyType::from_name(key_type_str).unwrap_or(KeyType::Rsa)
        return PublicKey { handle: pk_handle, key_type: key_type }
    }

    /// Returns the signature algorithm.
    pub func signature_algorithm(this) -> Str {
        return ffi_x509_get_sig_alg(this.handle)
    }

    /// Returns true if this is a CA certificate.
    pub func is_ca(this) -> Bool {
        return ffi_x509_is_ca(this.handle)
    }

    /// Returns the key usage flags.
    pub func key_usage(this) -> KeyUsage {
        let flags: I64 = ffi_x509_get_key_usage(this.handle)
        return KeyUsage {
            digital_signature: (flags & 0x80) != 0,
            non_repudiation: (flags & 0x40) != 0,
            key_encipherment: (flags & 0x20) != 0,
            data_encipherment: (flags & 0x10) != 0,
            key_agreement: (flags & 0x08) != 0,
            key_cert_sign: (flags & 0x04) != 0,
            crl_sign: (flags & 0x02) != 0,
            encipher_only: (flags & 0x01) != 0,
            decipher_only: false,
        }
    }

    /// Returns the Subject Alternative Names (SANs).
    pub func subject_alt_names(this) -> List[Str] {
        let handle: *Unit = ffi_x509_get_san(this.handle)
        return List[Str] { handle: handle }
    }

    /// Verifies the certificate signature using a public key.
    pub func verify(this, key: ref PublicKey) -> CryptoResult[Bool] {
        let result: Bool = ffi_x509_verify(this.handle, key.handle)
        return Ok(result)
    }

    /// Checks if the certificate was issued by another certificate.
    pub func check_issued(this, issuer_cert: ref X509Certificate) -> Bool {
        return ffi_x509_check_issued(this.handle, issuer_cert.handle)
    }

    /// Checks if the certificate is valid for a hostname.
    pub func check_host(this, hostname: Str) -> Bool {
        return ffi_x509_check_host(this.handle, hostname)
    }

    /// Checks if the certificate is valid for an email address.
    pub func check_email(this, email: Str) -> Bool {
        return ffi_x509_check_email(this.handle, email)
    }

    /// Checks if the certificate is valid for an IP address.
    pub func check_ip(this, ip: Str) -> Bool {
        return ffi_x509_check_ip(this.handle, ip)
    }

    /// Checks if the private key matches this certificate.
    pub func check_private_key(this, key: ref std::crypto::key::PrivateKey) -> Bool {
        return ffi_x509_check_private_key(this.handle, key.handle)
    }

    /// Returns true if the certificate is currently valid (time-wise).
    pub func is_valid_now(this) -> Bool {
        return ffi_x509_is_valid_now(this.handle)
    }

    /// Exports the certificate to PEM format.
    pub func to_pem(this) -> Str {
        return ffi_x509_to_pem(this.handle)
    }

    /// Exports the certificate to DER format.
    pub func to_der(this) -> Buffer {
        let handle: *Unit = ffi_x509_to_der(this.handle)
        return Buffer { handle: handle }
    }

    /// Returns raw text representation of the certificate.
    pub func to_text(this) -> Str {
        return ffi_x509_to_text(this.handle)
    }

    /// Frees the certificate resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_x509_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// X509Chain
// ============================================================================

/// Certificate chain for verification.
///
/// Internally stores certificate handles in a raw list to avoid
/// generic List[T] indexing limitations.
pub type X509Chain {
    list_handle: *Unit
}

impl X509Chain {
    /// Creates a new empty certificate chain.
    pub func new() -> X509Chain {
        let h: *Unit = ffi_list_new(4)
        return X509Chain {
            list_handle: h,
        }
    }

    /// Adds a certificate to the chain.
    pub func add_cert(mut this, cert: X509Certificate) {
        ffi_list_push(this.list_handle, cert.handle as I64)
    }

    /// Adds certificates from a PEM bundle (multiple certs in one string).
    pub func add_pem_bundle(mut this, pem: Str) -> CryptoResult[I64] {
        let count: I64 = ffi_x509_count_pem_certs(pem)
        let mut added: I64 = 0
        let mut offset: I64 = 0

        loop (added < count) {
            let cert_pem: Str = ffi_x509_extract_pem_cert(pem, offset)
            if cert_pem == "" {
                break
            }
            let cert = X509Certificate::from_pem(cert_pem)!
            ffi_list_push(this.list_handle, cert.handle as I64)
            added = added + 1
            offset = offset + 1
        }

        return Ok(added)
    }

    /// Returns the number of certificates in the chain.
    pub func len(this) -> I64 {
        return ffi_list_len(this.list_handle)
    }

    /// Verifies a certificate against this chain.
    pub func verify(this, cert: ref X509Certificate) -> CryptoResult[Bool] {
        let chain_len: I64 = this.len()
        let mut i: I64 = 0
        loop (i < chain_len) {
            let ca_handle: *Unit = ffi_list_get(this.list_handle, i) as *Unit
            let issued: Bool = ffi_x509_check_issued(cert.handle, ca_handle)
            if issued {
                let pk_handle: *Unit = ffi_x509_get_public_key(ca_handle)
                let result: Bool = ffi_x509_verify(cert.handle, pk_handle)
                if result {
                    return Ok(true)
                }
            }
            i = i + 1
        }
        return Ok(false)
    }

    /// Builds and verifies a complete certificate chain.
    pub func verify_chain(this, cert: ref X509Certificate) -> CryptoResult[Bool] {
        let chain_len: I64 = this.len()
        let mut i: I64 = 0
        loop (i < chain_len) {
            let ca_handle: *Unit = ffi_list_get(this.list_handle, i) as *Unit
            let issued: Bool = ffi_x509_check_issued(cert.handle, ca_handle)
            if issued {
                let pk_handle: *Unit = ffi_x509_get_public_key(ca_handle)
                let valid: Bool = ffi_x509_verify(cert.handle, pk_handle)
                if valid {
                    let self_issued: Bool = ffi_x509_check_issued(ca_handle, ca_handle)
                    if self_issued {
                        return Ok(true)
                    }
                }
            }
            i = i + 1
        }
        return Ok(false)
    }

    /// Frees all certificates in the chain.
    pub func destroy(mut this) {
        let chain_len: I64 = this.len()
        let mut i: I64 = 0
        loop (i < chain_len) {
            let cert_handle: *Unit = ffi_list_get(this.list_handle, i) as *Unit
            ffi_x509_destroy(cert_handle)
            i = i + 1
        }
        ffi_list_destroy(this.list_handle)
    }
}

// ============================================================================
// X509Store
// ============================================================================

/// Certificate store for system trusted roots.
pub type X509Store {
    handle: *Unit
}

impl X509Store {
    /// Creates a new certificate store.
    pub func new() -> X509Store {
        let handle: *Unit = ffi_x509_store_create()
        return X509Store { handle: handle }
    }

    /// Creates a store with system default trusted certificates.
    pub func system() -> CryptoResult[X509Store] {
        let handle: *Unit = ffi_x509_store_system()
        if handle == null {
            return Err(CryptoError::new("operation failed"))
        }
        return Ok(X509Store { handle: handle })
    }

    /// Adds a trusted certificate to the store.
    pub func add_cert(mut this, cert: ref X509Certificate) -> CryptoResult[Unit] {
        let success: Bool = ffi_x509_store_add_cert(this.handle, cert.handle)
        if not success {
            return Err(CryptoError::new("operation failed"))
        }
        return Ok(())
    }

    /// Adds certificates from a PEM file.
    pub func add_pem_file(mut this, path: Str) -> CryptoResult[I64] {
        let count: I64 = ffi_x509_store_add_pem_file(this.handle, path)
        if count < 0 {
            return Err(CryptoError::new("certificate parsing failed"))
        }
        return Ok(count)
    }

    /// Verifies a certificate chain against this store.
    pub func verify(this, cert: ref X509Certificate) -> CryptoResult[Bool] {
        let result: Bool = ffi_x509_store_verify(this.handle, cert.handle)
        return Ok(result)
    }

    /// Verifies a certificate chain with intermediates.
    pub func verify_chain(this, cert: ref X509Certificate, chain: ref X509Chain) -> CryptoResult[Bool] {
        let result: Bool = ffi_x509_store_verify_chain(this.handle, cert.handle, chain.list_handle)
        return Ok(result)
    }

    /// Frees the store resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_x509_store_destroy(this.handle)
            this.handle = null
        }
    }
}
