//! Cryptographic hash functions.
//!
//! This module provides cryptographic hash functions for computing message digests.
//!
//! # Supported Algorithms
//!
//! | Algorithm | Output Size | Security | Notes |
//! |-----------|-------------|----------|-------|
//! | MD5 | 128 bits | Broken | Legacy only, do not use for security |
//! | SHA-1 | 160 bits | Weak | Deprecated, avoid for new applications |
//! | SHA-256 | 256 bits | Strong | Recommended for general use |
//! | SHA-384 | 384 bits | Strong | Higher security margin |
//! | SHA-512 | 512 bits | Strong | Best for 64-bit platforms |
//! | SHA-512/256 | 256 bits | Strong | SHA-512 truncated to 256 bits |
//!
//! # Examples
//!
//! ## One-shot Hashing
//!
//! ```tml
//! use std::crypto::{sha256, sha512}
//!
//! let hash1 = sha256("hello world")
//! let hash2 = sha512("hello world")
//!
//! print("SHA-256: {hash1.to_hex()}\n")
//! print("SHA-512: {hash2.to_hex()}\n")
//! ```
//!
//! ## Streaming Hash
//!
//! ```tml
//! use std::crypto::{Hash, HashAlgorithm}
//!
//! let hash = Hash::create(HashAlgorithm::Sha256)
//! hash.update("hello ")
//! hash.update("world")
//! let digest = hash.digest()
//!
//! print("Digest: {digest.to_hex()}\n")
//! ```

use std::crypto::error::CryptoError
use std::collections::Buffer
use core::str

// ============================================================================
// Direct OpenSSL EVP — zero-allocation one-shot hash
// ============================================================================

@extern("EVP_sha256")
func evp_sha256_md() -> *Unit

@extern("EVP_sha512")
func evp_sha512_md() -> *Unit

@extern("EVP_md5")
func evp_md5_md() -> *Unit

@extern("EVP_sha384")
func evp_sha384_md() -> *Unit

@extern("EVP_sha1")
func evp_sha1_md() -> *Unit

// int EVP_Digest(data, count, md_out, size_out, type, engine)
@extern("EVP_Digest")
func evp_digest_oneshot(data: *Unit, count: I64, md: *Unit, size: *Unit, md_type: *Unit, engine: *Unit) -> I32

/// Call EVP_Digest and package result directly into inline TmlBuffer.
/// Single allocation: 32-byte header + digest_size bytes.
/// EVP_Digest writes directly into the inline data area — zero copy.
func make_evp_digest(data: *Unit, data_len: I64, md_type: *Unit, digest_size: I64) -> *Unit {
    let total: I64 = 32 + digest_size
    let buf: *Unit = lowlevel { mem_alloc(total) }
    let bp: I64 = buf as I64
    let data_area: I64 = bp + 32
    // Hash directly into inline data area
    evp_digest_oneshot(data, data_len, data_area as *Unit, 0 as *Unit, md_type, 0 as *Unit)
    // Set TmlBuffer header fields
    lowlevel { ptr_write[I64](bp as *I64, data_area) }          // data pointer
    lowlevel { ptr_write[I64]((bp + 8) as *I64, digest_size) }  // length
    lowlevel { ptr_write[I64]((bp + 16) as *I64, digest_size) } // capacity
    lowlevel { ptr_write[I64]((bp + 24) as *I64, 0 as I64) }   // read_pos
    return buf
}

// ============================================================================
// FFI Function Declarations (for streaming and fallback)
// ============================================================================

@extern("crypto_md5")
func ffi_crypto_md5(data: Str) -> *Unit

@extern("crypto_md5_bytes")
func ffi_crypto_md5_bytes(handle: *Unit) -> *Unit

@extern("crypto_sha1")
func ffi_crypto_sha1(data: Str) -> *Unit

@extern("crypto_sha1_bytes")
func ffi_crypto_sha1_bytes(handle: *Unit) -> *Unit

@extern("crypto_sha256")
func ffi_crypto_sha256(data: Str) -> *Unit

@extern("crypto_sha256_bytes")
func ffi_crypto_sha256_bytes(handle: *Unit) -> *Unit

@extern("crypto_sha384")
func ffi_crypto_sha384(data: Str) -> *Unit

@extern("crypto_sha384_bytes")
func ffi_crypto_sha384_bytes(handle: *Unit) -> *Unit

@extern("crypto_sha512")
func ffi_crypto_sha512(data: Str) -> *Unit

@extern("crypto_sha512_bytes")
func ffi_crypto_sha512_bytes(handle: *Unit) -> *Unit

@extern("crypto_sha512_256")
func ffi_crypto_sha512_256(data: Str) -> *Unit

@extern("crypto_sha512_256_bytes")
func ffi_crypto_sha512_256_bytes(handle: *Unit) -> *Unit

@extern("crypto_bytes_to_hex")
func ffi_crypto_bytes_to_hex(handle: *Unit) -> Str

@extern("crypto_bytes_to_base64")
func ffi_crypto_bytes_to_base64(handle: *Unit) -> Str

@extern("crypto_hex_to_bytes")
func ffi_crypto_hex_to_bytes(hex: Str) -> *Unit

@extern("crypto_base64_to_bytes")
func ffi_crypto_base64_to_bytes(b64: Str) -> *Unit

@extern("crypto_hash_create")
func ffi_crypto_hash_create(algorithm: Str) -> *Unit

@extern("crypto_hash_update_str")
func ffi_crypto_hash_update_str(handle: *Unit, data: Str)

@extern("crypto_hash_update_bytes")
func ffi_crypto_hash_update_bytes(handle: *Unit, data_handle: *Unit)

@extern("crypto_hash_digest")
func ffi_crypto_hash_digest(handle: *Unit) -> *Unit

@extern("crypto_hash_copy")
func ffi_crypto_hash_copy(handle: *Unit) -> *Unit

@extern("crypto_hash_destroy")
func ffi_crypto_hash_destroy(handle: *Unit)

@extern("crypto_timing_safe_equal")
func ffi_crypto_timing_safe_equal(a: *Unit, b: *Unit) -> Bool

// ============================================================================
// Hash Algorithm Enum
// ============================================================================

/// Supported hash algorithms.
pub type HashAlgorithm {
    /// MD5 (128-bit) - LEGACY ONLY, NOT SECURE
    Md5,
    /// SHA-1 (160-bit) - DEPRECATED
    Sha1,
    /// SHA-256 (256-bit) - Recommended
    Sha256,
    /// SHA-384 (384-bit)
    Sha384,
    /// SHA-512 (512-bit)
    Sha512,
    /// SHA-512/256 (256-bit, truncated SHA-512)
    Sha512_256,
}

impl HashAlgorithm {
    /// Returns the algorithm name as used by the FFI.
    pub func name(this) -> Str {
        when this {
            HashAlgorithm::Md5 => return "md5"
            HashAlgorithm::Sha1 => return "sha1"
            HashAlgorithm::Sha256 => return "sha256"
            HashAlgorithm::Sha384 => return "sha384"
            HashAlgorithm::Sha512 => return "sha512"
            HashAlgorithm::Sha512_256 => return "sha512-256"
        }
    }

    /// Returns the output size in bytes.
    pub func digest_size(this) -> I64 {
        when this {
            HashAlgorithm::Md5 => return 16
            HashAlgorithm::Sha1 => return 20
            HashAlgorithm::Sha256 => return 32
            HashAlgorithm::Sha384 => return 48
            HashAlgorithm::Sha512 => return 64
            HashAlgorithm::Sha512_256 => return 32
        }
    }

    /// Returns the block size in bytes.
    pub func block_size(this) -> I64 {
        when this {
            HashAlgorithm::Md5 => return 64
            HashAlgorithm::Sha1 => return 64
            HashAlgorithm::Sha256 => return 64
            HashAlgorithm::Sha384 => return 128
            HashAlgorithm::Sha512 => return 128
            HashAlgorithm::Sha512_256 => return 128
        }
    }
}

// ============================================================================
// Digest Type
// ============================================================================

/// A cryptographic hash digest (the output of a hash function).
pub type Digest {
    data: Buffer
}

impl Digest {
    /// Returns the digest as a hexadecimal string.
    @allocates
    pub func to_hex(this) -> Str {
        // Inline hex encoding — avoids FFI overhead of ffi_crypto_bytes_to_hex
        let h: I64 = this.data.handle as I64
        let data_ptr: I64 = lowlevel { ptr_read[I64](h as *I64) }
        let data_len: I64 = lowlevel { ptr_read[I64]((h + 8) as *I64) }
        let out_len: I64 = data_len * 2
        let hex_table: Str = "0123456789abcdef"
        let ht: I64 = hex_table as I64
        let out: *Unit = lowlevel { mem_alloc(out_len + 1) }
        var sp: I64 = data_ptr
        var dp: I64 = out as I64
        let end: I64 = sp + data_len
        loop (sp < end) {
            let b: I32 = lowlevel { ptr_read[U8](sp as *U8) } as I32
            lowlevel { ptr_write[U8](dp as *U8, ptr_read[U8]((ht + ((b >> 4) & 15) as I64) as *U8)) }
            lowlevel { ptr_write[U8]((dp + 1) as *U8, ptr_read[U8]((ht + (b & 15) as I64) as *U8)) }
            sp = sp + 1
            dp = dp + 2
        }
        lowlevel { ptr_write[U8](dp as *U8, 0 as U8) }
        return out as Str
    }

    /// Returns the digest as a base64 string.
    @allocates
    pub func to_base64(this) -> Str {
        return ffi_crypto_bytes_to_base64(this.data.handle)
    }

    /// Returns the raw bytes of the digest.
    pub func bytes(this) -> ref Buffer {
        return ref this.data
    }


    /// Frees the digest resources.
    pub func destroy(mut this) {
        this.data.destroy()
    }
}

// ============================================================================
// Streaming Hash Type
// ============================================================================

/// Streaming hash computation object.
///
/// Use this for computing hashes of large data or data that arrives in chunks.
pub type Hash {
    handle: *Unit
    finalized: Bool
}

impl Hash {
    /// Creates a new Hash object for the specified algorithm.
    pub func create(algorithm: HashAlgorithm) -> Hash {
        let algo_name: Str = algorithm.name()
        let handle: *Unit = ffi_crypto_hash_create(algo_name)
        return Hash {
            handle: handle,
            finalized: false,
        }
    }

    /// Updates the hash with string data.
    pub func update(mut this, data: Str) {
        if not this.finalized {
            ffi_crypto_hash_update_str(this.handle, data)
        }
    }

    /// Updates the hash with binary data.
    pub func update_bytes(mut this, data: ref Buffer) {
        if not this.finalized {
            ffi_crypto_hash_update_bytes(this.handle, data.handle)
        }
    }

    /// Finalizes the hash and returns the digest.
    ///
    /// After calling this method, the hash object cannot be used for further updates.
    pub func digest(mut this) -> Digest {
        this.finalized = true
        let result_handle: *Unit = ffi_crypto_hash_digest(this.handle)
        let buffer: Buffer = Buffer { handle: result_handle }
        return Digest { data: buffer }
    }

    /// Creates a copy of this hash object for parallel computation.
    pub func copy(this) -> Hash {
        let new_handle: *Unit = ffi_crypto_hash_copy(this.handle)
        return Hash {
            handle: new_handle,
            finalized: this.finalized,
        }
    }

    /// Frees the hash context resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_crypto_hash_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// One-shot hash functions
// ============================================================================

/// Computes the MD5 hash of the input string.
///
/// **Warning**: MD5 is cryptographically broken. Use only for legacy compatibility.
pub func md5(data: Str) -> Digest {
    let data_len: I64 = str::len(data)
    let handle: *Unit = make_evp_digest(data as *Unit, data_len, evp_md5_md(), 16)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the MD5 hash of the input bytes.
pub func md5_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_md5_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-1 hash of the input string.
///
/// **Warning**: SHA-1 is deprecated for security use. Prefer SHA-256 or better.
pub func sha1(data: Str) -> Digest {
    let data_len: I64 = str::len(data)
    let handle: *Unit = make_evp_digest(data as *Unit, data_len, evp_sha1_md(), 20)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-1 hash of the input bytes.
pub func sha1_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_sha1_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-256 hash of the input string.
///
/// This is the recommended hash function for most applications.
pub func sha256(data: Str) -> Digest {
    let data_len: I64 = str::len(data)
    let handle: *Unit = make_evp_digest(data as *Unit, data_len, evp_sha256_md(), 32)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-256 hash of the input bytes.
pub func sha256_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_sha256_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-384 hash of the input string.
pub func sha384(data: Str) -> Digest {
    let data_len: I64 = str::len(data)
    let handle: *Unit = make_evp_digest(data as *Unit, data_len, evp_sha384_md(), 48)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-384 hash of the input bytes.
pub func sha384_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_sha384_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-512 hash of the input string.
pub func sha512(data: Str) -> Digest {
    let data_len: I64 = str::len(data)
    let handle: *Unit = make_evp_digest(data as *Unit, data_len, evp_sha512_md(), 64)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-512 hash of the input bytes.
pub func sha512_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_sha512_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-512/256 hash of the input string.
pub func sha512_256(data: Str) -> Digest {
    let handle: *Unit = ffi_crypto_sha512_256(data)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

/// Computes the SHA-512/256 hash of the input bytes.
pub func sha512_256_bytes(data: ref Buffer) -> Digest {
    let handle: *Unit = ffi_crypto_sha512_256_bytes(data.handle)
    let buffer: Buffer = Buffer { handle: handle }
    return Digest { data: buffer }
}

impl Drop for Digest {
    func drop(mut this) {
        this.destroy()
    }
}

impl Drop for Hash {
    func drop(mut this) {
        this.destroy()
    }
}
