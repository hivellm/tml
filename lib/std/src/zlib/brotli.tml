//! Brotli compression and decompression.
//!
//! Brotli is a modern compression algorithm developed by Google,
//! designed for HTTP compression. It typically achieves better
//! compression ratios than gzip/deflate.
//!
//! # Examples
//!
//! ## Compress and decompress data
//!
//! ```tml
//! use std::zlib::{brotli_compress, brotli_decompress}
//!
//! let original = "Hello, World! This is some test data to compress."
//! let compressed = brotli_compress(original)?
//! let decompressed = brotli_decompress(compressed)?
//! assert_eq(decompressed, original)
//! ```
//!
//! ## With custom options
//!
//! ```tml
//! use std::zlib::{brotli_compress_with_options, BrotliOptions}
//!
//! // Best compression
//! let opts = BrotliOptions::best()
//! let compressed = brotli_compress_with_options(data, opts)?
//!
//! // Fast compression for text
//! let opts = BrotliOptions::text().with_quality(4)
//! let compressed = brotli_compress_with_options(text_data, opts)?
//! ```

use std::collections::{Buffer}
use std::zlib::error::{ZlibError, ZlibErrorKind}
use std::zlib::options::{BrotliOptions}
use std::zlib::constants::{
    BROTLI_OPERATION_PROCESS,
    BROTLI_OPERATION_FLUSH,
    BROTLI_OPERATION_FINISH
}

// ============================================================================
// FFI Function Declarations
// ============================================================================

@extern("brotli_compress")
func ffi_brotli_compress(data: Str, quality: I32, mode: I32, lgwin: I32, lgblock: I32, size_hint: I64) -> *Unit

@extern("brotli_compress_buffer")
func ffi_brotli_compress_buffer(handle: *Unit, quality: I32, mode: I32, lgwin: I32, lgblock: I32, size_hint: I64) -> *Unit

@extern("brotli_decompress")
func ffi_brotli_decompress(handle: *Unit, large_window: Bool) -> Str

@extern("brotli_decompress_buffer")
func ffi_brotli_decompress_buffer(handle: *Unit, large_window: Bool) -> *Unit

@extern("brotli_get_error_code")
func ffi_brotli_get_error_code(handle: *Unit) -> I32

@extern("brotli_last_error_code")
func ffi_brotli_last_error_code() -> I32

@extern("buffer_destroy")
func ffi_buffer_destroy(handle: *Unit)

// Encoder FFI
@extern("brotli_encoder_create")
func ffi_brotli_encoder_create(quality: I32, mode: I32, lgwin: I32, lgblock: I32) -> *Unit

@extern("brotli_encoder_process")
func ffi_brotli_encoder_process(handle: *Unit, data: Str, op: I32) -> *Unit

@extern("brotli_encoder_process_buffer")
func ffi_brotli_encoder_process_buffer(handle: *Unit, data_handle: *Unit, op: I32) -> *Unit

@extern("brotli_encoder_is_finished")
func ffi_brotli_encoder_is_finished(handle: *Unit) -> Bool

@extern("brotli_encoder_has_more_output")
func ffi_brotli_encoder_has_more_output(handle: *Unit) -> Bool

@extern("brotli_encoder_destroy")
func ffi_brotli_encoder_destroy(handle: *Unit)

// Decoder FFI
@extern("brotli_decoder_create")
func ffi_brotli_decoder_create(large_window: Bool) -> *Unit

@extern("brotli_decoder_process")
func ffi_brotli_decoder_process(handle: *Unit, data_handle: *Unit) -> *Unit

@extern("brotli_decoder_is_finished")
func ffi_brotli_decoder_is_finished(handle: *Unit) -> Bool

@extern("brotli_decoder_needs_more_input")
func ffi_brotli_decoder_needs_more_input(handle: *Unit) -> Bool

@extern("brotli_decoder_has_more_output")
func ffi_brotli_decoder_has_more_output(handle: *Unit) -> Bool

@extern("brotli_decoder_get_error_code")
func ffi_brotli_decoder_get_error_code(handle: *Unit) -> I32

@extern("brotli_decoder_destroy")
func ffi_brotli_decoder_destroy(handle: *Unit)

// ============================================================================
// Brotli Compression
// ============================================================================

/// Compresses data using Brotli with default options.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
///
/// # Returns
///
/// Compressed data as a Buffer.
///
/// # Example
///
/// ```tml
/// let compressed = brotli_compress("Hello, World!")?
/// ```
pub func brotli_compress(data: Str) -> Outcome[Buffer, ZlibError] {
    return brotli_compress_with_options(data, BrotliOptions::default())
}

/// Compresses data using Brotli with custom options.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
/// * `options` - Brotli compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func brotli_compress_with_options(data: Str, options: BrotliOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_brotli_compress(
        data,
        options.quality,
        options.mode,
        options.lgwin,
        options.lgblock,
        options.size_hint
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_brotli_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Compresses buffer data using Brotli with default options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func brotli_compress_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return brotli_compress_buffer_with_options(data, BrotliOptions::default())
}

/// Compresses buffer data using Brotli with custom options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
/// * `options` - Brotli compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func brotli_compress_buffer_with_options(data: ref Buffer, options: BrotliOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_brotli_compress_buffer(
        data.handle,
        options.quality,
        options.mode,
        options.lgwin,
        options.lgblock,
        options.size_hint
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_brotli_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously compresses data using Brotli.
/// Alias for `brotli_compress()`.
pub func brotli_compress_sync(data: Str) -> Outcome[Buffer, ZlibError] {
    return brotli_compress(data)
}

/// Synchronously compresses data using Brotli with options.
/// Alias for `brotli_compress_with_options()`.
pub func brotli_compress_sync_with_options(data: Str, options: BrotliOptions) -> Outcome[Buffer, ZlibError] {
    return brotli_compress_with_options(data, options)
}

// ============================================================================
// Brotli Decompression
// ============================================================================

/// Decompresses Brotli data with default options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a string.
///
/// # Example
///
/// ```tml
/// let decompressed = brotli_decompress(compressed)?
/// ```
pub func brotli_decompress(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return brotli_decompress_with_options(data, BrotliOptions::default())
}

/// Decompresses Brotli data with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Brotli decompression options
///
/// # Returns
///
/// Decompressed data as a string.
pub func brotli_decompress_with_options(data: ref Buffer, options: BrotliOptions) -> Outcome[Str, ZlibError] {
    let result: Str = ffi_brotli_decompress(data.handle, options.large_window)
    let code: I32 = ffi_brotli_last_error_code()
    if code != 0 {
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(result)
}

/// Decompresses Brotli data to a buffer.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func brotli_decompress_to_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return brotli_decompress_to_buffer_with_options(data, BrotliOptions::default())
}

/// Decompresses Brotli data to a buffer with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Brotli decompression options
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func brotli_decompress_to_buffer_with_options(data: ref Buffer, options: BrotliOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_brotli_decompress_buffer(data.handle, options.large_window)
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_brotli_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously decompresses Brotli data.
pub func brotli_decompress_sync(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return brotli_decompress(data)
}

/// Synchronously decompresses Brotli data with options.
pub func brotli_decompress_sync_with_options(data: ref Buffer, options: BrotliOptions) -> Outcome[Str, ZlibError] {
    return brotli_decompress_with_options(data, options)
}

// ============================================================================
// Brotli Streaming Compression
// ============================================================================

/// Brotli streaming compressor.
pub type BrotliCompress {
    handle: *Unit
    options: BrotliOptions
}

impl BrotliCompress {
    /// Creates a new Brotli compressor with default options.
    pub func new() -> Outcome[BrotliCompress, ZlibError] {
        return BrotliCompress::with_options(BrotliOptions::default())
    }

    /// Creates a new Brotli compressor with custom options.
    pub func with_options(options: BrotliOptions) -> Outcome[BrotliCompress, ZlibError] {
        let handle: *Unit = ffi_brotli_encoder_create(
            options.quality,
            options.mode,
            options.lgwin,
            options.lgblock
        )
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(BrotliCompress { handle: handle, options: options })
    }

    /// Writes data to be compressed.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to compress
    ///
    /// # Returns
    ///
    /// Compressed chunk (may be empty if more input is needed).
    pub func write(this, data: Str) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_brotli_encoder_process(this.handle, data, BROTLI_OPERATION_PROCESS)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Writes buffer data to be compressed.
    pub func write_buffer(this, data: ref Buffer) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_brotli_encoder_process_buffer(this.handle, data.handle, BROTLI_OPERATION_PROCESS)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Flushes pending compressed data.
    pub func flush(this) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_brotli_encoder_process(this.handle, "", BROTLI_OPERATION_FLUSH)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Finishes compression and returns remaining data.
    pub func finish(this) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_brotli_encoder_process(this.handle, "", BROTLI_OPERATION_FINISH)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Returns true if the compressor is finished.
    pub func is_finished(this) -> Bool {
        let finished: Bool = ffi_brotli_encoder_is_finished(this.handle)
        return finished
    }

    /// Returns true if more output is available.
    pub func has_more_output(this) -> Bool {
        let has: Bool = ffi_brotli_encoder_has_more_output(this.handle)
        return has
    }

    /// Frees the compressor resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_brotli_encoder_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// Brotli Streaming Decompression
// ============================================================================

/// Brotli streaming decompressor.
pub type BrotliDecompress {
    handle: *Unit
    options: BrotliOptions
}

impl BrotliDecompress {
    /// Creates a new Brotli decompressor with default options.
    pub func new() -> Outcome[BrotliDecompress, ZlibError] {
        return BrotliDecompress::with_options(BrotliOptions::default())
    }

    /// Creates a new Brotli decompressor with custom options.
    pub func with_options(options: BrotliOptions) -> Outcome[BrotliDecompress, ZlibError] {
        let handle: *Unit = ffi_brotli_decoder_create(options.large_window)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(BrotliDecompress { handle: handle, options: options })
    }

    /// Writes compressed data to decompress.
    ///
    /// # Arguments
    ///
    /// * `data` - The compressed data
    ///
    /// # Returns
    ///
    /// Decompressed chunk.
    pub func write(this, data: ref Buffer) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_brotli_decoder_process(this.handle, data.handle)
        if handle == null {
            let code: I32 = ffi_brotli_decoder_get_error_code(this.handle)
            return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Returns true if the decompressor is finished.
    pub func is_finished(this) -> Bool {
        let finished: Bool = ffi_brotli_decoder_is_finished(this.handle)
        return finished
    }

    /// Returns true if more input is needed.
    pub func needs_more_input(this) -> Bool {
        let needs: Bool = ffi_brotli_decoder_needs_more_input(this.handle)
        return needs
    }

    /// Returns true if more output is available.
    pub func has_more_output(this) -> Bool {
        let has: Bool = ffi_brotli_decoder_has_more_output(this.handle)
        return has
    }

    /// Gets the error code if decompression failed.
    pub func error_code(this) -> I32 {
        let code: I32 = ffi_brotli_decoder_get_error_code(this.handle)
        return code
    }

    /// Frees the decompressor resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_brotli_decoder_destroy(this.handle)
            this.handle = null
        }
    }
}

impl Drop for BrotliCompress {
    func drop(mut this) {
        this.destroy()
    }
}

impl Drop for BrotliDecompress {
    func drop(mut this) {
        this.destroy()
    }
}
