//! Gzip compression and decompression.
//!
//! This module provides gzip compression (RFC 1952) functions.
//! Gzip is the most common format for HTTP compression.
//!
//! # Examples
//!
//! ## Compress and decompress data
//!
//! ```tml
//! use std::zlib::{gzip, gunzip}
//!
//! let original = "Hello, World! This is some test data to compress."
//! let compressed = gzip(original)?
//! let decompressed = gunzip(compressed)?
//! assert_eq(decompressed, original)
//! ```
//!
//! ## With custom options
//!
//! ```tml
//! use std::zlib::{gzip_with_options, ZlibOptions, Z_BEST_COMPRESSION}
//!
//! let opts = ZlibOptions::gzip().with_level(Z_BEST_COMPRESSION)
//! let compressed = gzip_with_options(data, opts)?
//! ```

use std::collections::Buffer
use std::zlib::error::{ZlibError, ZlibErrorKind}
use std::zlib::options::ZlibOptions
use std::zlib::constants::*

// ============================================================================
// FFI Function Declarations
// ============================================================================

@extern("zlib_deflate")
func ffi_zlib_deflate(data: Str, level: I32, window_bits: I32, mem_level: I32, strategy: I32) -> *Unit

@extern("zlib_deflate_buffer")
func ffi_zlib_deflate_buffer(handle: *Unit, level: I32, window_bits: I32, mem_level: I32, strategy: I32) -> *Unit

@extern("zlib_inflate")
func ffi_zlib_inflate(handle: *Unit, window_bits: I32) -> Str

@extern("zlib_inflate_buffer")
func ffi_zlib_inflate_buffer(handle: *Unit, window_bits: I32) -> *Unit

@extern("zlib_get_error_code")
func ffi_zlib_get_error_code(handle: *Unit) -> I32

@extern("zlib_last_error_code")
func ffi_zlib_last_error_code() -> I32

@extern("buffer_destroy")
func ffi_buffer_destroy(handle: *Unit)

@extern("zlib_gzip_header_text")
func ffi_zlib_gzip_header_text(handle: *Unit) -> Bool

@extern("zlib_gzip_header_os")
func ffi_zlib_gzip_header_os(handle: *Unit) -> I32

@extern("zlib_gzip_header_name")
func ffi_zlib_gzip_header_name(handle: *Unit) -> Str

@extern("zlib_gzip_header_comment")
func ffi_zlib_gzip_header_comment(handle: *Unit) -> Str

@extern("zlib_gzip_header_hcrc")
func ffi_zlib_gzip_header_hcrc(handle: *Unit) -> Bool

@extern("zlib_gzip_header_time")
func ffi_zlib_gzip_header_time(handle: *Unit) -> I64

// ============================================================================
// Gzip Compression
// ============================================================================

/// Compresses data using gzip with default options.
///
/// Uses gzip format (RFC 1952) which includes a header with metadata
/// and CRC32 checksum.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
///
/// # Returns
///
/// Compressed data as a Buffer.
///
/// # Example
///
/// ```tml
/// let compressed = gzip("Hello, World!")?
/// ```
pub func gzip(data: Str) -> Outcome[Buffer, ZlibError] {
    return gzip_with_options(data, ZlibOptions::gzip())
}

/// Compresses data using gzip with custom options.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
/// * `options` - Compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func gzip_with_options(data: Str, options: ZlibOptions) -> Outcome[Buffer, ZlibError] {
    // Ensure gzip format window bits
    var opts: ZlibOptions = options
    if opts.window_bits > 0 and opts.window_bits <= Z_MAX_WINDOWBITS {
        opts.window_bits = opts.window_bits + GZIP_WINDOW_OFFSET
    }

    let handle: *Unit = ffi_zlib_deflate(
        data,
        opts.level,
        opts.window_bits,
        opts.mem_level,
        opts.strategy
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zlib_get_error_code(handle)
    if code != Z_OK and code != Z_STREAM_END {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::from_code(code))
    }
    return Ok(Buffer { handle: handle })
}

/// Compresses buffer data using gzip with default options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func gzip_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return gzip_buffer_with_options(data, ZlibOptions::gzip())
}

/// Compresses buffer data using gzip with custom options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
/// * `options` - Compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func gzip_buffer_with_options(data: ref Buffer, options: ZlibOptions) -> Outcome[Buffer, ZlibError] {
    var opts: ZlibOptions = options
    if opts.window_bits > 0 and opts.window_bits <= Z_MAX_WINDOWBITS {
        opts.window_bits = opts.window_bits + GZIP_WINDOW_OFFSET
    }

    let handle: *Unit = ffi_zlib_deflate_buffer(
        data.handle,
        opts.level,
        opts.window_bits,
        opts.mem_level,
        opts.strategy
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zlib_get_error_code(handle)
    if code != Z_OK and code != Z_STREAM_END {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::from_code(code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously compresses data using gzip.
/// Alias for `gzip()`.
pub func gzip_sync(data: Str) -> Outcome[Buffer, ZlibError] {
    return gzip(data)
}

/// Synchronously compresses data using gzip with options.
/// Alias for `gzip_with_options()`.
pub func gzip_sync_with_options(data: Str, options: ZlibOptions) -> Outcome[Buffer, ZlibError] {
    return gzip_with_options(data, options)
}

// ============================================================================
// Gunzip Decompression
// ============================================================================

/// Decompresses gzip data with default options.
///
/// Expects gzip format (RFC 1952) with header and CRC32 checksum.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a string.
///
/// # Example
///
/// ```tml
/// let decompressed = gunzip(compressed)?
/// ```
pub func gunzip(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return gunzip_with_options(data, ZlibOptions::gzip())
}

/// Decompresses gzip data with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Decompression options
///
/// # Returns
///
/// Decompressed data as a string.
pub func gunzip_with_options(data: ref Buffer, options: ZlibOptions) -> Outcome[Str, ZlibError] {
    // Ensure gzip format window bits
    var opts: ZlibOptions = options
    if opts.window_bits > 0 and opts.window_bits <= Z_MAX_WINDOWBITS {
        opts.window_bits = opts.window_bits + GZIP_WINDOW_OFFSET
    }

    let result: Str = ffi_zlib_inflate(data.handle, opts.window_bits)
    let code: I32 = ffi_zlib_last_error_code()
    if code != Z_OK and code != Z_STREAM_END {
        return Err(ZlibError::from_code(code))
    }
    return Ok(result)
}

/// Decompresses gzip data to a buffer.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func gunzip_to_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return gunzip_to_buffer_with_options(data, ZlibOptions::gzip())
}

/// Decompresses gzip data to a buffer with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Decompression options
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func gunzip_to_buffer_with_options(data: ref Buffer, options: ZlibOptions) -> Outcome[Buffer, ZlibError] {
    var opts: ZlibOptions = options
    if opts.window_bits > 0 and opts.window_bits <= Z_MAX_WINDOWBITS {
        opts.window_bits = opts.window_bits + GZIP_WINDOW_OFFSET
    }

    let handle: *Unit = ffi_zlib_inflate_buffer(data.handle, opts.window_bits)
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zlib_get_error_code(handle)
    if code != Z_OK and code != Z_STREAM_END {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::from_code(code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously decompresses gzip data.
pub func gunzip_sync(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return gunzip(data)
}

/// Synchronously decompresses gzip data with options.
pub func gunzip_sync_with_options(data: ref Buffer, options: ZlibOptions) -> Outcome[Str, ZlibError] {
    return gunzip_with_options(data, options)
}

// ============================================================================
// Gzip Header Information
// ============================================================================

/// Gzip header information.
pub type GzipHeader {
    /// True if text mode was set.
    pub text: Bool
    /// Operating system code.
    pub os: I32
    /// Extra field data (if any).
    pub extra: Maybe[Buffer]
    /// Original filename (if any).
    pub name: Maybe[Str]
    /// Comment (if any).
    pub comment: Maybe[Str]
    /// Header CRC present.
    pub hcrc: Bool
    /// Modification time (Unix timestamp).
    pub time: I64
}

impl GzipHeader {
    /// Creates an empty gzip header.
    pub func new() -> GzipHeader {
        return GzipHeader {
            text: false,
            os: 255,  // Unknown OS
            extra: Nothing,
            name: Nothing,
            comment: Nothing,
            hcrc: false,
            time: 0,
        }
    }

    /// Sets the filename in the header (returns new header).
    pub func with_name(this, new_name: Str) -> GzipHeader {
        return GzipHeader {
            text: this.text,
            os: this.os,
            extra: this.extra,
            name: Just(new_name),
            comment: this.comment,
            hcrc: this.hcrc,
            time: this.time,
        }
    }

    /// Sets the comment in the header (returns new header).
    pub func with_comment(this, new_comment: Str) -> GzipHeader {
        return GzipHeader {
            text: this.text,
            os: this.os,
            extra: this.extra,
            name: this.name,
            comment: Just(new_comment),
            hcrc: this.hcrc,
            time: this.time,
        }
    }

    /// Sets the modification time (returns new header).
    pub func with_time(this, new_time: I64) -> GzipHeader {
        return GzipHeader {
            text: this.text,
            os: this.os,
            extra: this.extra,
            name: this.name,
            comment: this.comment,
            hcrc: this.hcrc,
            time: new_time,
        }
    }

    /// Sets text mode flag (returns new header).
    pub func with_text(this) -> GzipHeader {
        return GzipHeader {
            text: true,
            os: this.os,
            extra: this.extra,
            name: this.name,
            comment: this.comment,
            hcrc: this.hcrc,
            time: this.time,
        }
    }
}

/// Reads the gzip header from compressed data.
///
/// # Arguments
///
/// * `data` - The gzip compressed buffer
///
/// # Returns
///
/// The gzip header information.
///
/// # Example
///
/// ```tml
/// let header = read_gzip_header(compressed)?
/// if let Just(name) = header.name {
///     print("Original filename: {name}\n")
/// }
/// ```
pub func read_gzip_header(data: ref Buffer) -> Outcome[GzipHeader, ZlibError] {
    // Parse gzip header - FFI functions check size internally
    let text: Bool = ffi_zlib_gzip_header_text(data.handle)
    let os: I32 = ffi_zlib_gzip_header_os(data.handle)
    let name: Str = ffi_zlib_gzip_header_name(data.handle)
    let comment: Str = ffi_zlib_gzip_header_comment(data.handle)
    let hcrc: Bool = ffi_zlib_gzip_header_hcrc(data.handle)
    let time: I64 = ffi_zlib_gzip_header_time(data.handle)

    return Ok(GzipHeader {
        text: text,
        os: os,
        extra: Nothing,
        name: if name != "" { Just(name) } else { Nothing },
        comment: if comment != "" { Just(comment) } else { Nothing },
        hcrc: hcrc,
        time: time,
    })
}
