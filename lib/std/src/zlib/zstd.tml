//! Zstandard (Zstd) compression and decompression.
//!
//! Zstd is a fast lossless compression algorithm developed by Facebook.
//! It provides excellent compression ratios with very high decompression speeds.
//!
//! **Note**: Zstd support is experimental as of Node.js v22.
//!
//! # Examples
//!
//! ## Compress and decompress data
//!
//! ```tml
//! use std::zlib::{zstd_compress, zstd_decompress}
//!
//! let original = "Hello, World! This is some test data to compress."
//! let compressed = zstd_compress(original)?
//! let decompressed = zstd_decompress(compressed)?
//! assert_eq(decompressed, original)
//! ```
//!
//! ## With custom options
//!
//! ```tml
//! use std::zlib::{zstd_compress_with_options, ZstdOptions}
//!
//! // Best compression
//! let opts = ZstdOptions::best()
//! let compressed = zstd_compress_with_options(data, opts)?
//!
//! // Multi-threaded compression
//! let opts = ZstdOptions::parallel(4).with_level(10)
//! let compressed = zstd_compress_with_options(data, opts)?
//! ```

use std::collections::{Buffer}
use std::zlib::error::{ZlibError, ZlibErrorKind}
use std::zlib::options::{ZstdOptions}
use std::zlib::constants::*

// ============================================================================
// FFI Function Declarations
// ============================================================================

@extern("zstd_compress")
func ffi_zstd_compress(data: Str, level: I32, strategy: I32, window_log: I32, checksum: Bool, content_size: Bool) -> *Unit

@extern("zstd_compress_buffer")
func ffi_zstd_compress_buffer(handle: *Unit, level: I32, strategy: I32, window_log: I32, checksum: Bool, content_size: Bool) -> *Unit

@extern("zstd_decompress")
func ffi_zstd_decompress(handle: *Unit, window_log: I32) -> Str

@extern("zstd_decompress_buffer")
func ffi_zstd_decompress_buffer(handle: *Unit, window_log: I32) -> *Unit

@extern("zstd_get_error_code")
func ffi_zstd_get_error_code(handle: *Unit) -> I32

@extern("zstd_last_error_code")
func ffi_zstd_last_error_code() -> I32

@extern("buffer_destroy")
func ffi_buffer_destroy(handle: *Unit)

// Streaming compressor FFI
@extern("zstd_cstream_create")
func ffi_zstd_cstream_create(level: I32, strategy: I32, window_log: I32, checksum: Bool, content_size: Bool, nb_workers: I32) -> *Unit

@extern("zstd_cstream_create_with_dict")
func ffi_zstd_cstream_create_with_dict(dict_handle: *Unit, level: I32) -> *Unit

@extern("zstd_cstream_process")
func ffi_zstd_cstream_process(handle: *Unit, data: Str, end_op: I32) -> *Unit

@extern("zstd_cstream_process_buffer")
func ffi_zstd_cstream_process_buffer(handle: *Unit, data_handle: *Unit, end_op: I32) -> *Unit

@extern("zstd_cstream_reset")
func ffi_zstd_cstream_reset(handle: *Unit) -> Bool

@extern("zstd_cstream_set_pledged_size")
func ffi_zstd_cstream_set_pledged_size(handle: *Unit, size: I64) -> Bool

@extern("zstd_cstream_destroy")
func ffi_zstd_cstream_destroy(handle: *Unit)

// Streaming decompressor FFI
@extern("zstd_dstream_create")
func ffi_zstd_dstream_create(window_log: I32) -> *Unit

@extern("zstd_dstream_create_with_dict")
func ffi_zstd_dstream_create_with_dict(dict_handle: *Unit) -> *Unit

@extern("zstd_dstream_process")
func ffi_zstd_dstream_process(handle: *Unit, data_handle: *Unit) -> *Unit

@extern("zstd_dstream_reset")
func ffi_zstd_dstream_reset(handle: *Unit) -> Bool

@extern("zstd_dstream_content_size")
func ffi_zstd_dstream_content_size(handle: *Unit) -> I64

@extern("zstd_dstream_get_error_code")
func ffi_zstd_dstream_get_error_code(handle: *Unit) -> I32

@extern("zstd_dstream_destroy")
func ffi_zstd_dstream_destroy(handle: *Unit)

// Dictionary FFI
@extern("zstd_dict_create")
func ffi_zstd_dict_create(data_handle: *Unit) -> *Unit

@extern("zstd_dict_train")
func ffi_zstd_dict_train(samples_handle: *Unit, dict_size: I64) -> *Unit

@extern("zstd_dict_get_id")
func ffi_zstd_dict_get_id(handle: *Unit) -> I32

@extern("zstd_dict_to_buffer")
func ffi_zstd_dict_to_buffer(handle: *Unit) -> *Unit

@extern("zstd_dict_destroy")
func ffi_zstd_dict_destroy(handle: *Unit)

// Utility FFI
@extern("zstd_get_frame_content_size")
func ffi_zstd_get_frame_content_size(handle: *Unit) -> I64

@extern("zstd_get_decompress_bound")
func ffi_zstd_get_decompress_bound(handle: *Unit) -> I64

@extern("zstd_get_frame_dict_id")
func ffi_zstd_get_frame_dict_id(handle: *Unit) -> I32

@extern("zstd_is_frame")
func ffi_zstd_is_frame(handle: *Unit) -> Bool

// ============================================================================
// Zstd Compression
// ============================================================================

/// Compresses data using Zstd with default options.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
///
/// # Returns
///
/// Compressed data as a Buffer.
///
/// # Example
///
/// ```tml
/// let compressed = zstd_compress("Hello, World!")?
/// ```
pub func zstd_compress(data: Str) -> Outcome[Buffer, ZlibError] {
    return zstd_compress_with_options(data, ZstdOptions::default())
}

/// Compresses data using Zstd with custom options.
///
/// # Arguments
///
/// * `data` - The data to compress (string)
/// * `options` - Zstd compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func zstd_compress_with_options(data: Str, options: ZstdOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_zstd_compress(
        data,
        options.level,
        options.strategy,
        options.window_log,
        options.checksum,
        options.content_size
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zstd_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Compresses buffer data using Zstd with default options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func zstd_compress_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return zstd_compress_buffer_with_options(data, ZstdOptions::default())
}

/// Compresses buffer data using Zstd with custom options.
///
/// # Arguments
///
/// * `data` - The buffer to compress
/// * `options` - Zstd compression options
///
/// # Returns
///
/// Compressed data as a Buffer.
pub func zstd_compress_buffer_with_options(data: ref Buffer, options: ZstdOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_zstd_compress_buffer(
        data.handle,
        options.level,
        options.strategy,
        options.window_log,
        options.checksum,
        options.content_size
    )
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zstd_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously compresses data using Zstd.
/// Alias for `zstd_compress()`.
pub func zstd_compress_sync(data: Str) -> Outcome[Buffer, ZlibError] {
    return zstd_compress(data)
}

/// Synchronously compresses data using Zstd with options.
/// Alias for `zstd_compress_with_options()`.
pub func zstd_compress_sync_with_options(data: Str, options: ZstdOptions) -> Outcome[Buffer, ZlibError] {
    return zstd_compress_with_options(data, options)
}

// ============================================================================
// Zstd Decompression
// ============================================================================

/// Decompresses Zstd data with default options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a string.
///
/// # Example
///
/// ```tml
/// let decompressed = zstd_decompress(compressed)?
/// ```
pub func zstd_decompress(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return zstd_decompress_with_options(data, ZstdOptions::default())
}

/// Decompresses Zstd data with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Zstd decompression options
///
/// # Returns
///
/// Decompressed data as a string.
pub func zstd_decompress_with_options(data: ref Buffer, options: ZstdOptions) -> Outcome[Str, ZlibError] {
    let result: Str = ffi_zstd_decompress(data.handle, options.window_log)
    let code: I32 = ffi_zstd_last_error_code()
    if code != 0 {
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(result)
}

/// Decompresses Zstd data to a buffer.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func zstd_decompress_to_buffer(data: ref Buffer) -> Outcome[Buffer, ZlibError] {
    return zstd_decompress_to_buffer_with_options(data, ZstdOptions::default())
}

/// Decompresses Zstd data to a buffer with custom options.
///
/// # Arguments
///
/// * `data` - The compressed buffer
/// * `options` - Zstd decompression options
///
/// # Returns
///
/// Decompressed data as a Buffer.
pub func zstd_decompress_to_buffer_with_options(data: ref Buffer, options: ZstdOptions) -> Outcome[Buffer, ZlibError] {
    let handle: *Unit = ffi_zstd_decompress_buffer(data.handle, options.window_log)
    if handle == null {
        return Err(ZlibError::new(ZlibErrorKind::MemoryError))
    }
    let code: I32 = ffi_zstd_get_error_code(handle)
    if code != 0 {
        ffi_buffer_destroy(handle)
        return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
    }
    return Ok(Buffer { handle: handle })
}

/// Synchronously decompresses Zstd data.
pub func zstd_decompress_sync(data: ref Buffer) -> Outcome[Str, ZlibError] {
    return zstd_decompress(data)
}

/// Synchronously decompresses Zstd data with options.
pub func zstd_decompress_sync_with_options(data: ref Buffer, options: ZstdOptions) -> Outcome[Str, ZlibError] {
    return zstd_decompress_with_options(data, options)
}

// ============================================================================
// Zstd Streaming Compression
// ============================================================================

/// Zstd streaming compressor.
pub type ZstdCompress {
    handle: *Unit
    options: ZstdOptions
}

impl ZstdCompress {
    /// Creates a new Zstd compressor with default options.
    pub func new() -> Outcome[ZstdCompress, ZlibError] {
        return ZstdCompress::with_options(ZstdOptions::default())
    }

    /// Creates a new Zstd compressor with custom options.
    pub func with_options(options: ZstdOptions) -> Outcome[ZstdCompress, ZlibError] {
        let handle: *Unit = ffi_zstd_cstream_create(
            options.level,
            options.strategy,
            options.window_log,
            options.checksum,
            options.content_size,
            options.nb_workers
        )
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdCompress { handle: handle, options: options })
    }

    /// Creates a new Zstd compressor with a dictionary.
    pub func with_dictionary(dict: ref Buffer, level: I32) -> Outcome[ZstdCompress, ZlibError] {
        let opts: ZstdOptions = ZstdOptions::default().with_level(level)
        let handle: *Unit = ffi_zstd_cstream_create_with_dict(dict.handle, level)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdCompress { handle: handle, options: opts })
    }

    /// Writes data to be compressed.
    ///
    /// # Arguments
    ///
    /// * `data` - The data to compress
    ///
    /// # Returns
    ///
    /// Compressed chunk (may be empty if more input is needed).
    pub func write(this, data: Str) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_zstd_cstream_process(this.handle, data, ZSTD_E_CONTINUE)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Writes buffer data to be compressed.
    pub func write_buffer(this, data: ref Buffer) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_zstd_cstream_process_buffer(this.handle, data.handle, ZSTD_E_CONTINUE)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Flushes pending compressed data.
    pub func flush(this) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_zstd_cstream_process(this.handle, "", ZSTD_E_FLUSH)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Finishes compression and returns remaining data.
    pub func finish(this) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_zstd_cstream_process(this.handle, "", ZSTD_E_END)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Resets the compressor for a new stream.
    pub func reset(this) -> Outcome[Unit, ZlibError] {
        let success: Bool = ffi_zstd_cstream_reset(this.handle)
        if not success {
            return Err(ZlibError::new(ZlibErrorKind::StreamError))
        }
        return Ok(())
    }

    /// Sets the pledged source size for the current frame.
    pub func set_pledged_size(this, size: I64) -> Outcome[Unit, ZlibError] {
        let success: Bool = ffi_zstd_cstream_set_pledged_size(this.handle, size)
        if not success {
            return Err(ZlibError::new(ZlibErrorKind::InvalidParameter))
        }
        return Ok(())
    }

    /// Frees the compressor resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_zstd_cstream_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// Zstd Streaming Decompression
// ============================================================================

/// Zstd streaming decompressor.
pub type ZstdDecompress {
    handle: *Unit
    options: ZstdOptions
}

impl ZstdDecompress {
    /// Creates a new Zstd decompressor with default options.
    pub func new() -> Outcome[ZstdDecompress, ZlibError] {
        return ZstdDecompress::with_options(ZstdOptions::default())
    }

    /// Creates a new Zstd decompressor with custom options.
    pub func with_options(options: ZstdOptions) -> Outcome[ZstdDecompress, ZlibError] {
        let handle: *Unit = ffi_zstd_dstream_create(options.window_log)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdDecompress { handle: handle, options: options })
    }

    /// Creates a new Zstd decompressor with a dictionary.
    pub func with_dictionary(dict: ref Buffer) -> Outcome[ZstdDecompress, ZlibError] {
        let handle: *Unit = ffi_zstd_dstream_create_with_dict(dict.handle)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdDecompress { handle: handle, options: ZstdOptions::default() })
    }

    /// Writes compressed data to decompress.
    ///
    /// # Arguments
    ///
    /// * `data` - The compressed data
    ///
    /// # Returns
    ///
    /// Decompressed chunk.
    pub func write(this, data: ref Buffer) -> Outcome[Buffer, ZlibError] {
        let handle: *Unit = ffi_zstd_dstream_process(this.handle, data.handle)
        if handle == null {
            let code: I32 = ffi_zstd_dstream_get_error_code(this.handle)
            return Err(ZlibError::with_code(ZlibErrorKind::DataError, code))
        }
        return Ok(Buffer { handle: handle })
    }

    /// Resets the decompressor for a new stream.
    pub func reset(this) -> Outcome[Unit, ZlibError] {
        let success: Bool = ffi_zstd_dstream_reset(this.handle)
        if not success {
            return Err(ZlibError::new(ZlibErrorKind::StreamError))
        }
        return Ok(())
    }

    /// Returns the frame content size if known.
    pub func content_size(this) -> Maybe[I64] {
        let size: I64 = ffi_zstd_dstream_content_size(this.handle)
        if size < 0 {
            return Nothing
        }
        return Just(size)
    }

    /// Frees the decompressor resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_zstd_dstream_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// Zstd Dictionary
// ============================================================================

/// Zstd compression dictionary.
///
/// Dictionaries can significantly improve compression ratio for small inputs
/// that share common patterns (e.g., JSON documents with similar structure).
pub type ZstdDict {
    handle: *Unit
}

impl ZstdDict {
    /// Loads a dictionary from a buffer.
    pub func from_buffer(data: ref Buffer) -> Outcome[ZstdDict, ZlibError] {
        let handle: *Unit = ffi_zstd_dict_create(data.handle)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdDict { handle: handle })
    }

    /// Trains a dictionary from sample data.
    ///
    /// # Arguments
    ///
    /// * `samples` - List of sample data to train from
    /// * `dict_size` - Target dictionary size in bytes
    ///
    /// # Returns
    ///
    /// A trained dictionary.
    pub func train(samples: ref std::collections::List[Buffer], dict_size: I64) -> Outcome[ZstdDict, ZlibError] {
        let handle: *Unit = ffi_zstd_dict_train(samples.handle, dict_size)
        if handle == null {
            return Err(ZlibError::new(ZlibErrorKind::MemoryError))
        }
        return Ok(ZstdDict { handle: handle })
    }

    /// Returns the dictionary ID.
    pub func id(this) -> I32 {
        let id: I32 = ffi_zstd_dict_get_id(this.handle)
        return id
    }

    /// Exports the dictionary to a buffer.
    pub func to_buffer(this) -> Buffer {
        let handle: *Unit = ffi_zstd_dict_to_buffer(this.handle)
        return Buffer { handle: handle }
    }

    /// Frees the dictionary resources.
    pub func destroy(mut this) {
        if this.handle != null {
            ffi_zstd_dict_destroy(this.handle)
            this.handle = null
        }
    }
}

// ============================================================================
// Zstd Utility Functions
// ============================================================================

/// Returns the content size from a Zstd frame.
///
/// # Arguments
///
/// * `data` - The compressed buffer
///
/// # Returns
///
/// The content size, or Nothing if unknown.
pub func zstd_content_size(data: ref Buffer) -> Maybe[I64] {
    let size: I64 = ffi_zstd_get_frame_content_size(data.handle)
    if size < 0 {
        return Nothing
    }
    return Just(size)
}

/// Returns the decompressed size bound for the given compressed data.
///
/// This is an upper bound on the decompressed size; actual size may be smaller.
pub func zstd_decompress_bound(data: ref Buffer) -> I64 {
    let bound: I64 = ffi_zstd_get_decompress_bound(data.handle)
    return bound
}

/// Returns the dictionary ID from a Zstd frame.
pub func zstd_frame_dict_id(data: ref Buffer) -> I32 {
    let id: I32 = ffi_zstd_get_frame_dict_id(data.handle)
    return id
}

/// Returns true if the data is a valid Zstd frame.
pub func zstd_is_frame(data: ref Buffer) -> Bool {
    let valid: Bool = ffi_zstd_is_frame(data.handle)
    return valid
}

/// Returns the minimum compression level.
pub func zstd_min_level() -> I32 {
    return ZSTD_MIN_CLEVEL
}

/// Returns the maximum compression level.
pub func zstd_max_level() -> I32 {
    return ZSTD_MAX_CLEVEL
}

/// Returns the default compression level.
pub func zstd_default_level() -> I32 {
    return ZSTD_DEFAULT_CLEVEL
}

impl Drop for ZstdCompress {
    func drop(mut this) {
        this.destroy()
    }
}

impl Drop for ZstdDecompress {
    func drop(mut this) {
        this.destroy()
    }
}

impl Drop for ZstdDict {
    func drop(mut this) {
        this.destroy()
    }
}
