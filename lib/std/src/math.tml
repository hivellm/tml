//! Mathematical functions and constants.
//!
//! This module provides common mathematical operations for floating-point
//! numbers. It wraps LLVM intrinsics for basic operations and uses libc
//! FFI for transcendental functions.
//!
//! # Constants
//!
//! | Constant | Value | Description |
//! |----------|-------|-------------|
//! | [`PI`] | 3.14159... | Ratio of circumference to diameter |
//! | [`E`] | 2.71828... | Euler's number |
//! | [`TAU`] | 6.28318... | 2 * PI |
//! | [`SQRT_2`] | 1.41421... | Square root of 2 |
//! | [`LN_2`] | 0.69314... | Natural log of 2 |
//! | [`LN_10`] | 2.30258... | Natural log of 10 |
//!
//! # Functions (F64)
//!
//! ## Trigonometric
//! `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `atan2`
//!
//! ## Hyperbolic
//! `sinh`, `cosh`, `tanh`
//!
//! ## Exponential & Logarithmic
//! `exp`, `ln`, `log2`, `log10`, `pow`
//!
//! ## Rounding
//! `floor`, `ceil`, `round`, `trunc`
//!
//! ## Utility
//! `abs`, `sqrt`, `cbrt`, `hypot`, `min`, `max`, `clamp`
//! `to_radians`, `to_degrees`, `mul_add`, `fract`, `copysign`, `signum`
//!
//! # F32 Variants
//!
//! All functions have F32 variants with a `_f32` suffix:
//! `sin_f32`, `cos_f32`, `sqrt_f32`, `mul_add_f32`, etc.

use core::intrinsics

// ============================================================================
// Constants
// ============================================================================

/// Pi (ratio of circumference to diameter).
pub const PI: F64 = 3.14159265358979323846

/// Euler's number (base of natural logarithm).
pub const E: F64 = 2.71828182845904523536

/// Tau (2 * PI, full circle in radians).
pub const TAU: F64 = 6.28318530717958647692

/// Square root of 2.
pub const SQRT_2: F64 = 1.41421356237309504880

/// Natural logarithm of 2.
pub const LN_2: F64 = 0.69314718055994530942

/// Natural logarithm of 10.
pub const LN_10: F64 = 2.30258509299404568402

/// log2(e).
pub const LOG2_E: F64 = 1.44269504088896340736

/// log10(e).
pub const LOG10_E: F64 = 0.43429448190325182765

/// 1/PI.
pub const FRAC_1_PI: F64 = 0.31830988618379067154

/// 2/PI.
pub const FRAC_2_PI: F64 = 0.63661977236758134308

/// 1/sqrt(2).
pub const FRAC_1_SQRT_2: F64 = 0.70710678118654752440

/// Pi as F32.
pub const PI_F32: F32 = 3.14159265

// ============================================================================
// FFI declarations for libc math functions (F64)
// ============================================================================

@extern("tan")
func ffi_tan(x: F64) -> F64

@extern("asin")
func ffi_asin(x: F64) -> F64

@extern("acos")
func ffi_acos(x: F64) -> F64

@extern("atan")
func ffi_atan(x: F64) -> F64

@extern("atan2")
func ffi_atan2(y: F64, x: F64) -> F64

@extern("sinh")
func ffi_sinh(x: F64) -> F64

@extern("cosh")
func ffi_cosh(x: F64) -> F64

@extern("tanh")
func ffi_tanh(x: F64) -> F64

@extern("log2")
func ffi_log2(x: F64) -> F64

@extern("log10")
func ffi_log10(x: F64) -> F64

@extern("cbrt")
func ffi_cbrt(x: F64) -> F64

@extern("hypot")
func ffi_hypot(x: F64, y: F64) -> F64

// FFI declarations for libc math functions (F32)
@extern("tanf")
func ffi_tanf(x: F32) -> F32

@extern("asinf")
func ffi_asinf(x: F32) -> F32

@extern("acosf")
func ffi_acosf(x: F32) -> F32

@extern("atanf")
func ffi_atanf(x: F32) -> F32

@extern("atan2f")
func ffi_atan2f(y: F32, x: F32) -> F32

@extern("sinhf")
func ffi_sinhf(x: F32) -> F32

@extern("coshf")
func ffi_coshf(x: F32) -> F32

@extern("tanhf")
func ffi_tanhf(x: F32) -> F32

@extern("log2f")
func ffi_log2f(x: F32) -> F32

@extern("log10f")
func ffi_log10f(x: F32) -> F32

@extern("cbrtf")
func ffi_cbrtf(x: F32) -> F32

@extern("hypotf")
func ffi_hypotf(x: F32, y: F32) -> F32

// ============================================================================
// Trigonometric Functions (F64)
// ============================================================================

/// Sine of `x` (in radians).
pub func sin(x: F64) -> F64 {
    return intrinsics::sin[F64](x)
}

/// Cosine of `x` (in radians).
pub func cos(x: F64) -> F64 {
    return intrinsics::cos[F64](x)
}

/// Tangent of `x` (in radians).
pub func tan(x: F64) -> F64 {
    return ffi_tan(x)
}

/// Arc sine. Returns value in [-PI/2, PI/2].
pub func asin(x: F64) -> F64 {
    return ffi_asin(x)
}

/// Arc cosine. Returns value in [0, PI].
pub func acos(x: F64) -> F64 {
    return ffi_acos(x)
}

/// Arc tangent. Returns value in [-PI/2, PI/2].
pub func atan(x: F64) -> F64 {
    return ffi_atan(x)
}

/// Two-argument arc tangent of `y/x`. Returns value in [-PI, PI].
pub func atan2(y: F64, x: F64) -> F64 {
    return ffi_atan2(y, x)
}

// ============================================================================
// Trigonometric Functions (F32)
// ============================================================================

/// Sine (F32).
pub func sin_f32(x: F32) -> F32 {
    return intrinsics::sin[F32](x)
}

/// Cosine (F32).
pub func cos_f32(x: F32) -> F32 {
    return intrinsics::cos[F32](x)
}

/// Tangent (F32).
pub func tan_f32(x: F32) -> F32 {
    return ffi_tanf(x)
}

/// Arc sine (F32).
pub func asin_f32(x: F32) -> F32 {
    return ffi_asinf(x)
}

/// Arc cosine (F32).
pub func acos_f32(x: F32) -> F32 {
    return ffi_acosf(x)
}

/// Arc tangent (F32).
pub func atan_f32(x: F32) -> F32 {
    return ffi_atanf(x)
}

/// Two-argument arc tangent (F32).
pub func atan2_f32(y: F32, x: F32) -> F32 {
    return ffi_atan2f(y, x)
}

// ============================================================================
// Hyperbolic Functions (F64)
// ============================================================================

/// Hyperbolic sine.
pub func sinh(x: F64) -> F64 {
    return ffi_sinh(x)
}

/// Hyperbolic cosine.
pub func cosh(x: F64) -> F64 {
    return ffi_cosh(x)
}

/// Hyperbolic tangent.
pub func tanh(x: F64) -> F64 {
    return ffi_tanh(x)
}

// ============================================================================
// Hyperbolic Functions (F32)
// ============================================================================

/// Hyperbolic sine (F32).
pub func sinh_f32(x: F32) -> F32 {
    return ffi_sinhf(x)
}

/// Hyperbolic cosine (F32).
pub func cosh_f32(x: F32) -> F32 {
    return ffi_coshf(x)
}

/// Hyperbolic tangent (F32).
pub func tanh_f32(x: F32) -> F32 {
    return ffi_tanhf(x)
}

// ============================================================================
// Exponential & Logarithmic Functions (F64)
// ============================================================================

/// Exponential function (e^x).
pub func exp(x: F64) -> F64 {
    return intrinsics::exp[F64](x)
}

/// Natural logarithm (ln).
pub func ln(x: F64) -> F64 {
    return intrinsics::log[F64](x)
}

/// Base-2 logarithm.
pub func log2(x: F64) -> F64 {
    return ffi_log2(x)
}

/// Base-10 logarithm.
pub func log10(x: F64) -> F64 {
    return ffi_log10(x)
}

/// Power function (x^y).
pub func pow(x: F64, y: F64) -> F64 {
    return intrinsics::pow[F64](x, y)
}

// ============================================================================
// Exponential & Logarithmic Functions (F32)
// ============================================================================

/// Exponential function (F32).
pub func exp_f32(x: F32) -> F32 {
    return intrinsics::exp[F32](x)
}

/// Natural logarithm (F32).
pub func ln_f32(x: F32) -> F32 {
    return intrinsics::log[F32](x)
}

/// Base-2 logarithm (F32).
pub func log2_f32(x: F32) -> F32 {
    return ffi_log2f(x)
}

/// Base-10 logarithm (F32).
pub func log10_f32(x: F32) -> F32 {
    return ffi_log10f(x)
}

/// Power function (F32).
pub func pow_f32(x: F32, y: F32) -> F32 {
    return intrinsics::pow[F32](x, y)
}

// ============================================================================
// Rounding Functions (F64)
// ============================================================================

/// Round down to nearest integer.
pub func floor(x: F64) -> F64 {
    return intrinsics::floor[F64](x)
}

/// Round up to nearest integer.
pub func ceil(x: F64) -> F64 {
    return intrinsics::ceil[F64](x)
}

/// Round to nearest integer (ties to even).
pub func round(x: F64) -> F64 {
    return intrinsics::round[F64](x)
}

/// Truncate toward zero.
pub func trunc(x: F64) -> F64 {
    return intrinsics::trunc[F64](x)
}

// ============================================================================
// Rounding Functions (F32)
// ============================================================================

/// Round down (F32).
pub func floor_f32(x: F32) -> F32 {
    return intrinsics::floor[F32](x)
}

/// Round up (F32).
pub func ceil_f32(x: F32) -> F32 {
    return intrinsics::ceil[F32](x)
}

/// Round to nearest integer (F32).
pub func round_f32(x: F32) -> F32 {
    return intrinsics::round[F32](x)
}

/// Truncate toward zero (F32).
pub func trunc_f32(x: F32) -> F32 {
    return intrinsics::trunc[F32](x)
}

// ============================================================================
// Utility Functions (F64)
// ============================================================================

/// Absolute value.
pub func abs(x: F64) -> F64 {
    return intrinsics::fabs[F64](x)
}

/// Square root.
pub func sqrt(x: F64) -> F64 {
    return intrinsics::sqrt[F64](x)
}

/// Cube root.
pub func cbrt(x: F64) -> F64 {
    return ffi_cbrt(x)
}

/// Euclidean distance: sqrt(x^2 + y^2).
pub func hypot(x: F64, y: F64) -> F64 {
    return ffi_hypot(x, y)
}

/// Minimum of two values.
pub func min(a: F64, b: F64) -> F64 {
    if a < b { return a }
    return b
}

/// Maximum of two values.
pub func max(a: F64, b: F64) -> F64 {
    if a > b { return a }
    return b
}

/// Clamp a value to the range [lo, hi].
pub func clamp(val: F64, lo: F64, hi: F64) -> F64 {
    if val < lo { return lo }
    if val > hi { return hi }
    return val
}

/// Convert degrees to radians.
pub func to_radians(degrees: F64) -> F64 {
    return degrees * PI / 180.0
}

/// Convert radians to degrees.
pub func to_degrees(radians: F64) -> F64 {
    return radians * 180.0 / PI
}

// ============================================================================
// Utility Functions (F32)
// ============================================================================

/// Absolute value (F32).
pub func abs_f32(x: F32) -> F32 {
    if x < 0.0 { return -x }
    return x
}

/// Square root (F32).
pub func sqrt_f32(x: F32) -> F32 {
    return intrinsics::sqrt[F32](x)
}

/// Cube root (F32).
pub func cbrt_f32(x: F32) -> F32 {
    return ffi_cbrtf(x)
}

/// Euclidean distance (F32).
pub func hypot_f32(x: F32, y: F32) -> F32 {
    return ffi_hypotf(x, y)
}

/// Minimum (F32).
pub func min_f32(a: F32, b: F32) -> F32 {
    if a < b { return a }
    return b
}

/// Maximum (F32).
pub func max_f32(a: F32, b: F32) -> F32 {
    if a > b { return a }
    return b
}

/// Clamp (F32).
pub func clamp_f32(val: F32, lo: F32, hi: F32) -> F32 {
    if val < lo { return lo }
    if val > hi { return hi }
    return val
}

/// Convert degrees to radians (F32).
pub func to_radians_f32(degrees: F32) -> F32 {
    // Compute in F64 then truncate to avoid F32 constant precision issues
    let deg_f64: F64 = degrees as F64
    let result: F64 = deg_f64 * PI / 180.0
    return result as F32
}

/// Convert radians to degrees (F32).
pub func to_degrees_f32(radians: F32) -> F32 {
    let rad_f64: F64 = radians as F64
    let result: F64 = rad_f64 * 180.0 / PI
    return result as F32
}

// ============================================================================
// Fused Multiply-Add
// ============================================================================

/// Fused multiply-add: `a * b + c` with a single rounding step.
///
/// More accurate than `a * b + c` because it avoids intermediate rounding.
/// Uses the LLVM `fma` intrinsic which maps to hardware FMA instructions.
pub func mul_add(a: F64, b: F64, c: F64) -> F64 {
    return intrinsics::fma[F64](a, b, c)
}

/// Fused multiply-add (F32).
pub func mul_add_f32(a: F32, b: F32, c: F32) -> F32 {
    return intrinsics::fma[F32](a, b, c)
}

// ============================================================================
// Additional Utility Functions
// ============================================================================

/// Returns the fractional part of `x` (i.e., `x - trunc(x)`).
pub func fract(x: F64) -> F64 {
    return x - intrinsics::trunc[F64](x)
}

/// Returns the fractional part (F32).
pub func fract_f32(x: F32) -> F32 {
    return x - intrinsics::trunc[F32](x)
}

/// Returns a value with the magnitude of `a` and the sign of `b`.
pub func copysign(a: F64, b: F64) -> F64 {
    let mag: F64 = intrinsics::fabs[F64](a)
    if b < 0.0 { return -mag }
    return mag
}

/// Copysign (F32).
pub func copysign_f32(a: F32, b: F32) -> F32 {
    let mag: F32 = abs_f32(a)
    if b < 0.0 { return -mag }
    return mag
}

/// Returns the sign of `x`: -1.0, 0.0, or 1.0.
///
/// Returns 0.0 for both positive and negative zero.
pub func signum(x: F64) -> F64 {
    if x > 0.0 { return 1.0 }
    if x < 0.0 { return -1.0 }
    return 0.0
}

/// Signum (F32).
pub func signum_f32(x: F32) -> F32 {
    if x > 0.0 { return 1.0 }
    if x < 0.0 {
        let neg: F32 = -1.0
        return neg
    }
    return 0.0
}
