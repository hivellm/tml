//! Free-standing helper functions for `Maybe[T]` and `Outcome[T, E]`.
//!
//! The types `Maybe[T]` and `Outcome[T, E]` are compiler builtins. This module
//! provides free-standing convenience functions that complement the method-based
//! API in [`core::option`] and [`core::result`].
//!
//! # Note
//!
//! Prefer the method syntax (e.g., `val.unwrap()`) from `core::option` /
//! `core::result` for idiomatic TML. The free functions here are provided for
//! cases where a function-call style is more convenient (e.g., passing to
//! higher-order functions).
//!
//! # Example
//!
//! ```tml
//! use std::types::{is_just, unwrap}
//!
//! let x: Maybe[I32] = Just(5)
//! assert(is_just(x))
//! assert(unwrap(x) == 5)
//! ```

// ============================================================================
// Maybe[T] free functions
// ============================================================================

/// Returns `true` if the maybe contains a value.
pub func is_just[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return true,
        Nothing => return false,
    }
    return false
}

/// Returns `true` if the maybe contains no value.
pub func is_nothing[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return false,
        Nothing => return true,
    }
    return true
}

/// Extracts the contained value, panicking if `Nothing`.
pub func unwrap[T](m: Maybe[T]) -> T {
    when m {
        Just(val) => return val,
        Nothing => panic("called unwrap() on Nothing"),
    }
    panic("unreachable")
}

/// Extracts the contained value, panicking with a custom message if `Nothing`.
pub func expect[T](m: Maybe[T], msg: Str) -> T {
    when m {
        Just(val) => return val,
        Nothing => panic(msg),
    }
    panic("unreachable")
}

/// Returns the contained value or a default.
pub func unwrap_or[T](m: Maybe[T], default_val: T) -> T {
    when m {
        Just(val) => return val,
        Nothing => return default_val,
    }
    return default_val
}

/// Maps a `Maybe[T]` to `Maybe[U]` by applying a function to the contained value.
pub func map[T, U](m: Maybe[T], f: func(T) -> U) -> Maybe[U] {
    when m {
        Just(val) => return Just(f(val)),
        Nothing => return Nothing,
    }
    return Nothing
}

/// Returns `Nothing` if the maybe is `Nothing`, otherwise calls `f` with the value.
pub func and_then[T, U](m: Maybe[T], f: func(T) -> Maybe[U]) -> Maybe[U] {
    when m {
        Just(val) => return f(val),
        Nothing => return Nothing,
    }
    return Nothing
}

/// Returns `Nothing` if the maybe is `Nothing`, or if the predicate returns false.
pub func filter[T](m: Maybe[T], predicate: func(T) -> Bool) -> Maybe[T] {
    when m {
        Just(val) => {
            if predicate(val) {
                return Just(val)
            }
            return Nothing
        },
        Nothing => return Nothing,
    }
    return Nothing
}

/// Returns the maybe if it contains a value, otherwise calls `f`.
pub func or_else[T](m: Maybe[T], f: func() -> Maybe[T]) -> Maybe[T] {
    when m {
        Just(val) => return Just(val),
        Nothing => return f(),
    }
    return f()
}

/// Transforms `Maybe[T]` into `Outcome[T, E]`, mapping `Just(v)` to `Ok(v)` and `Nothing` to `Err(err)`.
pub func ok_or[T, E](m: Maybe[T], err: E) -> Outcome[T, E] {
    when m {
        Just(val) => return Ok(val),
        Nothing => return Err(err),
    }
    return Err(err)
}

/// Transforms `Maybe[T]` into `Outcome[T, E]`, mapping `Just(v)` to `Ok(v)` and `Nothing` to `Err(f())`.
pub func ok_or_else[T, E](m: Maybe[T], f: func() -> E) -> Outcome[T, E] {
    when m {
        Just(val) => return Ok(val),
        Nothing => return Err(f()),
    }
    return Err(f())
}

// ============================================================================
// Outcome[T, E] free functions
// ============================================================================

/// Returns `true` if the outcome is `Ok`.
pub func is_ok[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return true,
        Err(_) => return false,
    }
    return false
}

/// Returns `true` if the outcome is `Err`.
pub func is_err[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return false,
        Err(_) => return true,
    }
    return true
}

/// Extracts the contained `Ok` value, panicking if `Err`.
pub func unwrap_ok[T, E](o: Outcome[T, E]) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => panic("called unwrap_ok() on Err"),
    }
    panic("unreachable")
}

/// Extracts the contained `Ok` value, panicking with a custom message if `Err`.
pub func expect_ok[T, E](o: Outcome[T, E], msg: Str) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => panic(msg),
    }
    panic("unreachable")
}

/// Extracts the contained `Err` value, panicking if `Ok`.
pub func unwrap_err[T, E](o: Outcome[T, E]) -> E {
    when o {
        Ok(_) => panic("called unwrap_err() on Ok"),
        Err(e) => return e,
    }
    panic("unreachable")
}

/// Extracts the contained `Err` value, panicking with a custom message if `Ok`.
pub func expect_err[T, E](o: Outcome[T, E], msg: Str) -> E {
    when o {
        Ok(_) => panic(msg),
        Err(e) => return e,
    }
    panic("unreachable")
}

/// Returns the contained `Ok` value or a default.
pub func unwrap_or_ok[T, E](o: Outcome[T, E], default_val: T) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => return default_val,
    }
    return default_val
}

/// Returns the contained `Err` value or a default.
pub func unwrap_or_err[T, E](o: Outcome[T, E], default_val: E) -> E {
    when o {
        Ok(_) => return default_val,
        Err(e) => return e,
    }
    return default_val
}

/// Maps an `Outcome[T, E]` to `Outcome[U, E]` by applying a function to the `Ok` value.
pub func map_ok[T, U, E](o: Outcome[T, E], f: func(T) -> U) -> Outcome[U, E] {
    when o {
        Ok(val) => return Ok(f(val)),
        Err(e) => return Err(e),
    }
}

/// Maps an `Outcome[T, E]` to `Outcome[T, F]` by applying a function to the `Err` value.
pub func map_err[T, E, F](o: Outcome[T, E], f: func(E) -> F) -> Outcome[T, F] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return Err(f(e)),
    }
}

/// Returns `Err` if the outcome is `Err`, otherwise calls `f` with the `Ok` value.
pub func and_then_ok[T, U, E](o: Outcome[T, E], f: func(T) -> Outcome[U, E]) -> Outcome[U, E] {
    when o {
        Ok(val) => return f(val),
        Err(e) => return Err(e),
    }
}

/// Returns `Ok` if the outcome is `Ok`, otherwise calls `f` with the `Err` value.
pub func or_else_ok[T, E](o: Outcome[T, E], f: func(E) -> Outcome[T, E]) -> Outcome[T, E] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return f(e),
    }
}
