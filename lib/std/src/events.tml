//! Event-driven programming primitives.
//!
//! This module provides an `EventEmitter` type for publish/subscribe
//! patterns, inspired by Node.js's `events` module.
//!
//! # Core Type
//!
//! | Type | Description |
//! |------|-------------|
//! | [`EventEmitter`] | Named-event dispatcher with ordered listeners |
//!
//! Listeners are `func(I64)` function pointers passed as I64.
//!
//! # Features
//!
//! - **on** — Register a listener
//! - **once** — Register a one-time listener
//! - **off** — Remove a listener
//! - **emit** — Synchronously call all listeners
//! - **emit_async** — Defer listeners to EventLoop pending queue
//! - **emit_next_tick** — Defer listeners to EventLoop next-tick queue
//! - **prepend_listener** — Register listener to be called first
//! - **listeners_of** — Get all listeners for an event
//! - **event_names** — Get all registered event names
//!
//! # Example
//!
//! ```tml
//! use std::events::EventEmitter
//!
//! func on_click(data: I64) {
//!     print("clicked!\n")
//! }
//!
//! var emitter = EventEmitter::new()
//! emitter.on("click", on_click as I64)
//! emitter.emit("click", 0)
//! emitter.destroy()
//! ```

use core::intrinsics::{ptr_read, ptr_write}
use std::collections::hashmap::HashMap
use std::collections::List
use std::aio::EventLoop

// ── Low-level memory allocation helpers ───────────────────────────────────

/// Allocate memory for internal use.
func ev_alloc(size: I64) -> *Unit {
    lowlevel { mem_alloc(size) }
}

/// Free memory allocated by ev_alloc.
func ev_free(ptr: *Unit) {
    lowlevel { mem_free(ptr) }
}

/// Reallocate memory to a new size.
func ev_realloc(ptr: *Unit, size: I64) -> *Unit {
    lowlevel { mem_realloc(ptr, size) }
}

// ── Memory read/write helpers ─────────────────────────────────────────────

/// Read a single I64 value from memory address.
func rd(addr: I64) -> I64 {
    lowlevel { ptr_read[I64](addr as *I64) }
}

/// Write a single I64 value to memory address.
func wr(addr: I64, val: I64) {
    lowlevel { ptr_write[I64](addr as *I64, val) }
}

// ── la_* helpers for low-level listener arrays ────────────────────────────
//!
//! Listener arrays store pairs: (callback_fn_ptr: I64, is_once: I64)
//! Layout: [0]=data_ptr, [8]=length, [16]=capacity (all as I64)

/// Create a new listener array with initial capacity.
func la_new() -> I64 {
    let header: *Unit = ev_alloc(24)
    let h: I64 = header as I64
    let data: *Unit = ev_alloc(64)
    wr(h, data as I64)
    wr(h + 8, 0)
    wr(h + 16, 8)
    h
}

/// Append a single I64 value to listener array.
func la_push(h: I64, val: I64) {
    let len: I64 = rd(h + 8)
    let cap: I64 = rd(h + 16)
    if len >= cap {
        let new_cap: I64 = cap * 2
        let old_data: *Unit = rd(h) as *Unit
        let new_data: *Unit = ev_realloc(old_data, new_cap * 8)
        wr(h, new_data as I64)
        wr(h + 16, new_cap)
    }
    let data: I64 = rd(h)
    wr(data + len * 8, val)
    wr(h + 8, len + 1)
}

/// Get value at index in listener array.
func la_get(h: I64, idx: I64) -> I64 {
    let data: I64 = rd(h)
    rd(data + idx * 8)
}

/// Set value at index in listener array.
func la_set(h: I64, idx: I64, val: I64) {
    let data: I64 = rd(h)
    wr(data + idx * 8, val)
}

/// Get current length of listener array.
func la_len(h: I64) -> I64 {
    rd(h + 8)
}

/// Pop and return last element from listener array.
func la_pop(h: I64) -> I64 {
    let len: I64 = rd(h + 8)
    let new_len: I64 = len - 1
    wr(h + 8, new_len)
    let data: I64 = rd(h)
    rd(data + new_len * 8)
}

/// Clear all elements without deallocating.
func la_clear(h: I64) {
    wr(h + 8, 0)
}

/// Free all memory used by listener array.
func la_destroy(h: I64) {
    let data: *Unit = rd(h) as *Unit
    ev_free(data)
    ev_free(h as *Unit)
}

/// Remove a pair (callback + is_once) at index, shifting remaining elements left.
func la_remove_pair(h: I64, idx: I64) {
    let len: I64 = la_len(h)
    var i: I64 = idx
    loop (i + 2 < len) {
        la_set(h, i, la_get(h, i + 2))
        i = i + 1
    }
    la_pop(h)
    la_pop(h)
}

/// Insert a pair (callback + is_once) at front, shifting all elements right.
func la_prepend_pair(h: I64, fn_ptr: I64, is_once: I64) {
    // First push two dummy values to ensure capacity and extend length
    la_push(h, 0)
    la_push(h, 0)
    // Now shift all existing elements right by 2
    let len: I64 = la_len(h)
    var i: I64 = len - 1
    loop (i >= 2) {
        la_set(h, i, la_get(h, i - 2))
        i = i - 1
    }
    // Write new pair at front
    la_set(h, 0, fn_ptr)
    la_set(h, 1, is_once)
}

// ── EventEmitter pub/sub type ──────────────────────────────────────────────

/// Event emitter for pub/sub patterns.
///
/// Manages listeners for named events. Each event name maps to an array of listener pairs.
/// Listeners are invoked synchronously when the event is emitted.
pub type EventEmitter {
    /// HashMap from event name to listener array handle.
    events: HashMap[Str, I64],
    /// Maximum allowed listeners per event (warning threshold).
    max_listeners: I64,
    /// Total number of active listeners across all events.
    total_count: I64
}

impl EventEmitter {
    /// Create a new EventEmitter.
    pub func new() -> EventEmitter {
        EventEmitter {
            events: HashMap[Str, I64]::new(16),
            max_listeners: 10,
            total_count: 0
        }
    }

    /// Register a listener for an event.
    /// Listener will be called on each emit. Function pointer must be cast as I64.
    pub func on(mut this, event: Str, listener: I64) {
        var arr: I64 = 0
        if this.events.has(event) {
            arr = this.events.get(event)
        } else {
            arr = la_new()
            this.events.set(event, arr)
        }
        la_push(arr, listener)
        la_push(arr, 0)
        this.total_count = this.total_count + 1
    }

    /// Register a one-time listener for an event.
    /// Listener is automatically removed after first emit.
    pub func once(mut this, event: Str, listener: I64) {
        var arr: I64 = 0
        if this.events.has(event) {
            arr = this.events.get(event)
        } else {
            arr = la_new()
            this.events.set(event, arr)
        }
        la_push(arr, listener)
        la_push(arr, 1)
        this.total_count = this.total_count + 1
    }

    /// Remove a listener from an event.
    /// Returns true if listener was found and removed.
    pub func off(mut this, event: Str, listener: I64) -> Bool {
        if not this.events.has(event) {
            return false
        }
        let arr: I64 = this.events.get(event)
        let len: I64 = la_len(arr)
        var i: I64 = 0
        loop (i < len) {
            if la_get(arr, i) == listener {
                la_remove_pair(arr, i)
                this.total_count = this.total_count - 1
                return true
            }
            i = i + 2
        }
        return false
    }

    /// Emit an event, synchronously calling all registered listeners.
    /// Returns true if event had listeners, false otherwise.
    pub func emit(mut this, event: Str, data: I64) -> Bool {
        if not this.events.has(event) {
            return false
        }
        let arr: I64 = this.events.get(event)
        let len: I64 = la_len(arr)
        if len == 0 {
            return false
        }

        let snapshot: I64 = la_new()
        let once_list: I64 = la_new()

        var i: I64 = 0
        loop (i < len) {
            la_push(snapshot, la_get(arr, i))
            if la_get(arr, i + 1) == 1 {
                la_push(once_list, i)
            }
            i = i + 2
        }

        let once_count: I64 = la_len(once_list)
        if once_count > 0 {
            var j: I64 = once_count - 1
            loop (j >= 0) {
                la_remove_pair(arr, la_get(once_list, j))
                this.total_count = this.total_count - 1
                j = j - 1
            }
        }
        la_destroy(once_list)

        let num_calls: I64 = la_len(snapshot)
        var k: I64 = 0
        loop (k < num_calls) {
            let f: func(I64) = la_get(snapshot, k) as func(I64)
            f(data)
            k = k + 1
        }

        la_destroy(snapshot)
        return true
    }

    /// Remove all listeners for an event.
    /// Returns the number of listeners that were removed.
    pub func remove_all(mut this, event: Str) -> I64 {
        if not this.events.has(event) {
            return 0
        }
        let arr: I64 = this.events.get(event)
        let count: I64 = la_len(arr) / 2
        la_destroy(arr)
        this.events.remove(event)
        this.total_count = this.total_count - count
        return count
    }

    /// Get the number of listeners for a specific event.
    pub func listener_count(this, event: Str) -> I64 {
        if not this.events.has(event) {
            return 0
        }
        la_len(this.events.get(event)) / 2
    }

    /// Get the total number of listeners across all events.
    pub func total_listeners(this) -> I64 {
        this.total_count
    }

    /// Set the max listener threshold (for warnings).
    pub func set_max_listeners(mut this, n: I64) {
        this.max_listeners = n
    }

    /// Get the current max listener threshold.
    pub func get_max_listeners(this) -> I64 {
        this.max_listeners
    }

    /// Check if an event has any listeners.
    pub func has_listeners(this, event: Str) -> Bool {
        this.listener_count(event) > 0
    }

    /// Register a listener to be called first (prepend).
    /// Prepended listeners execute before appended ones.
    pub func prepend_listener(mut this, event: Str, listener: I64) {
        var arr: I64 = 0
        if this.events.has(event) {
            arr = this.events.get(event)
        } else {
            arr = la_new()
            this.events.set(event, arr)
        }
        la_prepend_pair(arr, listener, 0)
        this.total_count = this.total_count + 1
    }

    /// Register a one-time listener to be called first (prepend).
    /// Prepended once-listener removes itself after first emit.
    pub func prepend_once_listener(mut this, event: Str, listener: I64) {
        var arr: I64 = 0
        if this.events.has(event) {
            arr = this.events.get(event)
        } else {
            arr = la_new()
            this.events.set(event, arr)
        }
        la_prepend_pair(arr, listener, 1)
        this.total_count = this.total_count + 1
    }

    /// Get a snapshot copy of all listeners for an event.
    /// Caller must call destroy() on the returned List.
    pub func listeners_of(this, event: Str) -> List[I64] {
        let result: List[I64] = List[I64]::new(4)
        if not this.events.has(event) {
            return result
        }
        let arr: I64 = this.events.get(event)
        let len: I64 = la_len(arr)
        var i: I64 = 0
        loop (i < len) {
            result.push(la_get(arr, i))
            i = i + 2
        }
        return result
    }

    /// Get all event names that have active listeners.
    /// Caller must call destroy() on the returned List.
    pub func event_names(this) -> List[Str] {
        let result: List[Str] = List[Str]::new(4)
        let hdr: I64 = this.events.handle as I64
        if hdr == 0 {
            return result
        }
        let entries_addr: I64 = rd(hdr)
        let ctrl_addr: I64 = rd(hdr + 8)
        let cap: I64 = rd(hdr + 24)
        var i: I64 = 0
        loop (i < cap) {
            let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + i) as *I8) }
            if c >= (0 as I8) {
                // Occupied slot — key is at offset 0, value is at offset 8
                let key: I64 = rd(entries_addr + i * 16)
                let val: I64 = rd(entries_addr + i * 16 + 8)
                // Only include events with active listeners
                if la_len(val) > 0 {
                    result.push(key as Str)
                }
            }
            i = i + 1
        }
        return result
    }

    /// Schedule event emission to pending queue (after I/O, setImmediate semantics).
    /// Callbacks are executed when drain_pending() is called.
    pub func emit_async(mut this, event: Str, data: I64, mut el: EventLoop) -> Bool {
        if not this.events.has(event) {
            return false
        }
        let arr: I64 = this.events.get(event)
        let len: I64 = la_len(arr)
        if len == 0 {
            return false
        }

        // Snapshot listeners and identify once-listeners
        let snapshot: I64 = la_new()
        let once_list: I64 = la_new()

        var i: I64 = 0
        loop (i < len) {
            la_push(snapshot, la_get(arr, i))
            if la_get(arr, i + 1) == 1 {
                la_push(once_list, i)
            }
            i = i + 2
        }

        // Remove once-listeners
        let once_count: I64 = la_len(once_list)
        if once_count > 0 {
            var j: I64 = once_count - 1
            loop (j >= 0) {
                la_remove_pair(arr, la_get(once_list, j))
                this.total_count = this.total_count - 1
                j = j - 1
            }
        }
        la_destroy(once_list)

        // Post each callback to the pending queue
        let num_calls: I64 = la_len(snapshot)
        var k: I64 = 0
        loop (k < num_calls) {
            let f: I64 = la_get(snapshot, k)
            el.post(f, data)
            k = k + 1
        }

        la_destroy(snapshot)
        return true
    }

    /// Schedule event emission to next_tick queue (before I/O, process.nextTick semantics).
    /// Callbacks are executed when drain_next_tick() is called.
    pub func emit_next_tick(mut this, event: Str, data: I64, mut el: EventLoop) -> Bool {
        if not this.events.has(event) {
            return false
        }
        let arr: I64 = this.events.get(event)
        let len: I64 = la_len(arr)
        if len == 0 {
            return false
        }

        // Snapshot listeners and identify once-listeners
        let snapshot: I64 = la_new()
        let once_list: I64 = la_new()

        var i: I64 = 0
        loop (i < len) {
            la_push(snapshot, la_get(arr, i))
            if la_get(arr, i + 1) == 1 {
                la_push(once_list, i)
            }
            i = i + 2
        }

        // Remove once-listeners
        let once_count: I64 = la_len(once_list)
        if once_count > 0 {
            var j: I64 = once_count - 1
            loop (j >= 0) {
                la_remove_pair(arr, la_get(once_list, j))
                this.total_count = this.total_count - 1
                j = j - 1
            }
        }
        la_destroy(once_list)

        // Post each callback to the next_tick queue
        let num_calls: I64 = la_len(snapshot)
        var k: I64 = 0
        loop (k < num_calls) {
            let f: I64 = la_get(snapshot, k)
            el.post_next_tick(f, data)
            k = k + 1
        }

        la_destroy(snapshot)
        return true
    }

    /// Free all resources held by this emitter.
    /// Must be called when done with the emitter.
    pub func destroy(mut this) {
        // Manually iterate HashMap buckets to free all listener arrays.
        // We read the internal layout directly because HashMapIter causes
        // codegen issues in DLL/test mode.
        let hdr: I64 = this.events.handle as I64
        if hdr != 0 {
            let entries_addr: I64 = rd(hdr)
            let ctrl_addr: I64 = rd(hdr + 8)
            let cap: I64 = rd(hdr + 24)
            var i: I64 = 0
            loop (i < cap) {
                let c: I8 = lowlevel { ptr_read[I8]((ctrl_addr + i) as *I8) }
                if c >= (0 as I8) {
                    // Occupied slot — value is a la_* array handle
                    let val: I64 = rd(entries_addr + i * 16 + 8)
                    la_destroy(val)
                }
                i = i + 1
            }
        }
        this.events.destroy()
        this.total_count = 0
    }
}
