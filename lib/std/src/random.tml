//! Pseudo-random number generation.
//!
//! This module provides a fast PRNG ([`Rng`]) using the xoshiro256**
//! algorithm. `Rng::new()` seeds from the monotonic clock via SplitMix64
//! expansion for good entropy without requiring the crypto runtime.
//!
//! # Example
//!
//! ```tml
//! use std::random::Rng
//!
//! var rng: Rng = Rng::new()
//! let n: I64 = rng.next_i64()
//! let r: I64 = rng.range(1, 100)
//! ```

use std::collections::List

/// A pseudo-random number generator using xoshiro256**.
///
/// Fast and suitable for simulations, games, and general-purpose
/// randomness. NOT cryptographically secure — use [`std::crypto::random`]
/// for security-sensitive applications.
pub type Rng {
    s0: I64,
    s1: I64,
    s2: I64,
    s3: I64
}

impl Rng {
    /// Creates a new Rng seeded from the monotonic clock.
    pub func new() -> Rng {
        return Rng::with_seed(time_ns())
    }

    /// Creates an Rng with a specific seed for reproducible sequences.
    pub func with_seed(seed: I64) -> Rng {
        // SplitMix64 to expand single seed into 4 state words
        var z: I64 = seed
        z = z + (-7046029254386353131)  // 0x9E3779B97F4A7C15
        var s0: I64 = splitmix_next(z)
        z = z + (-7046029254386353131)
        var s1: I64 = splitmix_next(z)
        z = z + (-7046029254386353131)
        var s2: I64 = splitmix_next(z)
        z = z + (-7046029254386353131)
        var s3: I64 = splitmix_next(z)
        if s0 == 0 and s1 == 0 and s2 == 0 and s3 == 0 {
            s0 = 1
        }
        return Rng { s0: s0, s1: s1, s2: s2, s3: s3 }
    }

    /// Returns the next pseudo-random I64 value.
    pub func next_i64(mut this) -> I64 {
        // xoshiro256** algorithm
        let result: I64 = rotl(this.s1 * 5, 7) * 9
        let t: I64 = this.s1 << 17

        this.s2 = this.s2 ^ this.s0
        this.s3 = this.s3 ^ this.s1
        this.s1 = this.s1 ^ this.s2
        this.s0 = this.s0 ^ this.s3

        this.s2 = this.s2 ^ t
        this.s3 = rotl(this.s3, 45)

        return result
    }

    /// Returns a pseudo-random I64 in [min, max) (exclusive upper bound).
    pub func range(mut this, min: I64, max: I64) -> I64 {
        if min >= max {
            return min
        }
        let span: I64 = max - min
        let raw: I64 = this.next_i64()
        // Make positive
        var positive: I64 = raw
        if positive < 0 {
            positive = 0 - positive
            if positive < 0 {
                positive = 1  // Handle I64::MIN edge case
            }
        }
        return min + (positive % span)
    }

    /// Returns a pseudo-random Bool.
    pub func next_bool(mut this) -> Bool {
        return (this.next_i64() & 1) == 1
    }

    /// Returns a pseudo-random F64 in [0.0, 1.0).
    pub func next_f64(mut this) -> F64 {
        let raw: I64 = this.next_i64()
        // Take upper 53 bits for double precision mantissa
        var positive: I64 = raw
        if positive < 0 {
            positive = 0 - positive
            if positive < 0 {
                positive = 1
            }
        }
        // Divide by 2^63 to get [0, 1)
        return (positive as F64) / 9223372036854775807.0
    }

    /// Returns a pseudo-random F64 in [min, max).
    pub func range_f64(mut this, min: F64, max: F64) -> F64 {
        return min + this.next_f64() * (max - min)
    }

    /// Shuffles a List[I64] in place using Fisher-Yates algorithm.
    pub func shuffle_i64(mut this, list: List[I64]) {
        let n: I64 = list.len()
        if n <= 1 {
            return
        }
        var i: I64 = n - 1
        loop (i > 0) {
            let j: I64 = this.range(0, i + 1)
            // Swap list[i] and list[j]
            let tmp: I64 = list.get(i)
            list.set(i, list.get(j))
            list.set(j, tmp)
            i = i - 1
        }
    }

    /// Shuffles a List[I32] in place using Fisher-Yates algorithm.
    pub func shuffle_i32(mut this, list: List[I32]) {
        let n: I64 = list.len()
        if n <= 1 {
            return
        }
        var i: I64 = n - 1
        loop (i > 0) {
            let j: I64 = this.range(0, i + 1)
            let tmp: I32 = list.get(i)
            list.set(i, list.get(j))
            list.set(j, tmp)
            i = i - 1
        }
    }
}

/// Returns a random I64 using a fresh Rng seeded from the clock.
pub func random_i64() -> I64 {
    var rng: Rng = Rng::new()
    return rng.next_i64()
}

/// Returns a random F64 in [0.0, 1.0) using a fresh Rng.
pub func random_f64() -> F64 {
    var rng: Rng = Rng::new()
    return rng.next_f64()
}

/// Returns a random Bool using a fresh Rng.
pub func random_bool() -> Bool {
    var rng: Rng = Rng::new()
    return rng.next_bool()
}

/// Returns a random I64 in [min, max) using a fresh Rng.
pub func random_range(min: I64, max: I64) -> I64 {
    var rng: Rng = Rng::new()
    return rng.range(min, max)
}

// ============================================================================
// ThreadRng — per-thread CSPRNG-seeded PRNG
// ============================================================================

/// A per-thread random number generator with high-entropy seeding.
///
/// `ThreadRng` wraps xoshiro256** but uses multiple entropy sources
/// (nanosecond clock + SplitMix64 mixing) to produce unpredictable seeds.
/// Each `ThreadRng::new()` call produces a differently-seeded generator.
///
/// For cryptographic security, use `std::crypto::random::SecureRandom`.
///
/// # Example
///
/// ```tml
/// use std::random::ThreadRng
///
/// var rng: ThreadRng = ThreadRng::new()
/// let n: I64 = rng.next_i64()
/// let r: I64 = rng.range(1, 100)
/// ```
pub type ThreadRng {
    _rng: Rng,
    _initialized: Bool
}

impl ThreadRng {
    /// Creates a new ThreadRng with high-entropy seeding.
    ///
    /// Uses nanosecond clock mixed with SplitMix64 finalizer for
    /// good entropy distribution without requiring the crypto runtime.
    pub func new() -> ThreadRng {
        let seed: I64 = splitmix_next(time_ns())
        return ThreadRng {
            _rng: Rng::with_seed(seed),
            _initialized: true
        }
    }

    /// Returns the next pseudo-random I64 value.
    pub func next_i64(mut this) -> I64 {
        return this._rng.next_i64()
    }

    /// Returns a pseudo-random I64 in [min, max) (exclusive upper bound).
    pub func range(mut this, min: I64, max: I64) -> I64 {
        return this._rng.range(min, max)
    }

    /// Returns a pseudo-random Bool.
    pub func next_bool(mut this) -> Bool {
        return this._rng.next_bool()
    }

    /// Returns a pseudo-random F64 in [0.0, 1.0).
    pub func next_f64(mut this) -> F64 {
        return this._rng.next_f64()
    }

    /// Returns a pseudo-random F64 in [min, max).
    pub func range_f64(mut this, min: F64, max: F64) -> F64 {
        return this._rng.range_f64(min, max)
    }

    /// Re-seeds with fresh entropy, discarding current state.
    pub func reseed(mut this) {
        let seed: I64 = splitmix_next(time_ns())
        this._rng = Rng::with_seed(seed)
    }
}

/// Returns a random I64 from a high-entropy-seeded generator.
pub func thread_random_i64() -> I64 {
    var rng: ThreadRng = ThreadRng::new()
    return rng.next_i64()
}

/// Returns a random I64 in [min, max) from a high-entropy-seeded generator.
pub func thread_random_range(min: I64, max: I64) -> I64 {
    var rng: ThreadRng = ThreadRng::new()
    return rng.range(min, max)
}

// ============================================================================
// Internal helpers
// ============================================================================

/// Rotate left for xoshiro.
func rotl(x: I64, k: I64) -> I64 {
    return (x << k) | (x >> (64 - k))
}

/// SplitMix64 finalizer for seed expansion.
func splitmix_next(z: I64) -> I64 {
    var x: I64 = z
    x = (x ^ (x >> 30)) * (-4658895280553007687)  // 0xBF58476D1CE4E5B9
    x = (x ^ (x >> 27)) * (-7723592293110705685)  // 0x94D049BB133111EB
    x = x ^ (x >> 31)
    return x
}
