// Consolidated IO Tests: Text Type - Constructors, Conversions, Properties, Modifications, Search (Part 1)
// Total @test count: 50
// Source: text.test.tml (tests 1-50 of 146)
// Sections: Constructor Tests, Conversion Tests, Properties Tests, Modification Tests, Search Tests (partial)

use std::text::Text
use test::*

// ============================================================================
// CONSTRUCTOR TESTS
// ============================================================================

@test
func test_new_creates_empty_text() {
    let t: Text = Text::new()
    assert_eq(t.len(), 0, "new text should have length 0")
    assert(t.is_empty(), "new text should be empty")
    assert_eq(t.as_str(), "", "new text should be empty string")
    t.drop()
}

@test
func test_from_creates_text_from_string() {
    let t: Text = Text::from("Hello")
    assert_eq(t.len(), 5, "text from 'Hello' should have length 5")
    assert(not t.is_empty(), "text should not be empty")
    assert_eq(t.as_str(), "Hello", "content should match")
    t.drop()
}

@test
func test_from_empty_string() {
    let t: Text = Text::from("")
    assert_eq(t.len(), 0, "empty string should have length 0")
    assert(t.is_empty(), "empty string should be empty")
    t.drop()
}

@test
func test_with_capacity_allocates_space() {
    let t: Text = Text::with_capacity(100)
    assert_eq(t.len(), 0, "text with capacity should have length 0")
    assert(t.capacity() >= 100, "text should have at least requested capacity")
    assert(t.is_empty(), "text should be empty")
    t.drop()
}

@test
func test_with_capacity_zero() {
    let t: Text = Text::with_capacity(0)
    assert_eq(t.len(), 0, "capacity 0 should create empty text")
    t.drop()
}

@test
func test_from_i64_positive() {
    let t: Text = Text::from_i64(42)
    assert_eq(t.as_str(), "42", "from_i64(42) should be '42'")
    t.drop()
}

@test
func test_from_i64_negative() {
    let t: Text = Text::from_i64(-123)
    assert_eq(t.as_str(), "-123", "from_i64(-123) should be '-123'")
    t.drop()
}

@test
func test_from_i64_zero() {
    let t: Text = Text::from_i64(0)
    assert_eq(t.as_str(), "0", "from_i64(0) should be '0'")
    t.drop()
}

@test
func test_from_i64_large_number() {
    let t: Text = Text::from_i64(9223372036854775807)
    assert(t.len() > 0, "large number should produce text")
    t.drop()
}

@test
func test_from_f64_basic() {
    let t: Text = Text::from_f64(3.14159)
    assert(t.starts_with("3.14"), "from_f64 should convert float")
    t.drop()
}

@test
func test_from_f64_integer_value() {
    let t: Text = Text::from_f64(42.0)
    assert(t.starts_with("42"), "from_f64(42.0) should start with 42")
    t.drop()
}

@test
func test_from_f64_precision_zero() {
    let t: Text = Text::from_f64_precision(3.14159, 0)
    assert_eq(t.as_str(), "3", "precision 0 should show no decimals")
    t.drop()
}

@test
func test_from_f64_precision_two() {
    let t: Text = Text::from_f64_precision(3.14159, 2)
    assert_eq(t.as_str(), "3.14", "precision 2 should show 2 decimals")
    t.drop()
}

@test
func test_from_f64_precision_five() {
    let t: Text = Text::from_f64_precision(3.14159, 5)
    assert_eq(t.as_str(), "3.14159", "precision 5 should show 5 decimals")
    t.drop()
}

@test
func test_from_bool_true() {
    let t: Text = Text::from_bool(true)
    assert_eq(t.as_str(), "true", "from_bool(true) should be 'true'")
    t.drop()
}

@test
func test_from_bool_false() {
    let t: Text = Text::from_bool(false)
    assert_eq(t.as_str(), "false", "from_bool(false) should be 'false'")
    t.drop()
}

// ============================================================================
// CONVERSION TESTS
// ============================================================================

@test
func test_as_str_returns_content() {
    let t: Text = Text::from("World")
    let s: Str = t.as_str()
    assert_eq(s, "World", "as_str should return correct string")
    t.drop()
}

@test
func test_clone_creates_copy() {
    let t1: Text = Text::from("Clone me")
    let t2: Text = t1.clone()
    assert(t1.equals(ref t2), "clone should be equal to original")
    assert_eq(t1.as_str(), t2.as_str(), "content should match")
    t1.drop()
    t2.drop()
}

@test
func test_clone_is_independent() {
    let t1: Text = Text::from("original")
    let t2: Text = t1.clone()

    t1.push_str(" modified")

    assert_eq(t2.as_str(), "original", "clone should be independent")
    assert_eq(t1.as_str(), "original modified", "original should be modified")
    t1.drop()
    t2.drop()
}

@test
func test_clone_empty_text() {
    let t1: Text = Text::new()
    let t2: Text = t1.clone()
    assert(t2.is_empty(), "clone of empty should be empty")
    t1.drop()
    t2.drop()
}

// ============================================================================
// PROPERTIES TESTS
// ============================================================================

@test
func test_len_empty() {
    let t: Text = Text::new()
    assert_eq(t.len(), 0, "empty text should have length 0")
    t.drop()
}

@test
func test_len_after_push() {
    let t: Text = Text::new()
    t.push_str("abc")
    assert_eq(t.len(), 3, "length should be 3 after pushing 'abc'")
    t.drop()
}

@test
func test_capacity_grows() {
    let t: Text = Text::new()
    let initial_cap: I64 = t.capacity()
    t.push_str("This is a very long string that should cause capacity to grow beyond initial")
    assert(t.capacity() >= t.len(), "capacity should be at least length")
    t.drop()
}

@test
func test_is_empty_true() {
    let t: Text = Text::new()
    assert(t.is_empty(), "new text should be empty")
    t.drop()
}

@test
func test_is_empty_false() {
    let t: Text = Text::from("x")
    assert(not t.is_empty(), "text with content should not be empty")
    t.drop()
}

@test
func test_is_empty_after_clear() {
    let t: Text = Text::from("content")
    t.clear()
    assert(t.is_empty(), "cleared text should be empty")
    t.drop()
}

@test
func test_byte_at_valid_indices() {
    let t: Text = Text::from("ABC")
    assert_eq(t.byte_at(0), 65, "byte_at(0) should be 'A' (65)")
    assert_eq(t.byte_at(1), 66, "byte_at(1) should be 'B' (66)")
    assert_eq(t.byte_at(2), 67, "byte_at(2) should be 'C' (67)")
    t.drop()
}

@test
func test_byte_at_out_of_bounds() {
    let t: Text = Text::from("ABC")
    assert_eq(t.byte_at(3), -1, "byte_at past end should return -1")
    assert_eq(t.byte_at(100), -1, "byte_at way past end should return -1")
    t.drop()
}

@test
func test_byte_at_negative_index() {
    let t: Text = Text::from("ABC")
    assert_eq(t.byte_at(-1), -1, "byte_at negative should return -1")
    t.drop()
}

@test
func test_byte_at_empty_text() {
    let t: Text = Text::new()
    assert_eq(t.byte_at(0), -1, "byte_at on empty should return -1")
    t.drop()
}

// ============================================================================
// MODIFICATION TESTS
// ============================================================================

@test
func test_clear_empties_text() {
    let t: Text = Text::from("Some content")
    t.clear()
    assert_eq(t.len(), 0, "clear should set length to 0")
    assert(t.is_empty(), "cleared text should be empty")
    assert_eq(t.as_str(), "", "cleared text should be empty string")
    t.drop()
}

@test
func test_clear_preserves_capacity() {
    let t: Text = Text::from("This is a long string to ensure heap allocation")
    let cap_before: I64 = t.capacity()
    t.clear()
    assert(t.capacity() >= 0, "capacity should remain valid after clear")
    t.drop()
}

@test
func test_push_single_byte() {
    let t: Text = Text::new()
    t.push(72)   // 'H'
    t.push(105)  // 'i'
    t.push(33)   // '!'
    assert_eq(t.as_str(), "Hi!", "push should append single bytes")
    t.drop()
}

@test
func test_push_builds_string() {
    let t: Text = Text::new()
    t.push(65)  // A
    t.push(66)  // B
    t.push(67)  // C
    assert_eq(t.len(), 3, "should have 3 bytes")
    assert_eq(t.as_str(), "ABC", "should be 'ABC'")
    t.drop()
}

@test
func test_push_str_appends() {
    let t: Text = Text::new()
    t.push_str("Hello")
    t.push_str(", ")
    t.push_str("World!")
    assert_eq(t.as_str(), "Hello, World!", "push_str should append correctly")
    t.drop()
}

@test
func test_push_str_empty_string() {
    let t: Text = Text::from("Hello")
    t.push_str("")
    assert_eq(t.as_str(), "Hello", "pushing empty string should not change content")
    assert_eq(t.len(), 5, "length should remain 5")
    t.drop()
}

@test
func test_reserve_increases_capacity() {
    let t: Text = Text::new()
    t.reserve(100)
    assert(t.capacity() >= 100, "reserve should increase capacity")
    assert_eq(t.len(), 0, "reserve should not change length")
    t.drop()
}

@test
func test_reserve_does_not_shrink() {
    let t: Text = Text::with_capacity(200)
    t.reserve(50)
    assert(t.capacity() >= 200, "reserve should not shrink capacity")
    t.drop()
}

// ============================================================================
// SEARCH TESTS (Part 1: index_of, last_index_of, starts_with, ends_with)
// ============================================================================

@test
func test_index_of_found() {
    let t: Text = Text::from("Hello, World!")
    assert_eq(t.index_of("World"), 7, "index_of should find substring")
    assert_eq(t.index_of("Hello"), 0, "index_of should find at start")
    assert_eq(t.index_of("!"), 12, "index_of should find at end")
    t.drop()
}

@test
func test_index_of_not_found() {
    let t: Text = Text::from("Hello, World!")
    assert_eq(t.index_of("xyz"), -1, "index_of should return -1 for missing")
    assert_eq(t.index_of("hello"), -1, "index_of is case sensitive")
    t.drop()
}

@test
func test_index_of_empty_text() {
    let t: Text = Text::new()
    assert_eq(t.index_of("x"), -1, "index_of on empty should return -1")
    t.drop()
}

@test
func test_last_index_of_found() {
    let t: Text = Text::from("abcabc")
    assert_eq(t.last_index_of("bc"), 4, "last_index_of should find last occurrence")
    assert_eq(t.last_index_of("a"), 3, "last_index_of should find last 'a'")
    t.drop()
}

@test
func test_last_index_of_not_found() {
    let t: Text = Text::from("abcabc")
    assert_eq(t.last_index_of("xyz"), -1, "last_index_of should return -1 for missing")
    t.drop()
}

@test
func test_last_index_of_single_occurrence() {
    let t: Text = Text::from("abcdef")
    assert_eq(t.last_index_of("cd"), 2, "should find single occurrence")
    t.drop()
}

@test
func test_starts_with_true() {
    let t: Text = Text::from("Hello, World!")
    assert(t.starts_with("Hello"), "should start with Hello")
    assert(t.starts_with("H"), "should start with H")
    assert(t.starts_with("Hello, World!"), "should start with itself")
    t.drop()
}

@test
func test_starts_with_false() {
    let t: Text = Text::from("Hello, World!")
    assert(not t.starts_with("World"), "should not start with World")
    assert(not t.starts_with("hello"), "case sensitive")
    t.drop()
}

@test
func test_starts_with_empty_prefix() {
    let t: Text = Text::from("Hello")
    assert(t.starts_with(""), "everything starts with empty string")
    t.drop()
}

@test
func test_ends_with_true() {
    let t: Text = Text::from("Hello, World!")
    assert(t.ends_with("World!"), "should end with World!")
    assert(t.ends_with("!"), "should end with !")
    assert(t.ends_with("Hello, World!"), "should end with itself")
    t.drop()
}

@test
func test_ends_with_false() {
    let t: Text = Text::from("Hello, World!")
    assert(not t.ends_with("Hello"), "should not end with Hello")
    assert(not t.ends_with("world!"), "case sensitive")
    t.drop()
}

@test
func test_ends_with_empty_suffix() {
    let t: Text = Text::from("Hello")
    assert(t.ends_with(""), "everything ends with empty string")
    t.drop()
}
