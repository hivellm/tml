//! Network Standard Library Tests
//!
//! Tests for the networking API (IP addresses, socket addresses, raw sockets)

use test::{assert, assert_eq}
use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr, Ipv6Addr, IpAddr}
use std::net::sys::{RawSocket}
use std::net::error::{NetError, NetErrorKind}

// ============================================================================
// IP Address Tests
// ============================================================================

@test
func test_ipv4_localhost() {
    let localhost: Ipv4Addr = Ipv4Addr::LOCALHOST()
    assert(localhost.is_loopback(), "LOCALHOST should be loopback")
    // Verify to_bits() gives correct 32-bit representation
    let bits: U32 = localhost.to_bits()
    assert_eq(bits, 0x7F000001 as U32)
}

@test
func test_ipv4_unspecified() {
    let unspec: Ipv4Addr = Ipv4Addr::UNSPECIFIED()
    assert(unspec.is_unspecified(), "UNSPECIFIED should be unspecified")
    // Verify to_bits() gives zero
    let bits: U32 = unspec.to_bits()
    assert_eq(bits, 0 as U32)
}

@test
func test_ipv4_broadcast() {
    let broadcast: Ipv4Addr = Ipv4Addr::BROADCAST()
    assert(broadcast.is_broadcast(), "BROADCAST should be broadcast")
}

@test
func test_ipv4_from_octets() {
    let ip: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    // Verify to_bits() gives correct 32-bit representation
    let bits: U32 = ip.to_bits()
    assert_eq(bits, 0xC0A80101 as U32)  // 192.168.1.1 in hex
    assert(ip.is_private(), "192.168.x.x should be private")
}

@test
func test_ipv4_from_bits() {
    let ip: Ipv4Addr = Ipv4Addr::from_bits(0xC0A80101 as U32)
    let bits: U32 = ip.to_bits()
    assert_eq(bits, 0xC0A80101 as U32)
    assert(ip.is_private(), "192.168.1.1 should be private")
}

@test
func test_ipv4_octets() {
    let ip: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    let octs: [U8; 4] = ip.octets()
    assert_eq(octs[0], 192 as U8)
    assert_eq(octs[1], 168 as U8)
    assert_eq(octs[2], 1 as U8)
    assert_eq(octs[3], 1 as U8)
}

// ============================================================================
// Ipv6 Address Tests
// ============================================================================

@test
func test_ipv6_localhost() {
    let localhost: Ipv6Addr = Ipv6Addr::LOCALHOST()
    assert(localhost.is_loopback(), "LOCALHOST should be loopback")
    assert(not localhost.is_unspecified(), "LOCALHOST should not be unspecified")
}

@test
func test_ipv6_unspecified() {
    let unspec: Ipv6Addr = Ipv6Addr::UNSPECIFIED()
    assert(unspec.is_unspecified(), "UNSPECIFIED should be unspecified")
    assert(not unspec.is_loopback(), "UNSPECIFIED should not be loopback")
}

@test
func test_ipv6_new() {
    let addr: Ipv6Addr = Ipv6Addr::new(0x2001, 0x0db8, 0, 0, 0, 0, 0, 1)
    assert(not addr.is_loopback(), "Custom address should not be loopback")
    assert(not addr.is_unspecified(), "Custom address should not be unspecified")
}

@test
func test_ipv6_segments() {
    let addr: Ipv6Addr = Ipv6Addr::new(0x2001, 0x0db8, 0x1234, 0x5678, 0xabcd, 0xef01, 0x2345, 0x6789)
    let segs: [U16; 8] = addr.segments()
    assert_eq(segs[0], 0x2001 as U16)
    assert_eq(segs[1], 0x0db8 as U16)
    assert_eq(segs[2], 0x1234 as U16)
    assert_eq(segs[3], 0x5678 as U16)
    assert_eq(segs[4], 0xabcd as U16)
    assert_eq(segs[5], 0xef01 as U16)
    assert_eq(segs[6], 0x2345 as U16)
    assert_eq(segs[7], 0x6789 as U16)
}

// ============================================================================
// IpAddr Enum Tests
// ============================================================================

@test
func test_ipaddr_v4_basic() {
    let v4: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let addr: IpAddr = IpAddr::V4(v4)
    assert(addr.is_ipv4(), "Should be IPv4")
    assert(not addr.is_ipv6(), "Should not be IPv6")
}

@test
func test_ipaddr_v6_basic() {
    let v6: Ipv6Addr = Ipv6Addr::LOCALHOST()
    let addr: IpAddr = IpAddr::V6(v6)
    assert(not addr.is_ipv4(), "Should not be IPv4")
    assert(addr.is_ipv6(), "Should be IPv6")
}

@test
func test_ipaddr_v4_loopback() {
    let v4: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let addr: IpAddr = IpAddr::V4(v4)
    assert(addr.is_loopback(), "V4 localhost should be loopback")
}

@test
func test_ipaddr_v6_loopback() {
    let v6: Ipv6Addr = Ipv6Addr::LOCALHOST()
    let addr: IpAddr = IpAddr::V6(v6)
    assert(addr.is_loopback(), "V6 localhost should be loopback")
}

// ============================================================================
// Socket Address Tests
// ============================================================================

@test
func test_socket_addr_v4_creation() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)
    assert(addr.ip().is_loopback(), "IP should be loopback")
}

@test
func test_socket_addr_port_change() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    var addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)

    addr.set_port(9090 as U16)
    assert_eq(addr.port(), 9090 as U16)
}

@test
func test_socket_addr_enum() {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)

    assert(addr.is_ipv4(), "Should be IPv4")
    assert(not addr.is_ipv6(), "Should not be IPv6")
    assert_eq(addr.port(), 80 as U16)
}

// ============================================================================
// RawSocket Tests
// ============================================================================

@test
func test_raw_socket_tcp_creation() {
    let result: Outcome[RawSocket, NetError] = RawSocket::tcp()
    when result {
        Ok(sock) => {
            assert(sock.is_valid(), "TCP socket should be valid")
        },
        Err(_) => {
            // Socket creation may fail on some systems (e.g., sandboxed environments)
            // This is acceptable - just verify we can handle the error case
        },
    }
}

@test
func test_raw_socket_udp_creation() {
    let result: Outcome[RawSocket, NetError] = RawSocket::udp()
    when result {
        Ok(sock) => {
            assert(sock.is_valid(), "UDP socket should be valid")
        },
        Err(_) => {
            // Socket creation may fail on some systems
        },
    }
}

// ============================================================================
// Error Type Tests
// ============================================================================

@test
func test_net_error_kinds() {
    let conn_refused: NetError = NetError::new(NetErrorKind::ConnectionRefused())
    assert(conn_refused.is_connection_refused(), "Should be connection refused")

    let would_block: NetError = NetError::new(NetErrorKind::WouldBlock())
    assert(would_block.is_would_block(), "Should be would block")

    let not_connected: NetError = NetError::new(NetErrorKind::NotConnected())
    assert(not_connected.is_not_connected(), "Should be not connected")
}
