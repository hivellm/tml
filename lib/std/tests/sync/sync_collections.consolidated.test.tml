// Consolidated Lock-Free Collections and Arc tests
// Total @test count: 36
// Sources: lockfree.test.tml, lockfree_queue.test.tml, lockfree_stack.test.tml,
//          lockfree_stack_peek.test.tml, arc.test.tml, arc_methods.test.tml
use test::{assert, assert_eq}
use std::sync::{LockFreeQueue, LockFreeStack, Arc, Weak}
use std::sync::Mutex

// ============================================================================
// Helper Types
// ============================================================================

type SimpleData {
    value: I32,
}

type ArcPoint { x: I32, y: I32 }

// ============================================================================
// LockFreeQueue Tests (from lockfree.test.tml)
// ============================================================================

@test
func test_queue_new() -> I32 {
    let queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    assert(queue.is_empty(), "new queue should be empty")
    assert_eq(queue.len(), 0 as I64, "new queue len should be 0")
    return 0
}

@test
func test_queue_push_single() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(42)
    assert(not queue.is_empty(), "queue should not be empty after push")
    assert_eq(queue.len(), 1 as I64, "queue len should be 1")
    return 0
}

@test
func test_queue_push_pop_single() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(42)
    let result: Maybe[I32] = queue.pop()
    when result {
        Just(v) => assert_eq(v, 42, "popped value should be 42"),
        Nothing => assert(false, "pop should return Just"),
    }
    assert(queue.is_empty(), "queue should be empty after pop")
    return 0
}

@test
func test_queue_fifo_order() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(1)
    queue.push(2)
    queue.push(3)
    let r1: Maybe[I32] = queue.pop()
    when r1 {
        Just(v) => assert_eq(v, 1, "first pop should be 1"),
        Nothing => assert(false, "pop should return Just"),
    }
    let r2: Maybe[I32] = queue.pop()
    when r2 {
        Just(v) => assert_eq(v, 2, "second pop should be 2"),
        Nothing => assert(false, "pop should return Just"),
    }
    let r3: Maybe[I32] = queue.pop()
    when r3 {
        Just(v) => assert_eq(v, 3, "third pop should be 3"),
        Nothing => assert(false, "pop should return Just"),
    }
    return 0
}

@test
func test_queue_pop_empty() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    let result: Maybe[I32] = queue.pop()
    when result {
        Just(_) => assert(false, "pop on empty should return Nothing"),
        Nothing => assert(true, "pop on empty returns Nothing"),
    }
    return 0
}

@test
func test_queue_multiple_push_pop() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    var i: I32 = 0
    loop (i < 5) {
        queue.push(i * 10)
        i = i + 1
    }
    assert_eq(queue.len(), 5 as I64, "queue should have 5 elements")
    i = 0
    loop (i < 5) {
        let result: Maybe[I32] = queue.pop()
        when result {
            Just(v) => assert_eq(v, i * 10, "values should match in FIFO order"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i + 1
    }
    assert(queue.is_empty(), "queue should be empty after all pops")
    return 0
}

@test
func test_queue_len_updates() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    assert_eq(queue.len(), 0 as I64, "initial len 0")
    queue.push(1)
    assert_eq(queue.len(), 1 as I64, "len 1 after push")
    queue.push(2)
    assert_eq(queue.len(), 2 as I64, "len 2 after push")
    queue.pop()
    assert_eq(queue.len(), 1 as I64, "len 1 after pop")
    queue.pop()
    assert_eq(queue.len(), 0 as I64, "len 0 after pop")
    return 0
}

@test
func test_queue_large_batch() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    var i: I32 = 0
    loop (i < 100) {
        queue.push(i)
        i = i + 1
    }
    assert_eq(queue.len(), 100 as I64, "queue should have 100 elements")
    i = 0
    loop (i < 100) {
        let result: Maybe[I32] = queue.pop()
        when result {
            Just(v) => assert_eq(v, i, "FIFO order maintained"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i + 1
    }
    return 0
}

// From lockfree_queue.test.tml (uses different import style)
@test
func test_queue_new_empty() -> I32 {
    let q: LockFreeQueue[I32] = LockFreeQueue::new()
    assert(q.is_empty(), "new queue should be empty")
    assert_eq(q.len(), 0 as I64, "new queue len is 0")
    return 0
}

@test
func test_queue_push_pop() -> I32 {
    var q: LockFreeQueue[I32] = LockFreeQueue::new()
    q.push(10 as I32)
    q.push(20 as I32)
    q.push(30 as I32)
    assert_eq(q.len(), 3 as I64, "len after 3 pushes")
    assert(not q.is_empty(), "queue should not be empty")
    return 0
}

@test
func test_queue_fifo_order_v2() -> I32 {
    var q: LockFreeQueue[I32] = LockFreeQueue::new()
    q.push(1 as I32)
    q.push(2 as I32)
    q.push(3 as I32)
    let first: Maybe[I32] = q.pop()
    assert(first.is_just(), "pop should return Just")
    let second: Maybe[I32] = q.pop()
    assert(second.is_just(), "second pop should return Just")
    let third: Maybe[I32] = q.pop()
    assert(third.is_just(), "third pop should return Just")
    let empty: Maybe[I32] = q.pop()
    assert(empty.is_nothing(), "pop on empty should return Nothing")
    return 0
}

// ============================================================================
// LockFreeStack Tests (from lockfree.test.tml)
// ============================================================================

@test
func test_stack_new() -> I32 {
    let stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    assert(stack.is_empty(), "new stack should be empty")
    assert_eq(stack.len(), 0 as I64, "new stack len should be 0")
    return 0
}

@test
func test_stack_push_single() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(42)
    assert(not stack.is_empty(), "stack should not be empty after push")
    assert_eq(stack.len(), 1 as I64, "stack len should be 1")
    return 0
}

@test
func test_stack_push_pop_single() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(42)
    let result: Maybe[I32] = stack.pop()
    when result {
        Just(v) => assert_eq(v, 42, "popped value should be 42"),
        Nothing => assert(false, "pop should return Just"),
    }
    assert(stack.is_empty(), "stack should be empty after pop")
    return 0
}

@test
func test_stack_lifo_order() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    let r1: Maybe[I32] = stack.pop()
    when r1 {
        Just(v) => assert_eq(v, 3, "first pop should be 3 (LIFO)"),
        Nothing => assert(false, "pop should return Just"),
    }
    let r2: Maybe[I32] = stack.pop()
    when r2 {
        Just(v) => assert_eq(v, 2, "second pop should be 2"),
        Nothing => assert(false, "pop should return Just"),
    }
    let r3: Maybe[I32] = stack.pop()
    when r3 {
        Just(v) => assert_eq(v, 1, "third pop should be 1"),
        Nothing => assert(false, "pop should return Just"),
    }
    return 0
}

@test
func test_stack_pop_empty() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    let result: Maybe[I32] = stack.pop()
    when result {
        Just(_) => assert(false, "pop on empty should return Nothing"),
        Nothing => assert(true, "pop on empty returns Nothing"),
    }
    return 0
}

@test
func test_stack_multiple_push_pop() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    var i: I32 = 0
    loop (i < 5) {
        stack.push(i * 10)
        i = i + 1
    }
    assert_eq(stack.len(), 5 as I64, "stack should have 5 elements")
    i = 4
    loop (i >= 0) {
        let result: Maybe[I32] = stack.pop()
        when result {
            Just(v) => assert_eq(v, i * 10, "values should match in LIFO order"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i - 1
    }
    assert(stack.is_empty(), "stack should be empty after all pops")
    return 0
}

@test
func test_stack_len_updates() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    assert_eq(stack.len(), 0 as I64, "initial len 0")
    stack.push(1)
    assert_eq(stack.len(), 1 as I64, "len 1 after push")
    stack.push(2)
    assert_eq(stack.len(), 2 as I64, "len 2 after push")
    stack.pop()
    assert_eq(stack.len(), 1 as I64, "len 1 after pop")
    stack.pop()
    assert_eq(stack.len(), 0 as I64, "len 0 after pop")
    return 0
}

@test
func test_stack_clear() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    assert_eq(stack.len(), 3 as I64, "len 3 before clear")
    stack.clear()
    assert(stack.is_empty(), "stack should be empty after clear")
    assert_eq(stack.len(), 0 as I64, "len 0 after clear")
    return 0
}

@test
func test_stack_large_batch() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    var i: I32 = 0
    loop (i < 100) {
        stack.push(i)
        i = i + 1
    }
    assert_eq(stack.len(), 100 as I64, "stack should have 100 elements")
    i = 99
    loop (i >= 0) {
        let result: Maybe[I32] = stack.pop()
        when result {
            Just(v) => assert_eq(v, i, "LIFO order maintained"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i - 1
    }
    return 0
}

// From lockfree_stack.test.tml (uses different import style)
@test
func test_stack_new_empty() -> I32 {
    let s: LockFreeStack[I32] = LockFreeStack::new()
    assert(s.is_empty(), "new stack should be empty")
    assert_eq(s.len(), 0 as I64, "new stack len is 0")
    return 0
}

@test
func test_stack_push_pop() -> I32 {
    var s: LockFreeStack[I32] = LockFreeStack::new()
    s.push(10 as I32)
    s.push(20 as I32)
    s.push(30 as I32)
    assert_eq(s.len(), 3 as I64, "len after 3 pushes")
    assert(not s.is_empty(), "stack should not be empty")
    return 0
}

@test
func test_stack_lifo_order_v2() -> I32 {
    var s: LockFreeStack[I32] = LockFreeStack::new()
    s.push(1 as I32)
    s.push(2 as I32)
    s.push(3 as I32)
    let top: Maybe[I32] = s.pop()
    assert(top.is_just(), "pop should return Just")
    let second: Maybe[I32] = s.pop()
    assert(second.is_just(), "second pop should return Just")
    let third: Maybe[I32] = s.pop()
    assert(third.is_just(), "third pop should return Just")
    let empty: Maybe[I32] = s.pop()
    assert(empty.is_nothing(), "pop on empty should return Nothing")
    return 0
}

// From lockfree_stack_peek.test.tml
@test
func test_stack_peek_empty() -> I32 {
    let s: LockFreeStack[I32] = LockFreeStack::new()
    let r: Maybe[ref I32] = s.peek()
    assert(r.is_nothing(), "peek on empty stack is Nothing")
    return 0
}

@test
func test_stack_peek_nonempty() -> I32 {
    var s: LockFreeStack[I32] = LockFreeStack::new()
    s.push(42 as I32)
    s.push(99 as I32)
    let r: Maybe[ref I32] = s.peek()
    assert(r.is_just(), "peek on nonempty stack is Just")
    return 0
}

// ============================================================================
// Arc Creation Tests (from arc.test.tml)
// ============================================================================

@test
func test_arc_new_i32() -> I32 {
    let arc: Arc[I32] = Arc::new(42)
    return 0
}

@test
func test_arc_new_struct() -> I32 {
    let arc: Arc[SimpleData] = Arc::new(SimpleData { value: 42 })
    return 0
}

@test
func test_arc_duplicate_i32() -> I32 {
    let arc1: Arc[I32] = Arc::new(42)
    let arc2: Arc[I32] = arc1.duplicate()
    return 0
}

@test
func test_arc_duplicate_struct() -> I32 {
    let arc1: Arc[SimpleData] = Arc::new(SimpleData { value: 42 })
    let arc2: Arc[SimpleData] = arc1.duplicate()
    return 0
}

@test
func test_arc_with_mutex() -> I32 {
    let a: Arc[Mutex[I32]] = Arc::new(Mutex::new(42))
    return 0
}

// ============================================================================
// Arc Methods (from arc_methods.test.tml)
// ============================================================================

@test
func test_arc_strong_count_initial() -> I32 {
    let arc: Arc[I32] = Arc::new(42)
    assert_eq(arc.strong_count(), 1 as I64)
    return 0
}

@test
func test_arc_strong_count_after_duplicate() -> I32 {
    let arc1: Arc[I32] = Arc::new(42)
    let arc2: Arc[I32] = arc1.duplicate()
    assert_eq(arc1.strong_count(), 2 as I64)
    assert_eq(arc2.strong_count(), 2 as I64)
    return 0
}

@test
func test_arc_strong_count_after_multiple_duplicates() -> I32 {
    let arc1: Arc[I32] = Arc::new(42)
    let arc2: Arc[I32] = arc1.duplicate()
    let arc3: Arc[I32] = arc1.duplicate()
    assert_eq(arc1.strong_count(), 3 as I64)
    return 0
}

@test
func test_arc_downgrade() -> I32 {
    let arc: Arc[I32] = Arc::new(42)
    let weak: Weak[I32] = arc.downgrade()
    assert_eq(arc.weak_count(), 1 as I64)
    return 0
}

@test
func test_arc_get() -> I32 {
    let arc: Arc[I32] = Arc::new(42)
    let val: ref I32 = arc.get()
    assert_eq(*val, 42)
    return 0
}

@test
func test_arc_with_struct_strong_count() -> I32 {
    let arc1: Arc[ArcPoint] = Arc::new(ArcPoint { x: 1, y: 2 })
    let arc2: Arc[ArcPoint] = arc1.duplicate()
    assert_eq(arc1.strong_count(), 2 as I64)
    return 0
}

@test
func test_arc_with_struct_weak() -> I32 {
    let arc: Arc[ArcPoint] = Arc::new(ArcPoint { x: 1, y: 2 })
    let weak: Weak[ArcPoint] = arc.downgrade()
    assert_eq(arc.weak_count(), 1 as I64)
    return 0
}
