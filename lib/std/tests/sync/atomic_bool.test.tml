// Test: AtomicBool operations (v2)
use test::{assert, assert_eq}
use std::sync::{AtomicBool, Ordering}

// ============================================================================
// AtomicBool Tests
// ============================================================================

@test
func test_atomic_bool_new() -> I32 {
    let flag: AtomicBool = AtomicBool::new(true)
    assert(flag.load(Ordering::Relaxed), "new bool should be true")
    return 0
}

@test
func test_atomic_bool_store_load() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    flag.store(true, Ordering::Relaxed)
    assert(flag.load(Ordering::Relaxed), "loaded value should be true")
    return 0
}

@test
func test_atomic_bool_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.swap(true, Ordering::Relaxed)
    assert(not old, "swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "new value should be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_success() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert(not v, "Ok should contain old value false"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_fail() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(_) => assert(false, "compare_exchange should fail"),
        Err(v) => assert(v, "Err should contain actual value true"),
    }
    assert(flag.load(Ordering::Relaxed), "value should still be true")
    return 0
}

@test
func test_atomic_bool_compare_and_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.compare_and_swap(false, true, Ordering::SeqCst)
    assert(not old, "compare_and_swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_fetch_and() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_and(false, Ordering::Relaxed)
    assert(old, "fetch_and should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true AND false = false")
    return 0
}

@test
func test_atomic_bool_fetch_or() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.fetch_or(true, Ordering::Relaxed)
    assert(not old, "fetch_or should return old value false")
    assert(flag.load(Ordering::Relaxed), "false OR true = true")
    return 0
}

@test
func test_atomic_bool_fetch_xor() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_xor(true, Ordering::Relaxed)
    assert(old, "fetch_xor should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true XOR true = false")
    return 0
}

@test
func test_atomic_bool_is_lock_free() -> I32 {
    let flag: AtomicBool = AtomicBool::new(false)
    assert(flag.is_lock_free(), "AtomicBool should be lock-free")
    return 0
}

@test
func test_atomic_bool_lock_free_constant() -> I32 {
    assert(AtomicBool::LOCK_FREE, "AtomicBool::LOCK_FREE should be true")
    return 0
}
