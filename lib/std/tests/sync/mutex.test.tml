// Mutex and RwLock tests
// Tests locking primitives and RAII guards
use test
use std::sync::{Mutex, MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard}

// ============================================================================
// Mutex Tests
// ============================================================================

@test
func test_mutex_new() {
    let mutex: Mutex[I32] = Mutex::new(42)
    assert(not mutex.is_locked())
}

@test
func test_mutex_lock_and_read() {
    let mutex: Mutex[I32] = Mutex::new(100)

    {
        let guard: MutexGuard[I32] = mutex.lock()
        assert_eq(*guard.get(), 100)
    }  // guard dropped here, lock released

}

@test
func test_mutex_lock_and_write() {
    let mutex: Mutex[I32] = Mutex::new(0)

    {
        var guard: MutexGuard[I32] = mutex.lock()
        *guard.get_mut() = 42
    }

    // Lock again to verify the write
    {
        let guard: MutexGuard[I32] = mutex.lock()
        assert_eq(*guard.get(), 42)
    }

}

@test
func test_mutex_try_lock_success() {
    let mutex: Mutex[I32] = Mutex::new(10)

    when mutex.try_lock() {
        Just(guard) => {
            assert_eq(*guard.get(), 10)
        },
        Nothing => panic("try_lock should succeed when mutex is unlocked")
    }
}

@test
func test_mutex_is_locked() {
    let mutex: Mutex[I32] = Mutex::new(0)

    assert(not mutex.is_locked())

    {
        let guard: MutexGuard[I32] = mutex.lock()
        // Note: is_locked checks the raw state, may vary by implementation
        // For now just verify we can lock and unlock
    }

    assert(not mutex.is_locked())
}

@test
func test_mutex_into_inner() {
    let mutex: Mutex[I32] = Mutex::new(999)

    // Modify the value
    {
        var guard: MutexGuard[I32] = mutex.lock()
        *guard.get_mut() = 123
    }

    // Consume mutex and get inner value
    let value: I32 = mutex.into_inner()
    assert_eq(value, 123)
}

@test
func test_mutex_get_mut() {
    var mutex: Mutex[I32] = Mutex::new(50)

    // get_mut requires exclusive access to the mutex (not locked)
    *mutex.get_mut() = 75

    let guard: MutexGuard[I32] = mutex.lock()
    assert_eq(*guard.get(), 75)
}

// ============================================================================
// RwLock Tests
// ============================================================================

@test
func test_rwlock_new() {
    let rwlock: RwLock[I32] = RwLock::new(42)
}

@test
func test_rwlock_read() {
    let rwlock: RwLock[I32] = RwLock::new(100)

    {
        let guard: RwLockReadGuard[I32] = rwlock.read()
        assert_eq(*guard.get(), 100)
    }

}

@test
func test_rwlock_multiple_readers() {
    let rwlock: RwLock[I32] = RwLock::new(55)

    {
        let r1: RwLockReadGuard[I32] = rwlock.read()
        let r2: RwLockReadGuard[I32] = rwlock.read()

        // Both readers see the same value
        assert_eq(*r1.get(), 55)
        assert_eq(*r2.get(), 55)
    }

}

@test
func test_rwlock_write() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    {
        var guard: RwLockWriteGuard[I32] = rwlock.write()
        *guard.get_mut() = 42
    }

    // Verify the write
    {
        let guard: RwLockReadGuard[I32] = rwlock.read()
        assert_eq(*guard.get(), 42)
    }

}

@test
func test_rwlock_try_read_success() {
    let rwlock: RwLock[I32] = RwLock::new(77)

    when rwlock.try_read() {
        Just(guard) => {
            assert_eq(*guard.get(), 77)
        },
        Nothing => panic("try_read should succeed")
    }

}

@test
func test_rwlock_try_write_success() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    when rwlock.try_write() {
        Just(guard) => {
            *guard.get_mut() = 88
        },
        Nothing => panic("try_write should succeed")
    }

    let r: RwLockReadGuard[I32] = rwlock.read()
    assert_eq(*r.get(), 88)
}

@test
func test_rwlock_into_inner() {
    let rwlock: RwLock[I32] = RwLock::new(123)

    {
        var w: RwLockWriteGuard[I32] = rwlock.write()
        *w.get_mut() = 456
    }

    let value: I32 = rwlock.into_inner()
    assert_eq(value, 456)
}

// ============================================================================
// Guard Drop Tests (RAII)
// ============================================================================

@test
func test_mutex_guard_drop_releases_lock() {
    let mutex: Mutex[I32] = Mutex::new(0)

    // Scope 1: acquire lock
    {
        let guard: MutexGuard[I32] = mutex.lock()
        // lock is held
    }
    // guard dropped, lock released

    // Scope 2: should be able to acquire lock again
    {
        let guard: MutexGuard[I32] = mutex.lock()
        // if we get here, lock was released
    }

}

@test
func test_rwlock_read_guard_drop() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    {
        let r: RwLockReadGuard[I32] = rwlock.read()
    }
    // read guard dropped

    // Should be able to write now
    {
        var w: RwLockWriteGuard[I32] = rwlock.write()
        *w.get_mut() = 1
    }

}

@test
func test_rwlock_write_guard_drop() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    {
        var w: RwLockWriteGuard[I32] = rwlock.write()
        *w.get_mut() = 42
    }
    // write guard dropped

    // Should be able to read now
    {
        let r: RwLockReadGuard[I32] = rwlock.read()
        assert_eq(*r.get(), 42)
    }

}

// ============================================================================
// Additional Edge Case Tests
// ============================================================================

@test
func test_mutex_with_i64() {
    // Test Mutex with a different type
    let mutex: Mutex[I64] = Mutex::new(1000000000000 as I64)

    {
        let guard: MutexGuard[I64] = mutex.lock()
        assert_eq(*guard.get(), 1000000000000 as I64)
    }

}

@test
func test_mutex_with_bool() {
    let mutex: Mutex[Bool] = Mutex::new(false)

    {
        var guard: MutexGuard[Bool] = mutex.lock()
        *guard.get_mut() = true
    }

    {
        let guard: MutexGuard[Bool] = mutex.lock()
        assert(*guard.get())
    }

}

@test
func test_mutex_sequential_locks() {
    // Test multiple sequential lock/unlock cycles
    let mutex: Mutex[I32] = Mutex::new(0)

    var i: I32 = 0
    loop (i < 5) {
        {
            var guard: MutexGuard[I32] = mutex.lock()
            *guard.get_mut() = *guard.get() + 1
        }
        i = i + 1
    }

    {
        let guard: MutexGuard[I32] = mutex.lock()
        assert_eq(*guard.get(), 5)
    }

}

@test
func test_rwlock_with_i64() {
    let rwlock: RwLock[I64] = RwLock::new(9999999999 as I64)

    {
        let r: RwLockReadGuard[I64] = rwlock.read()
        assert_eq(*r.get(), 9999999999 as I64)
    }

}

@test
func test_rwlock_read_after_write() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    // Write
    {
        var w: RwLockWriteGuard[I32] = rwlock.write()
        *w.get_mut() = 100
    }

    // Multiple reads after write
    {
        let r1: RwLockReadGuard[I32] = rwlock.read()
        let r2: RwLockReadGuard[I32] = rwlock.read()
        assert_eq(*r1.get(), 100)
        assert_eq(*r2.get(), 100)
    }

}

@test
func test_rwlock_sequential_writes() {
    let rwlock: RwLock[I32] = RwLock::new(0)

    var i: I32 = 0
    loop (i < 3) {
        {
            var w: RwLockWriteGuard[I32] = rwlock.write()
            *w.get_mut() = *w.get() + 10
        }
        i = i + 1
    }

    {
        let r: RwLockReadGuard[I32] = rwlock.read()
        assert_eq(*r.get(), 30)
    }

}
