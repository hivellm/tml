// Atomic types tests - AtomicBool, AtomicI32, AtomicI64, AtomicU32, AtomicU64, AtomicUsize, AtomicIsize, AtomicPtr
// Also includes Ordering method tests
use test::{assert, assert_eq}
use std::sync::{AtomicBool, AtomicI32, AtomicI64, AtomicU32, AtomicU64, AtomicUsize, AtomicIsize, AtomicPtr, Ordering}
// Note: fence and compiler_fence are declared but codegen not yet implemented
// use std::sync::{fence, compiler_fence}

// ============================================================================
// AtomicBool Tests
// ============================================================================

@test
func test_atomic_bool_new() -> I32 {
    let flag: AtomicBool = AtomicBool::new(true)
    assert(flag.load(Ordering::Relaxed), "new bool should be true")
    return 0
}

@test
func test_atomic_bool_store_load() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    flag.store(true, Ordering::Relaxed)
    assert(flag.load(Ordering::Relaxed), "loaded value should be true")
    return 0
}

@test
func test_atomic_bool_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.swap(true, Ordering::Relaxed)
    assert(not old, "swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "new value should be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_success() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert(not v, "Ok should contain old value false"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_fail() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(_) => assert(false, "compare_exchange should fail"),
        Err(v) => assert(v, "Err should contain actual value true"),
    }
    assert(flag.load(Ordering::Relaxed), "value should still be true")
    return 0
}

@test
func test_atomic_bool_compare_and_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.compare_and_swap(false, true, Ordering::SeqCst)
    assert(not old, "compare_and_swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_fetch_and() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_and(false, Ordering::Relaxed)
    assert(old, "fetch_and should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true AND false = false")
    return 0
}

@test
func test_atomic_bool_fetch_or() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.fetch_or(true, Ordering::Relaxed)
    assert(not old, "fetch_or should return old value false")
    assert(flag.load(Ordering::Relaxed), "false OR true = true")
    return 0
}

@test
func test_atomic_bool_fetch_xor() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_xor(true, Ordering::Relaxed)
    assert(old, "fetch_xor should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true XOR true = false")
    return 0
}

@test
func test_atomic_bool_is_lock_free() -> I32 {
    let flag: AtomicBool = AtomicBool::new(false)
    assert(flag.is_lock_free(), "AtomicBool should be lock-free")
    return 0
}

@test
func test_atomic_bool_lock_free_constant() -> I32 {
    assert(AtomicBool::LOCK_FREE, "AtomicBool::LOCK_FREE should be true")
    return 0
}

// ============================================================================
// AtomicI32 Tests
// ============================================================================

@test
func test_atomic_i32_new() -> I32 {
    let counter: AtomicI32 = AtomicI32::new(42)
    assert_eq(counter.load(Ordering::Relaxed), 42, "new i32 should be 42")
    return 0
}

@test
func test_atomic_i32_negative() -> I32 {
    let counter: AtomicI32 = AtomicI32::new(-100)
    assert_eq(counter.load(Ordering::Relaxed), -100, "should handle negative values")
    return 0
}

@test
func test_atomic_i32_store_load() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(0)
    counter.store(100, Ordering::Relaxed)
    assert_eq(counter.load(Ordering::Relaxed), 100, "loaded value should be 100")
    return 0
}

@test
func test_atomic_i32_swap() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(-10)
    let old: I32 = counter.swap(10, Ordering::Relaxed)
    assert_eq(old, -10, "swap should return old value -10")
    assert_eq(counter.load(Ordering::Relaxed), 10, "new value should be 10")
    return 0
}

@test
func test_atomic_i32_fetch_add() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(5)
    let old: I32 = counter.fetch_add(3, Ordering::Relaxed)
    assert_eq(old, 5, "fetch_add should return old value 5")
    assert_eq(counter.load(Ordering::Relaxed), 8, "5 + 3 = 8")
    return 0
}

@test
func test_atomic_i32_fetch_sub() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old: I32 = counter.fetch_sub(3, Ordering::Relaxed)
    assert_eq(old, 10, "fetch_sub should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 7, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_i32_compare_exchange_success() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let result: Outcome[I32, I32] = counter.compare_exchange(10, 20, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 10, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 20, "value should now be 20")
    return 0
}

@test
func test_atomic_i32_compare_and_swap() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old: I32 = counter.compare_and_swap(10, 20, Ordering::SeqCst)
    assert_eq(old, 10, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 20, "value should now be 20")
    return 0
}

@test
func test_atomic_i32_fetch_max() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(-10)
    let old1: I32 = counter.fetch_max(5, Ordering::Relaxed)
    assert_eq(old1, -10, "fetch_max(-10, 5) should return -10")
    assert_eq(counter.load(Ordering::Relaxed), 5, "max(-10, 5) = 5")
    return 0
}

@test
func test_atomic_i32_fetch_min() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old1: I32 = counter.fetch_min(-5, Ordering::Relaxed)
    assert_eq(old1, 10, "fetch_min(10, -5) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), -5, "min(10, -5) = -5")
    return 0
}

@test
func test_atomic_i32_lock_free_constant() -> I32 {
    assert(AtomicI32::LOCK_FREE, "AtomicI32::LOCK_FREE should be true")
    return 0
}

// ============================================================================
// AtomicI64 Tests
// ============================================================================

@test
func test_atomic_i64_new() -> I32 {
    let counter: AtomicI64 = AtomicI64::new(1000000000000 as I64)
    assert_eq(counter.load(Ordering::Relaxed), 1000000000000 as I64, "new i64 should be 1T")
    return 0
}

@test
func test_atomic_i64_negative() -> I32 {
    let counter: AtomicI64 = AtomicI64::new(-1000000000000 as I64)
    assert_eq(counter.load(Ordering::Relaxed), -1000000000000 as I64, "should handle negative")
    return 0
}

@test
func test_atomic_i64_fetch_add() -> I32 {
    var counter: AtomicI64 = AtomicI64::new(100 as I64)
    let old: I64 = counter.fetch_add(50 as I64, Ordering::Relaxed)
    assert_eq(old, 100 as I64, "fetch_add should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 150 as I64, "100 + 50 = 150")
    return 0
}

@test
func test_atomic_i64_compare_and_swap() -> I32 {
    var counter: AtomicI64 = AtomicI64::new(100 as I64)
    let old: I64 = counter.compare_and_swap(100 as I64, 200 as I64, Ordering::SeqCst)
    assert_eq(old, 100 as I64, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 200 as I64, "value should now be 200")
    return 0
}

@test
func test_atomic_i64_lock_free_constant() -> I32 {
    assert(AtomicI64::LOCK_FREE, "AtomicI64::LOCK_FREE should be true")
    return 0
}

// ============================================================================
// AtomicU32 Tests
// ============================================================================

@test
func test_atomic_u32_new() -> I32 {
    let counter: AtomicU32 = AtomicU32::new(42 as U32)
    assert_eq(counter.load(Ordering::Relaxed), 42 as U32, "new u32 should be 42")
    return 0
}

@test
func test_atomic_u32_store_load() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0 as U32)
    counter.store(100 as U32, Ordering::Relaxed)
    assert_eq(counter.load(Ordering::Relaxed), 100 as U32, "loaded value should be 100")
    return 0
}

@test
func test_atomic_u32_swap() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old: U32 = counter.swap(20 as U32, Ordering::Relaxed)
    assert_eq(old, 10 as U32, "swap should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 20 as U32, "new value should be 20")
    return 0
}

@test
func test_atomic_u32_fetch_add() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(5 as U32)
    let old: U32 = counter.fetch_add(3 as U32, Ordering::Relaxed)
    assert_eq(old, 5 as U32, "fetch_add should return old value 5")
    assert_eq(counter.load(Ordering::Relaxed), 8 as U32, "5 + 3 = 8")
    return 0
}

@test
func test_atomic_u32_fetch_sub() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old: U32 = counter.fetch_sub(3 as U32, Ordering::Relaxed)
    assert_eq(old, 10 as U32, "fetch_sub should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 7 as U32, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_u32_fetch_and() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0b1111 as U32)
    let old: U32 = counter.fetch_and(0b1010 as U32, Ordering::Relaxed)
    assert_eq(old, 0b1111 as U32, "fetch_and should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 0b1010 as U32, "1111 & 1010 = 1010")
    return 0
}

@test
func test_atomic_u32_fetch_or() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0b1010 as U32)
    let old: U32 = counter.fetch_or(0b0101 as U32, Ordering::Relaxed)
    assert_eq(old, 0b1010 as U32, "fetch_or should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 0b1111 as U32, "1010 | 0101 = 1111")
    return 0
}

@test
func test_atomic_u32_fetch_xor() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0b1111 as U32)
    let old: U32 = counter.fetch_xor(0b1010 as U32, Ordering::Relaxed)
    assert_eq(old, 0b1111 as U32, "fetch_xor should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 0b0101 as U32, "1111 ^ 1010 = 0101")
    return 0
}

@test
func test_atomic_u32_fetch_max() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old1: U32 = counter.fetch_max(5 as U32, Ordering::Relaxed)
    assert_eq(old1, 10 as U32, "fetch_max(10, 5) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), 10 as U32, "max(10, 5) = 10")

    let old2: U32 = counter.fetch_max(20 as U32, Ordering::Relaxed)
    assert_eq(old2, 10 as U32, "fetch_max(10, 20) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), 20 as U32, "max(10, 20) = 20")
    return 0
}

@test
func test_atomic_u32_fetch_min() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old1: U32 = counter.fetch_min(20 as U32, Ordering::Relaxed)
    assert_eq(old1, 10 as U32, "fetch_min(10, 20) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), 10 as U32, "min(10, 20) = 10")

    let old2: U32 = counter.fetch_min(5 as U32, Ordering::Relaxed)
    assert_eq(old2, 10 as U32, "fetch_min(10, 5) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), 5 as U32, "min(10, 5) = 5")
    return 0
}

@test
func test_atomic_u32_compare_exchange_success() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let result: Outcome[U32, U32] = counter.compare_exchange(10 as U32, 20 as U32, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 10 as U32, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 20 as U32, "value should now be 20")
    return 0
}

@test
func test_atomic_u32_compare_exchange_fail() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let result: Outcome[U32, U32] = counter.compare_exchange(5 as U32, 20 as U32, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(_) => assert(false, "compare_exchange should fail"),
        Err(v) => assert_eq(v, 10 as U32, "Err should contain actual value"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 10 as U32, "value should still be 10")
    return 0
}

@test
func test_atomic_u32_into_inner() -> I32 {
    let counter: AtomicU32 = AtomicU32::new(42 as U32)
    let value: U32 = counter.into_inner()
    assert_eq(value, 42 as U32, "into_inner should return 42")
    return 0
}

@test
func test_atomic_u32_is_lock_free() -> I32 {
    let counter: AtomicU32 = AtomicU32::new(0 as U32)
    assert(counter.is_lock_free(), "AtomicU32 should be lock-free")
    return 0
}

// ============================================================================
// AtomicU64 Tests
// ============================================================================

@test
func test_atomic_u64_new() -> I32 {
    let counter: AtomicU64 = AtomicU64::new(1000000000000 as U64)
    assert_eq(counter.load(Ordering::Relaxed), 1000000000000 as U64, "new u64 should be 1T")
    return 0
}

@test
func test_atomic_u64_fetch_add() -> I32 {
    var counter: AtomicU64 = AtomicU64::new(100 as U64)
    let old: U64 = counter.fetch_add(50 as U64, Ordering::Relaxed)
    assert_eq(old, 100 as U64, "fetch_add should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 150 as U64, "100 + 50 = 150")
    return 0
}

@test
func test_atomic_u64_fetch_sub() -> I32 {
    var counter: AtomicU64 = AtomicU64::new(100 as U64)
    let old: U64 = counter.fetch_sub(30 as U64, Ordering::Relaxed)
    assert_eq(old, 100 as U64, "fetch_sub should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 70 as U64, "100 - 30 = 70")
    return 0
}

@test
func test_atomic_u64_swap() -> I32 {
    var counter: AtomicU64 = AtomicU64::new(111 as U64)
    let old: U64 = counter.swap(222 as U64, Ordering::Relaxed)
    assert_eq(old, 111 as U64, "swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 222 as U64, "new value should be 222")
    return 0
}

@test
func test_atomic_u64_compare_exchange_success() -> I32 {
    var counter: AtomicU64 = AtomicU64::new(50 as U64)
    let result: Outcome[U64, U64] = counter.compare_exchange(50 as U64, 100 as U64, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 50 as U64, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 100 as U64, "value should now be 100")
    return 0
}

// ============================================================================
// AtomicUsize Tests (pointer-sized unsigned)
// Note: On 64-bit platforms, lowlevel returns U64 which needs casting
// ============================================================================

@test
func test_atomic_usize_new() -> I32 {
    let counter: AtomicUsize = AtomicUsize::new(42 as Usize)
    assert_eq(counter.load(Ordering::Relaxed), 42 as Usize, "new usize should be 42")
    return 0
}

@test
func test_atomic_usize_store_load() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(0 as Usize)
    counter.store(100 as Usize, Ordering::Relaxed)
    assert_eq(counter.load(Ordering::Relaxed), 100 as Usize, "loaded value should be 100")
    return 0
}

@test
func test_atomic_usize_fetch_add() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(5 as Usize)
    // Return is U64 on 64-bit platforms due to lowlevel block
    let old: U64 = counter.fetch_add(3 as Usize, Ordering::Relaxed)
    assert_eq(old, 5 as U64, "fetch_add should return old value 5")
    assert_eq(counter.load(Ordering::Relaxed), 8 as Usize, "5 + 3 = 8")
    return 0
}

@test
func test_atomic_usize_fetch_sub() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(10 as Usize)
    let old: U64 = counter.fetch_sub(3 as Usize, Ordering::Relaxed)
    assert_eq(old, 10 as U64, "fetch_sub should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 7 as Usize, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_usize_swap() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(10 as Usize)
    let old: U64 = counter.swap(20 as Usize, Ordering::Relaxed)
    assert_eq(old, 10 as U64, "swap should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 20 as Usize, "new value should be 20")
    return 0
}

@test
func test_atomic_usize_compare_exchange_success() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(10 as Usize)
    let result: Outcome[Usize, Usize] = counter.compare_exchange(10 as Usize, 20 as Usize, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 10 as Usize, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 20 as Usize, "value should now be 20")
    return 0
}

// ============================================================================
// AtomicIsize Tests (pointer-sized signed)
// ============================================================================

@test
func test_atomic_isize_new() -> I32 {
    let counter: AtomicIsize = AtomicIsize::new(42 as Isize)
    assert_eq(counter.load(Ordering::Relaxed), 42 as Isize, "new isize should be 42")
    return 0
}

@test
func test_atomic_isize_negative() -> I32 {
    let counter: AtomicIsize = AtomicIsize::new(-100 as Isize)
    assert_eq(counter.load(Ordering::Relaxed), -100 as Isize, "should handle negative values")
    return 0
}

@test
func test_atomic_isize_fetch_add() -> I32 {
    var counter: AtomicIsize = AtomicIsize::new(5 as Isize)
    let old: I64 = counter.fetch_add(3 as Isize, Ordering::Relaxed)
    assert_eq(old, 5 as I64, "fetch_add should return old value 5")
    assert_eq(counter.load(Ordering::Relaxed), 8 as Isize, "5 + 3 = 8")
    return 0
}

@test
func test_atomic_isize_fetch_sub() -> I32 {
    var counter: AtomicIsize = AtomicIsize::new(10 as Isize)
    let old: I64 = counter.fetch_sub(3 as Isize, Ordering::Relaxed)
    assert_eq(old, 10 as I64, "fetch_sub should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 7 as Isize, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_isize_swap() -> I32 {
    var counter: AtomicIsize = AtomicIsize::new(-50 as Isize)
    let old: I64 = counter.swap(50 as Isize, Ordering::Relaxed)
    assert_eq(old, -50 as I64, "swap should return old value -50")
    assert_eq(counter.load(Ordering::Relaxed), 50 as Isize, "new value should be 50")
    return 0
}

@test
func test_atomic_isize_compare_exchange_success() -> I32 {
    var counter: AtomicIsize = AtomicIsize::new(10 as Isize)
    let result: Outcome[Isize, Isize] = counter.compare_exchange(10 as Isize, 20 as Isize, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 10 as Isize, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 20 as Isize, "value should now be 20")
    return 0
}

// ============================================================================
// Edge Cases and Boundary Tests
// ============================================================================

@test
func test_atomic_u32_max_value() -> I32 {
    let max_u32: U32 = 4294967295 as U32
    var counter: AtomicU32 = AtomicU32::new(max_u32)
    assert_eq(counter.load(Ordering::Relaxed), max_u32, "should handle max U32")
    return 0
}

@test
func test_atomic_u64_max_value() -> I32 {
    let max_u64: U64 = 18446744073709551615 as U64
    var counter: AtomicU64 = AtomicU64::new(max_u64)
    assert_eq(counter.load(Ordering::Relaxed), max_u64, "should handle max U64")
    return 0
}

@test
func test_atomic_u32_zero() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0 as U32)
    assert_eq(counter.load(Ordering::Relaxed), 0 as U32, "should handle zero")
    counter.fetch_add(1 as U32, Ordering::Relaxed)
    assert_eq(counter.load(Ordering::Relaxed), 1 as U32, "0 + 1 = 1")
    return 0
}

// ============================================================================
// Ordering Combination Tests
// ============================================================================

@test
func test_ordering_release_acquire() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0 as U32)
    counter.store(1 as U32, Ordering::Release)
    let v: U32 = counter.load(Ordering::Acquire)
    assert_eq(v, 1 as U32, "Release store visible to Acquire load")
    return 0
}

@test
func test_ordering_acqrel() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old: U32 = counter.fetch_add(5 as U32, Ordering::AcqRel)
    assert_eq(old, 10 as U32, "AcqRel fetch_add should work")
    assert_eq(counter.load(Ordering::SeqCst), 15 as U32, "value should be 15")
    return 0
}

// ============================================================================
// Counter Pattern Tests with Unsigned Types
// ============================================================================

@test
func test_atomic_u32_counter_pattern() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(0 as U32)

    var i: I32 = 0
    loop (i < 10) {
        counter.fetch_add(1 as U32, Ordering::Relaxed)
        i = i + 1
    }

    assert_eq(counter.load(Ordering::Relaxed), 10 as U32, "counter should be 10")
    return 0
}

@test
func test_atomic_usize_index_pattern() -> I32 {
    var index: AtomicUsize = AtomicUsize::new(0 as Usize)

    var i: I32 = 0
    loop (i < 5) {
        let prev: U64 = index.fetch_add(1 as Usize, Ordering::Relaxed)
        i = i + 1
    }

    assert_eq(index.load(Ordering::Relaxed), 5 as Usize, "index should be 5")
    return 0
}

// ============================================================================
// LOCK_FREE Constant Tests for Remaining Types
// ============================================================================

@test
func test_atomic_u32_lock_free_constant() -> I32 {
    assert(AtomicU32::LOCK_FREE, "AtomicU32::LOCK_FREE should be true")
    return 0
}

@test
func test_atomic_u64_lock_free_constant() -> I32 {
    assert(AtomicU64::LOCK_FREE, "AtomicU64::LOCK_FREE should be true")
    return 0
}

@test
func test_atomic_usize_lock_free_constant() -> I32 {
    assert(AtomicUsize::LOCK_FREE, "AtomicUsize::LOCK_FREE should be true")
    return 0
}

@test
func test_atomic_isize_lock_free_constant() -> I32 {
    assert(AtomicIsize::LOCK_FREE, "AtomicIsize::LOCK_FREE should be true")
    return 0
}

// ============================================================================
// compare_and_swap Tests for Remaining Types
// ============================================================================

@test
func test_atomic_u32_compare_and_swap() -> I32 {
    var counter: AtomicU32 = AtomicU32::new(10 as U32)
    let old: U32 = counter.compare_and_swap(10 as U32, 20 as U32, Ordering::SeqCst)
    assert_eq(old, 10 as U32, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 20 as U32, "value should now be 20")
    return 0
}

@test
func test_atomic_u64_compare_and_swap() -> I32 {
    var counter: AtomicU64 = AtomicU64::new(100 as U64)
    let old: U64 = counter.compare_and_swap(100 as U64, 200 as U64, Ordering::SeqCst)
    assert_eq(old, 100 as U64, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 200 as U64, "value should now be 200")
    return 0
}

@test
func test_atomic_usize_compare_and_swap() -> I32 {
    var counter: AtomicUsize = AtomicUsize::new(10 as Usize)
    // Note: compare_and_swap returns U64 on 64-bit platforms (same as swap/fetch_add)
    let old: U64 = counter.compare_and_swap(10 as Usize, 20 as Usize, Ordering::SeqCst)
    assert_eq(old, 10 as U64, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 20 as Usize, "value should now be 20")
    return 0
}

@test
func test_atomic_isize_compare_and_swap() -> I32 {
    var counter: AtomicIsize = AtomicIsize::new(-10 as Isize)
    // Note: compare_and_swap returns I64 on 64-bit platforms (same as swap/fetch_add)
    let old: I64 = counter.compare_and_swap(-10 as Isize, 10 as Isize, Ordering::SeqCst)
    assert_eq(old, -10 as I64, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 10 as Isize, "value should now be 10")
    return 0
}

// ============================================================================
// AtomicPtr Tests
// ============================================================================

@test
func test_atomic_ptr_new() -> I32 {
    var x: I32 = 42
    let ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded != null, "loaded ptr should not be null")
    return 0
}

@test
func test_atomic_ptr_new_null() -> I32 {
    let ptr: AtomicPtr[I32] = AtomicPtr::new_null[I32]()
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded == null, "loaded ptr should be null")
    return 0
}

@test
func test_atomic_ptr_store_load() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    ptr.store(ref y as Ptr[I32], Ordering::Relaxed)
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded == ref y as Ptr[I32], "loaded ptr should be y's address")
    return 0
}

@test
func test_atomic_ptr_swap() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let old: Ptr[I32] = ptr.swap(ref y as Ptr[I32], Ordering::Relaxed)
    assert(old == ref x as Ptr[I32], "swap should return old ptr")
    assert(ptr.load(Ordering::Relaxed) == ref y as Ptr[I32], "new ptr should be y")
    return 0
}

@test
func test_atomic_ptr_compare_and_swap() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let old: Ptr[I32] = ptr.compare_and_swap(ref x as Ptr[I32], ref y as Ptr[I32], Ordering::SeqCst)
    assert(old == ref x as Ptr[I32], "compare_and_swap should return old ptr")
    assert(ptr.load(Ordering::Relaxed) == ref y as Ptr[I32], "new ptr should be y")
    return 0
}

@test
func test_atomic_ptr_is_lock_free() -> I32 {
    let ptr: AtomicPtr[I32] = AtomicPtr::new_null[I32]()
    assert(ptr.is_lock_free(), "AtomicPtr should be lock-free")
    return 0
}

// Note: AtomicPtr[T]::LOCK_FREE constant test skipped - generic type constant access
// syntax not yet supported in parser. The is_lock_free() method test above confirms
// the lock-free behavior.

// ============================================================================
// Ordering Method Tests
// ============================================================================

@test
func test_ordering_has_acquire_true() -> I32 {
    assert(Ordering::Acquire.has_acquire(), "Acquire should have acquire semantics")
    assert(Ordering::AcqRel.has_acquire(), "AcqRel should have acquire semantics")
    assert(Ordering::SeqCst.has_acquire(), "SeqCst should have acquire semantics")
    return 0
}

@test
func test_ordering_has_acquire_false() -> I32 {
    assert(not Ordering::Relaxed.has_acquire(), "Relaxed should not have acquire semantics")
    assert(not Ordering::Release.has_acquire(), "Release should not have acquire semantics")
    return 0
}

@test
func test_ordering_has_release_true() -> I32 {
    assert(Ordering::Release.has_release(), "Release should have release semantics")
    assert(Ordering::AcqRel.has_release(), "AcqRel should have release semantics")
    assert(Ordering::SeqCst.has_release(), "SeqCst should have release semantics")
    return 0
}

@test
func test_ordering_has_release_false() -> I32 {
    assert(not Ordering::Relaxed.has_release(), "Relaxed should not have release semantics")
    assert(not Ordering::Acquire.has_release(), "Acquire should not have release semantics")
    return 0
}

// ============================================================================
// Fence Tests - PENDING CODEGEN IMPLEMENTATION
// ============================================================================
// Note: fence(Ordering) and compiler_fence(Ordering) intrinsics are declared
// in sync::ordering but codegen support is not yet implemented.
// The tests below document the expected behavior once implemented.

// TODO: Uncomment when llvm.fence intrinsic with Ordering parameter is implemented
// @test
// func test_fence_acquire() -> I32 {
//     fence(Ordering::Acquire)
//     return 0
// }

// TODO: Uncomment when llvm.compiler_fence intrinsic is implemented
// @test
// func test_compiler_fence_seqcst() -> I32 {
//     compiler_fence(Ordering::SeqCst)
//     return 0
// }

// ============================================================================
// Fence Alternative: Use Ordering with Atomic Operations
// ============================================================================

// The recommended approach until fence intrinsics are implemented is to use
// the appropriate Ordering on atomic operations directly.

@test
func test_fence_pattern_with_ordering() -> I32 {
    // Instead of: fence(Ordering::Release) + relaxed store
    // Use: Release store directly
    var flag: AtomicBool = AtomicBool::new(false)
    var data: AtomicI32 = AtomicI32::new(0)

    // "Producer" - use Release ordering on the signal
    data.store(42, Ordering::Relaxed)
    flag.store(true, Ordering::Release)  // Acts as release fence

    // "Consumer" - use Acquire ordering on the signal
    if flag.load(Ordering::Acquire) {  // Acts as acquire fence
        let v: I32 = data.load(Ordering::Relaxed)
        assert_eq(v, 42, "data should be 42 after synchronization")
    }

    return 0
}

@test
func test_seqcst_synchronization() -> I32 {
    // SeqCst provides the strongest ordering - equivalent to a full fence
    var counter: AtomicU32 = AtomicU32::new(0 as U32)
    counter.store(100 as U32, Ordering::SeqCst)
    let v: U32 = counter.load(Ordering::SeqCst)
    assert_eq(v, 100 as U32, "SeqCst provides full synchronization")
    return 0
}
