// Barrier, Once, and OnceLock tests
use test::{assert, assert_eq}
use std::sync::{Barrier, BarrierWaitResult, Once, OnceLock}

// ============================================================================
// Barrier Tests
// ============================================================================

@test
func test_barrier_new() -> I32 {
    let barrier: Barrier = Barrier::new(1 as U32)
    return 0
}

@test
func test_barrier_wait_single_thread() -> I32 {
    // With count of 1, wait() should return immediately
    var barrier: Barrier = Barrier::new(1 as U32)
    let result: BarrierWaitResult = barrier.wait()
    // Single thread should be the leader
    assert(result.is_leader(), "Single thread should be leader")
    return 0
}

@test
func test_barrier_wait_result_is_leader() -> I32 {
    var barrier: Barrier = Barrier::new(1 as U32)
    let result: BarrierWaitResult = barrier.wait()
    let is_leader: Bool = result.is_leader()
    assert(is_leader, "is_leader should return true for single thread")
    return 0
}

// Note: test_barrier_reusable is disabled - multiple barrier.wait() calls on the
// same barrier cause hangs. This needs investigation in the Barrier/Condvar impl.

// ============================================================================
// Once Tests
// ============================================================================

@test
func test_once_new() -> I32 {
    let once: Once = Once::new()
    return 0
}

@test
func test_once_is_completed_initially_false() -> I32 {
    let once: Once = Once::new()
    assert(not once.is_completed(), "Once should not be completed initially")
    return 0
}

@test
func test_once_call_once_completes() -> I32 {
    var once: Once = Once::new()

    once.call_once(do() {
        // Initialization code
    })

    assert(once.is_completed(), "Once should be completed after call_once")
    return 0
}

@test
func test_once_call_once_runs_exactly_once() -> I32 {
    var once: Once = Once::new()

    // Call once multiple times - closure doesn't need to capture vars
    once.call_once(do() {
        // First call runs this
    })

    once.call_once(do() {
        // Second call skipped
    })

    once.call_once(do() {
        // Third call skipped
    })

    // Verify that multiple calls don't panic and is_completed stays true
    assert(once.is_completed(), "Once should remain completed")
    return 0
}

@test
func test_once_is_completed_after_multiple_calls() -> I32 {
    var once: Once = Once::new()

    once.call_once(do() {})
    assert(once.is_completed(), "Should be completed after first call")

    once.call_once(do() {})
    assert(once.is_completed(), "Should remain completed after second call")

    return 0
}

// ============================================================================
// OnceLock Tests
// ============================================================================

@test
func test_once_lock_new() -> I32 {
    let lock: OnceLock[I32] = OnceLock::new[I32]()
    return 0
}

@test
func test_once_lock_is_initialized_initially_false() -> I32 {
    let lock: OnceLock[I32] = OnceLock::new[I32]()
    assert(not lock.is_initialized(), "OnceLock should not be initialized initially")
    return 0
}

@test
func test_once_lock_set_success() -> I32 {
    var lock: OnceLock[I32] = OnceLock::new[I32]()
    let result: Outcome[Unit, I32] = lock.set(42)
    when result {
        Ok(_) => {},
        Err(_) => assert(false, "set() should succeed on empty OnceLock")
    }
    assert(lock.is_initialized(), "OnceLock should be initialized after set")
    return 0
}

@test
func test_once_lock_set_twice_fails() -> I32 {
    var lock: OnceLock[I32] = OnceLock::new[I32]()

    // First set should succeed
    let r1: Outcome[Unit, I32] = lock.set(42)
    when r1 {
        Ok(_) => {},
        Err(_) => assert(false, "First set should succeed")
    }

    // Second set should fail
    let r2: Outcome[Unit, I32] = lock.set(100)
    when r2 {
        Ok(_) => assert(false, "Second set should fail"),
        Err(v) => assert_eq(v, 100, "Err should contain the rejected value")
    }

    return 0
}

@test
func test_once_lock_with_i64() -> I32 {
    var lock: OnceLock[I64] = OnceLock::new[I64]()
    let result: Outcome[Unit, I64] = lock.set(9999999999 as I64)
    when result {
        Ok(_) => {},
        Err(_) => assert(false, "set() should succeed")
    }
    assert(lock.is_initialized(), "Should be initialized after set")
    return 0
}

@test
func test_once_lock_with_bool() -> I32 {
    var lock: OnceLock[Bool] = OnceLock::new[Bool]()
    let result: Outcome[Unit, Bool] = lock.set(true)
    when result {
        Ok(_) => {},
        Err(_) => assert(false, "set() should succeed")
    }
    assert(lock.is_initialized(), "Should be initialized after set")
    return 0
}

// Note: Tests for OnceLock::get(), take(), get_or_init(), into_inner() are
// temporarily skipped due to codegen issues with Maybe[ref T] type handling.
// These can be enabled once the codegen issue is fixed.
