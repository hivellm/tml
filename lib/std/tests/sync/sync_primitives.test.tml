// Sync primitives tests - Mutex, MutexGuard, Condvar
use test::{assert, assert_eq}
use std::sync::{Mutex, MutexGuard, Condvar, Arc}

// ============================================================================
// Basic Mutex Tests
// ============================================================================

@test
func test_mutex_new() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    return 0
}

@test
func test_mutex_lock() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    let guard: MutexGuard[I32] = mutex.lock()
    let val: I32 = *guard.get()
    assert_eq(val, 42)
    return 0
}

@test
func test_mutex_lock_twice() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)

    {
        let guard: MutexGuard[I32] = mutex.lock()
        let val: I32 = *guard.get()
        assert_eq(val, 42)
    }  // guard dropped here

    // Lock again - if Drop didn't unlock, this will deadlock
    {
        let guard: MutexGuard[I32] = mutex.lock()
        assert_eq(*guard.get(), 42)
    }

    return 0
}

@test
func test_mutex_explicit_type() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    return 0
}

@test
func test_arc_mutex_explicit() -> I32 {
    let inner: Mutex[I32] = Mutex::new(42)
    let a: Arc[Mutex[I32]] = Arc::new(inner)
    return 0
}

// ============================================================================
// Condvar Tests
// ============================================================================

@test
func test_condvar_creation() -> I32 {
    let cv: Condvar = Condvar::new()
    return 0
}

@test
func test_condvar_wait_timeout() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[I32] = mutex.lock()
    // Use wait_timeout_ms to test Condvar functionality
    // It should timeout since no one is signaling
    let result: (MutexGuard[I32], Bool) = condvar.wait_timeout_ms(guard, 10)
    guard = result.0
    let timed_out: Bool = result.1
    assert(timed_out)  // Should have timed out

    return 0
}

@test
func test_condvar_notify_one_no_waiters() -> I32 {
    // notify_one with no waiters is a no-op
    var condvar: Condvar = Condvar::new()
    condvar.notify_one()  // Should not panic or block
    return 0
}

@test
func test_condvar_notify_all_no_waiters() -> I32 {
    // notify_all with no waiters is a no-op
    var condvar: Condvar = Condvar::new()
    condvar.notify_all()  // Should not panic or block
    return 0
}

@test
func test_condvar_wait_timeout_longer() -> I32 {
    // Test with a slightly longer timeout
    let mutex: Mutex[I32] = Mutex::new(100)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[I32] = mutex.lock()
    let result: (MutexGuard[I32], Bool) = condvar.wait_timeout_ms(guard, 50)
    guard = result.0
    let timed_out: Bool = result.1
    assert(timed_out)  // Should have timed out

    // Verify the guard still works and data is preserved
    assert_eq(*guard.get(), 100)
    return 0
}

@test
func test_condvar_with_i64_mutex() -> I32 {
    let mutex: Mutex[I64] = Mutex::new(999999999 as I64)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[I64] = mutex.lock()
    let result: (MutexGuard[I64], Bool) = condvar.wait_timeout_ms(guard, 10)
    guard = result.0
    let timed_out: Bool = result.1
    assert(timed_out)
    assert_eq(*guard.get(), 999999999 as I64)
    return 0
}

@test
func test_condvar_with_bool_mutex() -> I32 {
    let mutex: Mutex[Bool] = Mutex::new(false)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[Bool] = mutex.lock()
    let result: (MutexGuard[Bool], Bool) = condvar.wait_timeout_ms(guard, 10)
    guard = result.0
    let timed_out: Bool = result.1
    assert(timed_out)
    assert(not *guard.get())  // Should still be false
    return 0
}

@test
func test_condvar_wait_timeout_zero() -> I32 {
    // Zero timeout should return immediately
    let mutex: Mutex[I32] = Mutex::new(0)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[I32] = mutex.lock()
    let result: (MutexGuard[I32], Bool) = condvar.wait_timeout_ms(guard, 0)
    guard = result.0
    let timed_out: Bool = result.1
    // Zero timeout might or might not report as timed out depending on implementation
    // The important thing is it returns immediately
    return 0
}

@test
func test_condvar_multiple_notify_one() -> I32 {
    // Multiple notify_one calls with no waiters
    var condvar: Condvar = Condvar::new()
    condvar.notify_one()
    condvar.notify_one()
    condvar.notify_one()
    return 0
}

@test
func test_condvar_multiple_notify_all() -> I32 {
    // Multiple notify_all calls with no waiters
    var condvar: Condvar = Condvar::new()
    condvar.notify_all()
    condvar.notify_all()
    condvar.notify_all()
    return 0
}

@test
func test_condvar_interleaved_notify() -> I32 {
    // Interleaved notify_one and notify_all
    var condvar: Condvar = Condvar::new()
    condvar.notify_one()
    condvar.notify_all()
    condvar.notify_one()
    condvar.notify_all()
    return 0
}

@test
func test_condvar_data_preserved_after_wait() -> I32 {
    // Ensure data inside mutex is preserved after wait_timeout
    let mutex: Mutex[I32] = Mutex::new(42)
    let condvar: Condvar = Condvar::new()

    // First access
    {
        var guard: MutexGuard[I32] = mutex.lock()
        *guard.get_mut() = 100
    }

    // Wait and verify
    {
        var guard: MutexGuard[I32] = mutex.lock()
        let result: (MutexGuard[I32], Bool) = condvar.wait_timeout_ms(guard, 10)
        guard = result.0
        assert_eq(*guard.get(), 100)
    }

    return 0
}
