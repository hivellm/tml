// Consolidated Atomic tests (Part 1: AtomicBool, AtomicI32, AtomicI64, AtomicPtr)
// Total @test count: 47
// Sources: atomic_bool.test.tml, atomic_i32.test.tml, atomic_i64.test.tml,
//          atomic_ptr.test.tml, atomic_coverage.test.tml (AtomicBool/I32 portions),
//          atomic_coverage2.test.tml (AtomicI64 portions),
//          atomic_extra.test.tml, sync_isolation.test.tml (atomic portions)
use test::{assert, assert_eq}
use std::sync::{AtomicBool, AtomicI32, AtomicI64, AtomicPtr, Ordering}
use std::sync::atomic::spin_loop_hint

// ============================================================================
// AtomicBool Tests
// ============================================================================

@test
func test_atomic_bool_new() -> I32 {
    let flag: AtomicBool = AtomicBool::new(true)
    assert(flag.load(Ordering::Relaxed), "new bool should be true")
    return 0
}

@test
func test_atomic_bool_store_load() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    flag.store(true, Ordering::Relaxed)
    assert(flag.load(Ordering::Relaxed), "loaded value should be true")
    return 0
}

@test
func test_atomic_bool_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.swap(true, Ordering::Relaxed)
    assert(not old, "swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "new value should be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_success() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert(not v, "Ok should contain old value false"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_compare_exchange_fail() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let result: Outcome[Bool, Bool] = flag.compare_exchange(false, true, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(_) => assert(false, "compare_exchange should fail"),
        Err(v) => assert(v, "Err should contain actual value true"),
    }
    assert(flag.load(Ordering::Relaxed), "value should still be true")
    return 0
}

@test
func test_atomic_bool_compare_and_swap() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.compare_and_swap(false, true, Ordering::SeqCst)
    assert(not old, "compare_and_swap should return old value false")
    assert(flag.load(Ordering::Relaxed), "value should now be true")
    return 0
}

@test
func test_atomic_bool_fetch_and() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_and(false, Ordering::Relaxed)
    assert(old, "fetch_and should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true AND false = false")
    return 0
}

@test
func test_atomic_bool_fetch_or() -> I32 {
    var flag: AtomicBool = AtomicBool::new(false)
    let old: Bool = flag.fetch_or(true, Ordering::Relaxed)
    assert(not old, "fetch_or should return old value false")
    assert(flag.load(Ordering::Relaxed), "false OR true = true")
    return 0
}

@test
func test_atomic_bool_fetch_xor() -> I32 {
    var flag: AtomicBool = AtomicBool::new(true)
    let old: Bool = flag.fetch_xor(true, Ordering::Relaxed)
    assert(old, "fetch_xor should return old value true")
    assert(not flag.load(Ordering::Relaxed), "true XOR true = false")
    return 0
}

@test
func test_atomic_bool_is_lock_free() -> I32 {
    let flag: AtomicBool = AtomicBool::new(false)
    assert(flag.is_lock_free(), "AtomicBool should be lock-free")
    return 0
}

@test
func test_atomic_bool_lock_free_constant() -> I32 {
    assert(AtomicBool::LOCK_FREE, "AtomicBool::LOCK_FREE should be true")
    return 0
}

// From atomic_coverage.test.tml
@test
func test_atomic_bool_compare_exchange_weak() -> I32 {
    var ab: AtomicBool = AtomicBool::new(true)
    let r: Outcome[Bool, Bool] = ab.compare_exchange_weak(true, false, Ordering::Relaxed, Ordering::Relaxed)
    assert(r.is_ok() or r.is_err(), "compare_exchange_weak returns result")
    return 0
}

@test
func test_atomic_bool_fetch_nand() -> I32 {
    var ab: AtomicBool = AtomicBool::new(true)
    let old: Bool = ab.fetch_nand(true, Ordering::Relaxed)
    assert_eq(old, true, "fetch_nand returns old value")
    assert_eq(ab.load(Ordering::Relaxed), false, "NAND(true,true) = false")
    return 0
}

@test
func test_atomic_bool_into_inner() -> I32 {
    let ab: AtomicBool = AtomicBool::new(true)
    let v: Bool = ab.into_inner()
    assert_eq(v, true, "into_inner should return initial value")
    return 0
}

// ============================================================================
// AtomicI32 Tests
// ============================================================================

@test
func test_atomic_i32_new() -> I32 {
    let counter: AtomicI32 = AtomicI32::new(42)
    assert_eq(counter.load(Ordering::Relaxed), 42, "new i32 should be 42")
    return 0
}

@test
func test_atomic_i32_negative() -> I32 {
    let counter: AtomicI32 = AtomicI32::new(-100)
    assert_eq(counter.load(Ordering::Relaxed), -100, "should handle negative values")
    return 0
}

@test
func test_atomic_i32_store_load() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(0)
    counter.store(100, Ordering::Relaxed)
    assert_eq(counter.load(Ordering::Relaxed), 100, "loaded value should be 100")
    return 0
}

@test
func test_atomic_i32_swap() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(-10)
    let old: I32 = counter.swap(10, Ordering::Relaxed)
    assert_eq(old, -10, "swap should return old value -10")
    assert_eq(counter.load(Ordering::Relaxed), 10, "new value should be 10")
    return 0
}

@test
func test_atomic_i32_fetch_add() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(5)
    let old: I32 = counter.fetch_add(3, Ordering::Relaxed)
    assert_eq(old, 5, "fetch_add should return old value 5")
    assert_eq(counter.load(Ordering::Relaxed), 8, "5 + 3 = 8")
    return 0
}

@test
func test_atomic_i32_fetch_sub() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old: I32 = counter.fetch_sub(3, Ordering::Relaxed)
    assert_eq(old, 10, "fetch_sub should return old value 10")
    assert_eq(counter.load(Ordering::Relaxed), 7, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_i32_compare_exchange_success() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let result: Outcome[I32, I32] = counter.compare_exchange(10, 20, Ordering::SeqCst, Ordering::Relaxed)
    when result {
        Ok(v) => assert_eq(v, 10, "Ok should contain old value"),
        Err(_) => assert(false, "compare_exchange should succeed"),
    }
    assert_eq(counter.load(Ordering::Relaxed), 20, "value should now be 20")
    return 0
}

@test
func test_atomic_i32_compare_and_swap() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old: I32 = counter.compare_and_swap(10, 20, Ordering::SeqCst)
    assert_eq(old, 10, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 20, "value should now be 20")
    return 0
}

@test
func test_atomic_i32_fetch_max() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(-10)
    let old1: I32 = counter.fetch_max(5, Ordering::Relaxed)
    assert_eq(old1, -10, "fetch_max(-10, 5) should return -10")
    assert_eq(counter.load(Ordering::Relaxed), 5, "max(-10, 5) = 5")
    return 0
}

@test
func test_atomic_i32_fetch_min() -> I32 {
    var counter: AtomicI32 = AtomicI32::new(10)
    let old1: I32 = counter.fetch_min(-5, Ordering::Relaxed)
    assert_eq(old1, 10, "fetch_min(10, -5) should return 10")
    assert_eq(counter.load(Ordering::Relaxed), -5, "min(10, -5) = -5")
    return 0
}

@test
func test_atomic_i32_lock_free_constant() -> I32 {
    assert(AtomicI32::LOCK_FREE, "AtomicI32::LOCK_FREE should be true")
    return 0
}

// From atomic_coverage.test.tml
@test
func test_atomic_i32_compare_exchange_weak() -> I32 {
    var ai: AtomicI32 = AtomicI32::new(42)
    let r: Outcome[I32, I32] = ai.compare_exchange_weak(42, 100, Ordering::Relaxed, Ordering::Relaxed)
    assert(r.is_ok() or r.is_err(), "compare_exchange_weak returns result")
    return 0
}

@test
func test_atomic_i32_fetch_and() -> I32 {
    var ai: AtomicI32 = AtomicI32::new(15)
    let old: I32 = ai.fetch_and(9, Ordering::Relaxed)
    assert_eq(old, 15, "fetch_and returns old value")
    assert_eq(ai.load(Ordering::Relaxed), 9, "15 & 9 = 9")
    return 0
}

@test
func test_atomic_i32_fetch_or() -> I32 {
    var ai: AtomicI32 = AtomicI32::new(3)
    let old: I32 = ai.fetch_or(12, Ordering::Relaxed)
    assert_eq(old, 3, "fetch_or returns old value")
    assert_eq(ai.load(Ordering::Relaxed), 15, "3 | 12 = 15")
    return 0
}

@test
func test_atomic_i32_fetch_xor() -> I32 {
    var ai: AtomicI32 = AtomicI32::new(15)
    let old: I32 = ai.fetch_xor(9, Ordering::Relaxed)
    assert_eq(old, 15, "fetch_xor returns old value")
    assert_eq(ai.load(Ordering::Relaxed), 6, "15 ^ 9 = 6")
    return 0
}

@test
func test_atomic_i32_is_lock_free() -> I32 {
    let ai: AtomicI32 = AtomicI32::new(0)
    let lf: Bool = ai.is_lock_free()
    assert(lf, "AtomicI32 should be lock-free on x86_64")
    return 0
}

@test
func test_atomic_i32_into_inner() -> I32 {
    let ai: AtomicI32 = AtomicI32::new(42)
    let v: I32 = ai.into_inner()
    assert_eq(v, 42, "into_inner returns initial value")
    return 0
}

// ============================================================================
// AtomicI64 Tests
// ============================================================================

@test
func test_atomic_i64_new() -> I32 {
    let counter: AtomicI64 = AtomicI64::new(1000000000000 as I64)
    assert_eq(counter.load(Ordering::Relaxed), 1000000000000 as I64, "new i64 should be 1T")
    return 0
}

@test
func test_atomic_i64_negative() -> I32 {
    let counter: AtomicI64 = AtomicI64::new(-1000000000000 as I64)
    assert_eq(counter.load(Ordering::Relaxed), -1000000000000 as I64, "should handle negative")
    return 0
}

@test
func test_atomic_i64_fetch_add() -> I32 {
    var counter: AtomicI64 = AtomicI64::new(100 as I64)
    let old: I64 = counter.fetch_add(50 as I64, Ordering::Relaxed)
    assert_eq(old, 100 as I64, "fetch_add should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 150 as I64, "100 + 50 = 150")
    return 0
}

@test
func test_atomic_i64_compare_and_swap() -> I32 {
    var counter: AtomicI64 = AtomicI64::new(100 as I64)
    let old: I64 = counter.compare_and_swap(100 as I64, 200 as I64, Ordering::SeqCst)
    assert_eq(old, 100 as I64, "compare_and_swap should return old value")
    assert_eq(counter.load(Ordering::Relaxed), 200 as I64, "value should now be 200")
    return 0
}

@test
func test_atomic_i64_lock_free_constant() -> I32 {
    assert(AtomicI64::LOCK_FREE, "AtomicI64::LOCK_FREE should be true")
    return 0
}

// From atomic_coverage2.test.tml
@test
func test_atomic_i64_store() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(0 as I64)
    ai.store(100 as I64, Ordering::Relaxed)
    assert(ai.load(Ordering::Relaxed) == 100 as I64, "store should set value")
    return 0
}

@test
func test_atomic_i64_swap() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(10 as I64)
    let old: I64 = ai.swap(20 as I64, Ordering::Relaxed)
    assert(old == 10 as I64, "swap returns old value")
    return 0
}

@test
func test_atomic_i64_compare_exchange_weak() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(42 as I64)
    let r: Outcome[I64, I64] = ai.compare_exchange_weak(42 as I64, 100 as I64, Ordering::Relaxed, Ordering::Relaxed)
    assert(r.is_ok() or r.is_err(), "compare_exchange_weak returns result")
    return 0
}

@test
func test_atomic_i64_fetch_sub() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(10 as I64)
    let old: I64 = ai.fetch_sub(3 as I64, Ordering::Relaxed)
    assert(old == 10 as I64, "fetch_sub returns old")
    assert(ai.load(Ordering::Relaxed) == 7 as I64, "10 - 3 = 7")
    return 0
}

@test
func test_atomic_i64_fetch_and() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(15 as I64)
    let old: I64 = ai.fetch_and(9 as I64, Ordering::Relaxed)
    assert(old == 15 as I64, "fetch_and returns old")
    return 0
}

@test
func test_atomic_i64_fetch_or() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(3 as I64)
    let old: I64 = ai.fetch_or(12 as I64, Ordering::Relaxed)
    assert(old == 3 as I64, "fetch_or returns old")
    return 0
}

@test
func test_atomic_i64_fetch_xor() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(15 as I64)
    let old: I64 = ai.fetch_xor(9 as I64, Ordering::Relaxed)
    assert(old == 15 as I64, "fetch_xor returns old")
    return 0
}

@test
func test_atomic_i64_fetch_max() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(5 as I64)
    let old: I64 = ai.fetch_max(10 as I64, Ordering::Relaxed)
    assert(old == 5 as I64, "fetch_max returns old")
    assert(ai.load(Ordering::Relaxed) == 10 as I64, "max(5,10) = 10")
    return 0
}

@test
func test_atomic_i64_fetch_min() -> I32 {
    var ai: AtomicI64 = AtomicI64::new(10 as I64)
    let old: I64 = ai.fetch_min(5 as I64, Ordering::Relaxed)
    assert(old == 10 as I64, "fetch_min returns old")
    assert(ai.load(Ordering::Relaxed) == 5 as I64, "min(10,5) = 5")
    return 0
}

@test
func test_atomic_i64_is_lock_free() -> I32 {
    let ai: AtomicI64 = AtomicI64::new(0 as I64)
    let lf: Bool = ai.is_lock_free()
    assert(lf, "AtomicI64 should be lock-free on x86_64")
    return 0
}

@test
func test_atomic_i64_into_inner() -> I32 {
    let ai: AtomicI64 = AtomicI64::new(42 as I64)
    let v: I64 = ai.into_inner()
    assert(v == 42 as I64, "into_inner returns initial value")
    return 0
}

// From atomic_extra.test.tml
@test
func test_atomic_i64_compare_exchange() -> I32 {
    var a: AtomicI64 = AtomicI64::new(10 as I64)
    let result: Outcome[I64, I64] = a.compare_exchange(10 as I64, 20 as I64, Ordering::SeqCst, Ordering::SeqCst)
    assert(result.is_ok(), "compare_exchange should succeed")
    assert_eq(a.load(Ordering::SeqCst), 20 as I64, "value should be 20")
    return 0
}

// ============================================================================
// AtomicPtr Tests
// ============================================================================

@test
func test_atomic_ptr_new() -> I32 {
    var x: I32 = 42
    let ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded != null, "loaded ptr should not be null")
    return 0
}

@test
func test_atomic_ptr_new_null() -> I32 {
    let ptr: AtomicPtr[I32] = AtomicPtr::new_null[I32]()
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded == null, "loaded ptr should be null")
    return 0
}

@test
func test_atomic_ptr_store_load() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    ptr.store(ref y as Ptr[I32], Ordering::Relaxed)
    let loaded: Ptr[I32] = ptr.load(Ordering::Relaxed)
    assert(loaded == ref y as Ptr[I32], "loaded ptr should be y's address")
    return 0
}

@test
func test_atomic_ptr_swap() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let old: Ptr[I32] = ptr.swap(ref y as Ptr[I32], Ordering::Relaxed)
    assert(old == ref x as Ptr[I32], "swap should return old ptr")
    assert(ptr.load(Ordering::Relaxed) == ref y as Ptr[I32], "new ptr should be y")
    return 0
}

@test
func test_atomic_ptr_compare_and_swap() -> I32 {
    var x: I32 = 42
    var y: I32 = 100
    var ptr: AtomicPtr[I32] = AtomicPtr::new(ref x as Ptr[I32])
    let old: Ptr[I32] = ptr.compare_and_swap(ref x as Ptr[I32], ref y as Ptr[I32], Ordering::SeqCst)
    assert(old == ref x as Ptr[I32], "compare_and_swap should return old ptr")
    assert(ptr.load(Ordering::Relaxed) == ref y as Ptr[I32], "new ptr should be y")
    return 0
}

@test
func test_atomic_ptr_is_lock_free() -> I32 {
    let ptr: AtomicPtr[I32] = AtomicPtr::new_null[I32]()
    assert(ptr.is_lock_free(), "AtomicPtr should be lock-free")
    return 0
}

// ============================================================================
// spin_loop_hint Test
// ============================================================================

@test
func test_spin_loop_hint() -> I32 {
    spin_loop_hint()
    return 0
}
