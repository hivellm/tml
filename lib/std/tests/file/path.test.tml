// Consolidated tests for std::file::path::Path and std::file::dir::Dir
use test
use std::file::path::Path
use std::file::dir::Dir
use test::{assert, assert_eq}
use std::file::file::File

// === Path basic operations ===

@test
func test_path_join() -> I32 {
    let result: Str = Path::join("parent", "child")
    assert(result.len() > 0, "join should produce non-empty path")
    return 0
}

@test
func test_path_filename() -> I32 {
    let name: Str = Path::filename("some/dir/file.txt")
    assert_eq(name, "file.txt", "filename should extract file name")
    return 0
}

@test
func test_path_extension() -> I32 {
    let ext: Str = Path::extension("document.pdf")
    assert_eq(ext, ".pdf", "extension should include dot")
    return 0
}

@test
func test_path_parent() -> I32 {
    let p: Str = Path::parent("some/dir/file.txt")
    assert(p.len() > 0, "parent should return non-empty path")
    return 0
}

@test
func test_path_absolute() -> I32 {
    let abs: Str = Path::absolute(".")
    assert(abs.len() > 0, "absolute path should be non-empty")
    return 0
}

// === Path predicates ===

@test
func test_path_is_dir() -> I32 {
    assert(Path::is_dir("build"), "build should be a directory")
    assert(not Path::is_dir("__nonexistent_xyz__"), "nonexistent should not be dir")
    return 0
}

@test
func test_path_exists() -> I32 {
    assert(Path::exists("build"), "build directory should exist")
    assert(not Path::exists("__nonexistent_dir_xyz__"), "nonexistent should return false")
    return 0
}

@test
func test_path_create_dir_all() -> I32 {
    let ok: Bool = Path::create_dir_all("build/debug/test_temp_dir")
    assert(ok, "create_dir_all should succeed")
    return 0
}

// === Dir operations ===

@test
func test_dir_create_and_remove() -> I32 {
    let dir_path: Str = "build/debug/_test_dir_tmp"
    let created: Bool = Dir::create(dir_path)
    assert(created, "Dir::create should succeed")
    assert(Path::exists(dir_path), "created dir should exist")
    assert(Path::is_dir(dir_path), "should be a directory")

    let removed: Bool = Dir::remove(dir_path)
    assert(removed, "Dir::remove should succeed")
    assert(not Path::exists(dir_path), "removed dir should not exist")
    return 0
}

@test
func test_dir_create_all() -> I32 {
    let dir_path: Str = "build/debug/_test_dir_nested/a/b"
    let created: Bool = Dir::create_all(dir_path)
    assert(created, "Dir::create_all should succeed")
    assert(Path::exists(dir_path), "nested dir should exist")
    assert(Path::is_dir(dir_path), "should be a directory")

    Dir::remove("build/debug/_test_dir_nested/a/b")
    Dir::remove("build/debug/_test_dir_nested/a")
    Dir::remove("build/debug/_test_dir_nested")
    return 0
}

@test
func test_dir_create_existing() -> I32 {
    let dir_path: Str = "build/debug/_test_dir_existing"
    Dir::create(dir_path)
    let created_again: Bool = Dir::create(dir_path)
    Dir::remove(dir_path)
    return 0
}

@test
func test_path_is_file() -> I32 {
    let tmp = "build/debug/_test_is_file.tmp"
    File::write_all(tmp, "hello")
    assert(Path::is_file(tmp), "tmp file should be a file")
    assert(not Path::is_file("build"), "build should not be a file")
    Path::remove(tmp)
    0
}

@test
func test_path_remove_file() -> I32 {
    let tmp = "build/debug/_test_remove.tmp"
    File::write_all(tmp, "data")
    assert(Path::exists(tmp), "file should exist before remove")
    let ok = Path::remove(tmp)
    assert(ok, "remove should succeed")
    assert(not Path::exists(tmp), "file should not exist after remove")
    0
}

@test
func test_path_rename() -> I32 {
    let src = "build/debug/_test_rename_src.tmp"
    let dst = "build/debug/_test_rename_dst.tmp"
    File::write_all(src, "rename me")
    let ok = Path::rename(src, dst)
    assert(ok, "rename should succeed")
    assert(not Path::exists(src), "src should not exist after rename")
    assert(Path::exists(dst), "dst should exist after rename")
    Path::remove(dst)
    0
}

@test
func test_path_copy() -> I32 {
    let src = "build/debug/_test_copy_src.tmp"
    let dst = "build/debug/_test_copy_dst.tmp"
    File::write_all(src, "copy me")
    // path_copy may not be implemented on all platforms
    let ok = Path::copy(src, dst)
    // Just exercise the function, don't assert return value
    let _ = ok
    Path::remove(src)
    Path::remove(dst)
    0
}
