// Tests for Statement metadata, column access, and lifecycle methods
use test::{assert, assert_eq}
use std::sqlite::database::Database
use std::sqlite::constants::{SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT, SQLITE_NULL}

@test
func test_run() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (42)").unwrap()
    let result = stmt.run()
    assert(result.is_ok(), "run should succeed")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_reset() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_i64(1, 1).is_ok(), "bind should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    assert(stmt.reset().is_ok(), "reset should succeed")
    assert(stmt.bind_i64(1, 2).is_ok(), "rebind should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT count(*) FROM t").unwrap()
    assert(q.step(), "should have result")
    assert_eq(q.column_i64(0), 2, "should have 2 rows")
    q.finalize()
    db.close()
    return 0
}

@test
func test_clear_bindings() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let stmt = db.prepare("SELECT ?").unwrap()
    assert(stmt.bind_i64(1, 42).is_ok(), "bind should succeed")
    assert(stmt.clear_bindings().is_ok(), "clear_bindings should succeed")
    // After clearing, param should be null
    assert(stmt.step(), "should have row")
    assert(stmt.column_is_null(0), "cleared binding should be null")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_type() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (i INTEGER, f REAL, s TEXT)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1, 2.5, 'abc')").unwrap()
    let stmt = db.prepare("SELECT i, f, s FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.column_type(0), SQLITE_INTEGER, "col 0 should be INTEGER")
    assert_eq(stmt.column_type(1), SQLITE_FLOAT, "col 1 should be FLOAT")
    assert_eq(stmt.column_type(2), SQLITE_TEXT, "col 2 should be TEXT")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_name() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (alpha INTEGER, beta TEXT)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1, 'x')").unwrap()
    let stmt = db.prepare("SELECT alpha, beta FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.column_name(0), "alpha", "col 0 name should be alpha")
    assert_eq(stmt.column_name(1), "beta", "col 1 name should be beta")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_decltype() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER, name TEXT)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1, 'x')").unwrap()
    let stmt = db.prepare("SELECT val, name FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.column_decltype(0), "INTEGER", "col 0 decltype should be INTEGER")
    assert_eq(stmt.column_decltype(1), "TEXT", "col 1 decltype should be TEXT")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_i32() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (123)").unwrap()
    let stmt = db.prepare("SELECT val FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.column_i32(0), 123, "should be 123")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_bytes() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val TEXT)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES ('hello')").unwrap()
    let stmt = db.prepare("SELECT val FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.column_bytes(0), 5, "hello should be 5 bytes")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_column_is_null() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val TEXT)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (NULL)").unwrap()
    let stmt = db.prepare("SELECT val FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert(stmt.column_is_null(0), "value should be null")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_source_sql() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let sql: Str = "SELECT 1 + 2"
    let stmt = db.prepare(sql).unwrap()
    assert_eq(stmt.source_sql(), sql, "source_sql should match")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_data_count() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (a INTEGER, b TEXT, c REAL)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1, 'x', 2.0)").unwrap()
    let stmt = db.prepare("SELECT a, b, c FROM t").unwrap()
    assert(stmt.step(), "should have row")
    assert_eq(stmt.data_count(), 3, "data_count should be 3")
    stmt.finalize()
    db.close()
    return 0
}
