// Tests for std::sqlite::database
use test::{assert, assert_eq}
use std::sqlite::database::Database
use std::sqlite::constants::{SQLITE_OPEN_READWRITE, SQLITE_OPEN_CREATE, SQLITE_OPEN_MEMORY}

@test
func test_open_in_memory() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    assert(db.is_open(), "database should be open")
    db.close()
    return 0
}

@test
func test_sqlite_version() -> I32 {
    let ver: Str = Database::sqlite_version()
    assert(ver.len() > 0, "version should not be empty")
    return 0
}

@test
func test_sqlite_version_number() -> I32 {
    let num: I32 = Database::sqlite_version_number()
    assert(num > 3000000, "version number should be > 3.0.0")
    return 0
}

@test
func test_open_with_flags() -> I32 {
    let flags: I32 = SQLITE_OPEN_READWRITE + SQLITE_OPEN_CREATE + SQLITE_OPEN_MEMORY
    let db: Database = Database::open_with_flags(":memory:", flags).unwrap()
    assert(db.is_open(), "database should be open with flags")
    db.close()
    return 0
}

@test
func test_error_message_on_fresh_db() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let msg: Str = db.error_message()
    assert_eq(msg, "not an error", "fresh db should have no error")
    db.close()
    return 0
}

@test
func test_error_code_on_fresh_db() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let code: I32 = db.error_code()
    assert_eq(code, 0, "fresh db should have error code 0")
    db.close()
    return 0
}

@test
func test_error_after_bad_sql() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let result = db.exec("THIS IS NOT SQL")
    assert(result.is_err(), "bad SQL should fail")
    let code: I32 = db.error_code()
    assert(code != 0, "error code should be non-zero after error")
    let msg: Str = db.error_message()
    assert(msg.len() > 0, "error message should not be empty")
    db.close()
    return 0
}

@test
func test_is_readonly_memory_db() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    assert(not db.is_readonly(), "memory db should not be readonly")
    db.close()
    return 0
}

@test
func test_raw_handle() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let handle: *Unit = db.raw_handle()
    assert(handle as I64 != 0, "raw handle should not be null")
    db.close()
    return 0
}

@test
func test_begin_immediate() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.begin_immediate().unwrap()
    assert(db.is_transaction(), "should be in transaction after begin_immediate")
    let _: I32 = db.commit().unwrap()
    db.close()
    return 0
}

@test
func test_begin_exclusive() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.begin_exclusive().unwrap()
    assert(db.is_transaction(), "should be in transaction after begin_exclusive")
    let _: I32 = db.commit().unwrap()
    db.close()
    return 0
}

@test
func test_savepoint_release() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let _: I32 = db.savepoint("sp1").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1)").unwrap()
    let _: I32 = db.release("sp1").unwrap()
    // Row should persist after release
    let stmt = db.prepare("SELECT count(*) FROM t").unwrap()
    assert(stmt.step(), "should have result")
    assert_eq(stmt.column_i64(0), 1, "should have 1 row after release")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_savepoint_rollback_to() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (1)").unwrap()
    let _: I32 = db.savepoint("sp1").unwrap()
    let _: I32 = db.exec("INSERT INTO t VALUES (2)").unwrap()
    let _: I32 = db.rollback_to("sp1").unwrap()
    let _: I32 = db.release("sp1").unwrap()
    // Only first row should remain
    let stmt = db.prepare("SELECT count(*) FROM t").unwrap()
    assert(stmt.step(), "should have result")
    assert_eq(stmt.column_i64(0), 1, "should have 1 row after rollback_to")
    stmt.finalize()
    db.close()
    return 0
}
