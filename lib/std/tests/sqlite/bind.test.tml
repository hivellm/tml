// Tests for Statement parameter binding methods
use test::{assert, assert_eq}
use std::sqlite::database::Database
use std::sqlite::constants::{SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT, SQLITE_NULL}

@test
func test_bind_i64() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_i64(1, 42).is_ok(), "bind_i64 should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT val FROM t").unwrap()
    assert(q.step(), "should have row")
    assert_eq(q.column_i64(0), 42, "should be 42")
    q.finalize()
    db.close()
    return 0
}

@test
func test_bind_i32() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val INTEGER)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_i32(1, 99).is_ok(), "bind_i32 should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT val FROM t").unwrap()
    assert(q.step(), "should have row")
    assert_eq(q.column_i64(0), 99, "should be 99")
    q.finalize()
    db.close()
    return 0
}

@test
func test_bind_f64() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val REAL)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_f64(1, 3.14).is_ok(), "bind_f64 should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT val FROM t").unwrap()
    assert(q.step(), "should have row")
    let v: F64 = q.column_f64(0)
    assert(v > 3.13 and v < 3.15, "should be ~3.14")
    q.finalize()
    db.close()
    return 0
}

@test
func test_bind_str() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val TEXT)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_str(1, "hello").is_ok(), "bind_str should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT val FROM t").unwrap()
    assert(q.step(), "should have row")
    assert_eq(q.column_str(0), "hello", "should be hello")
    q.finalize()
    db.close()
    return 0
}

@test
func test_bind_null() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let _: I32 = db.exec("CREATE TABLE t (val TEXT)").unwrap()
    let stmt = db.prepare("INSERT INTO t VALUES (?)").unwrap()
    assert(stmt.bind_null(1).is_ok(), "bind_null should succeed")
    let _: Outcome[I32, Str] = stmt.run()
    stmt.finalize()
    let q = db.prepare("SELECT val FROM t").unwrap()
    assert(q.step(), "should have row")
    assert(q.column_is_null(0), "should be null")
    q.finalize()
    db.close()
    return 0
}

@test
func test_bind_parameter_count() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let stmt = db.prepare("SELECT ? + ? + ?").unwrap()
    assert_eq(stmt.bind_parameter_count(), 3, "should have 3 params")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_bind_parameter_name() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let stmt = db.prepare("SELECT :foo, :bar").unwrap()
    let name1: Str = stmt.bind_parameter_name(1)
    let name2: Str = stmt.bind_parameter_name(2)
    assert_eq(name1, ":foo", "first param should be :foo")
    assert_eq(name2, ":bar", "second param should be :bar")
    stmt.finalize()
    db.close()
    return 0
}

@test
func test_bind_parameter_index() -> I32 {
    let db: Database = Database::open_in_memory().unwrap()
    let stmt = db.prepare("SELECT :foo, :bar").unwrap()
    let idx1: I32 = stmt.bind_parameter_index(":foo")
    let idx2: I32 = stmt.bind_parameter_index(":bar")
    assert_eq(idx1, 1, ":foo should be index 1")
    assert_eq(idx2, 2, ":bar should be index 2")
    stmt.finalize()
    db.close()
    return 0
}
