// Lock-free data structure tests - LockFreeQueue and LockFreeStack
use test::{assert, assert_eq}
use std::sync::{LockFreeQueue, LockFreeStack}

// ============================================================================
// LockFreeQueue Tests
// ============================================================================

@test
func test_queue_new() -> I32 {
    let queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    assert(queue.is_empty(), "new queue should be empty")
    assert_eq(queue.len(), 0 as I64, "new queue len should be 0")
    return 0
}

@test
func test_queue_push_single() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(42)
    assert(not queue.is_empty(), "queue should not be empty after push")
    assert_eq(queue.len(), 1 as I64, "queue len should be 1")
    return 0
}

@test
func test_queue_push_pop_single() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(42)
    let result: Maybe[I32] = queue.pop()
    when result {
        Just(v) => assert_eq(v, 42, "popped value should be 42"),
        Nothing => assert(false, "pop should return Just"),
    }
    assert(queue.is_empty(), "queue should be empty after pop")
    return 0
}

@test
func test_queue_fifo_order() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    queue.push(1)
    queue.push(2)
    queue.push(3)

    let r1: Maybe[I32] = queue.pop()
    when r1 {
        Just(v) => assert_eq(v, 1, "first pop should be 1"),
        Nothing => assert(false, "pop should return Just"),
    }

    let r2: Maybe[I32] = queue.pop()
    when r2 {
        Just(v) => assert_eq(v, 2, "second pop should be 2"),
        Nothing => assert(false, "pop should return Just"),
    }

    let r3: Maybe[I32] = queue.pop()
    when r3 {
        Just(v) => assert_eq(v, 3, "third pop should be 3"),
        Nothing => assert(false, "pop should return Just"),
    }
    return 0
}

@test
func test_queue_pop_empty() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()
    let result: Maybe[I32] = queue.pop()
    when result {
        Just(_) => assert(false, "pop on empty should return Nothing"),
        Nothing => assert(true, "pop on empty returns Nothing"),
    }
    return 0
}

@test
func test_queue_multiple_push_pop() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()

    var i: I32 = 0
    loop (i < 5) {
        queue.push(i * 10)
        i = i + 1
    }

    assert_eq(queue.len(), 5 as I64, "queue should have 5 elements")

    i = 0
    loop (i < 5) {
        let result: Maybe[I32] = queue.pop()
        when result {
            Just(v) => assert_eq(v, i * 10, "values should match in FIFO order"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i + 1
    }

    assert(queue.is_empty(), "queue should be empty after all pops")
    return 0
}

@test
func test_queue_len_updates() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()

    assert_eq(queue.len(), 0 as I64, "initial len 0")

    queue.push(1)
    assert_eq(queue.len(), 1 as I64, "len 1 after push")

    queue.push(2)
    assert_eq(queue.len(), 2 as I64, "len 2 after push")

    queue.pop()
    assert_eq(queue.len(), 1 as I64, "len 1 after pop")

    queue.pop()
    assert_eq(queue.len(), 0 as I64, "len 0 after pop")

    return 0
}

// ============================================================================
// LockFreeStack Tests
// ============================================================================

@test
func test_stack_new() -> I32 {
    let stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    assert(stack.is_empty(), "new stack should be empty")
    assert_eq(stack.len(), 0 as I64, "new stack len should be 0")
    return 0
}

@test
func test_stack_push_single() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(42)
    assert(not stack.is_empty(), "stack should not be empty after push")
    assert_eq(stack.len(), 1 as I64, "stack len should be 1")
    return 0
}

@test
func test_stack_push_pop_single() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(42)
    let result: Maybe[I32] = stack.pop()
    when result {
        Just(v) => assert_eq(v, 42, "popped value should be 42"),
        Nothing => assert(false, "pop should return Just"),
    }
    assert(stack.is_empty(), "stack should be empty after pop")
    return 0
}

@test
func test_stack_lifo_order() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    stack.push(1)
    stack.push(2)
    stack.push(3)

    let r1: Maybe[I32] = stack.pop()
    when r1 {
        Just(v) => assert_eq(v, 3, "first pop should be 3 (LIFO)"),
        Nothing => assert(false, "pop should return Just"),
    }

    let r2: Maybe[I32] = stack.pop()
    when r2 {
        Just(v) => assert_eq(v, 2, "second pop should be 2"),
        Nothing => assert(false, "pop should return Just"),
    }

    let r3: Maybe[I32] = stack.pop()
    when r3 {
        Just(v) => assert_eq(v, 1, "third pop should be 1"),
        Nothing => assert(false, "pop should return Just"),
    }
    return 0
}

@test
func test_stack_pop_empty() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()
    let result: Maybe[I32] = stack.pop()
    when result {
        Just(_) => assert(false, "pop on empty should return Nothing"),
        Nothing => assert(true, "pop on empty returns Nothing"),
    }
    return 0
}

@test
func test_stack_multiple_push_pop() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()

    var i: I32 = 0
    loop (i < 5) {
        stack.push(i * 10)
        i = i + 1
    }

    assert_eq(stack.len(), 5 as I64, "stack should have 5 elements")

    i = 4
    loop (i >= 0) {
        let result: Maybe[I32] = stack.pop()
        when result {
            Just(v) => assert_eq(v, i * 10, "values should match in LIFO order"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i - 1
    }

    assert(stack.is_empty(), "stack should be empty after all pops")
    return 0
}

@test
func test_stack_len_updates() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()

    assert_eq(stack.len(), 0 as I64, "initial len 0")

    stack.push(1)
    assert_eq(stack.len(), 1 as I64, "len 1 after push")

    stack.push(2)
    assert_eq(stack.len(), 2 as I64, "len 2 after push")

    stack.pop()
    assert_eq(stack.len(), 1 as I64, "len 1 after pop")

    stack.pop()
    assert_eq(stack.len(), 0 as I64, "len 0 after pop")

    return 0
}

@test
func test_stack_clear() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()

    stack.push(1)
    stack.push(2)
    stack.push(3)

    assert_eq(stack.len(), 3 as I64, "len 3 before clear")

    stack.clear()

    assert(stack.is_empty(), "stack should be empty after clear")
    assert_eq(stack.len(), 0 as I64, "len 0 after clear")

    return 0
}

// ============================================================================
// Large Batch Tests
// ============================================================================

@test
func test_queue_large_batch() -> I32 {
    var queue: LockFreeQueue[I32] = LockFreeQueue::new[I32]()

    var i: I32 = 0
    loop (i < 100) {
        queue.push(i)
        i = i + 1
    }

    assert_eq(queue.len(), 100 as I64, "queue should have 100 elements")

    i = 0
    loop (i < 100) {
        let result: Maybe[I32] = queue.pop()
        when result {
            Just(v) => assert_eq(v, i, "FIFO order maintained"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i + 1
    }

    return 0
}

@test
func test_stack_large_batch() -> I32 {
    var stack: LockFreeStack[I32] = LockFreeStack::new[I32]()

    var i: I32 = 0
    loop (i < 100) {
        stack.push(i)
        i = i + 1
    }

    assert_eq(stack.len(), 100 as I64, "stack should have 100 elements")

    i = 99
    loop (i >= 0) {
        let result: Maybe[I32] = stack.pop()
        when result {
            Just(v) => assert_eq(v, i, "LIFO order maintained"),
            Nothing => assert(false, "pop should return Just"),
        }
        i = i - 1
    }

    return 0
}
