// Advanced regex tests: shorthand classes, anchors, find, replace, split
use test::{assert, assert_eq}
use std::regex::{Regex, Match}
use std::collections::List

@test
func test_shorthand_digit() -> I32 {
    let re: Regex = Regex::new("\\d+")
    assert(re.is_match("abc123"), "\\d+ should match digits in abc123")
    assert(not re.is_match("abc"), "\\d+ should not match abc")
    re.destroy()
    return 0
}

@test
func test_shorthand_word() -> I32 {
    let re: Regex = Regex::new("\\w+")
    assert(re.is_match("hello"), "\\w+ should match hello")
    assert(re.is_match("test_123"), "\\w+ should match test_123")
    re.destroy()
    return 0
}

@test
func test_shorthand_space() -> I32 {
    let re: Regex = Regex::new("a\\sb")
    assert(re.is_match("a b"), "a\\sb should match 'a b'")
    assert(not re.is_match("ab"), "a\\sb should not match 'ab'")
    re.destroy()
    return 0
}

@test
func test_negated_shorthand() -> I32 {
    let re: Regex = Regex::new("\\D+")
    assert(re.is_match("abc"), "\\D+ should match abc")
    assert(not re.is_match("123"), "\\D+ should not match 123")
    re.destroy()
    return 0
}

@test
func test_anchor_start() -> I32 {
    let re: Regex = Regex::new("^hello")
    assert(re.is_match("hello world"), "^hello should match start")
    assert(not re.is_match("say hello"), "^hello should not match mid")
    re.destroy()
    return 0
}

@test
func test_anchor_end() -> I32 {
    let re: Regex = Regex::new("world$")
    assert(re.is_match("hello world"), "world$ should match end")
    assert(not re.is_match("world hello"), "world$ should not match mid")
    re.destroy()
    return 0
}

@test
func test_find_position() -> I32 {
    let re: Regex = Regex::new("\\d+")
    let m: Match = re.find("abc123def")
    assert(m.matched(), "should find digits")
    assert_eq(m.start(), 3, "start should be 3")
    assert_eq(m.end(), 6, "end should be 6")
    let g: Str = m.group("abc123def")
    assert_eq(g, "123", "group should be '123'")
    re.destroy()
    return 0
}

@test
func test_find_no_match() -> I32 {
    let re: Regex = Regex::new("\\d+")
    let m: Match = re.find("abcdef")
    assert(not m.matched(), "should not find digits")
    re.destroy()
    return 0
}

@test
func test_replace_first() -> I32 {
    let re: Regex = Regex::new("\\d+")
    let r: Str = re.replace("abc123def456", "NUM")
    assert_eq(r, "abcNUMdef456", "replace first match")
    re.destroy()
    return 0
}

@test
func test_replace_all() -> I32 {
    let re: Regex = Regex::new("\\d+")
    let r: Str = re.replace_all("abc123def456", "N")
    assert_eq(r, "abcNdefN", "replace all matches")
    re.destroy()
    return 0
}

@test
func test_find_all() -> I32 {
    let re: Regex = Regex::new("\\d+")
    let results: List[I64] = re.find_all("a1b22c333")
    // results should be [1,2, 3,5, 6,9] (start,end pairs)
    assert_eq(results.len(), 6, "should have 3 matches (6 entries)")
    assert_eq(results.get(0), 1, "first match start")
    assert_eq(results.get(1), 2, "first match end")
    assert_eq(results.get(2), 3, "second match start")
    assert_eq(results.get(3), 5, "second match end")
    assert_eq(results.get(4), 6, "third match start")
    assert_eq(results.get(5), 9, "third match end")
    results.destroy()
    re.destroy()
    return 0
}

@test
func test_split() -> I32 {
    let re: Regex = Regex::new(",")
    let parts: List[I64] = re.split("a,b,c")
    // parts should be [0,1, 2,3, 4,5] (start,end pairs for "a", "b", "c")
    assert_eq(parts.len(), 6, "should have 3 segments")
    assert_eq(parts.get(0), 0, "first segment start")
    assert_eq(parts.get(1), 1, "first segment end")
    assert_eq(parts.get(2), 2, "second segment start")
    assert_eq(parts.get(3), 3, "second segment end")
    assert_eq(parts.get(4), 4, "third segment start")
    assert_eq(parts.get(5), 5, "third segment end")
    parts.destroy()
    re.destroy()
    return 0
}
