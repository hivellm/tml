//! Network Standard Library Tests
//!
//! Tests for the networking API (IP addresses, socket addresses, RawSocket)

use test::{assert, assert_eq}
use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr, IpAddr}
use std::net::sys::{RawSocket, SocketType, SocketProtocol, AddressFamily}
use std::net::error::{NetError, NetErrorKind}

// ============================================================================
// IP Address Tests
// ============================================================================

@test
func test_ipv4_localhost() {
    let localhost: Ipv4Addr = Ipv4Addr::LOCALHOST()
    assert(localhost.is_loopback(), "LOCALHOST should be loopback")
    // Verify to_bits() gives correct 32-bit representation
    let bits: U32 = localhost.to_bits()
    assert_eq(bits, 0x7F000001 as U32)
}

@test
func test_ipv4_unspecified() {
    let unspec: Ipv4Addr = Ipv4Addr::UNSPECIFIED()
    assert(unspec.is_unspecified(), "UNSPECIFIED should be unspecified")
    // Verify to_bits() gives zero
    let bits: U32 = unspec.to_bits()
    assert_eq(bits, 0 as U32)
}

@test
func test_ipv4_broadcast() {
    let broadcast: Ipv4Addr = Ipv4Addr::BROADCAST()
    assert(broadcast.is_broadcast(), "BROADCAST should be broadcast")
}

@test
func test_ipv4_from_octets() {
    let ip: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    // Verify to_bits() gives correct 32-bit representation
    let bits: U32 = ip.to_bits()
    assert_eq(bits, 0xC0A80101 as U32)  // 192.168.1.1 in hex
    assert(ip.is_private(), "192.168.x.x should be private")
}

@test
func test_ipv4_from_bits() {
    let ip: Ipv4Addr = Ipv4Addr::from_bits(0xC0A80101 as U32)
    let bits: U32 = ip.to_bits()
    assert_eq(bits, 0xC0A80101 as U32)
    assert(ip.is_private(), "192.168.1.1 should be private")
}

// ============================================================================
// Socket Address Tests
// ============================================================================

@test
func test_socket_addr_v4_creation() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)
    assert(addr.ip().is_loopback(), "IP should be loopback")
}

@test
func test_socket_addr_port_change() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    var addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)

    addr.set_port(9090 as U16)
    assert_eq(addr.port(), 9090 as U16)
}

@test
func test_socket_addr_enum() {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)

    assert(addr.is_ipv4(), "Should be IPv4")
    assert(not addr.is_ipv6(), "Should not be IPv6")
    assert_eq(addr.port(), 80 as U16)
}

// ============================================================================
// RawSocket Tests
// ============================================================================

@test
func test_raw_socket_tcp_creation() {
    when RawSocket::tcp() {
        Ok(s) => {
            let socket: RawSocket = s
            assert(socket.is_valid(), "TCP socket should be valid")
        }
        Err(e) => {
            assert(false, "Failed to create TCP socket")
        }
    }
}

@test
func test_raw_socket_udp_creation() {
    when RawSocket::udp() {
        Ok(s) => {
            let socket: RawSocket = s
            assert(socket.is_valid(), "UDP socket should be valid")
        }
        Err(e) => {
            assert(false, "Failed to create UDP socket")
        }
    }
}

@test
func test_raw_socket_with_family() {
    when RawSocket::new_with_family(AddressFamily::Inet, SocketType::Stream, SocketProtocol::Tcp) {
        Ok(s) => {
            let socket: RawSocket = s
            assert(socket.is_valid(), "Socket should be valid")
            assert_eq(socket.family(), AddressFamily::Inet)
            assert_eq(socket.socket_type(), SocketType::Stream)
        }
        Err(e) => {
            assert(false, "Failed to create socket with family")
        }
    }
}

@test
func test_raw_socket_nonblocking() {
    when RawSocket::tcp() {
        Ok(s) => {
            var socket: RawSocket = s
            when socket.set_nonblocking(true) {
                Ok(()) => assert(true, "Set non-blocking succeeded")
                Err(e) => assert(false, "Failed to set non-blocking")
            }
            when socket.set_nonblocking(false) {
                Ok(()) => assert(true, "Set blocking succeeded")
                Err(e) => assert(false, "Failed to set blocking")
            }
        }
        Err(e) => {
            assert(false, "Failed to create socket")
        }
    }
}

@test
func test_raw_socket_options() {
    when RawSocket::tcp() {
        Ok(s) => {
            let socket: RawSocket = s
            // Test set_nodelay
            when socket.set_nodelay(true) {
                Ok(()) => assert(true, "Set nodelay succeeded")
                Err(e) => assert(false, "Failed to set nodelay")
            }

            // Test set_keepalive
            when socket.set_keepalive(true) {
                Ok(()) => assert(true, "Set keepalive succeeded")
                Err(e) => assert(false, "Failed to set keepalive")
            }

            // Test set_reuse_addr
            when socket.set_reuse_addr(true) {
                Ok(()) => assert(true, "Set reuse_addr succeeded")
                Err(e) => assert(false, "Failed to set reuse_addr")
            }
        }
        Err(e) => {
            assert(false, "Failed to create socket")
        }
    }
}

// ============================================================================
// Error Type Tests
// ============================================================================

@test
func test_net_error_kinds() {
    let conn_refused: NetError = NetError::new(NetErrorKind::ConnectionRefused)
    assert(conn_refused.is_connection_refused(), "Should be connection refused")

    let would_block: NetError = NetError::new(NetErrorKind::WouldBlock)
    assert(would_block.is_would_block(), "Should be would block")

    let not_connected: NetError = NetError::new(NetErrorKind::NotConnected)
    assert(not_connected.is_not_connected(), "Should be not connected")
}
