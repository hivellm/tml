// TLS version constraint, cipher inspection, and certificate verification tests.
// Validates TLS 1.2 and TLS 1.3 negotiation against real servers.
use test::{assert, assert_eq}
use std::net::dns
use std::net::ip::Ipv4Addr
use std::net::{SocketAddr, SocketAddrV4}
use std::net::tcp::TcpStream
use std::net::tls::{TlsContext, TlsStream, TlsVersion, TlsVerifyMode}
use std::net::tls
use std::net::sys::RawSocket

// ============================================================================
// Force TLS 1.2 to google.com
// ============================================================================

@test
func test_tls_force_12_google() -> I32 {
    let ip: Ipv4Addr = dns::lookup("google.com").unwrap()
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(ip, 443 as U16))
    let tcp: TcpStream = TcpStream::connect(addr).unwrap()
    let ctx: TlsContext = TlsContext::client().unwrap()
    ctx.set_verify_mode(TlsVerifyMode::None())
    let _r1 = ctx.set_min_version(TlsVersion::TLS_1_2())
    let _r2 = ctx.set_max_version(TlsVersion::TLS_1_2())
    let raw: RawSocket = tcp.into_raw_socket()
    let fd: I64 = raw.handle
    let stream: TlsStream = TlsStream::connect(ctx, fd, "google.com").unwrap()

    let ver: Str = stream.version()
    assert_eq(ver, "TLSv1.2", "should negotiate exactly TLSv1.2")

    let cipher: Str = stream.cipher()
    assert(cipher.len() > 0, "cipher should not be empty")

    // verify_result + peer_verified with None verify mode
    let verify_code: I32 = stream.verify_result()
    let verified: Bool = stream.peer_verified()
    if verified {
        assert(true, "peer is verified")
    } else {
        assert(false, "peer should be verified")
    }

    stream.shutdown()
    0
}
