// TLS certificate verification and version constraint tests
use test::{assert, assert_eq}
use std::net::dns
use std::net::ip::Ipv4Addr
use std::net::{SocketAddr, SocketAddrV4}
use std::net::tcp::TcpStream
use std::net::tls::{TlsContext, TlsStream, TlsVersion, TlsVerifyMode}
use std::net::tls
use std::net::sys::RawSocket

// ============================================================================
// Force TLS 1.2, verify_result, peer_verified
// ============================================================================

@test
func test_tls_google_force_tls12() -> I32 {
    let ip: Ipv4Addr = dns::lookup("google.com").unwrap()
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(ip, 443 as U16))
    let tcp: TcpStream = TcpStream::connect(addr).unwrap()
    let ctx: TlsContext = TlsContext::client().unwrap()
    ctx.set_verify_mode(TlsVerifyMode::None())
    let _r1 = ctx.set_min_version(TlsVersion::TLS_1_2())
    let _r2 = ctx.set_max_version(TlsVersion::TLS_1_2())
    let raw: RawSocket = tcp.into_raw_socket()
    let fd: I64 = raw.handle
    let stream: TlsStream = TlsStream::connect(ctx, fd, "google.com").unwrap()

    let ver: Str = stream.version()
    print("  Forced TLS version: " + ver + "\n")
    assert_eq(ver, "TLSv1.2", "version should be exactly TLSv1.2")

    // verify_result with None verify mode
    let verify_code: I32 = stream.verify_result()
    print("  Verify result: ")
    if verify_code == 0 {
        print("0 (X509_V_OK)\n")
    } else {
        print("non-zero (expected with None verify)\n")
    }

    // peer_verified with None verify mode
    let verified: Bool = stream.peer_verified()
    if verified {
        print("  Peer verified: true\n")
    } else {
        print("  Peer verified: false (expected with None verify)\n")
    }

    stream.shutdown()
    0
}
