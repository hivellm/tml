// TLS 1.3 negotiation test against Cloudflare.
// Cloudflare fully supports TLS 1.3, making it ideal for version constraint testing.
use test::{assert, assert_eq}
use std::net::dns
use std::net::ip::Ipv4Addr
use std::net::{SocketAddr, SocketAddrV4}
use std::net::tcp::TcpStream
use std::net::tls::{TlsContext, TlsStream, TlsVersion, TlsVerifyMode}
use std::net::tls
use std::net::sys::RawSocket

// ============================================================================
// Force TLS 1.3 to cloudflare.com
// ============================================================================

@test
func test_tls_force_13_cloudflare() -> I32 {
    let ip: Ipv4Addr = dns::lookup("cloudflare.com").unwrap()
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(ip, 443 as U16))
    let tcp: TcpStream = TcpStream::connect(addr).unwrap()
    let ctx: TlsContext = TlsContext::client().unwrap()
    ctx.set_verify_mode(TlsVerifyMode::None())
    let _r1 = ctx.set_min_version(TlsVersion::TLS_1_3())
    let _r2 = ctx.set_max_version(TlsVersion::TLS_1_3())
    let raw: RawSocket = tcp.into_raw_socket()
    let fd: I64 = raw.handle
    let stream: TlsStream = TlsStream::connect(ctx, fd, "cloudflare.com").unwrap()

    let ver: Str = stream.version()
    assert_eq(ver, "TLSv1.3", "should negotiate exactly TLSv1.3")

    let cipher: Str = stream.cipher()
    assert(cipher.len() > 0, "cipher should not be empty")

    let cn: Str = stream.peer_cn()

    let verify_code: I32 = stream.verify_result()
    let verified: Bool = stream.peer_verified()
    if verified {
    } else {
    }

    stream.shutdown()
    0
}
