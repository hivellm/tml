// Tests for UDP socket operations
use test
use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr}
use std::net::udp::{UdpSocket, UdpBuilder}

// --- Bind and basic accessors ---

@test
func test_udp_bind_loopback() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let result = UdpSocket::bind(addr)
    assert(result.is_ok(), "bind to loopback should succeed")
    return 0
}

@test
func test_udp_local_addr() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let local = sock.local_addr()
    assert(local.is_ok(), "local_addr should succeed")
    return 0
}

@test
func test_udp_not_connected() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    assert(not sock.is_connected(), "should not be connected initially")
    return 0
}

@test
func test_udp_peer_addr_not_connected() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let peer = sock.peer_addr()
    assert(peer.is_err(), "peer_addr should fail when not connected")
    return 0
}

@test
func test_udp_set_ttl() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let r = sock.set_ttl(64)
    assert(r.is_ok(), "set_ttl should succeed")
    return 0
}

@test
func test_udp_set_broadcast() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let r = sock.set_broadcast(true)
    assert(r.is_ok(), "set_broadcast should succeed")
    return 0
}

@test
func test_udp_set_nonblocking() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let mut sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let r = sock.set_nonblocking(true)
    assert(r.is_ok(), "set_nonblocking should succeed")
    return 0
}

@test
func test_udp_multicast_loop_v4() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let r = sock.set_multicast_loop_v4(false)
    assert(r.is_ok(), "set_multicast_loop_v4 should succeed")
    return 0
}

@test
func test_udp_multicast_ttl_v4() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let r = sock.set_multicast_ttl_v4(5)
    assert(r.is_ok(), "set_multicast_ttl_v4 should succeed")
    return 0
}

@test
func test_udp_connect_loopback() -> I32 {
    let v4a: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr_a: SocketAddr = SocketAddr::V4(v4a)
    let sock_a: UdpSocket = UdpSocket::bind(addr_a).unwrap()
    let local_a: SocketAddr = sock_a.local_addr().unwrap()

    let v4b: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr_b: SocketAddr = SocketAddr::V4(v4b)
    let mut sock_b: UdpSocket = UdpSocket::bind(addr_b).unwrap()

    let r = sock_b.connect(local_a)
    assert(r.is_ok(), "connect should succeed")
    assert(sock_b.is_connected(), "should be connected after connect")
    return 0
}

@test
func test_udp_send_not_connected() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let buf: [U8; 4] = [1, 2, 3, 4]
    let r = sock.send(ref buf)
    assert(r.is_err(), "send without connect should fail")
    return 0
}

@test
func test_udp_recv_not_connected() -> I32 {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let sock: UdpSocket = UdpSocket::bind(addr).unwrap()
    let mut buf: [U8; 64] = [0; 64]
    let r = sock.recv(mut ref buf)
    assert(r.is_err(), "recv without connect should fail")
    return 0
}

@test
func test_udp_builder_default() -> I32 {
    let builder: UdpBuilder = UdpBuilder::new()
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let result = builder.bind(addr)
    assert(result.is_ok(), "builder bind should succeed")
    return 0
}
