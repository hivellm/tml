// Test: std::net::tls module
// Tests TLS types, context configuration, stream operations, and helpers
use test::{assert, assert_eq, assert_ne}
use std::net::tls::{TlsContext, TlsStream, TlsVersion, TlsVerifyMode}
use std::net::tls
use std::net::error::{NetError, NetErrorKind}

// ============================================================================
// TLS Version Tests
// ============================================================================

@test
func test_tls_version_1_2() -> I32 {
    let v: TlsVersion = TlsVersion::TLS_1_2()
    assert_eq(v.raw(), 0x0303, "TLS 1.2 should be 0x0303")
    return 0
}

@test
func test_tls_version_1_3() -> I32 {
    let v: TlsVersion = TlsVersion::TLS_1_3()
    assert_eq(v.raw(), 0x0304, "TLS 1.3 should be 0x0304")
    return 0
}

@test
func test_tls_version_legacy() -> I32 {
    let v10: TlsVersion = TlsVersion::TLS_1_0()
    assert_eq(v10.raw(), 0x0301, "TLS 1.0 should be 0x0301")

    let v11: TlsVersion = TlsVersion::TLS_1_1()
    assert_eq(v11.raw(), 0x0302, "TLS 1.1 should be 0x0302")
    return 0
}

// ============================================================================
// TLS Verify Mode Tests
// ============================================================================

@test
func test_tls_verify_mode_none() -> I32 {
    let mode: TlsVerifyMode = TlsVerifyMode::None()
    assert_eq(mode.raw(), 0, "None should be 0")
    return 0
}

@test
func test_tls_verify_mode_peer() -> I32 {
    let mode: TlsVerifyMode = TlsVerifyMode::Peer()
    assert_eq(mode.raw(), 1, "Peer should be 1")
    return 0
}

@test
func test_tls_verify_mode_require_client() -> I32 {
    let mode: TlsVerifyMode = TlsVerifyMode::RequireClientCert()
    assert_eq(mode.raw(), 2, "RequireClientCert should be 2")
    return 0
}

// ============================================================================
// TLS Context Tests
// ============================================================================

@test
func test_tls_client_context_creation() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            // Context created successfully - OpenSSL available
            let handle: *Unit = ctx.raw_handle()
            assert(handle != null, "Client context handle should not be null")
        }
        Err(e) => {
            // OK if OpenSSL stubs are in use
            assert(true, "Client context error (stubs)")
        }
    }
    return 0
}

@test
func test_tls_server_context_missing_cert() -> I32 {
    // Server context with non-existent cert should fail
    let result = TlsContext::server("nonexistent.crt", "nonexistent.key")
    when result {
        Ok(ctx) => {
            // Should not succeed with non-existent files
            assert(false, "Server should fail with missing cert")
        }
        Err(e) => {
            // Expected failure
            assert(true, "Server context correctly rejects missing cert")
        }
    }
    return 0
}

// ============================================================================
// TLS Version to_string Tests
// ============================================================================

@test
func test_tls_version_to_string_1_2() -> I32 {
    let v: TlsVersion = TlsVersion::TLS_1_2()
    assert_eq(v.to_string(), "TLS 1.2", "TLS 1.2 to_string")
    return 0
}

@test
func test_tls_version_to_string_1_3() -> I32 {
    let v: TlsVersion = TlsVersion::TLS_1_3()
    assert_eq(v.to_string(), "TLS 1.3", "TLS 1.3 to_string")
    return 0
}

@test
func test_tls_version_to_string_legacy() -> I32 {
    let v10: TlsVersion = TlsVersion::TLS_1_0()
    assert_eq(v10.to_string(), "TLS 1.0", "TLS 1.0 to_string")

    let v11: TlsVersion = TlsVersion::TLS_1_1()
    assert_eq(v11.to_string(), "TLS 1.1", "TLS 1.1 to_string")
    return 0
}

@test
func test_tls_version_to_string_unknown() -> I32 {
    let v: TlsVersion = TlsVersion { value: 0x9999 }
    assert_eq(v.to_string(), "Unknown", "Unknown version to_string")
    return 0
}

// ============================================================================
// TLS Context Configuration Tests
// ============================================================================

@test
func test_tls_context_set_verify_mode() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            // set_verify_mode returns void, just verify it doesn't crash
            ctx.set_verify_mode(TlsVerifyMode::None())
            ctx.set_verify_mode(TlsVerifyMode::Peer())
            ctx.set_verify_mode(TlsVerifyMode::RequireClientCert())
            assert(true, "set_verify_mode completed without error")
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_set_min_version() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let min_result = ctx.set_min_version(TlsVersion::TLS_1_2())
            when min_result {
                Ok(u) => {
                    assert(true, "set_min_version TLS 1.2 succeeded")
                }
                Err(e) => {
                    assert(false, "set_min_version TLS 1.2 should succeed")
                }
            }
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_set_max_version() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let max_result = ctx.set_max_version(TlsVersion::TLS_1_3())
            when max_result {
                Ok(u) => {
                    assert(true, "set_max_version TLS 1.3 succeeded")
                }
                Err(e) => {
                    assert(false, "set_max_version TLS 1.3 should succeed")
                }
            }
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_set_ciphers() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let cipher_result = ctx.set_ciphers("HIGH:!aNULL:!MD5")
            when cipher_result {
                Ok(u) => {
                    assert(true, "set_ciphers succeeded")
                }
                Err(e) => {
                    assert(false, "set_ciphers should succeed with valid cipher string")
                }
            }
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_set_ciphersuites() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let suite_result = ctx.set_ciphersuites("TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256")
            when suite_result {
                Ok(u) => {
                    assert(true, "set_ciphersuites succeeded")
                }
                Err(e) => {
                    assert(false, "set_ciphersuites should succeed with valid suites")
                }
            }
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_set_ca_file_invalid() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let ca_result = ctx.set_ca_file("/nonexistent/ca-bundle.crt")
            when ca_result {
                Ok(u) => {
                    // Some OpenSSL versions may not fail on non-existent CA
                    assert(true, "set_ca_file returned ok")
                }
                Err(e) => {
                    assert(true, "set_ca_file correctly rejected invalid path")
                }
            }
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

@test
func test_tls_context_raw_handle() -> I32 {
    let result = TlsContext::client()
    when result {
        Ok(ctx) => {
            let h1: *Unit = ctx.raw_handle()
            let h2: *Unit = ctx.raw_handle()
            assert(h1 != null, "raw_handle should not be null")
            assert(h1 == h2, "raw_handle should return same handle")
        }
        Err(e) => {
            assert(true, "Skipped (stubs)")
        }
    }
    return 0
}

// ============================================================================
// Module-level Helpers
// ============================================================================

@test
func test_tls_clear_errors() -> I32 {
    // clear_errors is void, just verify it doesn't crash
    tls::clear_errors()
    assert(true, "clear_errors completed")
    return 0
}

@test
func test_tls_last_error() -> I32 {
    // After clearing, last_error should return an empty or non-crashing result
    tls::clear_errors()
    let err: Str = tls::last_error()
    // Just verify it doesn't crash - content depends on OpenSSL state
    assert(true, "last_error returned without crash")
    return 0
}
