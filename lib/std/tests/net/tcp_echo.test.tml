// TCP echo tests — single-threaded loopback send/recv cycle
// On loopback, connect() completes synchronously against a listening socket,
// so accept() returns immediately after connect() — no threads needed.
use test::{assert, assert_eq}
use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr}
use std::net::tcp::{TcpListener, TcpStream}

// --- Test 1: bind + listen + connect + accept lifecycle ---

@test
func test_tcp_connect_accept() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    // Bind listener (port 0 = OS assigns)
    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    // Client connects (completes synchronously on loopback)
    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    // Server accepts the pending connection
    when listener.accept() {
        Ok(result) => {
            assert(true, "accept succeeded")
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}

// --- Test 2: basic send and receive ---

@test
func test_tcp_send_recv() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    when listener.accept() {
        Ok(result) => {
            let server: TcpStream = result.0

            // Client sends "hello" (ASCII: 104,101,108,108,111)
            let data: [U8; 5] = [104 as U8, 101 as U8, 108 as U8, 108 as U8, 111 as U8]
            let sent: I64 = client.write(ref data).unwrap()
            assert_eq(sent as I32, 5)

            // Server receives
            var buf: [U8; 32] = [0 as U8; 32]
            let received: I64 = server.read(mut ref buf).unwrap()
            assert_eq(received as I32, 5)
            assert_eq(buf[0] as I32, 104)  // 'h'
            assert_eq(buf[1] as I32, 101)  // 'e'
            assert_eq(buf[2] as I32, 108)  // 'l'
            assert_eq(buf[3] as I32, 108)  // 'l'
            assert_eq(buf[4] as I32, 111)  // 'o'
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}

// --- Test 3: full echo round-trip (client -> server -> client) ---

@test
func test_tcp_echo_roundtrip() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    when listener.accept() {
        Ok(result) => {
            let server: TcpStream = result.0

            // Client sends data
            let payload: [U8; 4] = [65 as U8, 66 as U8, 67 as U8, 68 as U8]  // "ABCD"
            let sent: I64 = client.write(ref payload).unwrap()
            assert_eq(sent as I32, 4)

            // Server receives
            var srv_buf: [U8; 32] = [0 as U8; 32]
            let srv_received: I64 = server.read(mut ref srv_buf).unwrap()
            assert_eq(srv_received as I32, 4)

            // Server echoes back
            let echo: [U8; 4] = [srv_buf[0], srv_buf[1], srv_buf[2], srv_buf[3]]
            let echo_sent: I64 = server.write(ref echo).unwrap()
            assert_eq(echo_sent as I32, 4)

            // Client receives echo
            var cli_buf: [U8; 32] = [0 as U8; 32]
            let cli_received: I64 = client.read(mut ref cli_buf).unwrap()
            assert_eq(cli_received as I32, 4)

            // Verify echo matches original
            assert_eq(cli_buf[0] as I32, 65)  // 'A'
            assert_eq(cli_buf[1] as I32, 66)  // 'B'
            assert_eq(cli_buf[2] as I32, 67)  // 'C'
            assert_eq(cli_buf[3] as I32, 68)  // 'D'
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}

// --- Test 4: peer_addr and local_addr match after connect ---

@test
func test_tcp_peer_addr() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()
    let bound_port: U16 = bound_addr.port()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    // Client's peer_addr should match the listener's bound address
    let peer: SocketAddr = client.peer_addr().unwrap()
    assert_eq(peer.port() as I32, bound_port as I32)

    // Client has its own local address with an ephemeral port
    let client_local: SocketAddr = client.local_addr().unwrap()
    assert(client_local.port() as I32 > 0, "client should have ephemeral port")
    return 0
}

// --- Test 5: multiple sequential messages on same connection ---

@test
func test_tcp_multiple_messages() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    when listener.accept() {
        Ok(result) => {
            let server: TcpStream = result.0

            // Message 1
            let msg1: [U8; 3] = [1 as U8, 2 as U8, 3 as U8]
            client.write(ref msg1).unwrap()

            var buf1: [U8; 32] = [0 as U8; 32]
            let n1: I64 = server.read(mut ref buf1).unwrap()
            assert_eq(n1 as I32, 3)
            assert_eq(buf1[0] as I32, 1)
            assert_eq(buf1[1] as I32, 2)
            assert_eq(buf1[2] as I32, 3)

            // Message 2
            let msg2: [U8; 2] = [10 as U8, 20 as U8]
            client.write(ref msg2).unwrap()

            var buf2: [U8; 32] = [0 as U8; 32]
            let n2: I64 = server.read(mut ref buf2).unwrap()
            assert_eq(n2 as I32, 2)
            assert_eq(buf2[0] as I32, 10)
            assert_eq(buf2[1] as I32, 20)

            // Message 3 (server to client direction)
            let msg3: [U8; 3] = [77 as U8, 88 as U8, 99 as U8]
            server.write(ref msg3).unwrap()

            var buf3: [U8; 32] = [0 as U8; 32]
            let n3: I64 = client.read(mut ref buf3).unwrap()
            assert_eq(n3 as I32, 3)
            assert_eq(buf3[0] as I32, 77)
            assert_eq(buf3[1] as I32, 88)
            assert_eq(buf3[2] as I32, 99)
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}

// --- Test 6: set_nodelay option on connected stream ---

@test
func test_tcp_nodelay() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    // Enable TCP_NODELAY
    client.set_nodelay(true).unwrap()
    let nd: Bool = client.nodelay().unwrap()
    assert(nd, "nodelay should be true after set")

    // Disable TCP_NODELAY
    client.set_nodelay(false).unwrap()
    let nd2: Bool = client.nodelay().unwrap()
    assert(not nd2, "nodelay should be false after unset")

    return 0
}

// --- Test 7: keepalive option ---

@test
func test_tcp_keepalive() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    // Enable SO_KEEPALIVE
    client.set_keepalive(true).unwrap()
    let ka: Bool = client.keepalive().unwrap()
    assert(ka, "keepalive should be true after set")

    // Disable SO_KEEPALIVE
    client.set_keepalive(false).unwrap()
    let ka2: Bool = client.keepalive().unwrap()
    assert(not ka2, "keepalive should be false after unset")

    return 0
}

// --- Test 8: TTL on listener ---

@test
func test_tcp_listener_ttl() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()

    listener.set_ttl(64).unwrap()
    let ttl: I32 = listener.ttl().unwrap()
    assert_eq(ttl, 64)

    listener.set_ttl(128).unwrap()
    let ttl2: I32 = listener.ttl().unwrap()
    assert_eq(ttl2, 128)

    return 0
}

// --- Test 9: TTL on connected stream ---

@test
func test_tcp_stream_ttl() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    client.set_ttl(100).unwrap()
    let ttl: I32 = client.ttl().unwrap()
    assert_eq(ttl, 100)

    return 0
}

// --- Test 10: larger payload (256 bytes) ---

@test
func test_tcp_large_payload() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    let listener: TcpListener = TcpListener::bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    let client: TcpStream = TcpStream::connect(bound_addr).unwrap()

    when listener.accept() {
        Ok(result) => {
            let server: TcpStream = result.0

            // Send a pattern: bytes 0..255
            var payload: [U8; 256] = [0 as U8; 256]
            var i: I64 = 0
            loop (i < 256) {
                payload[i] = (i % 256) as U8
                i = i + 1
            }

            let sent: I64 = client.write(ref payload).unwrap()
            assert_eq(sent as I32, 256)

            // Receive all 256 bytes (may need multiple reads)
            var recv_buf: [U8; 512] = [0 as U8; 512]
            var total_recv: I64 = 0
            loop (total_recv < 256) {
                var tmp: [U8; 512] = [0 as U8; 512]
                let n: I64 = server.read(mut ref tmp).unwrap()
                assert(n as I32 > 0, "should receive some data")

                // Copy received bytes into recv_buf
                var j: I64 = 0
                loop (j < n) {
                    recv_buf[total_recv + j] = tmp[j]
                    j = j + 1
                }
                total_recv = total_recv + n
            }

            assert_eq(total_recv as I32, 256)

            // Verify first and last bytes
            assert_eq(recv_buf[0] as I32, 0)
            assert_eq(recv_buf[1] as I32, 1)
            assert_eq(recv_buf[255] as I32, 255)
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}

// --- Test 11: TcpBuilder pattern ---

@test
func test_tcp_builder_connect() -> I32 {
    let lo: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let bind_addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(lo, 0 as U16))

    // Use builder to create listener with custom options
    let builder = TcpBuilder::new().nodelay(true).backlog(64)
    let listener: TcpListener = builder.bind(bind_addr).unwrap()
    let bound_addr: SocketAddr = listener.local_addr().unwrap()

    // Use builder to create client with custom options
    let client_builder = TcpBuilder::new().nodelay(true)
    let client: TcpStream = client_builder.connect(bound_addr).unwrap()

    // Verify nodelay was set by builder
    let nd: Bool = client.nodelay().unwrap()
    assert(nd, "builder should set nodelay")

    when listener.accept() {
        Ok(result) => {
            let server: TcpStream = result.0

            // Basic echo to verify connection works
            let data: [U8; 2] = [42 as U8, 43 as U8]
            client.write(ref data).unwrap()

            var buf: [U8; 16] = [0 as U8; 16]
            let n: I64 = server.read(mut ref buf).unwrap()
            assert_eq(n as I32, 2)
            assert_eq(buf[0] as I32, 42)
            assert_eq(buf[1] as I32, 43)
        }
        Err(_) => assert(false, "accept should succeed")
    }
    return 0
}
