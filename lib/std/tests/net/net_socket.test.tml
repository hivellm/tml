//! Consolidated Socket, TCP, and Address Tests
//!
//! Tests for SocketAddr, SocketAddrV4, RawSocket, TcpBuilder, TcpListener,
//! TcpStream, SocketType, AddressFamily, ShutdownMode, SocketProtocol,
//! IpAddr enum, and misc diagnostics.

use test::{assert, assert_eq}
use std::net::{SocketAddr, SocketAddrV4, Ipv4Addr, Ipv6Addr, IpAddr}
use std::net::ip::{IpAddr, Ipv4Addr, Ipv6Addr}
use std::net::sys::{RawSocket, SocketType, AddressFamily, ShutdownMode, SocketProtocol, INVALID_SOCKET, AF_INET, AF_INET6, SOCK_STREAM, SOCK_DGRAM, IPPROTO_TCP, IPPROTO_UDP}
use std::net::socket::{SocketAddrV4, SocketAddr}
use std::net::error::{NetError, NetErrorKind}
use std::net::tcp::{TcpBuilder, TcpListener, TcpStream}

// ============================================================================
// Minimal Tests (from net_minimal, tcp_minimal, tcp_minimal2 - renamed)
// ============================================================================

@test
func test_minimal_net() {
    assert(true)
}

@test
func test_minimal_tcp() {
    assert(true)
}

@test
func test_minimal_tcp2() {
    assert(true)
}

// ============================================================================
// IpAddr Enum Tests (from ip_addr.test.tml)
// ============================================================================

@test
func test_ipaddr_v4() -> I32 {
    let addr: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST())
    assert(addr.is_ipv4(), "V4 should be ipv4")
    assert(not addr.is_ipv6(), "V4 should not be ipv6")
    assert(addr.is_loopback(), "V4 localhost should be loopback")
    return 0
}

@test
func test_ipaddr_v6() -> I32 {
    let addr: IpAddr = IpAddr::V6(Ipv6Addr::LOCALHOST())
    assert(addr.is_ipv6(), "V6 should be ipv6")
    assert(not addr.is_ipv4(), "V6 should not be ipv4")
    assert(addr.is_loopback(), "V6 localhost should be loopback")
    return 0
}

@test
func test_ipaddr_unspecified() -> I32 {
    let v4: IpAddr = IpAddr::V4(Ipv4Addr::UNSPECIFIED())
    let v6: IpAddr = IpAddr::V6(Ipv6Addr::UNSPECIFIED())
    assert(v4.is_unspecified(), "V4 0.0.0.0 should be unspecified")
    assert(v6.is_unspecified(), "V6 :: should be unspecified")
    return 0
}

// ============================================================================
// U8 Struct Field Diagnostic (from ip_diag2.test.tml)
// ============================================================================

type MyStruct {
    a: U8,
    b: U8,
}

@test
func test_u8_struct_field_cast() -> I32 {
    let s = MyStruct { a: 192, b: 168 }
    let a16: U16 = s.a as U16
    let b16: U16 = s.b as U16
    let shifted: U16 = (a16 shl 8) | b16
    assert_eq(a16, 192 as U16, "a should be 192")
    assert_eq(b16, 168 as U16, "b should be 168")
    return 0
}

// ============================================================================
// Socket Address Tests (from net.test.tml)
// ============================================================================

@test
func test_socket_addr_v4_creation() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    let addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)
    assert(addr.ip().is_loopback(), "IP should be loopback")
}

@test
func test_socket_addr_port_change() {
    let ip: Ipv4Addr = Ipv4Addr::LOCALHOST()
    var addr: SocketAddrV4 = SocketAddrV4::new(ip, 8080 as U16)

    assert_eq(addr.port(), 8080 as U16)

    addr.set_port(9090 as U16)
    assert_eq(addr.port(), 9090 as U16)
}

@test
func test_socket_addr_enum() {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)

    assert(addr.is_ipv4(), "Should be IPv4")
    assert(not addr.is_ipv6(), "Should not be IPv6")
    assert_eq(addr.port(), 80 as U16)
}

@test
func test_socket_addr_v4_set_ip() {
    let ip1: Ipv4Addr = Ipv4Addr::LOCALHOST()
    var addr: SocketAddrV4 = SocketAddrV4::new(ip1, 8080 as U16)
    assert(addr.ip().is_loopback(), "initial IP should be loopback")

    let ip2: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1)
    addr.set_ip(ip2)
    assert(addr.ip().is_private(), "updated IP should be private")
    assert_eq(addr.port(), 8080 as U16, "port should not change")
}

@test
func test_socket_addr_ip() {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 443 as U16)
    let addr: SocketAddr = SocketAddr::V4(v4)
    let ip: IpAddr = addr.ip()
    assert(ip.is_ipv4(), "ip() should return IPv4")
    assert(ip.is_loopback(), "ip() should be loopback")
}

@test
func test_socket_addr_set_port() {
    let v4: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    var addr: SocketAddr = SocketAddr::V4(v4)
    assert_eq(addr.port(), 80 as U16, "initial port")

    addr.set_port(443 as U16)
    assert_eq(addr.port(), 443 as U16, "updated port")
}

// ============================================================================
// RawSocket Tests (from net.test.tml)
// ============================================================================

@test
func test_raw_socket_tcp_creation() {
    let result: Outcome[RawSocket, NetError] = RawSocket::tcp()
    when result {
        Ok(sock) => {
            assert(sock.is_valid(), "TCP socket should be valid")
        },
        Err(_) => {
            // Socket creation may fail on some systems (e.g., sandboxed environments)
        },
    }
}

@test
func test_raw_socket_udp_creation() {
    let result: Outcome[RawSocket, NetError] = RawSocket::udp()
    when result {
        Ok(sock) => {
            assert(sock.is_valid(), "UDP socket should be valid")
        },
        Err(_) => {
            // Socket creation may fail on some systems
        },
    }
}

// ============================================================================
// Error Type Tests (from net.test.tml)
// ============================================================================

@test
func test_net_error_kinds() {
    let conn_refused: NetError = NetError::new(NetErrorKind::ConnectionRefused())
    assert(conn_refused.is_connection_refused(), "Should be connection refused")

    let would_block: NetError = NetError::new(NetErrorKind::WouldBlock())
    assert(would_block.is_would_block(), "Should be would block")

    let not_connected: NetError = NetError::new(NetErrorKind::NotConnected())
    assert(not_connected.is_not_connected(), "Should be not connected")
}

// ============================================================================
// SocketAddrV4 Tests (from socket_addr.test.tml, renamed dupes)
// ============================================================================

@test
func test_socket_addr_v4_new() -> I32 {
    let addr: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 8080 as U16)
    assert_eq(addr.port(), 8080 as U16, "port should be 8080")
    assert(addr.ip().is_loopback(), "ip should be loopback")
    return 0
}

@test
func test_socket_addr_v4_set_port() -> I32 {
    var addr: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    addr.set_port(443 as U16)
    assert_eq(addr.port(), 443 as U16, "port should be updated to 443")
    return 0
}

@test
func test_socket_addr_v4_set_ip_v2() -> I32 {
    var addr: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    addr.set_ip(Ipv4Addr::UNSPECIFIED())
    assert(addr.ip().is_unspecified(), "ip should be updated to unspecified")
    return 0
}

@test
func test_socket_addr_v4_eq_consolidated() -> I32 {
    let a = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let b = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    assert(a == b, "same addr should be equal")
    return 0
}

@test
func test_socket_addr_from_v4_consolidated() -> I32 {
    let v4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 3000 as U16)
    let addr = SocketAddr::V4(v4)
    assert(addr.port() == 3000 as U16, "SocketAddr port should be 3000")
    return 0
}

// ============================================================================
// SocketType Tests (from socket_type.test.tml)
// ============================================================================

@test
func test_socket_type_to_raw() -> I32 {
    assert_eq(SocketType::Stream.to_raw(), 1 as I32, "Stream is SOCK_STREAM(1)")
    assert_eq(SocketType::Datagram.to_raw(), 2 as I32, "Datagram is SOCK_DGRAM(2)")
    assert_eq(SocketType::Raw.to_raw(), 3 as I32, "Raw is SOCK_RAW(3)")
    return 0
}

@test
func test_socket_type_from_raw_valid() -> I32 {
    let stream: Maybe[SocketType] = SocketType::from_raw(1 as I32)
    assert(stream.is_just(), "from_raw(1) should be Just")
    let dgram: Maybe[SocketType] = SocketType::from_raw(2 as I32)
    assert(dgram.is_just(), "from_raw(2) should be Just")
    let raw: Maybe[SocketType] = SocketType::from_raw(3 as I32)
    assert(raw.is_just(), "from_raw(3) should be Just")
    return 0
}

@test
func test_socket_type_from_raw_invalid() -> I32 {
    let invalid: Maybe[SocketType] = SocketType::from_raw(0 as I32)
    assert(invalid.is_nothing(), "from_raw(0) should be Nothing")
    let invalid2: Maybe[SocketType] = SocketType::from_raw(99 as I32)
    assert(invalid2.is_nothing(), "from_raw(99) should be Nothing")
    return 0
}

// ============================================================================
// AddressFamily and ShutdownMode Tests (from address_family.test.tml)
// ============================================================================

@test
func test_address_family_to_raw() -> I32 {
    assert_eq(AddressFamily::Inet.to_raw(), 2 as I32, "Inet is AF_INET(2)")
    assert_eq(AddressFamily::Inet6.to_raw(), 23 as I32, "Inet6 is AF_INET6(23)")
    return 0
}

@test
func test_address_family_from_raw() -> I32 {
    let inet: Maybe[AddressFamily] = AddressFamily::from_raw(2 as I32)
    assert(inet.is_just(), "from_raw(2) should be Just(Inet)")
    let inet6: Maybe[AddressFamily] = AddressFamily::from_raw(23 as I32)
    assert(inet6.is_just(), "from_raw(23) should be Just(Inet6)")
    let inet6_unix: Maybe[AddressFamily] = AddressFamily::from_raw(10 as I32)
    assert(inet6_unix.is_just(), "from_raw(10) should be Just(Inet6) on Unix")
    let invalid: Maybe[AddressFamily] = AddressFamily::from_raw(99 as I32)
    assert(invalid.is_nothing(), "from_raw(99) should be Nothing")
    return 0
}

@test
func test_shutdown_mode_to_raw() -> I32 {
    assert_eq(ShutdownMode::Read.to_raw(), 0 as I32, "Read shutdown is 0")
    assert_eq(ShutdownMode::Write.to_raw(), 1 as I32, "Write shutdown is 1")
    assert_eq(ShutdownMode::Both.to_raw(), 2 as I32, "Both shutdown is 2")
    return 0
}

// ============================================================================
// SocketProtocol and Constants Tests (from socket_protocol.test.tml)
// ============================================================================

@test
func test_socket_protocol_to_raw() -> I32 {
    assert_eq(SocketProtocol::Tcp.to_raw(), 6 as I32, "Tcp is IPPROTO_TCP(6)")
    assert_eq(SocketProtocol::Udp.to_raw(), 17 as I32, "Udp is IPPROTO_UDP(17)")
    assert_eq(SocketProtocol::Default.to_raw(), 0 as I32, "Default is 0")
    return 0
}

@test
func test_net_constants() -> I32 {
    assert_eq(INVALID_SOCKET, -1 as I64, "INVALID_SOCKET is -1")
    assert_eq(AF_INET, 2 as I32, "AF_INET is 2")
    assert_eq(SOCK_STREAM, 1 as I32, "SOCK_STREAM is 1")
    assert_eq(SOCK_DGRAM, 2 as I32, "SOCK_DGRAM is 2")
    return 0
}

@test
func test_protocol_constants() -> I32 {
    assert_eq(IPPROTO_TCP, 6 as I32, "IPPROTO_TCP is 6")
    assert_eq(IPPROTO_UDP, 17 as I32, "IPPROTO_UDP is 17")
    return 0
}

// ============================================================================
// TcpBuilder Tests (from tcp.test.tml)
// ============================================================================

@test
func test_tcp_builder_defaults() {
    let builder: TcpBuilder = TcpBuilder::new()

    assert(builder.reuse_addr)
    assert(not builder.nodelay)
    assert(not builder.keepalive)
    assert_eq(builder.backlog, 128)
}

@test
func test_tcp_builder_chain() {
    var builder: TcpBuilder = TcpBuilder::new()
    builder = builder.reuse_addr(false)
    builder = builder.nodelay(true)
    builder = builder.keepalive(true)
    builder = builder.recv_buffer_size(8192)
    builder = builder.send_buffer_size(16384)
    builder = builder.backlog(512)

    assert(not builder.reuse_addr)
    assert(builder.nodelay)
    assert(builder.keepalive)
    assert_eq(builder.backlog, 512)
}

// ============================================================================
// TcpListener Tests (from tcp.test.tml)
// ============================================================================

@test
func test_tcp_listener_bind_port_zero() {
    // Bind to port 0 lets the OS assign an available port
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 0 as U16))
    let listener_result: Outcome[TcpListener, NetError] = TcpListener::bind(addr)

    when listener_result {
        Ok(listener) => {
            // Should have been assigned a real port
            let local: Outcome[SocketAddr, NetError] = listener.local_addr()
            when local {
                Ok(local_addr) => {
                    let port: U16 = local_addr.port()
                    assert(port > 0 as U16)
                }
                Err(e) => {
                    assert(false)
                }
            }
        }
        Err(e) => {
            // Bind should succeed
            assert(false)
        }
    }
}

// ============================================================================
// Additional SocketAddr Tests (from socket_addr.test.tml, test_socket_eq.test.tml)
// ============================================================================

@test
func test_socket_addr_v4_duplicate() -> I32 {
    let a = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 8080 as U16)
    let b = a.duplicate()
    assert(b.port() == 8080 as U16, "duplicate should have same port")
    return 0
}

@test
func test_socket_addr_is_ipv4() -> I32 {
    let v4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let addr = SocketAddr::V4(v4)
    assert(addr.is_ipv4(), "should be ipv4")
    assert(not addr.is_ipv6(), "should not be ipv6")
    return 0
}

@test
func test_socket_addr_duplicate() -> I32 {
    let v4 = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 9999 as U16)
    let addr = SocketAddr::V4(v4)
    let copy = addr.duplicate()
    assert(copy.port() == 9999 as U16, "duplicate should preserve port")
    return 0
}

@test
func test_socket_addr_eq_method() -> I32 {
    let a = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let b = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    assert(a.eq(ref b), "same addr should be equal via .eq()")
    return 0
}

@test
func test_socket_addr_cmp() -> I32 {
    let a = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 80 as U16)
    let b = SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 443 as U16)
    let ord = a.cmp(ref b)
    return 0
}

// ============================================================================
// TcpStream Integration Tests (requires Node.js echo server on port 19876)
// Run with: tml test --feature network
// ============================================================================

#ifdef FEATURE_NETWORK
@test
func test_tcp_stream_connect() {
    // Connect to the Node.js echo server
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 19876 as U16))
    let result: Outcome[TcpStream, NetError] = TcpStream::connect(addr)

    when result {
        Ok(stream) => {
            // Connection succeeded - check peer address
            let peer: Outcome[SocketAddr, NetError] = stream.peer_addr()
            when peer {
                Ok(peer_addr) => {
                    assert_eq(peer_addr.port(), 19876 as U16)
                }
                Err(e) => assert(false)
            }

            // Check local address is assigned
            let local: Outcome[SocketAddr, NetError] = stream.local_addr()
            when local {
                Ok(local_addr) => {
                    assert(local_addr.port() > 0 as U16)
                }
                Err(e) => assert(false)
            }
        }
        Err(e) => {
            // Connection should succeed (echo server must be running)
            assert(false)
        }
    }
}

@test
func test_tcp_stream_write_read_echo() {
    // Connect to the Node.js echo server
    let addr: SocketAddr = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::LOCALHOST(), 19876 as U16))
    let connect_result: Outcome[TcpStream, NetError] = TcpStream::connect(addr)

    when connect_result {
        Ok(stream) => {
            // Write "hello" to the echo server
            var send_buf: [U8; 5] = [104, 101, 108, 108, 111]  // "hello"
            let write_result: Outcome[I64, NetError] = stream.write(ref send_buf)
            when write_result {
                Ok(n) => assert_eq(n, 5 as I64)
                Err(e) => assert(false)
            }

            // Read the echoed data back
            var recv_buf: [U8; 64] = [0; 64]
            let read_result: Outcome[I64, NetError] = stream.read(mut ref recv_buf)
            when read_result {
                Ok(n) => {
                    assert_eq(n, 5 as I64)
                    // Verify echoed content
                    assert_eq(recv_buf[0], 104 as U8)  // 'h'
                    assert_eq(recv_buf[1], 101 as U8)  // 'e'
                    assert_eq(recv_buf[2], 108 as U8)  // 'l'
                    assert_eq(recv_buf[3], 108 as U8)  // 'l'
                    assert_eq(recv_buf[4], 111 as U8)  // 'o'
                }
                Err(e) => assert(false)
            }
        }
        Err(e) => {
            assert(false)
        }
    }
}
#endif
