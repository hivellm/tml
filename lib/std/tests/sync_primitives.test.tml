// Sync primitives tests - Mutex, MutexGuard, Condvar
use test::{assert, assert_eq}
use std::sync::{Mutex, MutexGuard, Condvar, Arc}

// ============================================================================
// Basic Mutex Tests
// ============================================================================

@test
func test_mutex_new() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    return 0
}

@test
func test_mutex_lock() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    let guard: MutexGuard[I32] = mutex.lock()
    let val: I32 = *guard.get()
    assert_eq(val, 42)
    return 0
}

@test
func test_mutex_lock_twice() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)

    {
        let guard: MutexGuard[I32] = mutex.lock()
        let val: I32 = *guard.get()
        assert_eq(val, 42)
    }  // guard dropped here

    // Lock again - if Drop didn't unlock, this will deadlock
    {
        let guard: MutexGuard[I32] = mutex.lock()
        assert_eq(*guard.get(), 42)
    }

    return 0
}

@test
func test_mutex_explicit_type() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    return 0
}

@test
func test_arc_mutex_explicit() -> I32 {
    let inner: Mutex[I32] = Mutex::new(42)
    let a: Arc[Mutex[I32]] = Arc::new(inner)
    return 0
}

// ============================================================================
// Condvar Tests
// ============================================================================

@test
func test_condvar_creation() -> I32 {
    let cv: Condvar = Condvar::new()
    return 0
}

@test
func test_condvar_wait_timeout() -> I32 {
    let mutex: Mutex[I32] = Mutex::new(42)
    let condvar: Condvar = Condvar::new()

    var guard: MutexGuard[I32] = mutex.lock()
    // Use wait_timeout_ms to test Condvar functionality
    // It should timeout since no one is signaling
    let result: (MutexGuard[I32], Bool) = condvar.wait_timeout_ms(guard, 10)
    guard = result.0
    let timed_out: Bool = result.1
    assert(timed_out)  // Should have timed out

    return 0
}
