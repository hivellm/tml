// Tests for std::hash module - Murmur2 and ETag functions
use test
use std::hash::{murmur2_32, murmur2_64, etag_weak, etag_strong, Hash32, Hash64}

// =============================================================================
// Murmur2 32-bit
// =============================================================================

@test
func test_murmur2_32_basic() -> I32 {
    let h: Hash32 = murmur2_32("hello", 0 as U32)
    let val: U32 = h.raw()
    assert(val > 0 as U32, "murmur2_32 should produce non-zero hash")
    return 0
}

@test
func test_murmur2_32_hex() -> I32 {
    let h: Hash32 = murmur2_32("hello", 0 as U32)
    let hex: Str = h.to_hex()
    assert(hex.len() > 0, "murmur2_32 to_hex should produce non-empty string")
    return 0
}

@test
func test_murmur2_32_different_seeds() -> I32 {
    let h1: Hash32 = murmur2_32("hello", 0 as U32)
    let h2: Hash32 = murmur2_32("hello", 42 as U32)
    assert(h1.raw() != h2.raw(), "different seeds should produce different hashes")
    return 0
}

@test
func test_murmur2_32_deterministic() -> I32 {
    let h1: Hash32 = murmur2_32("test", 100 as U32)
    let h2: Hash32 = murmur2_32("test", 100 as U32)
    assert(h1.raw() == h2.raw(), "same input and seed should produce same hash")
    return 0
}

// =============================================================================
// Murmur2 64-bit
// =============================================================================

@test
func test_murmur2_64_basic() -> I32 {
    let h: Hash64 = murmur2_64("hello", 0 as U64)
    let val: U64 = h.raw()
    assert(val > 0 as U64, "murmur2_64 should produce non-zero hash")
    return 0
}

@test
func test_murmur2_64_hex() -> I32 {
    let h: Hash64 = murmur2_64("hello", 0 as U64)
    let hex: Str = h.to_hex()
    assert(hex.len() > 0, "murmur2_64 to_hex should produce non-empty string")
    return 0
}

@test
func test_murmur2_64_different_seeds() -> I32 {
    let h1: Hash64 = murmur2_64("hello", 0 as U64)
    let h2: Hash64 = murmur2_64("hello", 42 as U64)
    assert(h1.raw() != h2.raw(), "different seeds should produce different hashes")
    return 0
}

@test
func test_murmur2_64_to_i64() -> I32 {
    let h: Hash64 = murmur2_64("hello", 0 as U64)
    let _val: I64 = h.to_i64()
    assert(true, "murmur2_64 to_i64 should not crash")
    return 0
}

// =============================================================================
// ETag functions
// =============================================================================

@test
func test_etag_weak() -> I32 {
    let etag: Str = etag_weak("Hello, World!")
    assert(etag.len() > 0, "etag_weak should produce non-empty string")
    return 0
}

@test
func test_etag_strong() -> I32 {
    let etag: Str = etag_strong("Hello, World!")
    assert(etag.len() > 0, "etag_strong should produce non-empty string")
    return 0
}

@test
func test_etag_weak_deterministic() -> I32 {
    let e1: Str = etag_weak("test content")
    let e2: Str = etag_weak("test content")
    assert(e1.len() == e2.len(), "same content should produce same etag length")
    return 0
}

@test
func test_etag_strong_deterministic() -> I32 {
    let e1: Str = etag_strong("test content")
    let e2: Str = etag_strong("test content")
    assert(e1.len() == e2.len(), "same content should produce same etag length")
    return 0
}
