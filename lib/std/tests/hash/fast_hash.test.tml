//! Tests for fast non-cryptographic hash functions
//!
//! Tests FNV-1a and Murmur2 hash algorithms.

use std::hash::{fnv1a32, fnv1a64, murmur2_32, murmur2_64}
use std::hash::{Hash32, Hash64}
use std::hash::{etag_weak, etag_strong}
use test::{assert, assert_eq}

// ============================================================================
// FNV-1a 32-bit Tests
// ============================================================================

@test
func test_fnv1a32_empty_string() -> I32 {
    let hash: Hash32 = fnv1a32("")
    // Empty string should hash to FNV offset basis
    assert_eq(hash.to_hex(), "811c9dc5", "fnv1a32 empty string")
    return 0
}

@test
func test_fnv1a32_hello() -> I32 {
    let hash: Hash32 = fnv1a32("hello")
    // Known FNV-1a 32-bit hash of "hello"
    assert_eq(hash.to_hex(), "4f9f2cab", "fnv1a32 hello")
    return 0
}

@test
func test_fnv1a32_deterministic() -> I32 {
    let hash1: Hash32 = fnv1a32("test")
    let hash2: Hash32 = fnv1a32("test")
    assert_eq(hash1.raw(), hash2.raw(), "fnv1a32 should be deterministic")
    return 0
}

@test
func test_fnv1a32_different_inputs() -> I32 {
    let hash1: Hash32 = fnv1a32("hello")
    let hash2: Hash32 = fnv1a32("world")
    assert(hash1.raw() != hash2.raw(), "different inputs should produce different hashes")
    return 0
}

// ============================================================================
// FNV-1a 64-bit Tests
// ============================================================================

@test
func test_fnv1a64_empty_string() -> I32 {
    let hash: Hash64 = fnv1a64("")
    // Empty string should hash to FNV offset basis
    assert_eq(hash.to_hex(), "cbf29ce484222325", "fnv1a64 empty string")
    return 0
}

@test
func test_fnv1a64_hello() -> I32 {
    let hash: Hash64 = fnv1a64("hello")
    // Known FNV-1a 64-bit hash of "hello"
    assert_eq(hash.to_hex(), "a430d84680aabd0b", "fnv1a64 hello")
    return 0
}

@test
func test_fnv1a64_deterministic() -> I32 {
    let hash1: Hash64 = fnv1a64("test")
    let hash2: Hash64 = fnv1a64("test")
    assert_eq(hash1.raw(), hash2.raw(), "fnv1a64 should be deterministic")
    return 0
}

@test
func test_fnv1a64_hex_length() -> I32 {
    let hash: Hash64 = fnv1a64("any string")
    let hex: Str = hash.to_hex()
    assert_eq(hex.len(), 16 as I64, "fnv1a64 hex should be 16 chars")
    return 0
}

// ============================================================================
// MurmurHash2 32-bit Tests
// ============================================================================

@test
func test_murmur2_32_empty_string() -> I32 {
    let hash: Hash32 = murmur2_32("", 0 as U32)
    // Empty string with seed 0
    let hex: Str = hash.to_hex()
    assert_eq(hex.len(), 8 as I64, "murmur2_32 hex should be 8 chars")
    return 0
}

@test
func test_murmur2_32_hello() -> I32 {
    let hash: Hash32 = murmur2_32("hello", 0 as U32)
    let hex: Str = hash.to_hex()
    assert_eq(hex.len(), 8 as I64, "murmur2_32 hex should be 8 chars")
    return 0
}

@test
func test_murmur2_32_different_seeds() -> I32 {
    let hash1: Hash32 = murmur2_32("hello", 0 as U32)
    let hash2: Hash32 = murmur2_32("hello", 42 as U32)
    assert(hash1.raw() != hash2.raw(), "different seeds should produce different hashes")
    return 0
}

@test
func test_murmur2_32_deterministic() -> I32 {
    let hash1: Hash32 = murmur2_32("test", 123 as U32)
    let hash2: Hash32 = murmur2_32("test", 123 as U32)
    assert_eq(hash1.raw(), hash2.raw(), "murmur2_32 should be deterministic")
    return 0
}

// ============================================================================
// MurmurHash2 64-bit Tests
// ============================================================================

@test
func test_murmur2_64_empty_string() -> I32 {
    let hash: Hash64 = murmur2_64("", 0 as U64)
    let hex: Str = hash.to_hex()
    assert_eq(hex.len(), 16 as I64, "murmur2_64 hex should be 16 chars")
    return 0
}

@test
func test_murmur2_64_hello() -> I32 {
    let hash: Hash64 = murmur2_64("hello", 0 as U64)
    let hex: Str = hash.to_hex()
    assert_eq(hex.len(), 16 as I64, "murmur2_64 hex should be 16 chars")
    return 0
}

@test
func test_murmur2_64_different_seeds() -> I32 {
    let hash1: Hash64 = murmur2_64("hello", 0 as U64)
    let hash2: Hash64 = murmur2_64("hello", 42 as U64)
    assert(hash1.raw() != hash2.raw(), "different seeds should produce different hashes")
    return 0
}

@test
func test_murmur2_64_deterministic() -> I32 {
    let hash1: Hash64 = murmur2_64("test", 123 as U64)
    let hash2: Hash64 = murmur2_64("test", 123 as U64)
    assert_eq(hash1.raw(), hash2.raw(), "murmur2_64 should be deterministic")
    return 0
}

// ============================================================================
// ETag Helper Tests
// ============================================================================

@test
func test_etag_weak_format() -> I32 {
    let etag: Str = etag_weak("Hello, World!")
    // Should be in format: W/"<hash>"
    assert(etag.starts_with("W/\""), "weak etag should start with W/\"")
    assert(etag.ends_with("\""), "etag should end with quote")
    return 0
}

@test
func test_etag_strong_format() -> I32 {
    let etag: Str = etag_strong("Hello, World!")
    // Should be in format: "<hash>"
    assert(etag.starts_with("\""), "strong etag should start with quote")
    assert(etag.ends_with("\""), "etag should end with quote")
    assert(not etag.starts_with("W/"), "strong etag should not start with W/")
    return 0
}

@test
func test_etag_deterministic() -> I32 {
    let etag1: Str = etag_strong("content")
    let etag2: Str = etag_strong("content")
    assert_eq(etag1, etag2, "etags should be deterministic")
    return 0
}

@test
func test_etag_different_content() -> I32 {
    let etag1: Str = etag_strong("content1")
    let etag2: Str = etag_strong("content2")
    assert(etag1 != etag2, "different content should produce different etags")
    return 0
}

// ============================================================================
// Hash32/Hash64 Conversion Tests
// ============================================================================

@test
func test_hash32_to_i64() -> I32 {
    let hash: Hash32 = fnv1a32("test")
    let i64_val: I64 = hash.to_i64()
    assert(i64_val == (hash.raw() as I64), "to_i64 should return same value as raw cast")
    return 0
}

@test
func test_hash64_raw() -> I32 {
    let hash: Hash64 = fnv1a64("test")
    let raw: U64 = hash.raw()
    assert(raw != (0 as U64), "hash should not be zero for non-empty input")
    return 0
}
