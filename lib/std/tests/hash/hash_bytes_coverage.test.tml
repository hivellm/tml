// Tests for std::hash â€” uncovered bytes functions
use test
use std::hash::{fnv1a32_bytes, fnv1a64_bytes, murmur2_32_bytes, murmur2_64_bytes, etag_strong_bytes, etag_weak_bytes, Hash32, Hash64}
use std::collections::Buffer

// =============================================================================
// fnv1a32_bytes
// =============================================================================

@test
func test_fnv1a32_bytes_basic() -> I32 {
    var buf: Buffer = Buffer::from_string("hello")
    let h: Hash32 = fnv1a32_bytes(ref buf)
    assert(h.raw() != 0, "fnv1a32_bytes should produce non-zero hash")
    buf.destroy()
    return 0
}

@test
func test_fnv1a32_bytes_deterministic() -> I32 {
    var buf1: Buffer = Buffer::from_string("test data")
    var buf2: Buffer = Buffer::from_string("test data")
    let h1: Hash32 = fnv1a32_bytes(ref buf1)
    let h2: Hash32 = fnv1a32_bytes(ref buf2)
    assert_eq(h1.raw(), h2.raw(), "fnv1a32_bytes should be deterministic")
    buf1.destroy()
    buf2.destroy()
    return 0
}

// =============================================================================
// fnv1a64_bytes
// =============================================================================

@test
func test_fnv1a64_bytes_basic() -> I32 {
    var buf: Buffer = Buffer::from_string("hello")
    let h: Hash64 = fnv1a64_bytes(ref buf)
    assert(h.raw() != 0, "fnv1a64_bytes should produce non-zero hash")
    buf.destroy()
    return 0
}

@test
func test_fnv1a64_bytes_hex() -> I32 {
    var buf: Buffer = Buffer::from_string("test")
    let h: Hash64 = fnv1a64_bytes(ref buf)
    let hex: Str = h.to_hex()
    assert(hex.len() > 0, "fnv1a64_bytes hex should not be empty")
    buf.destroy()
    return 0
}

// =============================================================================
// murmur2_32_bytes
// =============================================================================

@test
func test_murmur2_32_bytes_basic() -> I32 {
    var buf: Buffer = Buffer::from_string("hello")
    let h: Hash32 = murmur2_32_bytes(ref buf, 0 as U32)
    assert(h.raw() != 0, "murmur2_32_bytes should produce non-zero hash")
    buf.destroy()
    return 0
}

@test
func test_murmur2_32_bytes_different_seeds() -> I32 {
    var buf1: Buffer = Buffer::from_string("hello")
    var buf2: Buffer = Buffer::from_string("hello")
    let h1: Hash32 = murmur2_32_bytes(ref buf1, 0 as U32)
    let h2: Hash32 = murmur2_32_bytes(ref buf2, 42 as U32)
    // Different seeds should generally produce different hashes
    // (not guaranteed but very likely for non-trivial data)
    buf1.destroy()
    buf2.destroy()
    return 0
}

// =============================================================================
// murmur2_64_bytes
// =============================================================================

@test
func test_murmur2_64_bytes_basic() -> I32 {
    var buf: Buffer = Buffer::from_string("hello world")
    let h: Hash64 = murmur2_64_bytes(ref buf, 0 as U64)
    assert(h.raw() != 0, "murmur2_64_bytes should produce non-zero hash")
    buf.destroy()
    return 0
}

// =============================================================================
// etag_strong_bytes / etag_weak_bytes
// =============================================================================

@test
func test_etag_strong_bytes() -> I32 {
    var buf: Buffer = Buffer::from_string("content data")
    let etag: Str = etag_strong_bytes(ref buf)
    assert(etag.len() > 2, "etag_strong_bytes should produce a quoted string")
    buf.destroy()
    return 0
}

@test
func test_etag_weak_bytes() -> I32 {
    var buf: Buffer = Buffer::from_string("content data")
    let etag: Str = etag_weak_bytes(ref buf)
    assert(etag.len() > 4, "etag_weak_bytes should produce a W/ prefixed string")
    buf.destroy()
    return 0
}
