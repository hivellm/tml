// Tests for std::hash module - FNV-1a hash functions
use test
use std::hash::{fnv1a32, fnv1a64, Hash32, Hash64}

// =============================================================================
// FNV-1a 32-bit
// =============================================================================

@test
func test_fnv1a32_basic() -> I32 {
    let h: Hash32 = fnv1a32("hello")
    let val: U32 = h.raw()
    assert(val > 0 as U32, "fnv1a32 should produce non-zero hash")
    return 0
}

@test
func test_fnv1a32_hex() -> I32 {
    let h: Hash32 = fnv1a32("hello")
    let hex: Str = h.to_hex()
    assert(hex.len() > 0, "fnv1a32 to_hex should produce non-empty string")
    return 0
}

@test
func test_fnv1a32_to_i64() -> I32 {
    let h: Hash32 = fnv1a32("hello")
    let val: I64 = h.to_i64()
    assert(val > 0, "fnv1a32 to_i64 should be positive")
    return 0
}

@test
func test_fnv1a32_different_inputs() -> I32 {
    let h1: Hash32 = fnv1a32("hello")
    let h2: Hash32 = fnv1a32("world")
    assert(h1.raw() != h2.raw(), "different inputs should produce different hashes")
    return 0
}

@test
func test_fnv1a32_deterministic() -> I32 {
    let h1: Hash32 = fnv1a32("test")
    let h2: Hash32 = fnv1a32("test")
    assert(h1.raw() == h2.raw(), "same input should produce same hash")
    return 0
}

@test
func test_fnv1a32_empty_string() -> I32 {
    let h: Hash32 = fnv1a32("")
    let val: U32 = h.raw()
    // Empty string should still produce a valid hash (the offset basis)
    assert(true, "fnv1a32 empty string should not crash")
    return 0
}

// =============================================================================
// FNV-1a 64-bit
// =============================================================================

@test
func test_fnv1a64_basic() -> I32 {
    let h: Hash64 = fnv1a64("hello")
    let val: U64 = h.raw()
    assert(val > 0 as U64, "fnv1a64 should produce non-zero hash")
    return 0
}

@test
func test_fnv1a64_hex() -> I32 {
    let h: Hash64 = fnv1a64("hello")
    let hex: Str = h.to_hex()
    assert(hex.len() > 0, "fnv1a64 to_hex should produce non-empty string")
    return 0
}

@test
func test_fnv1a64_to_i64() -> I32 {
    let h: Hash64 = fnv1a64("hello")
    let _val: I64 = h.to_i64()
    // Value may be negative due to U64->I64 cast, just verify no crash
    assert(true, "fnv1a64 to_i64 should not crash")
    return 0
}

@test
func test_fnv1a64_different_inputs() -> I32 {
    let h1: Hash64 = fnv1a64("hello")
    let h2: Hash64 = fnv1a64("world")
    assert(h1.raw() != h2.raw(), "different inputs should produce different hashes")
    return 0
}

@test
func test_fnv1a64_deterministic() -> I32 {
    let h1: Hash64 = fnv1a64("test")
    let h2: Hash64 = fnv1a64("test")
    assert(h1.raw() == h2.raw(), "same input should produce same hash")
    return 0
}
