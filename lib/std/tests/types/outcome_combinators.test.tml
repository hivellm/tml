// Tests for Outcome[T, E] - basic operations and combinators
use test
use std::types

// ============================================================================
// Basic Outcome Tests
// ============================================================================

@test
func test_outcome_ok_unwrap_or() -> I32 {
    let x: Outcome[I32, I32] = Ok(5)
    assert(unwrap_or_ok(x, 0) == 5, "Ok(5).unwrap_or(0) should be 5")
    return 0
}

@test
func test_outcome_err_unwrap_or() -> I32 {
    let a: Outcome[I32, I32] = Err(42)
    assert(unwrap_or_ok(a, 0) == 0, "Err(42).unwrap_or(0) should be 0")
    return 0
}

@test
func test_outcome_is_ok() -> I32 {
    let x: Outcome[I32, I32] = Ok(10)
    assert(is_ok(x), "Ok(10).is_ok() should be true")
    return 0
}

@test
func test_outcome_is_err() -> I32 {
    let a: Outcome[I32, I32] = Err(99)
    assert(is_err(a), "Err(99).is_err() should be true")
    return 0
}

// ============================================================================
// map_ok Tests
// ============================================================================

@test
func test_map_ok_on_ok() -> I32 {
    let x: Outcome[I32, I32] = Ok(5)
    let y: Outcome[I32, I32] = map_ok(x, do(val: I32) val * 2)
    assert(unwrap_or_ok(y, 0) == 10, "map_ok(Ok(5), *2) should be Ok(10)")
    return 0
}

@test
func test_map_ok_on_err() -> I32 {
    let x: Outcome[I32, I32] = Err(42)
    let y: Outcome[I32, I32] = map_ok(x, do(val: I32) val * 2)
    assert(is_err(y) == true, "map_ok(Err(42), *2) should be Err")
    assert(unwrap_or_err(y, 0) == 42, "map_ok(Err(42), *2) should preserve error value")
    return 0
}

// ============================================================================
// map_err Tests
// ============================================================================

@test
func test_map_err_on_err() -> I32 {
    let a: Outcome[I32, I32] = Err(5)
    let b: Outcome[I32, I32] = map_err(a, do(err: I32) err * 2)
    assert(unwrap_or_err(b, 0) == 10, "map_err(Err(5), *2) should be Err(10)")
    return 0
}

@test
func test_map_err_on_ok() -> I32 {
    let a: Outcome[I32, I32] = Ok(42)
    let b: Outcome[I32, I32] = map_err(a, do(err: I32) err * 2)
    assert(is_ok(b) == true, "map_err(Ok(42), *2) should be Ok")
    assert(unwrap_or_ok(b, 0) == 42, "map_err(Ok(42), *2) should preserve ok value")
    return 0
}

// ============================================================================
// and_then_ok Tests
// ============================================================================

@test
func test_and_then_ok_returns_ok() -> I32 {
    let d: Outcome[I32, I32] = Ok(5)
    let e: Outcome[I32, I32] = and_then_ok(d, do(val: I32) if val > 0 then Ok(val * 2) else Err(999))
    assert(unwrap_or_ok(e, 0) == 10, "and_then_ok(Ok(5), check>0) should be Ok(10)")
    return 0
}

@test
func test_and_then_ok_returns_err() -> I32 {
    let d: Outcome[I32, I32] = Ok(5)
    let e: Outcome[I32, I32] = and_then_ok(d, do(val: I32) if val > 10 then Ok(val * 2) else Err(999))
    assert(is_err(e) == true, "and_then_ok(Ok(5), check>10) should be Err")
    assert(unwrap_or_err(e, 0) == 999, "and_then_ok(Ok(5), check>10) should be Err(999)")
    return 0
}

@test
func test_and_then_ok_on_err() -> I32 {
    let d: Outcome[I32, I32] = Err(100)
    let e: Outcome[I32, I32] = and_then_ok(d, do(val: I32) Ok(val * 2))
    assert(is_err(e) == true, "and_then_ok(Err(100), f) should be Err")
    assert(unwrap_or_err(e, 0) == 100, "and_then_ok(Err(100), f) should preserve Err(100)")
    return 0
}

// ============================================================================
// or_else_ok Tests
// ============================================================================

@test
func test_or_else_ok_on_err() -> I32 {
    let h: Outcome[I32, I32] = Err(5)
    let i: Outcome[I32, I32] = or_else_ok(h, do(err: I32) Ok(0))
    assert(is_ok(i) == true, "or_else_ok(Err(5), Ok(0)) should be Ok")
    assert(unwrap_or_ok(i, -1) == 0, "or_else_ok(Err(5), Ok(0)) should be Ok(0)")
    return 0
}

@test
func test_or_else_ok_on_ok() -> I32 {
    let j: Outcome[I32, I32] = Ok(42)
    let k: Outcome[I32, I32] = or_else_ok(j, do(err: I32) Ok(0))
    assert(is_ok(k) == true, "or_else_ok(Ok(42), Ok(0)) should be Ok")
    assert(unwrap_or_ok(k, -1) == 42, "or_else_ok(Ok(42), Ok(0)) should preserve Ok(42)")
    return 0
}
