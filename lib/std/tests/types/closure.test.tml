// Comprehensive closure tests
use test::{assert, assert_eq}

// ============================================================================
// Helper functions for higher-order function tests
// ============================================================================

func apply(x: I32, f: func(I32) -> I32) -> I32 {
    return f(x)
}

func apply_twice(x: I32, f: func(I32) -> I32) -> I32 {
    return f(f(x))
}

func apply_n_times(x: I32, n: I32, f: func(I32) -> I32) -> I32 {
    var result: I32 = x
    var i: I32 = 0
    loop (i < n) {
        result = f(result)
        i = i + 1
    }
    return result
}

// Note: compose function removed - TML doesn't yet support returning closures with captures
// func compose(f: func(I32) -> I32, g: func(I32) -> I32) -> func(I32) -> I32 {
//     return do(x: I32) -> I32 { f(g(x)) }
// }

func fold_array(arr: [I32; 5], init: I32, f: func(I32, I32) -> I32) -> I32 {
    var acc: I32 = init
    var i: I32 = 0
    loop (i < 5) {
        acc = f(acc, arr[i])
        i = i + 1
    }
    return acc
}

func all_array(arr: [I32; 5], pred: func(I32) -> Bool) -> Bool {
    var i: I32 = 0
    loop (i < 5) {
        if not pred(arr[i]) {
            return false
        }
        i = i + 1
    }
    return true
}

func any_array(arr: [I32; 5], pred: func(I32) -> Bool) -> Bool {
    var i: I32 = 0
    loop (i < 5) {
        if pred(arr[i]) {
            return true
        }
        i = i + 1
    }
    return false
}

func count_array(arr: [I32; 5], pred: func(I32) -> Bool) -> I32 {
    var count: I32 = 0
    var i: I32 = 0
    loop (i < 5) {
        if pred(arr[i]) {
            count = count + 1
        }
        i = i + 1
    }
    return count
}

func find_first(arr: [I32; 5], pred: func(I32) -> Bool) -> I32 {
    var i: I32 = 0
    loop (i < 5) {
        if pred(arr[i]) {
            return arr[i]
        }
        i = i + 1
    }
    return -1  // Not found
}

// ============================================================================
// Basic Closure Tests
// ============================================================================

@test
func test_closure_identity() -> I32 {
    let identity: func(I32) -> I32 = do(x: I32) -> I32 { x }
    let result: I32 = identity(42)
    assert_eq(result, 42, "identity should return 42")
    return 0
}

@test
func test_closure_add() -> I32 {
    let add_one: func(I32) -> I32 = do(x: I32) -> I32 { x + 1 }
    let result: I32 = add_one(9)
    assert_eq(result, 10, "add_one should return 10")
    return 0
}

@test
func test_closure_multiply() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = double(21)
    assert_eq(result, 42, "double should return 42")
    return 0
}

@test
func test_closure_subtract() -> I32 {
    let decrement: func(I32) -> I32 = do(x: I32) -> I32 { x - 1 }
    let result: I32 = decrement(11)
    assert_eq(result, 10, "decrement should return 10")
    return 0
}

@test
func test_closure_complex_expr() -> I32 {
    let compute: func(I32) -> I32 = do(x: I32) -> I32 { (x * 2) + 3 }
    let result: I32 = compute(5)
    assert_eq(result, 13, "compute(5) = 5*2+3 = 13")
    return 0
}

// ============================================================================
// Higher-Order Function Tests
// ============================================================================

@test
func test_apply_double() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = apply(5, double)
    assert_eq(result, 10, "apply(5, double) should be 10")
    return 0
}

@test
func test_apply_inline() -> I32 {
    let result: I32 = apply(7, do(x: I32) -> I32 { x + 3 })
    assert_eq(result, 10, "apply with inline closure")
    return 0
}

@test
func test_apply_twice_add() -> I32 {
    let add_three: func(I32) -> I32 = do(x: I32) -> I32 { x + 3 }
    let result: I32 = apply_twice(0, add_three)
    assert_eq(result, 6, "apply_twice(0, +3) = 6")
    return 0
}

@test
func test_apply_twice_double() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = apply_twice(3, double)
    assert_eq(result, 12, "apply_twice(3, *2) = 12")
    return 0
}

@test
func test_apply_n_times() -> I32 {
    let increment: func(I32) -> I32 = do(x: I32) -> I32 { x + 1 }
    let result: I32 = apply_n_times(0, 5, increment)
    assert_eq(result, 5, "apply 5 times +1 starting from 0")
    return 0
}

@test
func test_apply_n_times_double() -> I32 {
    let double: func(I32) -> I32 = do(x: I32) -> I32 { x * 2 }
    let result: I32 = apply_n_times(1, 4, double)
    assert_eq(result, 16, "1 doubled 4 times = 16")
    return 0
}

// ============================================================================
// Composition Tests (removed - TML doesn't yet support returning closures with captures)
// ============================================================================

// Note: compose tests removed because the compiler doesn't yet support
// returning closures that capture variables from the enclosing function.
// The captured values go out of scope when the function returns.

// ============================================================================
// Fold/Reduce Tests
// ============================================================================

@test
func test_fold_sum() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    let add: func(I32, I32) -> I32 = do(acc: I32, x: I32) -> I32 { acc + x }
    let sum: I32 = fold_array(arr, 0, add)
    assert_eq(sum, 15, "sum of 1..5 should be 15")
    return 0
}

@test
func test_fold_product() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    let mul: func(I32, I32) -> I32 = do(acc: I32, x: I32) -> I32 { acc * x }
    let product: I32 = fold_array(arr, 1, mul)
    assert_eq(product, 120, "product of 1..5 should be 120")
    return 0
}

// Note: max/min fold tests removed - inline if-else not supported in closure body

// ============================================================================
// Predicate Tests (all, any, count, find)
// ============================================================================

@test
func test_all_positive() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 5]
    let is_positive: func(I32) -> Bool = do(x: I32) -> Bool { x > 0 }
    let result: Bool = all_array(arr, is_positive)
    assert(result, "all should be true for positive array")
    return 0
}

@test
func test_all_false() -> I32 {
    let arr: [I32; 5] = [1, 2, 0, 4, 5]
    let is_positive: func(I32) -> Bool = do(x: I32) -> Bool { x > 0 }
    let result: Bool = all_array(arr, is_positive)
    assert(not result, "all should be false when 0 is present")
    return 0
}

@test
func test_any_even() -> I32 {
    let arr: [I32; 5] = [1, 3, 4, 7, 9]
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let result: Bool = any_array(arr, is_even)
    assert(result, "any should find 4 as even")
    return 0
}

@test
func test_any_none() -> I32 {
    let arr: [I32; 5] = [1, 3, 5, 7, 9]
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let result: Bool = any_array(arr, is_even)
    assert(not result, "any should not find even in odd array")
    return 0
}

@test
func test_count_even() -> I32 {
    let arr: [I32; 5] = [1, 2, 3, 4, 6]
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let count: I32 = count_array(arr, is_even)
    assert_eq(count, 3, "should count 3 even numbers")
    return 0
}

@test
func test_count_greater_than() -> I32 {
    let arr: [I32; 5] = [1, 5, 3, 8, 2]
    let gt_three: func(I32) -> Bool = do(x: I32) -> Bool { x > 3 }
    let count: I32 = count_array(arr, gt_three)
    assert_eq(count, 2, "should count 2 numbers > 3")
    return 0
}

@test
func test_find_first_even() -> I32 {
    let arr: [I32; 5] = [1, 3, 6, 8, 10]
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let result: I32 = find_first(arr, is_even)
    assert_eq(result, 6, "first even should be 6")
    return 0
}

@test
func test_find_not_found() -> I32 {
    let arr: [I32; 5] = [1, 3, 5, 7, 9]
    let is_even: func(I32) -> Bool = do(x: I32) -> Bool { x % 2 == 0 }
    let result: I32 = find_first(arr, is_even)
    assert_eq(result, -1, "should return -1 when not found")
    return 0
}

// ============================================================================
// Multi-Parameter Closure Tests
// ============================================================================

@test
func test_two_param_closure() -> I32 {
    let add: func(I32, I32) -> I32 = do(a: I32, b: I32) -> I32 { a + b }
    let result: I32 = add(3, 7)
    assert_eq(result, 10, "add(3, 7) should be 10")
    return 0
}

@test
func test_two_param_multiply() -> I32 {
    let mul: func(I32, I32) -> I32 = do(a: I32, b: I32) -> I32 { a * b }
    let result: I32 = mul(6, 7)
    assert_eq(result, 42, "mul(6, 7) should be 42")
    return 0
}

// Note: max closure test removed - inline if-else not supported in closure body

// ============================================================================
// Boolean Closure Tests
// ============================================================================

@test
func test_bool_closure_true() -> I32 {
    let is_positive: func(I32) -> Bool = do(x: I32) -> Bool { x > 0 }
    assert(is_positive(5), "5 is positive")
    return 0
}

@test
func test_bool_closure_false() -> I32 {
    let is_negative: func(I32) -> Bool = do(x: I32) -> Bool { x < 0 }
    assert(not is_negative(5), "5 is not negative")
    return 0
}

@test
func test_bool_closure_equality() -> I32 {
    let equals_ten: func(I32) -> Bool = do(x: I32) -> Bool { x == 10 }
    assert(equals_ten(10), "10 equals 10")
    assert(not equals_ten(5), "5 does not equal 10")
    return 0
}

// ============================================================================
// Closure Variable Capture Tests
// ============================================================================

@test
func test_capture_simple() -> I32 {
    let offset: I32 = 10
    let add_offset: func(I32) -> I32 = do(x: I32) -> I32 { x + offset }
    let result: I32 = add_offset(5)
    assert_eq(result, 15, "should add captured offset")
    return 0
}

@test
func test_capture_multiple() -> I32 {
    let a: I32 = 2
    let b: I32 = 3
    let compute: func(I32) -> I32 = do(x: I32) -> I32 { x * a + b }
    let result: I32 = compute(5)
    assert_eq(result, 13, "5*2+3 = 13")
    return 0
}

// ============================================================================
// Expression Closure (Short Form) Tests
// ============================================================================

@test
func test_expr_closure_add() -> I32 {
    let result: I32 = apply(5, do(x: I32) x + 5)
    assert_eq(result, 10, "short form closure")
    return 0
}

@test
func test_expr_closure_multiply() -> I32 {
    let result: I32 = apply(7, do(x: I32) x * 3)
    assert_eq(result, 21, "short form multiply")
    return 0
}

// ============================================================================
// Generic Closure Tests
// ============================================================================

func apply_generic[T](x: T, f: func(T) -> T) -> T {
    return f(x)
}

func apply_i32(x: I32, f: func(I32) -> I32) -> I32 {
    return f(x)
}

@test
func test_generic_apply_multiply() -> I32 {
    let result: I32 = apply_generic(5, do(val: I32) val * 2)
    assert_eq(result, 10, "apply_generic(5, *2) should be 10")
    return 0
}

@test
func test_generic_apply_add() -> I32 {
    let result: I32 = apply_generic(7, do(val: I32) val + 3)
    assert_eq(result, 10, "apply_generic(7, +3) should be 10")
    return 0
}

@test
func test_apply_i32_multiply() -> I32 {
    let result: I32 = apply_i32(5, do(val: I32) val * 2)
    assert_eq(result, 10, "apply_i32(5, *2) should be 10")
    return 0
}

@test
func test_apply_i32_add() -> I32 {
    let result: I32 = apply_i32(10, do(val: I32) val + 3)
    assert_eq(result, 13, "apply_i32(10, +3) should be 13")
    return 0
}
