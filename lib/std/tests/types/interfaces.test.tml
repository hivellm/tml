// Tests for C#-style OOP interfaces
use test
use std::interfaces::*

// ============================================================================
// IEquatable Tests
// ============================================================================

class Point implements IEquatable[Point] {
    x: I32
    y: I32

    static func create(x: I32, y: I32) -> Point {
        return Point { x: x, y: y }
    }

    func equals(this, other: Point) -> Bool {
        return this.x == other.x and this.y == other.y
    }

    func get_x(this) -> I32 { return this.x }
    func get_y(this) -> I32 { return this.y }
}

@test
func test_iequatable_equal() -> I32 {
    let p1: Point = Point::create(10, 20)
    let p2: Point = Point::create(10, 20)
    assert(p1.equals(p2), "Points with same values should be equal")
    return 0
}

@test
func test_iequatable_not_equal() -> I32 {
    let p1: Point = Point::create(10, 20)
    let p2: Point = Point::create(30, 40)
    assert(not p1.equals(p2), "Points with different values should not be equal")
    return 0
}

// ============================================================================
// IComparable Tests
// ============================================================================

class Age implements IComparable[Age] {
    years: I32

    static func create(years: I32) -> Age {
        return Age { years: years }
    }

    func compare_to(this, other: Age) -> I32 {
        return this.years - other.years
    }

    func get_years(this) -> I32 { return this.years }
}

@test
func test_icomparable_less() -> I32 {
    let a1: Age = Age::create(20)
    let a2: Age = Age::create(30)
    let cmp: I32 = a1.compare_to(a2)
    assert(cmp < 0, "20 should be less than 30")
    return 0
}

@test
func test_icomparable_equal() -> I32 {
    let a1: Age = Age::create(25)
    let a2: Age = Age::create(25)
    let cmp: I32 = a1.compare_to(a2)
    assert_eq(cmp, 0, "Same ages should compare equal")
    return 0
}

@test
func test_icomparable_greater() -> I32 {
    let a1: Age = Age::create(40)
    let a2: Age = Age::create(30)
    let cmp: I32 = a1.compare_to(a2)
    assert(cmp > 0, "40 should be greater than 30")
    return 0
}

// ============================================================================
// IDisposable Tests
// ============================================================================

class Resource implements IDisposable {
    is_disposed: Bool

    static func create() -> Resource {
        return Resource { is_disposed: false }
    }

    func dispose(mut this) {
        this.is_disposed = true
    }

    func check_disposed(this) -> Bool {
        return this.is_disposed
    }
}

@test
func test_idisposable_dispose() -> I32 {
    let r: Resource = Resource::create()
    assert(not r.check_disposed(), "Resource should not be disposed initially")
    r.dispose()
    assert(r.check_disposed(), "Resource should be disposed after dispose()")
    return 0
}

// ============================================================================
// ICloneable Tests
// ============================================================================

class Config implements ICloneable {
    value: I32

    static func create(value: I32) -> Config {
        return Config { value: value }
    }

    func clone(this) -> Config {
        return Config { value: this.value }
    }

    func get_value(this) -> I32 { return this.value }
    func set_value(mut this, v: I32) { this.value = v }
}

@test
func test_icloneable_clone() -> I32 {
    let c1: Config = Config::create(42)
    let c2: Config = c1.clone()

    assert_eq(c1.get_value(), 42, "Original should have value 42")
    assert_eq(c2.get_value(), 42, "Clone should have value 42")

    // Modifying clone should not affect original
    c2.set_value(100)
    assert_eq(c1.get_value(), 42, "Original should still be 42")
    assert_eq(c2.get_value(), 100, "Clone should be 100")

    return 0
}

// ============================================================================
// IHashable Tests
// ============================================================================

class UserId implements IHashable, IEquatable[UserId] {
    id: I64

    static func create(id: I64) -> UserId {
        return UserId { id: id }
    }

    func get_hash_code(this) -> I64 {
        return this.id
    }

    func equals(this, other: UserId) -> Bool {
        return this.id == other.id
    }

    func get_id(this) -> I64 { return this.id }
}

@test
func test_ihashable_same_id() -> I32 {
    let u1: UserId = UserId::create(12345)
    let u2: UserId = UserId::create(12345)

    // Same IDs should have same hash
    assert_eq(u1.get_hash_code() as I32, u2.get_hash_code() as I32, "Same IDs should have same hash")
    // And should be equal
    assert(u1.equals(u2), "Same IDs should be equal")
    return 0
}

@test
func test_ihashable_different_id() -> I32 {
    let u1: UserId = UserId::create(111)
    let u2: UserId = UserId::create(222)

    // Different IDs should have different hashes
    assert(u1.get_hash_code() != u2.get_hash_code(), "Different IDs should have different hash")
    // And should not be equal
    assert(not u1.equals(u2), "Different IDs should not be equal")
    return 0
}

// ============================================================================
// Multiple Interface Implementation
// ============================================================================

class Person implements IEquatable[Person], IComparable[Person], IFormattable {
    name_id: I32  // Using I32 for simplicity
    age: I32

    static func create(name_id: I32, age: I32) -> Person {
        return Person { name_id: name_id, age: age }
    }

    func equals(this, other: Person) -> Bool {
        return this.name_id == other.name_id
    }

    func compare_to(this, other: Person) -> I32 {
        return this.age - other.age
    }

    func to_string(this) -> Str {
        return "Person"
    }

    func to_string_format(this, format: Str) -> Str {
        return "Person"
    }

    func get_age(this) -> I32 { return this.age }
}

@test
func test_multiple_interfaces() -> I32 {
    let p1: Person = Person::create(1, 25)
    let p2: Person = Person::create(1, 30)  // Same name_id, different age
    let p3: Person = Person::create(2, 25)  // Different name_id, same age

    // Test IEquatable - compares by name_id
    assert(p1.equals(p2), "Same name_id should be equal")
    assert(not p1.equals(p3), "Different name_id should not be equal")

    // Test IComparable - compares by age
    assert(p1.compare_to(p2) < 0, "25 should be less than 30")
    assert_eq(p1.compare_to(p3), 0, "Same age should compare equal")

    return 0
}
