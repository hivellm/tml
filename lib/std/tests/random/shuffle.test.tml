// Tests for std::random shuffle and convenience functions
use test::{assert, assert_eq}
use std::random::{Rng, random_i64, random_f64, random_bool, random_range}
use std::collections::List

@test
func test_next_f64_range() -> I32 {
    var rng: Rng = Rng::with_seed(42)
    var i: I64 = 0
    loop (i < 100) {
        let v: F64 = rng.next_f64()
        assert(v >= 0.0, "next_f64 should be >= 0.0")
        assert(v < 1.0, "next_f64 should be < 1.0")
        i = i + 1
    }
    return 0
}

@test
func test_range_f64() -> I32 {
    var rng: Rng = Rng::with_seed(99)
    var i: I64 = 0
    loop (i < 50) {
        let v: F64 = rng.range_f64(10.0, 20.0)
        assert(v >= 10.0, "range_f64 should be >= min")
        assert(v < 20.0, "range_f64 should be < max")
        i = i + 1
    }
    return 0
}

@test
func test_shuffle_i64() -> I32 {
    var rng: Rng = Rng::with_seed(123)
    let list: List[I64] = List[I64]::new(10)
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)

    rng.shuffle_i64(list)

    // After shuffle, all elements should still be present (sum unchanged)
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < list.len()) {
        sum = sum + list.get(i)
        i = i + 1
    }
    assert_eq(sum, 15, "shuffle should preserve all elements (sum=15)")
    assert_eq(list.len(), 5, "shuffle should preserve length")
    list.destroy()
    return 0
}

@test
func test_shuffle_i32() -> I32 {
    var rng: Rng = Rng::with_seed(456)
    let list: List[I32] = List[I32]::new(8)
    list.push(10)
    list.push(20)
    list.push(30)
    list.push(40)

    rng.shuffle_i32(list)

    var sum: I32 = 0
    var i: I64 = 0
    loop (i < list.len()) {
        sum = sum + list.get(i)
        i = i + 1
    }
    assert_eq(sum, 100, "shuffle i32 should preserve all elements (sum=100)")
    list.destroy()
    return 0
}

@test
func test_shuffle_empty_and_single() -> I32 {
    var rng: Rng = Rng::with_seed(789)

    // Empty list — should not crash
    let empty: List[I64] = List[I64]::new(4)
    rng.shuffle_i64(empty)
    assert_eq(empty.len(), 0, "empty shuffle should have len 0")
    empty.destroy()

    // Single element — should be unchanged
    let single: List[I64] = List[I64]::new(4)
    single.push(42)
    rng.shuffle_i64(single)
    assert_eq(single.get(0), 42, "single element should be unchanged")
    single.destroy()

    return 0
}
