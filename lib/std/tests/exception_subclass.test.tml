// Tests for exception subclass-like patterns using struct types with impl blocks
// Note: Real Exception class hierarchy (class keyword with extends Object)
// has codegen limitations for method dispatch (transitive class dependency
// resolution), tracked in rulebook/tasks/test-failures/
use test

// Mock exception subtypes using type + impl pattern

type MockArgNull {
    message: Str
    param_name: Str
}

impl MockArgNull {
    pub func create(param_name: Str) -> MockArgNull {
        return MockArgNull {
            message: "Value cannot be null: " + param_name,
            param_name: param_name
        }
    }
    pub func get_message(this) -> Str { return this.message }
    pub func get_param_name(this) -> Str { return this.param_name }
}

type MockIO {
    message: Str
}

impl MockIO {
    pub func create(message: Str) -> MockIO {
        return MockIO { message: message }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockInvalidOp {
    message: Str
}

impl MockInvalidOp {
    pub func create(message: Str) -> MockInvalidOp {
        return MockInvalidOp { message: message }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockNotSupported {
    message: Str
}

impl MockNotSupported {
    pub func create() -> MockNotSupported {
        return MockNotSupported { message: "Operation is not supported" }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockNotImpl {
    message: Str
}

impl MockNotImpl {
    pub func create() -> MockNotImpl {
        return MockNotImpl { message: "Method not implemented" }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockTimeout {
    message: Str
}

impl MockTimeout {
    pub func create() -> MockTimeout {
        return MockTimeout { message: "Operation timed out" }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockFormat {
    message: Str
}

impl MockFormat {
    pub func with_message(message: Str) -> MockFormat {
        return MockFormat { message: message }
    }
    pub func get_message(this) -> Str { return this.message }
}

type MockIndexOutOfRange {
    message: Str
    index: I64
    length: I64
}

impl MockIndexOutOfRange {
    pub func with_bounds(index: I64, length: I64) -> MockIndexOutOfRange {
        return MockIndexOutOfRange {
            message: "Index out of range",
            index: index,
            length: length
        }
    }
    pub func get_message(this) -> Str { return this.message }
    pub func get_index(this) -> I64 { return this.index }
    pub func get_length(this) -> I64 { return this.length }
}

type MockArgOutOfRange {
    message: Str
    param_name: Str
    actual_value: I64
}

impl MockArgOutOfRange {
    pub func create(param_name: Str, actual: I64, message: Str) -> MockArgOutOfRange {
        return MockArgOutOfRange {
            message: message,
            param_name: param_name,
            actual_value: actual
        }
    }
    pub func get_message(this) -> Str { return this.message }
    pub func get_param_name(this) -> Str { return this.param_name }
}

type MockFileNotFound {
    message: Str
    file_path: Str
}

impl MockFileNotFound {
    pub func create(file_path: Str) -> MockFileNotFound {
        return MockFileNotFound {
            message: "File not found: " + file_path,
            file_path: file_path
        }
    }
    pub func get_message(this) -> Str { return this.message }
    pub func get_file_path(this) -> Str { return this.file_path }
}

@test
func test_arg_null_alloc() -> I32 {
    let e = MockArgNull::create("myParam")
    assert_eq(e.get_param_name(), "myParam", "param name")
    return 0
}

@test
func test_io_exception_alloc() -> I32 {
    let e = MockIO::create("disk full")
    assert_eq(e.get_message(), "disk full", "message")
    return 0
}

@test
func test_invalid_op_alloc() -> I32 {
    let e = MockInvalidOp::create("not allowed")
    assert_eq(e.get_message(), "not allowed", "message")
    return 0
}

@test
func test_not_supported_alloc() -> I32 {
    let e = MockNotSupported::create()
    assert_eq(e.get_message(), "Operation is not supported", "message")
    return 0
}

@test
func test_not_implemented_alloc() -> I32 {
    let e = MockNotImpl::create()
    assert_eq(e.get_message(), "Method not implemented", "message")
    return 0
}

@test
func test_timeout_alloc() -> I32 {
    let e = MockTimeout::create()
    assert_eq(e.get_message(), "Operation timed out", "message")
    return 0
}

@test
func test_format_exception_alloc() -> I32 {
    let e = MockFormat::with_message("bad format")
    assert_eq(e.get_message(), "bad format", "message")
    return 0
}

@test
func test_index_out_of_range_alloc() -> I32 {
    let e = MockIndexOutOfRange::with_bounds(5 as I64, 3 as I64)
    assert_eq(e.get_index(), 5 as I64, "index")
    assert_eq(e.get_length(), 3 as I64, "length")
    return 0
}

@test
func test_arg_out_of_range_alloc() -> I32 {
    let e = MockArgOutOfRange::create("idx", 10 as I64, "too big")
    assert_eq(e.get_message(), "too big", "message")
    return 0
}

@test
func test_file_not_found_alloc() -> I32 {
    let e = MockFileNotFound::create("/etc/missing.txt")
    assert_eq(e.get_file_path(), "/etc/missing.txt", "file path")
    return 0
}
