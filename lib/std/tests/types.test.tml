// Tests for Maybe and Outcome types
// Uses the builtin Maybe and Outcome types
use test

// ============================================================================
// Maybe[T] Tests
// ============================================================================

@test
func test_maybe_just_is_just() {
    let m: Maybe[I32] = Just(42)
    assert(m.is_just() == true, "Just should return true for is_just")
    println("Maybe Just is_just test passed!")
}

@test
func test_maybe_nothing_is_nothing() {
    let m: Maybe[I32] = Nothing
    assert(m.is_nothing() == true, "Nothing should return true for is_nothing")
    println("Maybe Nothing is_nothing test passed!")
}

@test
func test_maybe_just_is_not_nothing() {
    let m: Maybe[I32] = Just(100)
    assert(m.is_nothing() == false, "Just should return false for is_nothing")
    println("Maybe Just is_not_nothing test passed!")
}

@test
func test_maybe_nothing_is_not_just() {
    let m: Maybe[I32] = Nothing
    assert(m.is_just() == false, "Nothing should return false for is_just")
    println("Maybe Nothing is_not_just test passed!")
}

@test
func test_maybe_unwrap_or_just() {
    let m: Maybe[I32] = Just(42)
    let val: I32 = m.unwrap_or(0)
    assert(val == 42, "unwrap_or on Just should return the value")
    println("Maybe unwrap_or Just test passed!")
}

@test
func test_maybe_unwrap_or_nothing() {
    let m: Maybe[I32] = Nothing
    let val: I32 = m.unwrap_or(99)
    assert(val == 99, "unwrap_or on Nothing should return the default")
    println("Maybe unwrap_or Nothing test passed!")
}

// ============================================================================
// Outcome[T, E] Tests
// ============================================================================

@test
func test_outcome_ok_is_ok() {
    let o: Outcome[I32, Str] = Ok(100)
    assert(o.is_ok() == true, "Ok should return true for is_ok")
    println("Outcome Ok is_ok test passed!")
}

@test
func test_outcome_err_is_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.is_err() == true, "Err should return true for is_err")
    println("Outcome Err is_err test passed!")
}

@test
func test_outcome_ok_is_not_err() {
    let o: Outcome[I32, Str] = Ok(50)
    assert(o.is_err() == false, "Ok should return false for is_err")
    println("Outcome Ok is_not_err test passed!")
}

@test
func test_outcome_err_is_not_ok() {
    let o: Outcome[I32, Str] = Err("fail")
    assert(o.is_ok() == false, "Err should return false for is_ok")
    println("Outcome Err is_not_ok test passed!")
}

@test
func test_outcome_unwrap_or_ok_success() {
    let o: Outcome[I32, Str] = Ok(42)
    let val: I32 = o.unwrap_or(0)
    assert(val == 42, "unwrap_or on Ok should return the value")
    println("Outcome unwrap_or Ok test passed!")
}

@test
func test_outcome_unwrap_or_ok_default() {
    let o: Outcome[I32, Str] = Err("error")
    let val: I32 = o.unwrap_or(99)
    assert(val == 99, "unwrap_or on Err should return the default")
    println("Outcome unwrap_or Err test passed!")
}

// ============================================================================
// Pattern Matching Tests
// ============================================================================

@test
func test_maybe_pattern_match() {
    let m: Maybe[I32] = Just(123)

    when m {
        Just(val) => {
            assert(val == 123, "Pattern should extract correct value")
            println("Maybe pattern match test passed!")
        },
        Nothing => {
            assert(false, "Should not reach Nothing branch")
        }
    }
}

@test
func test_outcome_pattern_match() {
    let o: Outcome[I32, Str] = Ok(456)

    when o {
        Ok(val) => {
            assert(val == 456, "Pattern should extract correct value")
            println("Outcome pattern match test passed!")
        },
        Err(_) => {
            assert(false, "Should not reach Err branch")
        }
    }
}
