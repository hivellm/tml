// Tests for exception patterns using mock structs (14 tests)
// Note: Real Exception class tests require class method dispatch codegen
// which is tracked in rulebook/tasks/test-failures/
use test

// === Mock argument exceptions ===

type MockArgNullException {
    message: Str
    param_name: Str
}

impl MockArgNullException {
    pub func create(param_name: Str) -> MockArgNullException {
        return MockArgNullException {
            message: "Value cannot be null: " + param_name,
            param_name: param_name
        }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_param_name(this) -> Str { return this.param_name }
    pub func get_type(this) -> Str { return "ArgumentNullException" }
    pub func to_string(this) -> Str { return "ArgumentNullException: " + this.message }
}

type MockArgOutOfRangeException {
    message: Str
    param_name: Str
    actual_value: I64
}

impl MockArgOutOfRangeException {
    pub func create(param_name: Str, actual: I64, message: Str) -> MockArgOutOfRangeException {
        return MockArgOutOfRangeException {
            message: message,
            param_name: param_name,
            actual_value: actual
        }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_param_name(this) -> Str { return this.param_name }
    pub func get_actual_value(this) -> I64 { return this.actual_value }
    pub func get_type(this) -> Str { return "ArgumentOutOfRangeException" }
    pub func to_string(this) -> Str { return "ArgumentOutOfRangeException: " + this.message }
}

@test
func test_arg_null_create() -> I32 {
    let e: MockArgNullException = MockArgNullException::create("name")
    assert_eq(e.get_type(), "ArgumentNullException", "type should match")
    assert_eq(e.get_param_name(), "name", "param name should match")
    assert_eq(e.get_message(), "Value cannot be null: name", "message format")
    return 0
}

@test
func test_arg_null_to_string() -> I32 {
    let e: MockArgNullException = MockArgNullException::create("data")
    assert_eq(e.to_string(), "ArgumentNullException: Value cannot be null: data", "to_string format")
    return 0
}

@test
func test_arg_out_of_range() -> I32 {
    let e: MockArgOutOfRangeException = MockArgOutOfRangeException::create("index", 15 as I64, "Must be 0-10")
    assert_eq(e.get_type(), "ArgumentOutOfRangeException", "type")
    assert_eq(e.get_param_name(), "index", "param name")
    assert_eq(e.get_actual_value(), 15 as I64, "actual value")
    assert_eq(e.get_message(), "Must be 0-10", "message")
    return 0
}

// === Mock IO exceptions ===

type MockIOException {
    message: Str
}

impl MockIOException {
    pub func create(message: Str) -> MockIOException {
        return MockIOException { message: message }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "IOException" }
    pub func to_string(this) -> Str { return "IOException: " + this.message }
}

type MockFileNotFoundException {
    message: Str
    file_path: Str
}

impl MockFileNotFoundException {
    pub func create(file_path: Str) -> MockFileNotFoundException {
        return MockFileNotFoundException {
            message: "File not found: " + file_path,
            file_path: file_path
        }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_file_path(this) -> Str { return this.file_path }
    pub func get_type(this) -> Str { return "FileNotFoundException" }
    pub func to_string(this) -> Str { return "FileNotFoundException: " + this.message }
}

type MockArithmeticException {
    message: Str
}

impl MockArithmeticException {
    pub func create(message: Str) -> MockArithmeticException {
        return MockArithmeticException { message: message }
    }

    pub func overflow() -> MockArithmeticException {
        return MockArithmeticException { message: "Arithmetic overflow" }
    }

    pub func divide_by_zero() -> MockArithmeticException {
        return MockArithmeticException { message: "Division by zero" }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "ArithmeticException" }
}

type MockTimeoutException {
    message: Str
}

impl MockTimeoutException {
    pub func create() -> MockTimeoutException {
        return MockTimeoutException { message: "Operation timed out" }
    }

    pub func with_message(message: Str) -> MockTimeoutException {
        return MockTimeoutException { message: message }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "TimeoutException" }
}

@test
func test_io_exception() -> I32 {
    let e: MockIOException = MockIOException::create("disk full")
    assert_eq(e.get_type(), "IOException", "type")
    assert_eq(e.get_message(), "disk full", "message")
    assert_eq(e.to_string(), "IOException: disk full", "to_string")
    return 0
}

@test
func test_file_not_found() -> I32 {
    let e: MockFileNotFoundException = MockFileNotFoundException::create("/etc/config.json")
    assert_eq(e.get_type(), "FileNotFoundException", "type")
    assert_eq(e.get_file_path(), "/etc/config.json", "file path")
    assert_eq(e.get_message(), "File not found: /etc/config.json", "message format")
    return 0
}

@test
func test_arithmetic_overflow() -> I32 {
    let e: MockArithmeticException = MockArithmeticException::overflow()
    assert_eq(e.get_type(), "ArithmeticException", "type")
    assert_eq(e.get_message(), "Arithmetic overflow", "overflow message")
    return 0
}

@test
func test_arithmetic_divide_by_zero() -> I32 {
    let e: MockArithmeticException = MockArithmeticException::divide_by_zero()
    assert_eq(e.get_message(), "Division by zero", "divide by zero message")
    return 0
}

@test
func test_timeout_default() -> I32 {
    let e: MockTimeoutException = MockTimeoutException::create()
    assert_eq(e.get_type(), "TimeoutException", "type")
    assert_eq(e.get_message(), "Operation timed out", "default message")
    return 0
}

@test
func test_timeout_with_message() -> I32 {
    let e: MockTimeoutException = MockTimeoutException::with_message("Connection timed out after 30s")
    assert_eq(e.get_message(), "Connection timed out after 30s", "custom message")
    return 0
}

// === Mock operation exceptions ===

type MockInvalidOpException {
    message: Str
}

impl MockInvalidOpException {
    pub func create(message: Str) -> MockInvalidOpException {
        return MockInvalidOpException { message: message }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "InvalidOperationException" }
    pub func to_string(this) -> Str { return "InvalidOperationException: " + this.message }
}

type MockNotSupportedException {
    message: Str
}

impl MockNotSupportedException {
    pub func create() -> MockNotSupportedException {
        return MockNotSupportedException { message: "Operation is not supported" }
    }

    pub func with_message(message: Str) -> MockNotSupportedException {
        return MockNotSupportedException { message: message }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "NotSupportedException" }
    pub func to_string(this) -> Str { return "NotSupportedException: " + this.message }
}

type MockNotImplException {
    message: Str
}

impl MockNotImplException {
    pub func create() -> MockNotImplException {
        return MockNotImplException { message: "Method not implemented" }
    }

    pub func with_message(message: Str) -> MockNotImplException {
        return MockNotImplException { message: message }
    }

    pub func get_message(this) -> Str { return this.message }
    pub func get_type(this) -> Str { return "NotImplementedException" }
    pub func to_string(this) -> Str { return "NotImplementedException: " + this.message }
}

@test
func test_invalid_op_exception() -> I32 {
    let e: MockInvalidOpException = MockInvalidOpException::create("Cannot send while disconnected")
    assert_eq(e.get_type(), "InvalidOperationException", "type")
    assert_eq(e.get_message(), "Cannot send while disconnected", "message")
    assert_eq(e.to_string(), "InvalidOperationException: Cannot send while disconnected", "to_string")
    return 0
}

@test
func test_not_supported_default() -> I32 {
    let e: MockNotSupportedException = MockNotSupportedException::create()
    assert_eq(e.get_type(), "NotSupportedException", "type")
    assert_eq(e.get_message(), "Operation is not supported", "default message")
    return 0
}

@test
func test_not_supported_with_message() -> I32 {
    let e: MockNotSupportedException = MockNotSupportedException::with_message("Read-only collection")
    assert_eq(e.get_message(), "Read-only collection", "custom message")
    assert_eq(e.to_string(), "NotSupportedException: Read-only collection", "to_string")
    return 0
}

@test
func test_not_implemented_default() -> I32 {
    let e: MockNotImplException = MockNotImplException::create()
    assert_eq(e.get_type(), "NotImplementedException", "type")
    assert_eq(e.get_message(), "Method not implemented", "default message")
    return 0
}

@test
func test_not_implemented_with_message() -> I32 {
    let e: MockNotImplException = MockNotImplException::with_message("TODO: implement serialize")
    assert_eq(e.get_message(), "TODO: implement serialize", "custom message")
    return 0
}
