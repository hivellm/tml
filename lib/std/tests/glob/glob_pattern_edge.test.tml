//! Edge case tests for glob pattern matching.
//!
//! Covers: star-only, combined wildcards, trailing star, pattern/text length mismatches.

use std::glob::matches
use test::{assert, assert_eq}

// ============================================================================
// Star-only and bare wildcards
// ============================================================================

@test
func test_star_only() -> I32 {
    assert(matches("*", "anything"), "* should match any string")
    assert(matches("*", ""), "* should match empty string")
    assert(matches("*", "a"), "* should match single char")
    assert(matches("*", "hello.world.txt"), "* should match dots")
    return 0
}

@test
func test_question_only() -> I32 {
    assert(matches("?", "a"), "? should match single char")
    assert(not matches("?", ""), "? should not match empty")
    assert(not matches("?", "ab"), "? should not match two chars")
    return 0
}

// ============================================================================
// Combined wildcards: *, ?, literals
// ============================================================================

@test
func test_star_dot_star() -> I32 {
    assert(matches("*.*", "file.txt"), "*.* should match file.txt")
    assert(matches("*.*", "a.b"), "*.* should match a.b")
    assert(matches("*.*", "name.tar.gz"), "*.* should match name.tar.gz")
    assert(not matches("*.*", "nodot"), "*.* should not match no-dot string")
    return 0
}

@test
func test_question_star_combo() -> I32 {
    assert(matches("?*", "a"), "?* should match single char")
    assert(matches("?*", "ab"), "?* should match two chars")
    assert(matches("?*", "abc"), "?* should match three chars")
    assert(not matches("?*", ""), "?* should not match empty")
    return 0
}

@test
func test_star_question_combo() -> I32 {
    assert(matches("*?", "a"), "*? should match single char")
    assert(matches("*?", "ab"), "*? should match two chars")
    assert(not matches("*?", ""), "*? should not match empty")
    return 0
}

@test
func test_mixed_wildcards() -> I32 {
    assert(matches("a?c*", "abc"), "a?c* should match abc")
    assert(matches("a?c*", "axcdef"), "a?c* should match axcdef")
    assert(not matches("a?c*", "axx"), "a?c* should not match axx")
    assert(matches("*a?b", "xaxb"), "*a?b should match xaxb")
    return 0
}

// ============================================================================
// Trailing star patterns
// ============================================================================

@test
func test_trailing_star() -> I32 {
    assert(matches("hello*", "hello"), "hello* matches hello exactly")
    assert(matches("hello*", "hello_world"), "hello* matches hello_world")
    assert(not matches("hello*", "hell"), "hello* should not match hell")
    return 0
}

@test
func test_multiple_stars() -> I32 {
    assert(matches("*a*", "a"), "*a* should match a")
    assert(matches("*a*", "bac"), "*a* should match bac")
    assert(matches("*a*", "xyzabc"), "*a* should match xyzabc")
    assert(not matches("*a*", "xyz"), "*a* should not match xyz (no 'a')")
    return 0
}

// ============================================================================
// Length mismatches
// ============================================================================

@test
func test_pattern_longer_than_text() -> I32 {
    assert(not matches("abcdef", "abc"), "longer pattern should not match shorter text")
    assert(not matches("a?c?e", "ac"), "pattern with ? should not match too-short text")
    return 0
}

@test
func test_text_longer_than_pattern() -> I32 {
    assert(not matches("abc", "abcdef"), "shorter pattern should not match longer text")
    assert(not matches("a", "ab"), "single char pattern should not match two chars")
    return 0
}

@test
func test_both_empty() -> I32 {
    assert(matches("", ""), "empty matches empty")
    assert(not matches("a", ""), "non-empty pattern should not match empty text")
    return 0
}
