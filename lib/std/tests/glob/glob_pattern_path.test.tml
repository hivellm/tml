//! Tests for path-style glob pattern matching edge cases.
//!
//! Covers: multi-segment paths, multiple **, trailing **, backslash normalization,
//! single-file patterns with separators, and negative cases.

use std::glob::matches
use test::{assert, assert_eq}

// ============================================================================
// Multi-segment literal paths
// ============================================================================

@test
func test_multi_segment_literal() -> I32 {
    assert(matches("a/b/c", "a/b/c"), "exact multi-segment should match")
    assert(not matches("a/b/c", "a/b/d"), "different last segment")
    assert(not matches("a/b/c", "a/x/c"), "different middle segment")
    return 0
}

// ============================================================================
// ** at end (trailing globstar)
// ============================================================================

@test
func test_trailing_globstar() -> I32 {
    assert(matches("src/**", "src/foo"), "trailing ** should match one level")
    assert(matches("src/**", "src/foo/bar"), "trailing ** should match two levels")
    assert(matches("src/**", "src/a/b/c"), "trailing ** should match deep paths")
    return 0
}

// ============================================================================
// ** at beginning
// ============================================================================

@test
func test_leading_globstar() -> I32 {
    assert(matches("**/test.tml", "test.tml"), "leading ** should match root file")
    assert(matches("**/test.tml", "a/test.tml"), "leading ** should match one dir")
    assert(matches("**/test.tml", "a/b/c/test.tml"), "leading ** should match deep dirs")
    assert(not matches("**/test.tml", "test.rs"), "leading ** wrong extension")
    return 0
}

// ============================================================================
// Multiple ** segments
// ============================================================================

@test
func test_multiple_globstars() -> I32 {
    assert(matches("**/*.tml", "src/main.tml"), "**/*.tml matches one-deep")
    assert(matches("a/**/b/**/c", "a/b/c"), "double ** zero dirs each")
    assert(matches("a/**/b/**/c", "a/x/b/y/c"), "double ** one dir each")
    assert(matches("a/**/b/**/c", "a/x/y/b/z/c"), "double ** multi+one dirs")
    return 0
}

// ============================================================================
// Backslash normalization (Windows paths)
// ============================================================================

@test
func test_backslash_normalization() -> I32 {
    assert(matches("src/*.tml", "src\\main.tml"), "backslash in text should be normalized")
    assert(matches("src\\*.tml", "src/main.tml"), "backslash in pattern should be normalized")
    return 0
}

// ============================================================================
// Wildcard in directory segment
// ============================================================================

@test
func test_wildcard_dir_segment() -> I32 {
    assert(matches("s*c/main.tml", "src/main.tml"), "* in dir segment")
    assert(matches("s?c/main.tml", "src/main.tml"), "? in dir segment")
    assert(not matches("s?c/main.tml", "srrc/main.tml"), "? matches exactly one char in dir")
    return 0
}

// ============================================================================
// Negative path cases
// ============================================================================

@test
func test_path_no_match_extra_segments() -> I32 {
    assert(not matches("src/*.tml", "src/sub/main.tml"), "* should not cross dir boundary")
    assert(not matches("a/b", "a/b/c"), "shorter pattern should not match longer text")
    assert(not matches("a/b/c", "a/b"), "longer pattern should not match shorter text")
    return 0
}

// ============================================================================
// ** matching zero directories
// ============================================================================

@test
func test_globstar_zero_dirs() -> I32 {
    assert(matches("a/**/b", "a/b"), "** should match zero directories")
    assert(matches("**/a", "a"), "leading ** should match zero dirs")
    return 0
}

// ============================================================================
// Complex combined path patterns
// ============================================================================

@test
func test_complex_path_pattern() -> I32 {
    assert(matches("src/**/*.test.tml", "src/foo.test.tml"), "complex path zero dirs")
    assert(matches("src/**/*.test.tml", "src/a/b/foo.test.tml"), "complex path multi dirs")
    assert(not matches("src/**/*.test.tml", "lib/foo.test.tml"), "complex path wrong root")
    return 0
}
