//! Tests for character class and alternation edge cases.
//!
//! Covers: [^abc] caret negation, [0-9] numeric, multi-range, combined features.

use std::glob::matches
use test::{assert, assert_eq}

// ============================================================================
// Caret negation: [^abc] (alternative to [!abc])
// ============================================================================

@test
func test_caret_negation() -> I32 {
    assert(matches("[^abc].txt", "d.txt"), "[^abc] should match d")
    assert(matches("[^abc].txt", "x.txt"), "[^abc] should match x")
    assert(not matches("[^abc].txt", "a.txt"), "[^abc] should not match a")
    assert(not matches("[^abc].txt", "b.txt"), "[^abc] should not match b")
    return 0
}

// ============================================================================
// Numeric ranges: [0-9]
// ============================================================================

@test
func test_numeric_range() -> I32 {
    assert(matches("file[0-9].txt", "file0.txt"), "[0-9] should match 0")
    assert(matches("file[0-9].txt", "file5.txt"), "[0-9] should match 5")
    assert(matches("file[0-9].txt", "file9.txt"), "[0-9] should match 9")
    assert(not matches("file[0-9].txt", "filea.txt"), "[0-9] should not match a")
    return 0
}

@test
func test_numeric_set() -> I32 {
    assert(matches("v[123].txt", "v1.txt"), "set [123] should match 1")
    assert(matches("v[123].txt", "v2.txt"), "set [123] should match 2")
    assert(matches("v[123].txt", "v3.txt"), "set [123] should match 3")
    assert(not matches("v[123].txt", "v4.txt"), "set [123] should not match 4")
    return 0
}

// ============================================================================
// Uppercase ranges: [A-Z]
// ============================================================================

@test
func test_uppercase_range() -> I32 {
    assert(matches("[A-Z].txt", "A.txt"), "[A-Z] should match A")
    assert(matches("[A-Z].txt", "M.txt"), "[A-Z] should match M")
    assert(matches("[A-Z].txt", "Z.txt"), "[A-Z] should match Z")
    assert(not matches("[A-Z].txt", "a.txt"), "[A-Z] should not match lowercase a")
    return 0
}

// ============================================================================
// Negated range: [!0-9]
// ============================================================================

@test
func test_negated_range() -> I32 {
    assert(matches("[!0-9].txt", "a.txt"), "[!0-9] should match a")
    assert(matches("[!0-9].txt", "z.txt"), "[!0-9] should match z")
    assert(not matches("[!0-9].txt", "5.txt"), "[!0-9] should not match 5")
    assert(not matches("[!0-9].txt", "0.txt"), "[!0-9] should not match 0")
    return 0
}

// ============================================================================
// Character class combined with wildcards
// ============================================================================

@test
func test_class_with_star() -> I32 {
    assert(matches("[abc]*", "apple"), "[abc]* should match apple")
    assert(matches("[abc]*", "banana"), "[abc]* should match banana")
    assert(matches("[abc]*", "a"), "[abc]* should match single char a")
    assert(not matches("[abc]*", "dog"), "[abc]* should not match dog")
    return 0
}

@test
func test_star_then_class() -> I32 {
    assert(matches("*[0-9]", "file1"), "*[0-9] should match file1")
    assert(matches("*[0-9]", "test9"), "*[0-9] should match test9")
    assert(matches("*[0-9]", "0"), "*[0-9] should match 0")
    assert(not matches("*[0-9]", "abc"), "*[0-9] should not match abc")
    return 0
}

@test
func test_class_with_question() -> I32 {
    assert(matches("[a-z]?[0-9]", "a_1"), "[a-z]?[0-9] should match a_1")
    assert(matches("[a-z]?[0-9]", "zx9"), "[a-z]?[0-9] should match zx9")
    assert(not matches("[a-z]?[0-9]", "A_1"), "[a-z]?[0-9] should not match A_1")
    assert(not matches("[a-z]?[0-9]", "aaa"), "[a-z]?[0-9] should not match aaa")
    return 0
}

// ============================================================================
// Single character in alternation
// ============================================================================

@test
func test_alternation_single_chars() -> I32 {
    assert(matches("\{a,b,c}.txt", "a.txt"), "single char alternation a")
    assert(matches("\{a,b,c}.txt", "b.txt"), "single char alternation b")
    assert(matches("\{a,b,c}.txt", "c.txt"), "single char alternation c")
    assert(not matches("\{a,b,c}.txt", "d.txt"), "single char alternation not d")
    return 0
}

@test
func test_alternation_with_wildcard() -> I32 {
    assert(matches("\{src,lib}/*.tml", "src/main.tml"), "alt + path: src")
    assert(matches("\{src,lib}/*.tml", "lib/mod.tml"), "alt + path: lib")
    assert(not matches("\{src,lib}/*.tml", "test/foo.tml"), "alt + path: not test")
    return 0
}

@test
func test_alternation_empty_option() -> I32 {
    assert(matches("file\{.txt,.rs}", "file.txt"), "alt should match file.txt")
    assert(matches("file\{.txt,.rs}", "file.rs"), "alt should match file.rs")
    assert(not matches("file\{.txt,.rs}", "file.py"), "alt should not match file.py")
    return 0
}
