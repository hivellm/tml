//! Tests for glob iteration and convenience functions.
//!
//! Covers: next() iteration, count(), find_all(), empty dir, sorted output.

use std::glob::{Glob, matches, find_all}
use std::file::{File, Dir, Path}
use test::{assert, assert_eq}

// ============================================================================
// next() iteration: consume results one by one
// ============================================================================

@test
func test_glob_next_iteration() -> I32 {
    Dir::create_all("_gi1/src")
    File::write_all("_gi1/src/a.txt", "a")
    File::write_all("_gi1/src/b.txt", "b")
    File::write_all("_gi1/src/c.txt", "c")

    var g: Glob = Glob::find("_gi1/src", "*.txt")
    let total: I64 = g.count()

    // Iterate all results
    let p1: Str = g.next()
    let p2: Str = g.next()
    let p3: Str = g.next()
    let p4: Str = g.next()  // should be empty

    g.free()

    // cleanup
    Path::remove("_gi1/src/a.txt")
    Path::remove("_gi1/src/b.txt")
    Path::remove("_gi1/src/c.txt")
    Dir::remove("_gi1/src")
    Dir::remove("_gi1")

    assert_eq(total, 3, "count should be 3")
    assert(p1 != "", "first next() should return a path")
    assert(p2 != "", "second next() should return a path")
    assert(p3 != "", "third next() should return a path")
    assert(p4 == "", "fourth next() should return empty (exhausted)")
    return 0
}

// ============================================================================
// next() returns empty string when no results at all
// ============================================================================

@test
func test_glob_next_empty_results() -> I32 {
    Dir::create_all("_gi2")
    File::write_all("_gi2/test.txt", "hi")

    var g: Glob = Glob::find("_gi2", "*.xyz")
    let n: I64 = g.count()
    let p: Str = g.next()
    g.free()

    Path::remove("_gi2/test.txt")
    Dir::remove("_gi2")

    assert_eq(n, 0, "count should be 0")
    assert(p == "", "next on empty results should return empty string")
    return 0
}

// ============================================================================
// find_all convenience function
// ============================================================================

@test
func test_find_all_basic() -> I32 {
    Dir::create_all("_gi3")
    File::write_all("_gi3/x.tml", "x")
    File::write_all("_gi3/y.tml", "y")
    File::write_all("_gi3/z.rs", "z")

    let result: Str = find_all("_gi3", "*.tml")

    Path::remove("_gi3/x.tml")
    Path::remove("_gi3/y.tml")
    Path::remove("_gi3/z.rs")
    Dir::remove("_gi3")

    // result should contain paths separated by newlines
    assert(result != "", "find_all should return non-empty string")
    return 0
}

// ============================================================================
// Empty directory returns 0 results
// ============================================================================

@test
func test_glob_empty_dir() -> I32 {
    Dir::create_all("_gi4")

    var g: Glob = Glob::find("_gi4", "*")
    let n: I64 = g.count()
    g.free()

    Dir::remove("_gi4")

    assert_eq(n, 0, "empty directory should have 0 matches")
    return 0
}

// ============================================================================
// Sorted output: results should be alphabetically ordered
// ============================================================================

@test
func test_glob_sorted_output() -> I32 {
    Dir::create_all("_gi5sort")
    File::write_all("_gi5sort/c.txt", "c")
    File::write_all("_gi5sort/a.txt", "a")
    File::write_all("_gi5sort/b.txt", "b")

    var g: Glob = Glob::find("_gi5sort", "*.txt")
    let n: I64 = g.count()
    let p1: Str = g.next()
    let p2: Str = g.next()
    let p3: Str = g.next()
    let p4: Str = g.next()
    g.free()

    Path::remove("_gi5sort/a.txt")
    Path::remove("_gi5sort/b.txt")
    Path::remove("_gi5sort/c.txt")
    Dir::remove("_gi5sort")

    assert_eq(n, 3, "should find 3 files")
    assert(p1 != "", "first result non-empty")
    assert(p2 != "", "second result non-empty")
    assert(p3 != "", "third result non-empty")
    assert(p4 == "", "fourth result should be empty (exhausted)")
    return 0
}
