// Tests for zlib/stream Gzip and Gunzip classes

use test
use std::collections::{Buffer}
use std::zlib::stream::{Gzip, Gunzip}
use std::zlib::options::{ZlibOptions}
use std::zlib::error::{ZlibError}

// =============================================================================
// Gzip Tests
// =============================================================================

@test
func test_gzip_new() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    gzip.destroy()
    return 0
}

@test
func test_gzip_with_options() -> I32 {
    let options: ZlibOptions = ZlibOptions::default()
    let result: Outcome[Gzip, ZlibError] = Gzip::with_options(options)
    if result.is_err() {
        assert(false, "Gzip::with_options should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    gzip.destroy()
    return 0
}

@test
func test_gzip_write() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    let write_result: Outcome[Buffer, ZlibError] = gzip.write("Hello")
    if write_result.is_err() {
        gzip.destroy()
        assert(false, "write should succeed")
        return 1
    }
    gzip.destroy()
    return 0
}

@test
func test_gzip_write_multiple() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    let w1: Outcome[Buffer, ZlibError] = gzip.write("Hello, ")
    let w2: Outcome[Buffer, ZlibError] = gzip.write("World!")
    gzip.destroy()
    return 0
}

@test
func test_gzip_flush() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = gzip.write("Hello")
    let flush_result: Outcome[Buffer, ZlibError] = gzip.flush()
    if flush_result.is_err() {
        gzip.destroy()
        assert(false, "flush should succeed")
        return 1
    }
    let buf: Buffer = flush_result.unwrap()
    assert(buf.len() > 0, "flush should produce output")
    gzip.destroy()
    return 0
}

@test
func test_gzip_finish() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = gzip.write("Hello, World!")
    let finish_result: Outcome[Buffer, ZlibError] = gzip.finish()
    if finish_result.is_err() {
        gzip.destroy()
        assert(false, "finish should succeed")
        return 1
    }
    let buf: Buffer = finish_result.unwrap()
    assert(buf.len() > 0, "finish should produce output")
    gzip.destroy()
    return 0
}

@test
func test_gzip_reset() -> I32 {
    let result: Outcome[Gzip, ZlibError] = Gzip::new()
    if result.is_err() {
        assert(false, "Gzip::new should succeed")
        return 1
    }
    let gzip: Gzip = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = gzip.write("Hello")
    let reset_result: Outcome[Unit, ZlibError] = gzip.reset()
    if reset_result.is_err() {
        gzip.destroy()
        assert(false, "reset should succeed")
        return 1
    }
    gzip.destroy()
    return 0
}

// =============================================================================
// Gunzip Tests
// =============================================================================

@test
func test_gunzip_new() -> I32 {
    let result: Outcome[Gunzip, ZlibError] = Gunzip::new()
    if result.is_err() {
        assert(false, "Gunzip::new should succeed")
        return 1
    }
    let gunzip: Gunzip = result.unwrap()
    gunzip.destroy()
    return 0
}

@test
func test_gunzip_with_options() -> I32 {
    let options: ZlibOptions = ZlibOptions::default()
    let result: Outcome[Gunzip, ZlibError] = Gunzip::with_options(options)
    if result.is_err() {
        assert(false, "Gunzip::with_options should succeed")
        return 1
    }
    let gunzip: Gunzip = result.unwrap()
    gunzip.destroy()
    return 0
}

@test
func test_gunzip_reset() -> I32 {
    let result: Outcome[Gunzip, ZlibError] = Gunzip::new()
    if result.is_err() {
        assert(false, "Gunzip::new should succeed")
        return 1
    }
    let gunzip: Gunzip = result.unwrap()
    let reset_result: Outcome[Unit, ZlibError] = gunzip.reset()
    if reset_result.is_err() {
        gunzip.destroy()
        assert(false, "reset should succeed")
        return 1
    }
    gunzip.destroy()
    return 0
}

@test
func test_gunzip_with_custom_window_bits() -> I32 {
    var options: ZlibOptions = ZlibOptions::default()
    options.window_bits = 12
    let result: Outcome[Gunzip, ZlibError] = Gunzip::with_options(options)
    if result.is_err() {
        assert(false, "Gunzip with window_bits 12 should succeed")
        return 1
    }
    let gunzip: Gunzip = result.unwrap()
    gunzip.destroy()
    return 0
}
