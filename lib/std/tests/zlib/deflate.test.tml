// Tests for deflate/inflate compression
use test
use std::zlib::{deflate, inflate, deflate_raw, inflate_raw}
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_deflate_basic() -> I32 {
    let original: Str = "Hello, World! This is some test data to compress."
    let result: Outcome[Buffer, ZlibError] = deflate(original)

    if result.is_err() {
        print("deflate failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Compressed data should be smaller or at least exist
    if compressed.len() == 0 {
        print("compressed data is empty\n")
        return 1
    }

    // Now decompress
    let inflate_result: Outcome[Str, ZlibError] = inflate(ref compressed)
    if inflate_result.is_err() {
        print("inflate failed\n")
        return 1
    }

    let decompressed: Str = inflate_result.unwrap()
    assert_eq(decompressed, original, "deflate/inflate roundtrip")

    return 0
}

@test
func test_deflate_empty_string() -> I32 {
    let original: Str = ""
    let result: Outcome[Buffer, ZlibError] = deflate(original)

    if result.is_err() {
        // Empty string compression might fail or succeed depending on implementation
        return 0
    }

    var compressed: Buffer = result.unwrap()
    let inflate_result: Outcome[Str, ZlibError] = inflate(ref compressed)

    if inflate_result.is_ok() {
        let decompressed: Str = inflate_result.unwrap()
        assert_eq(decompressed, original, "empty string roundtrip")
    }

    return 0
}

@test
func test_deflate_raw_basic() -> I32 {
    let original: Str = "Raw deflate test data without zlib header"
    let result: Outcome[Buffer, ZlibError] = deflate_raw(original)

    if result.is_err() {
        print("deflate_raw failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    if compressed.len() == 0 {
        print("raw compressed data is empty\n")
        return 1
    }

    let inflate_result: Outcome[Str, ZlibError] = inflate_raw(ref compressed)
    if inflate_result.is_err() {
        print("inflate_raw failed\n")
        return 1
    }

    let decompressed: Str = inflate_result.unwrap()
    assert_eq(decompressed, original, "deflate_raw/inflate_raw roundtrip")

    return 0
}

@test
func test_deflate_large_data() -> I32 {
    // Create a larger string with repeating pattern (compresses well)
    var data: Str = ""
    var i: I32 = 0
    loop (i < 100) {
        data = data + "This is line number " + i.to_string() + " of test data.\n"
        i = i + 1
    }

    let result: Outcome[Buffer, ZlibError] = deflate(data)
    if result.is_err() {
        print("deflate large data failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Compressed should be significantly smaller due to repetition
    let original_len: I64 = data.len()
    let compressed_len: I64 = compressed.len()

    if compressed_len >= original_len {
        print("compression did not reduce size\n")
        // This is not necessarily an error, just a warning
    }

    let inflate_result: Outcome[Str, ZlibError] = inflate(ref compressed)
    if inflate_result.is_err() {
        print("inflate large data failed\n")
        return 1
    }

    let decompressed: Str = inflate_result.unwrap()
    assert_eq(decompressed, data, "large data roundtrip")

    return 0
}
