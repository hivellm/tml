// Tests for gzip/gunzip compression
use test
use std::zlib::{gzip, gunzip, GzipHeader, read_gzip_header}
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_gzip_compress_basic() -> I32 {
    let original: Str = "Hello, World! This is some test data to compress with gzip."
    let result: Outcome[Buffer, ZlibError] = gzip(original)

    if result.is_err() {
        print("gzip failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Compressed data should exist
    if compressed.len() == 0 {
        print("compressed data is empty\n")
        return 1
    }

    // Now decompress
    let decompress_result: Outcome[Str, ZlibError] = gunzip(ref compressed)
    if decompress_result.is_err() {
        print("gunzip failed\n")
        return 1
    }

    let decompressed: Str = decompress_result.unwrap()
    assert_eq(decompressed, original, "gzip roundtrip")

    return 0
}

@test
func test_gzip_compress_empty() -> I32 {
    let original: Str = ""
    let result: Outcome[Buffer, ZlibError] = gzip(original)

    if result.is_err() {
        // Empty string compression might fail
        return 0
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = gunzip(ref compressed)

    if decompress_result.is_ok() {
        let decompressed: Str = decompress_result.unwrap()
        assert_eq(decompressed, original, "empty string roundtrip")
    }

    return 0
}

@test
func test_gzip_compress_large_data() -> I32 {
    // Create a larger string with repeating pattern
    var data: Str = ""
    var i: I32 = 0
    loop (i < 100) {
        data = data + "Gzip compression test line " + i.to_string() + " with some data.\n"
        i = i + 1
    }

    let result: Outcome[Buffer, ZlibError] = gzip(data)
    if result.is_err() {
        print("gzip large data failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Compressed should be smaller due to repetition
    let original_len: I64 = data.len()
    let compressed_len: I64 = compressed.len()

    // Gzip should compress well
    if compressed_len >= original_len {
        print("gzip compression did not reduce size\n")
    }

    let decompress_result: Outcome[Str, ZlibError] = gunzip(ref compressed)
    if decompress_result.is_err() {
        print("gunzip large data failed\n")
        return 1
    }

    let decompressed: Str = decompress_result.unwrap()
    assert_eq(decompressed, data, "large data roundtrip")

    return 0
}

@test
func test_gzip_header_read() -> I32 {
    // First compress something
    let original: Str = "Test data for header reading"
    let result: Outcome[Buffer, ZlibError] = gzip(original)

    if result.is_err() {
        print("gzip failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Try to read the gzip header
    let header_result: Outcome[GzipHeader, ZlibError] = read_gzip_header(ref compressed)

    if header_result.is_err() {
        // Header reading might not be implemented yet
        return 0
    }

    // If it works, the header should have valid magic bytes
    let header: GzipHeader = header_result.unwrap()

    return 0
}
