// Tests for Zstd streaming compression/decompression
use test
use std::zlib::{zstd_compress}
use std::zlib::{ZstdCompress, ZstdDecompress}
use std::zlib::options::ZstdOptions
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_zstd_compress_new() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        print("ZstdCompress::new failed\n")
        return 1
    }
    var comp: ZstdCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_zstd_compress_with_options() -> I32 {
    let opts: ZstdOptions = ZstdOptions::default().with_level(6)
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::with_options(opts)
    if result.is_err() {
        print("ZstdCompress::with_options failed\n")
        return 1
    }
    var comp: ZstdCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_zstd_compress_write() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        print("ZstdCompress::new failed\n")
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    let write_result: Outcome[Buffer, ZlibError] = comp.write("Test data for Zstd streaming compression")
    if write_result.is_err() {
        print("ZstdCompress::write failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_compress_flush() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        print("ZstdCompress::new failed\n")
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Some data")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Flush
    let flush_result: Outcome[Buffer, ZlibError] = comp.flush()
    if flush_result.is_err() {
        print("ZstdCompress::flush failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_compress_finish() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        print("ZstdCompress::new failed\n")
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Data to compress")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Finish compression
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_err() {
        print("ZstdCompress::finish failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_compress_reset() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    // Write and finish
    let write_result: Outcome[Buffer, ZlibError] = comp.write("First data")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_err() {
        comp.destroy()
        return 1
    }

    // Reset for new stream
    let reset_result: Outcome[Unit, ZlibError] = comp.reset()
    if reset_result.is_err() {
        print("ZstdCompress::reset failed\n")
        comp.destroy()
        return 1
    }

    // Should be able to write again
    let write_result2: Outcome[Buffer, ZlibError] = comp.write("Second data")
    if write_result2.is_err() {
        print("ZstdCompress::write after reset failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_compress_set_pledged_size() -> I32 {
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    // Set pledged size
    let pledge_result: Outcome[Unit, ZlibError] = comp.set_pledged_size(1024)
    if pledge_result.is_err() {
        print("ZstdCompress::set_pledged_size failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_compress_write_buffer() -> I32 {
    // First create a buffer with data
    let compress_result: Outcome[Buffer, ZlibError] = zstd_compress("source data")
    if compress_result.is_err() {
        return 1
    }
    var data_buffer: Buffer = compress_result.unwrap()

    // Create compressor
    let result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: ZstdCompress = result.unwrap()

    // Write buffer (recompressing already compressed data as a test)
    let write_result: Outcome[Buffer, ZlibError] = comp.write_buffer(ref data_buffer)
    if write_result.is_err() {
        print("ZstdCompress::write_buffer failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_zstd_decompress_new() -> I32 {
    let result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::new()
    if result.is_err() {
        print("ZstdDecompress::new failed\n")
        return 1
    }
    var decomp: ZstdDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_zstd_decompress_with_options() -> I32 {
    let opts: ZstdOptions = ZstdOptions::default()
    let result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::with_options(opts)
    if result.is_err() {
        print("ZstdDecompress::with_options failed\n")
        return 1
    }
    var decomp: ZstdDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_zstd_decompress_write() -> I32 {
    // First compress some data
    let original: Str = "Test data for ZstdDecompress::write"
    let compress_result: Outcome[Buffer, ZlibError] = zstd_compress(original)
    if compress_result.is_err() {
        print("zstd_compress failed\n")
        return 1
    }
    var compressed: Buffer = compress_result.unwrap()

    // Create decompressor
    let result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::new()
    if result.is_err() {
        print("ZstdDecompress::new failed\n")
        return 1
    }
    let decomp: ZstdDecompress = result.unwrap()

    // Write compressed data
    let write_result: Outcome[Buffer, ZlibError] = decomp.write(ref compressed)
    if write_result.is_err() {
        print("ZstdDecompress::write failed\n")
        decomp.destroy()
        return 1
    }

    let decompressed: Buffer = write_result.unwrap()
    if decompressed.len() > 0 {
        assert(true, "decompressed data has content")
    }

    decomp.destroy()
    return 0
}

@test
func test_zstd_decompress_reset() -> I32 {
    let result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: ZstdDecompress = result.unwrap()

    let reset_result: Outcome[Unit, ZlibError] = decomp.reset()
    if reset_result.is_err() {
        print("ZstdDecompress::reset failed\n")
        decomp.destroy()
        return 1
    }

    decomp.destroy()
    return 0
}

@test
func test_zstd_decompress_content_size() -> I32 {
    let result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: ZstdDecompress = result.unwrap()

    // Check content_size (should be Nothing initially)
    let size: Maybe[I64] = decomp.content_size()
    // Just verify the method works
    assert(true, "content_size called successfully")

    decomp.destroy()
    return 0
}

@test
func test_zstd_streaming_roundtrip() -> I32 {
    let original: Str = "Test data for Zstd streaming roundtrip compression and decompression"

    // Create compressor
    let comp_result: Outcome[ZstdCompress, ZlibError] = ZstdCompress::new()
    if comp_result.is_err() {
        print("ZstdCompress::new failed\n")
        return 1
    }
    let comp: ZstdCompress = comp_result.unwrap()

    // Write and finish
    let write_result: Outcome[Buffer, ZlibError] = comp.write(original)
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_err() {
        comp.destroy()
        return 1
    }
    var compressed: Buffer = finish_result.unwrap()
    comp.destroy()

    // Create decompressor
    let decomp_result: Outcome[ZstdDecompress, ZlibError] = ZstdDecompress::new()
    if decomp_result.is_err() {
        print("ZstdDecompress::new failed\n")
        return 1
    }
    let decomp: ZstdDecompress = decomp_result.unwrap()

    // Decompress
    let decompress_result: Outcome[Buffer, ZlibError] = decomp.write(ref compressed)
    if decompress_result.is_err() {
        decomp.destroy()
        return 1
    }

    decomp.destroy()
    return 0
}
