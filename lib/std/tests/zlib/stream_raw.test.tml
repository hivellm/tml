// Tests for zlib/stream DeflateRaw and InflateRaw classes

use test
use std::collections::{Buffer}
use std::zlib::stream::{DeflateRaw, InflateRaw}
use std::zlib::options::{ZlibOptions}
use std::zlib::error::{ZlibError}

// =============================================================================
// DeflateRaw Tests
// =============================================================================

@test
func test_deflate_raw_new() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_with_options() -> I32 {
    let options: ZlibOptions = ZlibOptions::default()
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::with_options(options)
    if result.is_err() {
        assert(false, "DeflateRaw::with_options should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_with_max_level() -> I32 {
    var options: ZlibOptions = ZlibOptions::default()
    options.level = 9
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::with_options(options)
    if result.is_err() {
        assert(false, "DeflateRaw with level 9 should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_write() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    let write_result: Outcome[Buffer, ZlibError] = deflate.write("Hello")
    if write_result.is_err() {
        deflate.destroy()
        assert(false, "write should succeed")
        return 1
    }
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_write_multiple() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    let w1: Outcome[Buffer, ZlibError] = deflate.write("Hello, ")
    let w2: Outcome[Buffer, ZlibError] = deflate.write("World!")
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_flush() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = deflate.write("Hello")
    let flush_result: Outcome[Buffer, ZlibError] = deflate.flush()
    if flush_result.is_err() {
        deflate.destroy()
        assert(false, "flush should succeed")
        return 1
    }
    let buf: Buffer = flush_result.unwrap()
    assert(buf.len() > 0, "flush should produce output")
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_finish() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = deflate.write("Hello, World!")
    let finish_result: Outcome[Buffer, ZlibError] = deflate.finish()
    if finish_result.is_err() {
        deflate.destroy()
        assert(false, "finish should succeed")
        return 1
    }
    let buf: Buffer = finish_result.unwrap()
    assert(buf.len() > 0, "finish should produce output")
    deflate.destroy()
    return 0
}

@test
func test_deflate_raw_reset() -> I32 {
    let result: Outcome[DeflateRaw, ZlibError] = DeflateRaw::new()
    if result.is_err() {
        assert(false, "DeflateRaw::new should succeed")
        return 1
    }
    let deflate: DeflateRaw = result.unwrap()
    let wr: Outcome[Buffer, ZlibError] = deflate.write("Hello")
    let reset_result: Outcome[Unit, ZlibError] = deflate.reset()
    if reset_result.is_err() {
        deflate.destroy()
        assert(false, "reset should succeed")
        return 1
    }
    deflate.destroy()
    return 0
}

// =============================================================================
// InflateRaw Tests
// =============================================================================

@test
func test_inflate_raw_new() -> I32 {
    let result: Outcome[InflateRaw, ZlibError] = InflateRaw::new()
    if result.is_err() {
        assert(false, "InflateRaw::new should succeed")
        return 1
    }
    let infl: InflateRaw = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_raw_with_options() -> I32 {
    let options: ZlibOptions = ZlibOptions::default()
    let result: Outcome[InflateRaw, ZlibError] = InflateRaw::with_options(options)
    if result.is_err() {
        assert(false, "InflateRaw::with_options should succeed")
        return 1
    }
    let infl: InflateRaw = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_raw_with_custom_window_bits() -> I32 {
    var options: ZlibOptions = ZlibOptions::default()
    options.window_bits = 12
    let result: Outcome[InflateRaw, ZlibError] = InflateRaw::with_options(options)
    if result.is_err() {
        assert(false, "InflateRaw with window_bits 12 should succeed")
        return 1
    }
    let infl: InflateRaw = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_raw_reset() -> I32 {
    let result: Outcome[InflateRaw, ZlibError] = InflateRaw::new()
    if result.is_err() {
        assert(false, "InflateRaw::new should succeed")
        return 1
    }
    let infl: InflateRaw = result.unwrap()
    let reset_result: Outcome[Unit, ZlibError] = infl.reset()
    if reset_result.is_err() {
        infl.destroy()
        assert(false, "reset should succeed")
        return 1
    }
    infl.destroy()
    return 0
}
