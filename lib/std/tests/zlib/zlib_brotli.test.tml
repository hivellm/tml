// Consolidated Brotli compression tests
// Sources: brotli.test.tml, brotli_buffer.test.tml, brotli_options.test.tml,
//          brotli_sync.test.tml, brotli_stream.test.tml
// Test count: 28 @test functions
// Renamed duplicates: test_brotli_compress_with_options_v2, test_brotli_decompress_with_options_v2

use test
use std::zlib::{brotli_compress, brotli_decompress}
use std::zlib::{brotli_compress_with_options, brotli_decompress_with_options}
use std::zlib::{brotli_compress_buffer, brotli_decompress_to_buffer}
use std::zlib::{brotli_compress_sync, brotli_compress_sync_with_options}
use std::zlib::{brotli_decompress_sync, brotli_decompress_sync_with_options}
use std::zlib::{BrotliCompress, BrotliDecompress}
use std::zlib::options::BrotliOptions
use std::zlib::error::ZlibError
use std::collections::Buffer

// ============================================================================
// From: brotli.test.tml - Basic brotli compress/decompress
// ============================================================================

@test
func test_brotli_compress_basic() -> I32 {
    let original: Str = "Hello, World! This is some test data to compress with Brotli."
    let result: Outcome[Buffer, ZlibError] = brotli_compress(original)

    if result.is_err() {
        print("brotli_compress failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Compressed data should exist
    if compressed.len() == 0 {
        print("compressed data is empty\n")
        return 1
    }

    // Now decompress
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress(ref compressed)
    if decompress_result.is_err() {
        print("brotli_decompress failed\n")
        return 1
    }

    let decompressed: Str = decompress_result.unwrap()
    assert_eq(decompressed, original, "brotli roundtrip")

    return 0
}

@test
func test_brotli_compress_empty() -> I32 {
    let original: Str = ""
    let result: Outcome[Buffer, ZlibError] = brotli_compress(original)

    if result.is_err() {
        // Empty string compression might fail
        return 0
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress(ref compressed)

    if decompress_result.is_ok() {
        let decompressed: Str = decompress_result.unwrap()
        assert_eq(decompressed, original, "empty string roundtrip")
    }

    return 0
}

// ============================================================================
// From: brotli_buffer.test.tml - Buffer operations
// ============================================================================

@test
func test_brotli_compress_buffer() -> I32 {
    // First compress to create a buffer
    let original: Str = "Test data for brotli buffer compression"
    let result: Outcome[Buffer, ZlibError] = brotli_compress(original)
    if result.is_err() {
        print("brotli_compress failed\n")
        return 1
    }

    var input_buf: Buffer = result.unwrap()

    // Now compress the already compressed buffer
    let result2: Outcome[Buffer, ZlibError] = brotli_compress_buffer(ref input_buf)
    if result2.is_err() {
        print("brotli_compress_buffer failed\n")
        return 1
    }

    var compressed: Buffer = result2.unwrap()
    if compressed.len() == 0 {
        print("brotli_compress_buffer returned empty buffer\n")
        return 1
    }

    return 0
}

@test
func test_brotli_decompress_to_buffer() -> I32 {
    let original: Str = "Data for brotli buffer decompression"
    let result: Outcome[Buffer, ZlibError] = brotli_compress(original)
    if result.is_err() {
        return 1
    }

    var compressed: Buffer = result.unwrap()

    // Decompress to buffer instead of string
    let decompress_result: Outcome[Buffer, ZlibError] = brotli_decompress_to_buffer(ref compressed)
    if decompress_result.is_err() {
        print("brotli_decompress_to_buffer failed\n")
        return 1
    }

    var decompressed_buf: Buffer = decompress_result.unwrap()
    if decompressed_buf.len() == 0 {
        print("brotli_decompress_to_buffer returned empty\n")
        return 1
    }

    return 0
}

// ============================================================================
// From: brotli_options.test.tml - Options-based compression
// ============================================================================

@test
func test_brotli_compress_with_options() -> I32 {
    let original: Str = "Test data for brotli compression with options"
    let options: BrotliOptions = BrotliOptions::default().with_quality(6)
    let result: Outcome[Buffer, ZlibError] = brotli_compress_with_options(original, options)

    if result.is_err() {
        print("brotli_compress_with_options failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress(ref compressed)
    if decompress_result.is_err() {
        print("brotli_decompress failed\n")
        return 1
    }

    let decompressed: Str = decompress_result.unwrap()
    assert_eq(decompressed, original, "brotli with options roundtrip")

    return 0
}

@test
func test_brotli_decompress_with_options() -> I32 {
    let original: Str = "Test data for brotli decompression with options"
    let result: Outcome[Buffer, ZlibError] = brotli_compress(original)
    if result.is_err() {
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let options: BrotliOptions = BrotliOptions::default()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_with_options(ref compressed, options)
    if decompress_result.is_err() {
        print("brotli_decompress_with_options failed\n")
        return 1
    }

    let decompressed: Str = decompress_result.unwrap()
    assert_eq(decompressed, original, "brotli decompress with options")

    return 0
}

// ============================================================================
// From: brotli_sync.test.tml - Sync operations
// ============================================================================

@test
func test_brotli_compress_sync() -> I32 {
    let original: Str = "Test data for brotli_compress_sync"
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync(original)

    if result.is_err() {
        print("brotli_compress_sync failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    if compressed.len() == 0 {
        print("brotli_compress_sync returned empty buffer\n")
        return 1
    }

    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_sync(ref compressed)
    if decompress_result.is_err() {
        print("brotli_decompress_sync failed\n")
        return 1
    }

    assert_eq(decompress_result.unwrap(), original, "brotli sync roundtrip")
    return 0
}

@test
func test_brotli_compress_sync_with_options() -> I32 {
    let original: Str = "Test data for brotli_compress_sync_with_options"
    let opts: BrotliOptions = BrotliOptions::default().with_quality(6)
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync_with_options(original, opts)

    if result.is_err() {
        print("brotli_compress_sync_with_options failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    if compressed.len() == 0 {
        print("brotli_compress_sync_with_options returned empty buffer\n")
        return 1
    }

    return 0
}

@test
func test_brotli_decompress_sync_with_options() -> I32 {
    let original: Str = "Test data for brotli_decompress_sync_with_options"
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync(original)
    if result.is_err() {
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let opts: BrotliOptions = BrotliOptions::default()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_sync_with_options(ref compressed, opts)
    if decompress_result.is_err() {
        print("brotli_decompress_sync_with_options failed\n")
        return 1
    }

    assert_eq(decompress_result.unwrap(), original, "brotli sync with options roundtrip")
    return 0
}

@test
func test_brotli_compress_sync_text_mode() -> I32 {
    let original: Str = "This is text content for Brotli text mode compression test."
    let opts: BrotliOptions = BrotliOptions::text()
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync_with_options(original, opts)

    if result.is_err() {
        print("brotli text mode compression failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_sync(ref compressed)
    if decompress_result.is_err() {
        print("brotli text mode decompression failed\n")
        return 1
    }

    assert_eq(decompress_result.unwrap(), original, "brotli text mode roundtrip")
    return 0
}

@test
func test_brotli_compress_sync_fast() -> I32 {
    let original: Str = "Fast compression test data for Brotli."
    let opts: BrotliOptions = BrotliOptions::fast()
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync_with_options(original, opts)

    if result.is_err() {
        print("brotli fast compression failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_sync(ref compressed)
    if decompress_result.is_err() {
        print("brotli fast decompression failed\n")
        return 1
    }

    assert_eq(decompress_result.unwrap(), original, "brotli fast roundtrip")
    return 0
}

@test
func test_brotli_compress_sync_best() -> I32 {
    let original: Str = "Best compression test data for Brotli - should achieve highest compression ratio."
    let opts: BrotliOptions = BrotliOptions::best()
    let result: Outcome[Buffer, ZlibError] = brotli_compress_sync_with_options(original, opts)

    if result.is_err() {
        print("brotli best compression failed\n")
        return 1
    }

    var compressed: Buffer = result.unwrap()
    let decompress_result: Outcome[Str, ZlibError] = brotli_decompress_sync(ref compressed)
    if decompress_result.is_err() {
        print("brotli best decompression failed\n")
        return 1
    }

    assert_eq(decompress_result.unwrap(), original, "brotli best roundtrip")
    return 0
}

// ============================================================================
// From: brotli_stream.test.tml - BrotliCompress/BrotliDecompress stream classes
// Renamed: test_brotli_compress_with_options -> test_brotli_compress_with_options_v2
// Renamed: test_brotli_decompress_with_options -> test_brotli_decompress_with_options_v2
// ============================================================================

@test
func test_brotli_compress_new() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    var comp: BrotliCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_brotli_compress_with_options_v2() -> I32 {
    let opts: BrotliOptions = BrotliOptions::default().with_quality(6)
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::with_options(opts)
    if result.is_err() {
        print("BrotliCompress::with_options failed\n")
        return 1
    }
    var comp: BrotliCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_brotli_compress_write() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    let write_result: Outcome[Buffer, ZlibError] = comp.write("Test data for streaming compression")
    if write_result.is_err() {
        print("BrotliCompress::write failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_flush() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Some data")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Flush
    let flush_result: Outcome[Buffer, ZlibError] = comp.flush()
    if flush_result.is_err() {
        print("BrotliCompress::flush failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_finish() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Data to compress")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Finish compression
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_err() {
        print("BrotliCompress::finish failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_is_finished() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Initially not finished
    let initial: Bool = comp.is_finished()
    // After finish, should be finished
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_ok() {
        let after: Bool = comp.is_finished()
        assert_eq(after, true, "should be finished after finish()")
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_has_more_output() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Check has_more_output method
    let has: Bool = comp.has_more_output()
    // Just verify the method doesn't crash
    assert(true, "has_more_output called successfully")

    comp.destroy()
    return 0
}

@test
func test_brotli_decompress_new() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        print("BrotliDecompress::new failed\n")
        return 1
    }
    var decomp: BrotliDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_with_options_v2() -> I32 {
    let opts: BrotliOptions = BrotliOptions::default()
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::with_options(opts)
    if result.is_err() {
        print("BrotliDecompress::with_options failed\n")
        return 1
    }
    var decomp: BrotliDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_write() -> I32 {
    // First compress some data
    let original: Str = "Test data for BrotliDecompress::write"
    let compress_result: Outcome[Buffer, ZlibError] = brotli_compress(original)
    if compress_result.is_err() {
        print("brotli_compress failed\n")
        return 1
    }
    var compressed: Buffer = compress_result.unwrap()

    // Create decompressor
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        print("BrotliDecompress::new failed\n")
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    // Write compressed data
    let write_result: Outcome[Buffer, ZlibError] = decomp.write(ref compressed)
    if write_result.is_err() {
        print("BrotliDecompress::write failed\n")
        decomp.destroy()
        return 1
    }

    let decompressed: Buffer = write_result.unwrap()
    if decompressed.len() > 0 {
        assert(true, "decompressed data has content")
    }

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_is_finished() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let finished: Bool = decomp.is_finished()
    assert(true, "is_finished called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_needs_more_input() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let needs: Bool = decomp.needs_more_input()
    assert(true, "needs_more_input called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_has_more_output() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let has: Bool = decomp.has_more_output()
    assert(true, "has_more_output called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_error_code() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    // Should be 0 initially
    let code: I32 = decomp.error_code()
    assert_eq(code, 0, "error code should be 0 initially")

    decomp.destroy()
    return 0
}

@test
func test_brotli_compress_write_buffer() -> I32 {
    // First create a buffer with data
    let compress_result: Outcome[Buffer, ZlibError] = brotli_compress("source data")
    if compress_result.is_err() {
        return 1
    }
    var data_buffer: Buffer = compress_result.unwrap()

    // Create compressor
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write buffer (recompressing already compressed data as a test)
    let write_result: Outcome[Buffer, ZlibError] = comp.write_buffer(ref data_buffer)
    if write_result.is_err() {
        print("BrotliCompress::write_buffer failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}
