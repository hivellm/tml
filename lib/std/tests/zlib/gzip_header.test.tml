// Tests for GzipHeader - verifies read_gzip_header FFI
use test
use std::zlib::{gzip, GzipHeader, read_gzip_header}
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_gzip_header_new() -> I32 {
    let header: GzipHeader = GzipHeader::new()

    // Default header should have unknown OS (255)
    assert_eq(header.os, 255, "default header os")
    assert_eq(header.text, false, "default header text flag")
    assert_eq(header.hcrc, false, "default header hcrc flag")

    return 0
}

@test
func test_gzip_header_with_time() -> I32 {
    let header: GzipHeader = GzipHeader::new()
    let header2: GzipHeader = header.with_time(1234567890)

    assert_eq(header2.time, 1234567890, "header time")

    return 0
}

// Note: Tests for with_name and with_comment require accessing Maybe[Str] fields
// which triggers a compiler codegen bug. These tests verify the functions execute
// without crashing but cannot verify the field values directly.

@test
func test_gzip_header_with_name() -> I32 {
    let header: GzipHeader = GzipHeader::new()
    // with_name should return a new header without crashing
    let header2: GzipHeader = header.with_name("test.txt")
    // Verify other fields are preserved
    assert_eq(header2.os, 255, "os should be preserved")
    assert_eq(header2.text, false, "text should be preserved")

    return 0
}

@test
func test_gzip_header_with_comment() -> I32 {
    let header: GzipHeader = GzipHeader::new()
    // with_comment should return a new header without crashing
    let header2: GzipHeader = header.with_comment("Test comment")
    // Verify other fields are preserved
    assert_eq(header2.os, 255, "os should be preserved")
    assert_eq(header2.text, false, "text should be preserved")

    return 0
}

@test
func test_gzip_header_with_text() -> I32 {
    let header: GzipHeader = GzipHeader::new()
    let header2: GzipHeader = header.with_text()

    assert_eq(header2.text, true, "header text flag")

    return 0
}

@test
func test_gzip_header_chaining() -> I32 {
    // Chaining should work without crashing
    let header: GzipHeader = GzipHeader::new()
        .with_name("data.txt")
        .with_comment("compressed file")
        .with_time(1000000000)
        .with_text()

    // Verify non-Maybe fields are set correctly
    assert_eq(header.time, 1000000000, "chained time")
    assert_eq(header.text, true, "chained text flag")
    assert_eq(header.os, 255, "chained os preserved")

    return 0
}

@test
func test_read_gzip_header_basic() -> I32 {
    // Compress some data to get a valid gzip buffer
    let data: Str = "Hello, World!"
    let compressed: Outcome[Buffer, ZlibError] = gzip(data)
    if compressed.is_err() {
        return 1
    }
    var buf: Buffer = compressed.unwrap()

    // Read the header from the compressed data
    let header_result: Outcome[GzipHeader, ZlibError] = read_gzip_header(buf)
    if header_result.is_err() {
        buf.destroy()
        return 2
    }
    let header: GzipHeader = header_result.unwrap()

    // Verify basic header fields
    // OS code should be valid (0-255)
    assert_true(header.os >= 0 and header.os <= 255, "header os valid range")

    buf.destroy()
    return 0
}

@test
func test_read_gzip_header_fields() -> I32 {
    // Compress with gzip to get valid header
    let data: Str = "Test data for header reading"
    let compressed: Outcome[Buffer, ZlibError] = gzip(data)
    if compressed.is_err() {
        return 1
    }
    var buf: Buffer = compressed.unwrap()

    let header_result: Outcome[GzipHeader, ZlibError] = read_gzip_header(buf)
    if header_result.is_err() {
        buf.destroy()
        return 2
    }
    let header: GzipHeader = header_result.unwrap()

    // Default gzip doesn't set name/comment, so they should be Nothing
    assert_eq(header.text, false, "default gzip text flag is false")
    assert_eq(header.hcrc, false, "default gzip hcrc is false")

    buf.destroy()
    return 0
}
