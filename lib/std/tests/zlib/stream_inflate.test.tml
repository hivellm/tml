// Tests for zlib/stream Inflate class

use test
use std::collections::{Buffer}
use std::zlib::{deflate}
use std::zlib::stream::{Inflate}
use std::zlib::options::{ZlibOptions}
use std::zlib::error::{ZlibError}

@test
func test_inflate_new() -> I32 {
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_with_options() -> I32 {
    let options: ZlibOptions = ZlibOptions::default()
    let result: Outcome[Inflate, ZlibError] = Inflate::with_options(options)
    if result.is_err() {
        assert(false, "Inflate::with_options should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_with_custom_window_bits() -> I32 {
    var options: ZlibOptions = ZlibOptions::default()
    options.window_bits = 12
    let result: Outcome[Inflate, ZlibError] = Inflate::with_options(options)
    if result.is_err() {
        assert(false, "Inflate with window_bits 12 should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    infl.destroy()
    return 0
}

@test
func test_inflate_reset() -> I32 {
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    let reset_result: Outcome[Unit, ZlibError] = infl.reset()
    if reset_result.is_err() {
        infl.destroy()
        assert(false, "reset should succeed")
        return 1
    }
    infl.destroy()
    return 0
}

@test
func test_inflate_is_finished_false_initially() -> I32 {
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    let finished: Bool = infl.is_finished()
    assert(not finished, "should not be finished initially")
    infl.destroy()
    return 0
}

@test
func test_inflate_bytes_written_initially_zero() -> I32 {
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()
    let bytes: I64 = infl.bytes_written()
    assert_eq(bytes, 0, "should be 0 initially")
    infl.destroy()
    return 0
}

@test
func test_inflate_write() -> I32 {
    // First compress some data
    let original: Str = "Test data for Inflate::write"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        print("deflate failed\n")
        return 1
    }
    var compressed: Buffer = compress_result.unwrap()

    // Create Inflate stream
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()

    // Write compressed data
    let write_result: Outcome[Buffer, ZlibError] = infl.write(ref compressed)
    if write_result.is_err() {
        print("Inflate::write failed\n")
        infl.destroy()
        return 1
    }

    let decompressed: Buffer = write_result.unwrap()
    if decompressed.len() > 0 {
        // Good, we got some decompressed data
        assert(true, "write returned data")
    }

    infl.destroy()
    return 0
}

@test
func test_inflate_flush() -> I32 {
    // First compress some data
    let original: Str = "Test data for Inflate::flush"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        print("deflate failed\n")
        return 1
    }
    var compressed: Buffer = compress_result.unwrap()

    // Create Inflate stream
    let result: Outcome[Inflate, ZlibError] = Inflate::new()
    if result.is_err() {
        assert(false, "Inflate::new should succeed")
        return 1
    }
    let infl: Inflate = result.unwrap()

    // Write compressed data first
    let write_result: Outcome[Buffer, ZlibError] = infl.write(ref compressed)
    if write_result.is_err() {
        infl.destroy()
        return 1
    }

    // Flush
    let flush_result: Outcome[Buffer, ZlibError] = infl.flush()
    if flush_result.is_err() {
        print("Inflate::flush failed\n")
        infl.destroy()
        return 1
    }

    // Flush should succeed even if it returns empty buffer
    assert(true, "flush succeeded")

    infl.destroy()
    return 0
}
