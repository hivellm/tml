// Tests for Brotli streaming compression/decompression
use test
use std::zlib::{brotli_compress}
use std::zlib::{BrotliCompress, BrotliDecompress}
use std::zlib::options::BrotliOptions
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_brotli_compress_new() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    var comp: BrotliCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_brotli_compress_with_options() -> I32 {
    let opts: BrotliOptions = BrotliOptions::default().with_quality(6)
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::with_options(opts)
    if result.is_err() {
        print("BrotliCompress::with_options failed\n")
        return 1
    }
    var comp: BrotliCompress = result.unwrap()
    comp.destroy()
    return 0
}

@test
func test_brotli_compress_write() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    let write_result: Outcome[Buffer, ZlibError] = comp.write("Test data for streaming compression")
    if write_result.is_err() {
        print("BrotliCompress::write failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_flush() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Some data")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Flush
    let flush_result: Outcome[Buffer, ZlibError] = comp.flush()
    if flush_result.is_err() {
        print("BrotliCompress::flush failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_finish() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        print("BrotliCompress::new failed\n")
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write some data first
    let write_result: Outcome[Buffer, ZlibError] = comp.write("Data to compress")
    if write_result.is_err() {
        comp.destroy()
        return 1
    }

    // Finish compression
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_err() {
        print("BrotliCompress::finish failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_is_finished() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Initially not finished
    let initial: Bool = comp.is_finished()
    // After finish, should be finished
    let finish_result: Outcome[Buffer, ZlibError] = comp.finish()
    if finish_result.is_ok() {
        let after: Bool = comp.is_finished()
        assert_eq(after, true, "should be finished after finish()")
    }

    comp.destroy()
    return 0
}

@test
func test_brotli_compress_has_more_output() -> I32 {
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Check has_more_output method
    let has: Bool = comp.has_more_output()
    // Just verify the method doesn't crash
    assert(true, "has_more_output called successfully")

    comp.destroy()
    return 0
}

@test
func test_brotli_decompress_new() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        print("BrotliDecompress::new failed\n")
        return 1
    }
    var decomp: BrotliDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_with_options() -> I32 {
    let opts: BrotliOptions = BrotliOptions::default()
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::with_options(opts)
    if result.is_err() {
        print("BrotliDecompress::with_options failed\n")
        return 1
    }
    var decomp: BrotliDecompress = result.unwrap()
    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_write() -> I32 {
    // First compress some data
    let original: Str = "Test data for BrotliDecompress::write"
    let compress_result: Outcome[Buffer, ZlibError] = brotli_compress(original)
    if compress_result.is_err() {
        print("brotli_compress failed\n")
        return 1
    }
    var compressed: Buffer = compress_result.unwrap()

    // Create decompressor
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        print("BrotliDecompress::new failed\n")
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    // Write compressed data
    let write_result: Outcome[Buffer, ZlibError] = decomp.write(ref compressed)
    if write_result.is_err() {
        print("BrotliDecompress::write failed\n")
        decomp.destroy()
        return 1
    }

    let decompressed: Buffer = write_result.unwrap()
    if decompressed.len() > 0 {
        assert(true, "decompressed data has content")
    }

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_is_finished() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let finished: Bool = decomp.is_finished()
    assert(true, "is_finished called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_needs_more_input() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let needs: Bool = decomp.needs_more_input()
    assert(true, "needs_more_input called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_has_more_output() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    let has: Bool = decomp.has_more_output()
    assert(true, "has_more_output called successfully")

    decomp.destroy()
    return 0
}

@test
func test_brotli_decompress_error_code() -> I32 {
    let result: Outcome[BrotliDecompress, ZlibError] = BrotliDecompress::new()
    if result.is_err() {
        return 1
    }
    let decomp: BrotliDecompress = result.unwrap()

    // Should be 0 initially
    let code: I32 = decomp.error_code()
    assert_eq(code, 0, "error code should be 0 initially")

    decomp.destroy()
    return 0
}

@test
func test_brotli_compress_write_buffer() -> I32 {
    // First create a buffer with data
    let compress_result: Outcome[Buffer, ZlibError] = brotli_compress("source data")
    if compress_result.is_err() {
        return 1
    }
    var data_buffer: Buffer = compress_result.unwrap()

    // Create compressor
    let result: Outcome[BrotliCompress, ZlibError] = BrotliCompress::new()
    if result.is_err() {
        return 1
    }
    let comp: BrotliCompress = result.unwrap()

    // Write buffer (recompressing already compressed data as a test)
    let write_result: Outcome[Buffer, ZlibError] = comp.write_buffer(ref data_buffer)
    if write_result.is_err() {
        print("BrotliCompress::write_buffer failed\n")
        comp.destroy()
        return 1
    }

    comp.destroy()
    return 0
}
