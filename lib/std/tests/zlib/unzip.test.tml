// Tests for unzip (auto-detect) operations
use test
use std::zlib::{deflate, unzip, unzip_with_options, unzip_to_buffer, unzip_to_buffer_with_options}
use std::zlib::{unzip_sync, unzip_sync_with_options}
use std::zlib::options::ZlibOptions
use std::zlib::error::ZlibError
use std::collections::Buffer

@test
func test_unzip_zlib_format() -> I32 {
    let original: Str = "Test data for unzip auto-detection (zlib format)"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let result: Outcome[Str, ZlibError] = unzip(ref compressed)
    if result.is_err() {
        print("unzip failed on zlib format\n")
        return 1
    }

    assert_eq(result.unwrap(), original, "unzip zlib roundtrip")
    return 0
}

@test
func test_unzip_with_options() -> I32 {
    let original: Str = "Test data for unzip_with_options"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let opts: ZlibOptions = ZlibOptions::auto_detect()
    let result: Outcome[Str, ZlibError] = unzip_with_options(ref compressed, opts)
    if result.is_err() {
        print("unzip_with_options failed\n")
        return 1
    }

    assert_eq(result.unwrap(), original, "unzip with options roundtrip")
    return 0
}

@test
func test_unzip_to_buffer() -> I32 {
    let original: Str = "Test data for unzip_to_buffer"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let result: Outcome[Buffer, ZlibError] = unzip_to_buffer(ref compressed)
    if result.is_err() {
        print("unzip_to_buffer failed\n")
        return 1
    }

    if result.unwrap().len() == 0 {
        print("unzip_to_buffer returned empty\n")
        return 1
    }

    return 0
}

@test
func test_unzip_to_buffer_with_options() -> I32 {
    let original: Str = "Test data for unzip_to_buffer_with_options"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let opts: ZlibOptions = ZlibOptions::auto_detect()
    let result: Outcome[Buffer, ZlibError] = unzip_to_buffer_with_options(ref compressed, opts)
    if result.is_err() {
        print("unzip_to_buffer_with_options failed\n")
        return 1
    }

    return 0
}

@test
func test_unzip_sync() -> I32 {
    let original: Str = "Test data for unzip_sync"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let result: Outcome[Str, ZlibError] = unzip_sync(ref compressed)
    if result.is_err() {
        print("unzip_sync failed\n")
        return 1
    }

    assert_eq(result.unwrap(), original, "unzip sync roundtrip")
    return 0
}

@test
func test_unzip_sync_with_options() -> I32 {
    let original: Str = "Test data for unzip_sync_with_options"
    let compress_result: Outcome[Buffer, ZlibError] = deflate(original)
    if compress_result.is_err() {
        return 1
    }

    var compressed: Buffer = compress_result.unwrap()
    let opts: ZlibOptions = ZlibOptions::auto_detect()
    let result: Outcome[Str, ZlibError] = unzip_sync_with_options(ref compressed, opts)
    if result.is_err() {
        print("unzip_sync_with_options failed\n")
        return 1
    }

    assert_eq(result.unwrap(), original, "unzip sync with opts roundtrip")
    return 0
}
