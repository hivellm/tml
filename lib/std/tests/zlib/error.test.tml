// Tests for zlib/error module
// Tests ZlibErrorKind and ZlibError types

use test
use std::zlib::error::{ZlibErrorKind, ZlibError, zlib_error_kind_from_code}

// =============================================================================
// ZlibErrorKind::to_message Tests
// =============================================================================

@test
func test_error_kind_ok_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::Ok
    assert_eq(kind.to_message(), "no error", "Ok should have correct message")
    return 0
}

@test
func test_error_kind_stream_error_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::StreamError
    assert(kind.to_message().len() > 0, "StreamError should have message")
    return 0
}

@test
func test_error_kind_data_error_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::DataError
    assert(kind.to_message().len() > 0, "DataError should have message")
    return 0
}

@test
func test_error_kind_memory_error_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::MemoryError
    assert(kind.to_message().len() > 0, "MemoryError should have message")
    return 0
}

@test
func test_error_kind_buffer_error_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::BufferError
    assert(kind.to_message().len() > 0, "BufferError should have message")
    return 0
}

@test
func test_error_kind_version_error_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::VersionError
    assert(kind.to_message().len() > 0, "VersionError should have message")
    return 0
}

@test
func test_error_kind_need_dict_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::NeedDict
    assert(kind.to_message().len() > 0, "NeedDict should have message")
    return 0
}

@test
func test_error_kind_invalid_level_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidLevel
    assert(kind.to_message().len() > 0, "InvalidLevel should have message")
    return 0
}

@test
func test_error_kind_invalid_window_bits_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidWindowBits
    assert(kind.to_message().len() > 0, "InvalidWindowBits should have message")
    return 0
}

@test
func test_error_kind_invalid_mem_level_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidMemLevel
    assert(kind.to_message().len() > 0, "InvalidMemLevel should have message")
    return 0
}

@test
func test_error_kind_invalid_strategy_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidStrategy
    assert(kind.to_message().len() > 0, "InvalidStrategy should have message")
    return 0
}

@test
func test_error_kind_invalid_flush_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidFlush
    assert(kind.to_message().len() > 0, "InvalidFlush should have message")
    return 0
}

@test
func test_error_kind_input_too_large_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InputTooLarge
    assert(kind.to_message().len() > 0, "InputTooLarge should have message")
    return 0
}

@test
func test_error_kind_output_too_large_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::OutputTooLarge
    assert(kind.to_message().len() > 0, "OutputTooLarge should have message")
    return 0
}

@test
func test_error_kind_cancelled_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::Cancelled
    assert(kind.to_message().len() > 0, "Cancelled should have message")
    return 0
}

@test
func test_error_kind_invalid_parameter_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::InvalidParameter
    assert(kind.to_message().len() > 0, "InvalidParameter should have message")
    return 0
}

@test
func test_error_kind_unknown_message() -> I32 {
    let kind: ZlibErrorKind = ZlibErrorKind::Unknown
    assert(kind.to_message().len() > 0, "Unknown should have message")
    return 0
}

// =============================================================================
// zlib_error_kind_from_code Tests
// =============================================================================

@test
func test_error_kind_from_code_ok() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(0)
    when kind {
        ZlibErrorKind::Ok => return 0,
        _ => {
            assert(false, "code 0 should be Ok")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_stream_error() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-2)
    when kind {
        ZlibErrorKind::StreamError => return 0,
        _ => {
            assert(false, "code -2 should be StreamError")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_data_error() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-3)
    when kind {
        ZlibErrorKind::DataError => return 0,
        _ => {
            assert(false, "code -3 should be DataError")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_memory_error() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-4)
    when kind {
        ZlibErrorKind::MemoryError => return 0,
        _ => {
            assert(false, "code -4 should be MemoryError")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_buffer_error() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-5)
    when kind {
        ZlibErrorKind::BufferError => return 0,
        _ => {
            assert(false, "code -5 should be BufferError")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_version_error() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-6)
    when kind {
        ZlibErrorKind::VersionError => return 0,
        _ => {
            assert(false, "code -6 should be VersionError")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_need_dict() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(2)
    when kind {
        ZlibErrorKind::NeedDict => return 0,
        _ => {
            assert(false, "code 2 should be NeedDict")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_unknown() -> I32 {
    let kind: ZlibErrorKind = zlib_error_kind_from_code(-1)
    when kind {
        ZlibErrorKind::Unknown => return 0,
        _ => {
            assert(false, "code -1 should be Unknown")
            return 1
        }
    }
}

@test
func test_error_kind_from_code_invalid_code() -> I32 {
    // Any unrecognized code should map to Unknown
    let kind: ZlibErrorKind = zlib_error_kind_from_code(999)
    when kind {
        ZlibErrorKind::Unknown => return 0,
        _ => {
            assert(false, "unrecognized code should be Unknown")
            return 1
        }
    }
}

// =============================================================================
// ZlibError::new Tests
// =============================================================================

@test
func test_zlib_error_new_ok() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::Ok)
    assert(err.is_ok(), "new with Ok kind should be ok")
    assert_eq(err.code, 0, "default code should be 0")
    return 0
}

@test
func test_zlib_error_new_data_error() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::DataError)
    assert(not err.is_ok(), "DataError should not be ok")
    assert(err.message.len() > 0, "should have message")
    return 0
}

@test
func test_zlib_error_new_stream_error() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::StreamError)
    assert(not err.is_ok(), "StreamError should not be ok")
    return 0
}

// =============================================================================
// ZlibError::with_code Tests
// =============================================================================

@test
func test_zlib_error_with_code() -> I32 {
    let err: ZlibError = ZlibError::with_code(ZlibErrorKind::DataError, -3)
    assert_eq(err.code, -3, "code should be set")
    assert(not err.is_ok(), "should not be ok")
    return 0
}

@test
func test_zlib_error_with_code_zero() -> I32 {
    let err: ZlibError = ZlibError::with_code(ZlibErrorKind::Ok, 0)
    assert(err.is_ok(), "should be ok")
    assert_eq(err.code, 0, "code should be 0")
    return 0
}

@test
func test_zlib_error_with_code_negative() -> I32 {
    let err: ZlibError = ZlibError::with_code(ZlibErrorKind::MemoryError, -4)
    assert_eq(err.code, -4, "code should be -4")
    return 0
}

// =============================================================================
// ZlibError::with_message Tests
// =============================================================================

@test
func test_zlib_error_with_message() -> I32 {
    let err: ZlibError = ZlibError::with_message(ZlibErrorKind::DataError, "custom message")
    assert_eq(err.message, "custom message", "message should be custom")
    assert_eq(err.code, 0, "code should be 0")
    return 0
}

@test
func test_zlib_error_with_message_empty() -> I32 {
    let err: ZlibError = ZlibError::with_message(ZlibErrorKind::Unknown, "")
    assert_eq(err.message, "", "message should be empty")
    return 0
}

@test
func test_zlib_error_with_message_long() -> I32 {
    let msg: Str = "This is a very long error message that describes the error in detail"
    let err: ZlibError = ZlibError::with_message(ZlibErrorKind::StreamError, msg)
    assert_eq(err.message, msg, "message should match")
    return 0
}

// =============================================================================
// ZlibError::from_code Tests
// =============================================================================

@test
func test_zlib_error_from_code_ok() -> I32 {
    let err: ZlibError = ZlibError::from_code(0)
    assert(err.is_ok(), "code 0 should create ok error")
    assert_eq(err.code, 0, "code should be 0")
    return 0
}

@test
func test_zlib_error_from_code_data_error() -> I32 {
    let err: ZlibError = ZlibError::from_code(-3)
    assert(not err.is_ok(), "code -3 should not be ok")
    assert_eq(err.code, -3, "code should be -3")
    return 0
}

@test
func test_zlib_error_from_code_stream_error() -> I32 {
    let err: ZlibError = ZlibError::from_code(-2)
    assert_eq(err.code, -2, "code should be -2")
    return 0
}

@test
func test_zlib_error_from_code_unknown() -> I32 {
    let err: ZlibError = ZlibError::from_code(-100)
    assert_eq(err.code, -100, "code should be preserved")
    return 0
}

// =============================================================================
// ZlibError::is_ok Tests
// =============================================================================

@test
func test_zlib_error_is_ok_true() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::Ok)
    assert(err.is_ok(), "Ok kind should be ok")
    return 0
}

@test
func test_zlib_error_is_ok_false_data_error() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::DataError)
    assert(not err.is_ok(), "DataError should not be ok")
    return 0
}

@test
func test_zlib_error_is_ok_false_buffer_error() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::BufferError)
    assert(not err.is_ok(), "BufferError should not be ok")
    return 0
}

@test
func test_zlib_error_is_ok_false_memory_error() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::MemoryError)
    assert(not err.is_ok(), "MemoryError should not be ok")
    return 0
}

// =============================================================================
// ZlibError::to_string Tests
// =============================================================================

@test
func test_zlib_error_to_string_without_code() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::DataError)
    let s: Str = err.to_string()
    assert(s.len() > 0, "to_string should return non-empty")
    return 0
}

@test
func test_zlib_error_to_string_with_code() -> I32 {
    let err: ZlibError = ZlibError::with_code(ZlibErrorKind::DataError, -3)
    let s: Str = err.to_string()
    assert(s.len() > 0, "to_string should return non-empty")
    // Should contain the code
    assert(s.contains("code"), "should include code in message")
    return 0
}

@test
func test_zlib_error_to_string_ok() -> I32 {
    let err: ZlibError = ZlibError::new(ZlibErrorKind::Ok)
    let s: Str = err.to_string()
    assert_eq(s, "no error", "Ok should say no error")
    return 0
}

@test
func test_zlib_error_to_string_custom_message() -> I32 {
    let err: ZlibError = ZlibError::with_message(ZlibErrorKind::Unknown, "custom error")
    let s: Str = err.to_string()
    assert_eq(s, "custom error", "should use custom message")
    return 0
}

@test
func test_zlib_error_to_string_custom_message_with_code() -> I32 {
    let mut err: ZlibError = ZlibError::with_message(ZlibErrorKind::Unknown, "custom error")
    err.code = 42
    let s: Str = err.to_string()
    assert(s.contains("custom error"), "should include custom message")
    assert(s.contains("42"), "should include code")
    return 0
}
