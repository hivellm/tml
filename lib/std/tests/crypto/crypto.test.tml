//! Consolidated crypto tests - File 1 of 3
//!
//! Contains 49 @test functions:
//!   - Hash functions (SHA-256, SHA-512, SHA-384, SHA-1, MD5, SHA-512/256)
//!   - Hash streaming API and digest encoding
//!   - HashAlgorithm name methods
//!   - CipherAlgorithm enum (name, key_size, iv_size)
//!   - Cipher/Decipher error handling and padding
//!   - Cipher encrypt_string/decrypt_string helpers
//!   - HMAC (SHA-256, SHA-512, SHA-384, SHA-1, MD5, streaming, determinism)
//!   - HMAC update_bytes
//!   - Placeholder tests (KDF, constants, key management)
//!
//! Sources: hash.test.tml, hash_extra.test.tml, cipher.test.tml,
//!          cipher_enum.test.tml, cipher_helpers.test.tml, hmac.test.tml,
//!          hmac_update_bytes.test.tml, kdf.test.tml, constants.test.tml,
//!          key.test.tml

use std::crypto::hash::{sha256, sha512, sha384, sha1, md5, sha512_256}
use std::crypto::hash::{Hash, HashAlgorithm, Digest}
use std::crypto::cipher::{CipherAlgorithm, Cipher, Decipher, encrypt_string, decrypt_string}
use std::crypto::hmac::{hmac_sha256, hmac_sha512, hmac_sha384, hmac_sha1, hmac_md5}
use std::crypto::hmac::{Hmac, HmacDigest}
use std::crypto::random::random_bytes
use std::collections::Buffer
use std::collections::buffer::Buffer
use test::{assert, assert_eq}
use test

// ============================================================================
// SHA-256 Tests (from hash.test.tml)
// ============================================================================

@test
func test_sha256_empty_string() -> I32 {
    let mut digest: Digest = sha256("")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", "sha256 empty")
    digest.destroy()
    return 0
}

@test
func test_sha256_hello_world() -> I32 {
    let mut digest: Digest = sha256("hello world")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9", "sha256 hello world")
    digest.destroy()
    return 0
}

@test
func test_sha256_hello() -> I32 {
    let mut digest: Digest = sha256("hello")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824", "sha256 hello")
    digest.destroy()
    return 0
}

// ============================================================================
// SHA-512 Tests (from hash.test.tml)
// ============================================================================

@test
func test_sha512_empty_string() -> I32 {
    let mut digest: Digest = sha512("")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e", "sha512 empty")
    digest.destroy()
    return 0
}

@test
func test_sha512_hello() -> I32 {
    let mut digest: Digest = sha512("hello")
    let hex: Str = digest.to_hex()
    assert(hex.len() == (128 as I64), "sha512 produces 128 hex chars")
    digest.destroy()
    return 0
}

// ============================================================================
// SHA-384 Tests (from hash.test.tml)
// ============================================================================

@test
func test_sha384_empty_string() -> I32 {
    let mut digest: Digest = sha384("")
    let hex: Str = digest.to_hex()
    assert(hex.len() == (96 as I64), "sha384 produces 96 hex chars")
    digest.destroy()
    return 0
}

// ============================================================================
// SHA-1 Tests (legacy, not for security) (from hash.test.tml)
// ============================================================================

@test
func test_sha1_empty_string() -> I32 {
    let mut digest: Digest = sha1("")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "da39a3ee5e6b4b0d3255bfef95601890afd80709", "sha1 empty")
    digest.destroy()
    return 0
}

@test
func test_sha1_hello() -> I32 {
    let mut digest: Digest = sha1("hello")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d", "sha1 hello")
    digest.destroy()
    return 0
}

// ============================================================================
// MD5 Tests (legacy, not for security) (from hash.test.tml)
// ============================================================================

@test
func test_md5_empty_string() -> I32 {
    let mut digest: Digest = md5("")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "d41d8cd98f00b204e9800998ecf8427e", "md5 empty")
    digest.destroy()
    return 0
}

@test
func test_md5_hello() -> I32 {
    let mut digest: Digest = md5("hello")
    let hex: Str = digest.to_hex()
    assert_eq(hex, "5d41402abc4b2a76b9719d911017c592", "md5 hello")
    digest.destroy()
    return 0
}

// ============================================================================
// SHA-512/256 Tests (from hash.test.tml)
// ============================================================================

@test
func test_sha512_256_empty() -> I32 {
    let mut digest: Digest = sha512_256("")
    let hex: Str = digest.to_hex()
    assert(hex.len() == (64 as I64), "sha512-256 produces 64 hex chars")
    digest.destroy()
    return 0
}

// ============================================================================
// Streaming Hash API Tests (from hash.test.tml)
// ============================================================================

@test
func test_hash_streaming_sha256() -> I32 {
    let mut hash: Hash = Hash::create(HashAlgorithm::Sha256)
    hash.update("hello")
    hash.update(" ")
    hash.update("world")
    let mut digest: Digest = hash.digest()
    let hex: Str = digest.to_hex()
    assert_eq(hex, "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9", "streaming sha256")
    digest.destroy()
    hash.destroy()
    return 0
}

@test
func test_hash_algorithm_md5() -> I32 {
    let mut hash: Hash = Hash::create(HashAlgorithm::Md5)
    hash.update("hello")
    let mut digest: Digest = hash.digest()
    assert_eq(digest.to_hex(), "5d41402abc4b2a76b9719d911017c592", "streaming md5")
    digest.destroy()
    hash.destroy()
    return 0
}

// ============================================================================
// Digest Encoding Tests (from hash.test.tml)
// ============================================================================

@test
func test_digest_to_base64() -> I32 {
    let mut digest: Digest = sha256("hello")
    let base64: Str = digest.to_base64()
    assert_eq(base64, "LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=", "sha256 base64")
    digest.destroy()
    return 0
}

// ============================================================================
// HashAlgorithm Name Tests (from hash_extra.test.tml)
// ============================================================================

@test
func test_hash_algorithm_name_md5() -> I32 {
    let name: Str = HashAlgorithm::Md5.name()
    assert_eq(name, "md5", "MD5 name")
    return 0
}

@test
func test_hash_algorithm_name_sha1() -> I32 {
    let name: Str = HashAlgorithm::Sha1.name()
    assert_eq(name, "sha1", "SHA-1 name")
    return 0
}

@test
func test_hash_algorithm_name_sha256() -> I32 {
    let name: Str = HashAlgorithm::Sha256.name()
    assert_eq(name, "sha256", "SHA-256 name")
    return 0
}

@test
func test_hash_algorithm_name_sha384() -> I32 {
    let name: Str = HashAlgorithm::Sha384.name()
    assert_eq(name, "sha384", "SHA-384 name")
    return 0
}

@test
func test_hash_algorithm_name_sha512() -> I32 {
    let name: Str = HashAlgorithm::Sha512.name()
    assert_eq(name, "sha512", "SHA-512 name")
    return 0
}

@test
func test_hash_algorithm_name_sha512_256() -> I32 {
    let name: Str = HashAlgorithm::Sha512_256.name()
    assert_eq(name, "sha512-256", "SHA-512/256 name")
    return 0
}

// ============================================================================
// CipherAlgorithm Enum Tests (from cipher.test.tml)
// ============================================================================

@test
func test_cipher_algorithm_name() -> I32 {
    // Test name() method returns correct OpenSSL algorithm names
    assert_eq(CipherAlgorithm::Aes128Cbc.name(), "aes-128-cbc", "AES-128-CBC name")
    assert_eq(CipherAlgorithm::Aes256Cbc.name(), "aes-256-cbc", "AES-256-CBC name")
    assert_eq(CipherAlgorithm::Aes256Gcm.name(), "aes-256-gcm", "AES-256-GCM name")
    assert_eq(CipherAlgorithm::ChaCha20Poly1305.name(), "chacha20-poly1305", "ChaCha20-Poly1305 name")
    assert_eq(CipherAlgorithm::XChaCha20Poly1305.name(), "xchacha20-poly1305", "XChaCha20-Poly1305 name")
    return 0
}

@test
func test_cipher_algorithm_key_size() -> I32 {
    // Test key_size() returns correct byte counts
    assert_eq(CipherAlgorithm::Aes128Cbc.key_size(), 16, "AES-128 key size")
    assert_eq(CipherAlgorithm::Aes192Cbc.key_size(), 24, "AES-192 key size")
    assert_eq(CipherAlgorithm::Aes256Cbc.key_size(), 32, "AES-256 key size")
    assert_eq(CipherAlgorithm::ChaCha20Poly1305.key_size(), 32, "ChaCha20-Poly1305 key size")
    assert_eq(CipherAlgorithm::Des3Cbc.key_size(), 24, "3DES key size")
    return 0
}

@test
func test_cipher_algorithm_iv_size() -> I32 {
    // Test iv_size() returns correct byte counts
    assert_eq(CipherAlgorithm::Aes128Cbc.iv_size(), 16, "AES-CBC IV size")
    assert_eq(CipherAlgorithm::Aes256Gcm.iv_size(), 12, "AES-GCM nonce size")
    assert_eq(CipherAlgorithm::ChaCha20Poly1305.iv_size(), 12, "ChaCha20-Poly1305 nonce size")
    assert_eq(CipherAlgorithm::XChaCha20Poly1305.iv_size(), 24, "XChaCha20-Poly1305 nonce size")
    assert_eq(CipherAlgorithm::Aes256Ecb.iv_size(), 0, "ECB has no IV")
    return 0
}

// ============================================================================
// Cipher/Decipher Error Handling Tests (from cipher_enum.test.tml)
// ============================================================================

@test
func test_cipher_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(10 as I64)
    let iv: Buffer = random_bytes(16 as I64)

    let result = Cipher::new(CipherAlgorithm::Aes256Cbc, ref bad_key, ref iv)
    assert(result.is_err(), "wrong key size should fail")

    bad_key.destroy()
    iv.destroy()
    return 0
}

@test
func test_cipher_invalid_iv_size() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let bad_iv: Buffer = random_bytes(5 as I64)

    let result = Cipher::new(CipherAlgorithm::Aes256Cbc, ref key, ref bad_iv)
    assert(result.is_err(), "wrong IV size should fail")

    key.destroy()
    bad_iv.destroy()
    return 0
}

@test
func test_decipher_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(10 as I64)
    let iv: Buffer = random_bytes(16 as I64)

    let result = Decipher::new(CipherAlgorithm::Aes256Cbc, ref bad_key, ref iv)
    assert(result.is_err(), "wrong key size should fail for decipher")

    bad_key.destroy()
    iv.destroy()
    return 0
}

@test
func test_decipher_invalid_iv_size() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let bad_iv: Buffer = random_bytes(5 as I64)

    let result = Decipher::new(CipherAlgorithm::Aes256Cbc, ref key, ref bad_iv)
    assert(result.is_err(), "wrong IV size should fail for decipher")

    key.destroy()
    bad_iv.destroy()
    return 0
}

@test
func test_cipher_set_auto_padding() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let iv: Buffer = random_bytes(16 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Cbc, ref key, ref iv) {
        Err(e) => return 1,
        Ok(c) => c
    }
    cipher.set_auto_padding(false)
    cipher.destroy()

    key.destroy()
    iv.destroy()
    return 0
}

@test
func test_decipher_set_auto_padding() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let iv: Buffer = random_bytes(16 as I64)

    let mut decipher: Decipher = when Decipher::new(CipherAlgorithm::Aes256Cbc, ref key, ref iv) {
        Err(e) => return 1,
        Ok(d) => d
    }
    decipher.set_auto_padding(false)
    decipher.destroy()

    key.destroy()
    iv.destroy()
    return 0
}

@test
func test_aes_gcm_set_aad_str() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    when cipher.set_aad_str("additional data") {
        Err(e) => return 1,
        Ok(_) => {}
    }
    cipher.update("test data")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    assert(ct.len() > (0 as I64), "GCM with AAD string works")

    cipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_cbc_set_aad_fails() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let iv: Buffer = random_bytes(16 as I64)
    let aad: Buffer = Buffer::new(0)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Cbc, ref key, ref iv) {
        Err(e) => return 1,
        Ok(c) => c
    }
    let result = cipher.set_aad(ref aad)
    assert(result.is_err(), "CBC should reject AAD")

    cipher.destroy()
    key.destroy()
    iv.destroy()
    return 0
}

// ============================================================================
// Cipher encrypt_string/decrypt_string Helpers (from cipher_helpers.test.tml)
// ============================================================================

@test
func test_decrypt_string_invalid_base64() -> I32 {
    let key: Buffer = random_bytes(32 as I64)

    let result = decrypt_string(ref key, "not-valid-base64!!!")
    assert(result.is_err(), "invalid base64 should fail")

    key.destroy()
    return 0
}

@test
func test_encrypt_decrypt_long_string() -> I32 {
    let key: Buffer = random_bytes(32 as I64)

    let encrypted: Str = when encrypt_string(ref key, "this is a longer test message with more than 16 bytes") {
        Err(e) => return 1,
        Ok(s) => s
    }

    let decrypted: Str = when decrypt_string(ref key, encrypted) {
        Err(e) => return 1,
        Ok(s) => s
    }

    assert_eq(decrypted, "this is a longer test message with more than 16 bytes", "long string roundtrip")

    key.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA256 Tests (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_sha256_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 32 bytes = 64 hex chars
    assert_eq(hex.len(), 64 as I64, "sha256 hex length")
    assert_eq(mac.len(), 32 as I64, "sha256 digest length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_empty_message() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("key", "")
    let hex: Str = mac.to_hex()

    assert_eq(hex.len(), 64 as I64, "empty message hex length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_rfc4231_test2() -> I32 {
    // RFC 4231 Test Case 2
    // Key = "Jefe"
    // Data = "what do ya want for nothing?"
    // Expected HMAC-SHA256 = 5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843

    let mut mac: HmacDigest = hmac_sha256("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()

    assert_eq(hex, "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843", "rfc4231 test 2")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA512 Tests (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_sha512_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha512("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 64 bytes = 128 hex chars
    assert_eq(hex.len(), 128 as I64, "sha512 hex length")
    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA384 Tests (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_sha384_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha384("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 48 bytes = 96 hex chars
    assert_eq(hex.len(), 96 as I64, "sha384 hex length")
    assert_eq(mac.len(), 48 as I64, "sha384 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA1 Tests (legacy) (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_sha1_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha1("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 20 bytes = 40 hex chars
    assert_eq(hex.len(), 40 as I64, "sha1 hex length")
    assert_eq(mac.len(), 20 as I64, "sha1 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-MD5 Tests (legacy) (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_md5_basic() -> I32 {
    let mut mac: HmacDigest = hmac_md5("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 16 bytes = 32 hex chars
    assert_eq(hex.len(), 32 as I64, "md5 hex length")
    assert_eq(mac.len(), 16 as I64, "md5 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// Streaming HMAC API Tests (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_streaming_sha256() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha256, "secret")
    hmac.update("hello")
    hmac.update(" ")
    hmac.update("world")
    let mut mac: HmacDigest = hmac.digest()

    // Should match one-shot version
    let mut oneshot: HmacDigest = hmac_sha256("secret", "hello world")

    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_sha512() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha512, "key")
    hmac.update("test data")
    let mut mac: HmacDigest = hmac.digest()

    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    hmac.destroy()
    return 0
}

// ============================================================================
// HMAC Determinism Tests (from hmac.test.tml)
// ============================================================================

@test
func test_hmac_deterministic() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message")
    let mut mac2: HmacDigest = hmac_sha256("key", "message")

    // Same key and data should produce same MAC
    assert_eq(mac1.to_hex(), mac2.to_hex(), "deterministic hmac")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_keys() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key1", "message")
    let mut mac2: HmacDigest = hmac_sha256("key2", "message")

    // Different keys should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different keys different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_data() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message1")
    let mut mac2: HmacDigest = hmac_sha256("key", "message2")

    // Different data should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different data different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}

// ============================================================================
// HMAC update_bytes Test (from hmac_update_bytes.test.tml)
// ============================================================================

@test
func test_hmac_update_bytes() -> I32 {
    var h: Hmac = Hmac::create(HashAlgorithm::Sha256, "secret")
    let buf: Buffer = Buffer.new(16)
    buf.write_u8(0x41, 0)
    buf.write_u8(0x42, 1)
    h.update_bytes(ref buf)
    let d: HmacDigest = h.digest()
    assert(d.len() > 0 as I64, "hmac digest should have length")
    d.destroy()
    buf.destroy()
    return 0
}

// ============================================================================
// Placeholder Tests (from kdf.test.tml, constants.test.tml, key.test.tml)
// ============================================================================

@test
func test_kdf_placeholder() -> I32 {
    // KDF functionality will be added in a future release.
    assert(true, "placeholder test")
    return 0
}

// NOTE: constants module has a codegen bug with lowlevel blocks returning *Unit
// (generates i32 instead of ptr). Tests deferred until bug is fixed.
@test
func test_constants_placeholder() -> I32 {
    return 0
}

@test
func test_key_placeholder() -> I32 {
    // Key management functionality will be added in a future release.
    assert(true, "placeholder test")
    return 0
}
