//! Consolidated crypto tests - File 2 of 3
//!
//! Contains 49 @test functions:
//!   - AES encrypt/decrypt roundtrip and error paths
//!   - ChaCha20-Poly1305 / XChaCha20-Poly1305 validation
//!   - AuthTag methods (len, to_hex, from_hex, from_bytes, bytes_ref)
//!   - Decipher set_aad_str
//!   - CryptoErrorKind description tests (all 19 variants)
//!   - CryptoError constructor tests (12 constructors + to_string)
//!
//! Sources: cipher_aes.test.tml, cipher_authtag.test.tml, error.test.tml

use std::collections::Buffer
use std::crypto::cipher::{
    AuthTag,
    CipherAlgorithm, Cipher, Decipher,
    aes_encrypt, aes_decrypt,
    aes_gcm_encrypt, aes_gcm_decrypt,
    chacha20_poly1305_encrypt, chacha20_poly1305_decrypt,
    xchacha20_poly1305_encrypt, xchacha20_poly1305_decrypt,
}
use std::crypto::error::{CryptoError, CryptoErrorKind}
use std::crypto::random::random_bytes
use test::{assert, assert_eq}

// ============================================================================
// AES Encrypt/Decrypt Tests (from cipher_aes.test.tml)
// ============================================================================

@test
func test_aes_encrypt_decrypt_roundtrip() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let iv: Buffer = random_bytes(16 as I64)

    let plaintext: Buffer = Buffer::from_string("hello world CBC")

    let ct: Buffer = when aes_encrypt(ref key, ref iv, ref plaintext) {
        Err(e) => return 1,
        Ok(b) => b
    }
    assert(ct.len() > (0 as I64), "ciphertext not empty")

    let pt: Buffer = when aes_decrypt(ref key, ref iv, ref ct) {
        Err(e) => return 1,
        Ok(b) => b
    }
    assert(pt.len() > (0 as I64), "plaintext not empty after decrypt")

    key.destroy()
    iv.destroy()
    return 0
}

@test
func test_aes_encrypt_invalid_key() -> I32 {
    let bad_key: Buffer = random_bytes(10 as I64)
    let iv: Buffer = random_bytes(16 as I64)
    let plaintext: Buffer = Buffer::from_string("test")

    let result = aes_encrypt(ref bad_key, ref iv, ref plaintext)
    assert(result.is_err(), "bad key should fail")

    bad_key.destroy()
    iv.destroy()
    return 0
}

@test
func test_aes_decrypt_invalid_key() -> I32 {
    let bad_key: Buffer = random_bytes(10 as I64)
    let iv: Buffer = random_bytes(16 as I64)
    let ct: Buffer = random_bytes(32 as I64)

    let result = aes_decrypt(ref bad_key, ref iv, ref ct)
    assert(result.is_err(), "bad key should fail")

    bad_key.destroy()
    iv.destroy()
    return 0
}

// ============================================================================
// ChaCha20-Poly1305 Error Tests (from cipher_aes.test.tml)
// ============================================================================

@test
func test_chacha20_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(16 as I64)
    let nonce: Buffer = random_bytes(12 as I64)
    let pt: Buffer = Buffer::from_string("test")
    let aad: Buffer = Buffer::new(0)

    let result = chacha20_poly1305_encrypt(ref bad_key, ref nonce, ref pt, ref aad)
    assert(result.is_err(), "ChaCha20 requires 32-byte key")

    bad_key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_chacha20_invalid_nonce_size() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let bad_nonce: Buffer = random_bytes(8 as I64)
    let pt: Buffer = Buffer::from_string("test")
    let aad: Buffer = Buffer::new(0)

    let result = chacha20_poly1305_encrypt(ref key, ref bad_nonce, ref pt, ref aad)
    assert(result.is_err(), "ChaCha20 requires 12-byte nonce")

    key.destroy()
    bad_nonce.destroy()
    return 0
}

@test
func test_chacha20_decrypt_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(16 as I64)
    let nonce: Buffer = random_bytes(12 as I64)
    let ct: Buffer = random_bytes(32 as I64)
    let aad: Buffer = Buffer::new(0)
    let tag_buf: Buffer = random_bytes(16 as I64)
    let tag: AuthTag = AuthTag::from_bytes(tag_buf)

    let result = chacha20_poly1305_decrypt(ref bad_key, ref nonce, ref ct, ref aad, ref tag)
    assert(result.is_err(), "ChaCha20 decrypt requires 32-byte key")

    bad_key.destroy()
    nonce.destroy()
    return 0
}

// ============================================================================
// XChaCha20-Poly1305 Error Tests (from cipher_aes.test.tml)
// ============================================================================

@test
func test_xchacha20_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(16 as I64)
    let nonce: Buffer = random_bytes(24 as I64)
    let pt: Buffer = Buffer::from_string("test")
    let aad: Buffer = Buffer::new(0)

    let result = xchacha20_poly1305_encrypt(ref bad_key, ref nonce, ref pt, ref aad)
    assert(result.is_err(), "XChaCha20 requires 32-byte key")

    bad_key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_xchacha20_invalid_nonce_size() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let bad_nonce: Buffer = random_bytes(12 as I64)
    let pt: Buffer = Buffer::from_string("test")
    let aad: Buffer = Buffer::new(0)

    let result = xchacha20_poly1305_encrypt(ref key, ref bad_nonce, ref pt, ref aad)
    assert(result.is_err(), "XChaCha20 requires 24-byte nonce")

    key.destroy()
    bad_nonce.destroy()
    return 0
}

@test
func test_xchacha20_decrypt_invalid_key_size() -> I32 {
    let bad_key: Buffer = random_bytes(16 as I64)
    let nonce: Buffer = random_bytes(24 as I64)
    let ct: Buffer = random_bytes(32 as I64)
    let aad: Buffer = Buffer::new(0)
    let tag_buf: Buffer = random_bytes(16 as I64)
    let tag: AuthTag = AuthTag::from_bytes(tag_buf)

    let result = xchacha20_poly1305_decrypt(ref bad_key, ref nonce, ref ct, ref aad, ref tag)
    assert(result.is_err(), "XChaCha20 decrypt requires 32-byte key")

    bad_key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_xchacha20_decrypt_invalid_nonce_size() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let bad_nonce: Buffer = random_bytes(12 as I64)
    let ct: Buffer = random_bytes(32 as I64)
    let aad: Buffer = Buffer::new(0)
    let tag_buf: Buffer = random_bytes(16 as I64)
    let tag: AuthTag = AuthTag::from_bytes(tag_buf)

    let result = xchacha20_poly1305_decrypt(ref key, ref bad_nonce, ref ct, ref aad, ref tag)
    assert(result.is_err(), "XChaCha20 decrypt requires 24-byte nonce")

    key.destroy()
    bad_nonce.destroy()
    return 0
}

// ============================================================================
// AuthTag Method Tests (from cipher_authtag.test.tml)
// ============================================================================

@test
func test_authtag_len() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    cipher.update("test data")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    let tag: AuthTag = when cipher.get_auth_tag() {
        Err(e) => return 1,
        Ok(t) => t
    }

    assert_eq(tag.len(), 16 as I64, "GCM auth tag is 16 bytes")

    cipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_authtag_to_hex() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    cipher.update("hello")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    let tag: AuthTag = when cipher.get_auth_tag() {
        Err(e) => return 1,
        Ok(t) => t
    }

    let hex: Str = tag.to_hex()
    assert_eq(hex.len(), 32 as I64, "hex representation is 32 chars for 16 bytes")

    cipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_authtag_from_hex_roundtrip() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    cipher.update("roundtrip test")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    let tag: AuthTag = when cipher.get_auth_tag() {
        Err(e) => return 1,
        Ok(t) => t
    }

    let hex: Str = tag.to_hex()
    let tag2: AuthTag = when AuthTag::from_hex(hex) {
        Err(e) => return 1,
        Ok(t) => t
    }
    assert_eq(tag2.len(), 16 as I64, "restored tag has correct length")
    assert_eq(tag2.to_hex(), hex, "hex roundtrip preserves value")

    cipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

@test
func test_authtag_from_hex_invalid() -> I32 {
    let result = AuthTag::from_hex("not-valid-hex!!!")
    assert(result.is_err(), "invalid hex should fail")
    return 0
}

@test
func test_authtag_from_bytes() -> I32 {
    let buf: Buffer = random_bytes(16 as I64)
    let tag: AuthTag = AuthTag::from_bytes(buf)
    assert_eq(tag.len(), 16 as I64, "from_bytes preserves length")
    return 0
}

@test
func test_authtag_bytes_ref() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    cipher.update("data")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    let tag: AuthTag = when cipher.get_auth_tag() {
        Err(e) => return 1,
        Ok(t) => t
    }

    let bytes_ref: ref Buffer = tag.bytes()
    assert(bytes_ref.len() > (0 as I64), "bytes() returns non-empty buffer ref")

    cipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

// ============================================================================
// Decipher set_aad_str Test (from cipher_authtag.test.tml)
// ============================================================================

@test
func test_decipher_set_aad_str() -> I32 {
    let key: Buffer = random_bytes(32 as I64)
    let nonce: Buffer = random_bytes(12 as I64)

    // Encrypt with AAD string
    let mut cipher: Cipher = when Cipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(c) => c
    }
    when cipher.set_aad_str("additional data") {
        Err(e) => return 1,
        Ok(_) => {}
    }
    cipher.update("secret")
    let ct: Buffer = when cipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    let tag: AuthTag = when cipher.get_auth_tag() {
        Err(e) => return 1,
        Ok(t) => t
    }

    // Decrypt with matching AAD string using Decipher::set_aad_str
    let mut decipher: Decipher = when Decipher::new(CipherAlgorithm::Aes256Gcm, ref key, ref nonce) {
        Err(e) => return 1,
        Ok(d) => d
    }
    when decipher.set_aad_str("additional data") {
        Err(e) => return 1,
        Ok(_) => {}
    }
    decipher.set_auth_tag(ref tag)
    decipher.update_bytes(ref ct)
    let pt: Buffer = when decipher.finalize() {
        Err(e) => return 1,
        Ok(b) => b
    }
    assert(pt.len() > (0 as I64), "decrypted with set_aad_str works")

    cipher.destroy()
    decipher.destroy()
    key.destroy()
    nonce.destroy()
    return 0
}

// ============================================================================
// CryptoErrorKind Description Tests (from error.test.tml)
// ============================================================================

@test
func test_error_kind_invalid_key() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidKey.description()
    assert_eq(desc, "invalid key format or encoding", "InvalidKey description")
    return 0
}

@test
func test_error_kind_invalid_iv() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidIv.description()
    assert_eq(desc, "invalid initialization vector", "InvalidIv description")
    return 0
}

@test
func test_error_kind_auth_failed() -> I32 {
    let desc: Str = CryptoErrorKind::AuthenticationFailed.description()
    assert_eq(desc, "authentication failed", "AuthenticationFailed description")
    return 0
}

@test
func test_error_kind_unsupported_algorithm() -> I32 {
    let desc: Str = CryptoErrorKind::UnsupportedAlgorithm.description()
    assert_eq(desc, "unsupported algorithm", "UnsupportedAlgorithm description")
    return 0
}

@test
func test_error_kind_operation_failed() -> I32 {
    let desc: Str = CryptoErrorKind::OperationFailed.description()
    assert_eq(desc, "operation failed", "OperationFailed description")
    return 0
}

@test
func test_error_kind_internal_error() -> I32 {
    let desc: Str = CryptoErrorKind::InternalError.description()
    assert_eq(desc, "internal cryptographic error", "InternalError description")
    return 0
}

@test
func test_error_kind_invalid_auth_tag() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidAuthTag.description()
    assert_eq(desc, "invalid authentication tag", "InvalidAuthTag description")
    return 0
}

@test
func test_error_kind_invalid_signature() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidSignature.description()
    assert_eq(desc, "invalid signature format", "InvalidSignature description")
    return 0
}

@test
func test_error_kind_verification_failed() -> I32 {
    let desc: Str = CryptoErrorKind::VerificationFailed.description()
    assert_eq(desc, "signature verification failed", "VerificationFailed description")
    return 0
}

@test
func test_error_kind_invalid_parameter() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidParameter.description()
    assert_eq(desc, "invalid parameter", "InvalidParameter description")
    return 0
}

@test
func test_error_kind_invalid_padding() -> I32 {
    let desc: Str = CryptoErrorKind::InvalidPadding.description()
    assert_eq(desc, "invalid padding", "InvalidPadding description")
    return 0
}

@test
func test_error_kind_key_derivation_failed() -> I32 {
    let desc: Str = CryptoErrorKind::KeyDerivationFailed.description()
    assert_eq(desc, "key derivation failed", "KeyDerivationFailed description")
    return 0
}

@test
func test_error_kind_random_generation_failed() -> I32 {
    let desc: Str = CryptoErrorKind::RandomGenerationFailed.description()
    assert_eq(desc, "random generation failed", "RandomGenerationFailed description")
    return 0
}

@test
func test_error_kind_cert_parse_error() -> I32 {
    let desc: Str = CryptoErrorKind::CertificateParseError.description()
    assert_eq(desc, "certificate parsing failed", "CertificateParseError description")
    return 0
}

@test
func test_error_kind_cert_verification_failed() -> I32 {
    let desc: Str = CryptoErrorKind::CertificateVerificationFailed.description()
    assert_eq(desc, "certificate verification failed", "CertificateVerificationFailed description")
    return 0
}

@test
func test_error_kind_cert_expired() -> I32 {
    let desc: Str = CryptoErrorKind::CertificateExpired.description()
    assert_eq(desc, "certificate has expired", "CertificateExpired description")
    return 0
}

@test
func test_error_kind_cert_not_yet_valid() -> I32 {
    let desc: Str = CryptoErrorKind::CertificateNotYetValid.description()
    assert_eq(desc, "certificate is not yet valid", "CertificateNotYetValid description")
    return 0
}

@test
func test_error_kind_key_exchange_failed() -> I32 {
    let desc: Str = CryptoErrorKind::KeyExchangeFailed.description()
    assert_eq(desc, "key exchange failed", "KeyExchangeFailed description")
    return 0
}

@test
func test_error_kind_buffer_too_small() -> I32 {
    let desc: Str = CryptoErrorKind::BufferTooSmall.description()
    assert_eq(desc, "buffer too small", "BufferTooSmall description")
    return 0
}

// ============================================================================
// CryptoError Constructor Tests (from error.test.tml)
// ============================================================================

@test
func test_crypto_error_new() -> I32 {
    let err: CryptoError = CryptoError::new("test error message")
    assert_eq(err.get_message(), "test error message", "new error message")
    assert_eq(err.get_details(), "", "new error has empty details")
    return 0
}

@test
func test_crypto_error_with_details() -> I32 {
    let err: CryptoError = CryptoError::with_details("operation failed", "extra info")
    assert_eq(err.get_details(), "extra info", "details preserved")
    return 0
}

@test
func test_crypto_error_invalid_parameter() -> I32 {
    let err: CryptoError = CryptoError::invalid_parameter("key too short")
    assert_eq(err.get_details(), "key too short", "invalid_parameter details")
    return 0
}

@test
func test_crypto_error_invalid_key() -> I32 {
    let err: CryptoError = CryptoError::invalid_key("must be 32 bytes")
    assert_eq(err.get_details(), "must be 32 bytes", "invalid_key details")
    return 0
}

@test
func test_crypto_error_invalid_iv() -> I32 {
    let err: CryptoError = CryptoError::invalid_iv("must be 12 bytes")
    assert_eq(err.get_details(), "must be 12 bytes", "invalid_iv details")
    return 0
}

@test
func test_crypto_error_auth_failed() -> I32 {
    let err: CryptoError = CryptoError::auth_failed()
    assert_eq(err.get_message(), "authentication failed", "auth_failed message")
    return 0
}

@test
func test_crypto_error_verification_failed() -> I32 {
    let err: CryptoError = CryptoError::verification_failed()
    assert_eq(err.get_message(), "signature verification failed", "verification_failed message")
    return 0
}

@test
func test_crypto_error_unsupported_algorithm() -> I32 {
    let err: CryptoError = CryptoError::unsupported_algorithm("blowfish")
    assert_eq(err.get_details(), "blowfish", "unsupported algo details")
    return 0
}

@test
func test_crypto_error_operation_failed() -> I32 {
    let err: CryptoError = CryptoError::operation_failed("timeout")
    assert_eq(err.get_details(), "timeout", "operation_failed details")
    return 0
}

@test
func test_crypto_error_random_failed() -> I32 {
    let err: CryptoError = CryptoError::random_failed()
    assert_eq(err.get_message(), "random generation failed", "random_failed message")
    return 0
}

@test
func test_crypto_error_buffer_too_small() -> I32 {
    let err: CryptoError = CryptoError::buffer_too_small("need 64 bytes")
    assert_eq(err.get_details(), "need 64 bytes", "buffer_too_small details")
    return 0
}

@test
func test_crypto_error_to_string() -> I32 {
    let err: CryptoError = CryptoError::new("test message")
    let s: Str = err.to_string()
    assert_eq(s, "CryptoError: test message", "to_string format")
    return 0
}

@test
func test_crypto_error_to_string_with_details() -> I32 {
    let err: CryptoError = CryptoError::with_details("bad key", "expected 32 bytes")
    let s: Str = err.to_string()
    assert(s.len() > (0 as I64), "to_string with details non-empty")
    return 0
}
