// Tests for crypto Elliptic Curve Diffie-Hellman key exchange
use test
use std::crypto::ecdh::{
    EcCurve, EcPointFormat, Ecdh, create_ecdh,
    generate_x25519_keypair, x25519, x25519_public_from_private,
    is_curve_supported
}

// === EcCurve enum tests ===

@test
func test_ec_curve_names() -> I32 {
    assert_eq(EcCurve::P256.name(), "prime256v1", "P256")
    assert_eq(EcCurve::P384.name(), "secp384r1", "P384")
    assert_eq(EcCurve::P521.name(), "secp521r1", "P521")
    assert_eq(EcCurve::Secp256k1.name(), "secp256k1", "secp256k1")
    assert_eq(EcCurve::X25519.name(), "X25519", "X25519")
    assert_eq(EcCurve::X448.name(), "X448", "X448")
    assert_eq(EcCurve::BrainpoolP256r1.name(), "brainpoolP256r1", "BP256")
    return 0
}

@test
func test_ec_curve_key_bits() -> I32 {
    assert_eq(EcCurve::P256.key_bits(), 256 as I64, "P256 bits")
    assert_eq(EcCurve::P384.key_bits(), 384 as I64, "P384 bits")
    assert_eq(EcCurve::P521.key_bits(), 521 as I64, "P521 bits")
    assert_eq(EcCurve::X25519.key_bits(), 256 as I64, "X25519 bits")
    assert_eq(EcCurve::X448.key_bits(), 448 as I64, "X448 bits")
    return 0
}

@test
func test_ec_curve_shared_secret_size() -> I32 {
    assert_eq(EcCurve::P256.shared_secret_size(), 32 as I64, "P256 ss")
    assert_eq(EcCurve::P384.shared_secret_size(), 48 as I64, "P384 ss")
    assert_eq(EcCurve::X25519.shared_secret_size(), 32 as I64, "X25519 ss")
    assert_eq(EcCurve::X448.shared_secret_size(), 56 as I64, "X448 ss")
    return 0
}

@test
func test_ec_curve_is_modern() -> I32 {
    assert_eq(EcCurve::X25519.is_modern(), true, "X25519 modern")
    assert_eq(EcCurve::X448.is_modern(), true, "X448 modern")
    assert_eq(EcCurve::P256.is_modern(), false, "P256 not modern")
    assert_eq(EcCurve::Secp256k1.is_modern(), false, "secp256k1 not modern")
    return 0
}

@test
func test_ec_curve_from_name() -> I32 {
    assert_eq(EcCurve::from_name("prime256v1").is_just(), true, "prime256v1")
    assert_eq(EcCurve::from_name("P-256").is_just(), true, "P-256")
    assert_eq(EcCurve::from_name("X25519").is_just(), true, "X25519")
    assert_eq(EcCurve::from_name("x25519").is_just(), true, "x25519")
    assert_eq(EcCurve::from_name("unknown").is_nothing(), true, "unknown")
    return 0
}

@test
func test_ec_point_format_names() -> I32 {
    assert_eq(EcPointFormat::Uncompressed.name(), "uncompressed", "uncomp")
    assert_eq(EcPointFormat::Compressed.name(), "compressed", "comp")
    assert_eq(EcPointFormat::Hybrid.name(), "hybrid", "hybrid")
    return 0
}

// === ECDH FFI tests ===

@test
func test_ecdh_create_p256() -> I32 {
    let result = Ecdh::new(EcCurve::P256)
    assert_eq(result.is_ok(), true, "P256 create ok")
    return 0
}

@test
func test_ecdh_generate_keys_p256() -> I32 {
    let mut ecdh = Ecdh::new(EcCurve::P256).unwrap()
    ecdh.generate_keys()
    let pub_key = ecdh.public_key()
    assert_eq(pub_key.len() > 0 as I64, true, "pub key not empty")
    let priv_key = ecdh.private_key()
    assert_eq(priv_key.len() > 0 as I64, true, "priv key not empty")
    return 0
}

@test
func test_ecdh_key_exchange_p256() -> I32 {
    let mut alice = Ecdh::new(EcCurve::P256).unwrap()
    alice.generate_keys()
    let alice_pub = alice.public_key()

    let mut bob = Ecdh::new(EcCurve::P256).unwrap()
    bob.generate_keys()
    let bob_pub = bob.public_key()

    let alice_secret = alice.compute_secret(ref bob_pub)
    assert_eq(alice_secret.is_ok(), true, "alice ok")
    let bob_secret = bob.compute_secret(ref alice_pub)
    assert_eq(bob_secret.is_ok(), true, "bob ok")

    let a = alice_secret.unwrap()
    let b = bob_secret.unwrap()
    assert_eq(a.len(), b.len(), "secret lengths match")
    assert_eq(a.len(), 32 as I64, "P256 secret is 32 bytes")
    return 0
}

@test
func test_ecdh_create_convenience() -> I32 {
    let result = create_ecdh(EcCurve::P256)
    assert_eq(result.is_ok(), true, "create_ecdh ok")
    let ecdh = result.unwrap()
    assert_eq(ecdh.curve().name(), "prime256v1", "curve name")
    return 0
}

@test
func test_x25519_keypair() -> I32 {
    let (priv_key, pub_key) = generate_x25519_keypair()
    assert_eq(priv_key.len(), 32 as I64, "x25519 priv 32 bytes")
    assert_eq(pub_key.len(), 32 as I64, "x25519 pub 32 bytes")
    return 0
}

@test
func test_x25519_exchange() -> I32 {
    let (alice_priv, alice_pub) = generate_x25519_keypair()
    let (bob_priv, bob_pub) = generate_x25519_keypair()

    let alice_secret = x25519(ref alice_priv, ref bob_pub)
    assert_eq(alice_secret.is_ok(), true, "alice x25519 ok")
    let bob_secret = x25519(ref bob_priv, ref alice_pub)
    assert_eq(bob_secret.is_ok(), true, "bob x25519 ok")

    let a = alice_secret.unwrap()
    let b = bob_secret.unwrap()
    assert_eq(a.len(), 32 as I64, "secret 32 bytes")
    assert_eq(b.len(), 32 as I64, "secret 32 bytes b")
    return 0
}

@test
func test_x25519_public_from_private() -> I32 {
    let (priv_key, pub_key) = generate_x25519_keypair()
    let derived = x25519_public_from_private(ref priv_key)
    assert_eq(derived.is_ok(), true, "derive ok")
    let derived_pub = derived.unwrap()
    assert_eq(derived_pub.len(), 32 as I64, "derived 32 bytes")
    return 0
}

@test
func test_is_curve_supported() -> I32 {
    assert_eq(is_curve_supported("prime256v1"), true, "P256 supported")
    assert_eq(is_curve_supported("secp384r1"), true, "P384 supported")
    assert_eq(is_curve_supported("fake_curve"), false, "fake not supported")
    return 0
}
