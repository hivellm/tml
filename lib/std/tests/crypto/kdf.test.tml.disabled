// Tests for Key Derivation Functions (PBKDF2, scrypt, HKDF)
use test
use std::crypto::kdf::{
    ScryptParams, Argon2Variant, Argon2Params,
    pbkdf2, scrypt, hkdf, hkdf_extract, hkdf_expand
}
use std::crypto::hash::HashAlgorithm
use std::crypto::random::random_bytes

// === Param constructors ===

@test
func test_scrypt_params() -> I32 {
    let d = ScryptParams::default()
    assert_eq(d.n, 16384 as I64, "default n")
    assert_eq(d.r, 8 as I64, "default r")
    assert_eq(d.p, 1 as I64, "default p")
    let h = ScryptParams::high_security()
    assert_eq(h.n, 1048576 as I64, "high n")
    let l = ScryptParams::low_memory()
    assert_eq(l.maxmem, 33554432 as I64, "low mem maxmem")
    let c = ScryptParams::custom(1024, 4, 2)
    assert_eq(c.n, 1024 as I64, "custom n")
    assert_eq(c.r, 4 as I64, "custom r")
    assert_eq(c.p, 2 as I64, "custom p")
    return 0
}

@test
func test_argon2_variant_names() -> I32 {
    assert_eq(Argon2Variant::Argon2d.name(), "argon2d", "d")
    assert_eq(Argon2Variant::Argon2i.name(), "argon2i", "i")
    assert_eq(Argon2Variant::Argon2id.name(), "argon2id", "id")
    return 0
}

@test
func test_argon2_params() -> I32 {
    let d = Argon2Params::default()
    assert_eq(d.time_cost, 3 as I64, "default time")
    assert_eq(d.memory_cost, 65536 as I64, "default mem")
    assert_eq(d.parallelism, 4 as I64, "default par")
    let h = Argon2Params::high_security()
    assert_eq(h.memory_cost, 131072 as I64, "high mem")
    let l = Argon2Params::low_memory()
    assert_eq(l.time_cost, 6 as I64, "low time")
    assert_eq(l.memory_cost, 16384 as I64, "low mem")
    let c = Argon2Params::custom(2, 8192, 1)
    assert_eq(c.time_cost, 2 as I64, "custom time")
    assert_eq(c.memory_cost, 8192 as I64, "custom mem")
    assert_eq(c.parallelism, 1 as I64, "custom par")
    return 0
}

// === PBKDF2 ===

@test
func test_pbkdf2_sha256() -> I32 {
    let salt = random_bytes(16)
    let result = pbkdf2("password", ref salt, 1000, 32, HashAlgorithm::Sha256)
    assert_eq(result.is_ok(), true, "pbkdf2 ok")
    let key = result.unwrap()
    assert_eq(key.len() > 0 as I64, true, "key not empty")
    return 0
}

@test
func test_pbkdf2_deterministic() -> I32 {
    let salt = random_bytes(16)
    let r1 = pbkdf2("password", ref salt, 1000, 32, HashAlgorithm::Sha256).unwrap()
    let r2 = pbkdf2("password", ref salt, 1000, 32, HashAlgorithm::Sha256).unwrap()
    assert_eq(r1.to_hex(), r2.to_hex(), "deterministic")
    return 0
}

@test
func test_pbkdf2_invalid_params() -> I32 {
    let salt = random_bytes(16)
    assert_eq(pbkdf2("pw", ref salt, 0, 32, HashAlgorithm::Sha256).is_err(), true, "0 iters")
    assert_eq(pbkdf2("pw", ref salt, 1000, 0, HashAlgorithm::Sha256).is_err(), true, "0 len")
    assert_eq(pbkdf2("pw", ref salt, 1000, 2000, HashAlgorithm::Sha256).is_err(), true, "2000 len")
    return 0
}

// === scrypt ===

@test
func test_scrypt_derive() -> I32 {
    let salt = random_bytes(16)
    let params = ScryptParams::custom(1024, 8, 1)
    let result = scrypt("password", ref salt, 32, ref params)
    assert_eq(result.is_ok(), true, "scrypt ok")
    let key = result.unwrap()
    assert_eq(key.len() > 0 as I64, true, "key not empty")
    return 0
}

@test
func test_scrypt_deterministic() -> I32 {
    let salt = random_bytes(16)
    let params = ScryptParams::custom(1024, 8, 1)
    let r1 = scrypt("password", ref salt, 32, ref params).unwrap()
    let r2 = scrypt("password", ref salt, 32, ref params).unwrap()
    assert_eq(r1.to_hex(), r2.to_hex(), "deterministic")
    return 0
}

@test
func test_scrypt_invalid_key_length() -> I32 {
    let salt = random_bytes(16)
    let params = ScryptParams::custom(1024, 8, 1)
    assert_eq(scrypt("pw", ref salt, 0, ref params).is_err(), true, "0 len")
    assert_eq(scrypt("pw", ref salt, 2000, ref params).is_err(), true, "2000 len")
    return 0
}

// === HKDF ===

@test
func test_hkdf_sha256() -> I32 {
    let ikm = random_bytes(32)
    let salt = random_bytes(32)
    let result = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "test info", 32)
    assert_eq(result.is_ok(), true, "hkdf ok")
    let key = result.unwrap()
    assert_eq(key.len() > 0 as I64, true, "key not empty")
    return 0
}

@test
func test_hkdf_deterministic() -> I32 {
    let ikm = random_bytes(32)
    let salt = random_bytes(32)
    let r1 = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "ctx", 32).unwrap()
    let r2 = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "ctx", 32).unwrap()
    assert_eq(r1.to_hex(), r2.to_hex(), "deterministic")
    return 0
}

@test
func test_hkdf_extract_expand() -> I32 {
    let ikm = random_bytes(32)
    let salt = random_bytes(32)
    let prk_result = hkdf_extract(HashAlgorithm::Sha256, ref ikm, ref salt)
    assert_eq(prk_result.is_ok(), true, "extract ok")
    let prk = prk_result.unwrap()
    let info = random_bytes(16)
    let okm_result = hkdf_expand(HashAlgorithm::Sha256, ref prk, ref info, 32)
    assert_eq(okm_result.is_ok(), true, "expand ok")
    return 0
}
