//! Tests for crypto key derivation functions
//!
//! Tests PBKDF2, HKDF, scrypt, Argon2, and bcrypt.

use std::crypto::{pbkdf2, pbkdf2_bytes}
use std::crypto::{hkdf, hkdf_extract, hkdf_expand}
use std::crypto::{scrypt, ScryptParams}
use std::crypto::{argon2, argon2_hash, argon2_verify, Argon2Variant, Argon2Params}
use std::crypto::{bcrypt_hash, bcrypt_verify}
use std::crypto::random_bytes
use std::collections::Buffer
use test::{assert, assert_eq}

// ============================================================================
// PBKDF2 Tests
// ============================================================================

@test
func test_pbkdf2_sha256_basic() -> I32 {
    let password = "password"
    let salt = Buffer.from_str("salt")
    let iterations: I64 = 10000
    let key_len: I64 = 32

    let derived = pbkdf2(password, salt, iterations, key_len, "sha256")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

@test
func test_pbkdf2_rfc6070_vector1() -> I32 {
    // RFC 6070 Test Vector 1
    // Password: "password"
    // Salt: "salt"
    // Iterations: 1
    // Key length: 20
    // Expected (PBKDF2-HMAC-SHA1): 0c60c80f961f0e71f3a9b524af6012062fe037a6

    let password = "password"
    let salt = Buffer.from_str("salt")

    let derived = pbkdf2(password, salt, 1, 20, "sha1")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 20)
            assert_eq(key.to_hex(), "0c60c80f961f0e71f3a9b524af6012062fe037a6")
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

@test
func test_pbkdf2_rfc6070_vector2() -> I32 {
    // RFC 6070 Test Vector 2
    // Password: "password"
    // Salt: "salt"
    // Iterations: 2
    // Key length: 20

    let password = "password"
    let salt = Buffer.from_str("salt")

    let derived = pbkdf2(password, salt, 2, 20, "sha1")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 20)
            assert_eq(key.to_hex(), "ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957")
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

@test
func test_pbkdf2_sha512() -> I32 {
    let password = "secret"
    let salt = random_bytes(16)

    let derived = pbkdf2(password, salt, 100000, 64, "sha512")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 64)
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

@test
func test_pbkdf2_bytes_password() -> I32 {
    let password = Buffer.from_str("password")
    let salt = Buffer.from_str("salt")

    let derived = pbkdf2_bytes(password, salt, 1000, 32, "sha256")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    password.destroy()
    salt.destroy()
    return 0
}

@test
func test_pbkdf2_deterministic() -> I32 {
    let password = "test"
    let salt = Buffer.from_str("fixed_salt")

    let key1 = pbkdf2(password, salt, 1000, 32, "sha256")
    let key2 = pbkdf2(password, salt, 1000, 32, "sha256")

    when (key1, key2) {
        (Just(k1), Just(k2)) => {
            assert(k1.equals(k2))
            k1.destroy()
            k2.destroy()
        }
        _ => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

// ============================================================================
// HKDF Tests
// ============================================================================

@test
func test_hkdf_sha256() -> I32 {
    let ikm = Buffer.from_str("input keying material")
    let salt = Buffer.from_str("salt")
    let info = "context info"

    let derived = hkdf("sha256", ikm, salt, info, 32)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            // HKDF might not be implemented on all platforms
        }
    }

    ikm.destroy()
    salt.destroy()
    return 0
}

@test
func test_hkdf_rfc5869_vector1() -> I32 {
    // RFC 5869 Test Case 1
    // IKM: 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 bytes)
    // Salt: 0x000102030405060708090a0b0c (13 bytes)
    // Info: 0xf0f1f2f3f4f5f6f7f8f9 (10 bytes)
    // L: 42

    let ikm = Buffer.alloc(22)
    loop i in 0 to 22 {
        ikm.set(i, 0x0b)
    }

    let salt = Buffer.alloc(13)
    loop i in 0 to 13 {
        salt.set(i, i as U8)
    }

    let info = Buffer.alloc(10)
    loop i in 0 to 10 {
        info.set(i, (0xf0 + i) as U8)
    }

    // Extract + Expand
    let prk = hkdf_extract("sha256", ikm, salt)
    when prk {
        Just(p) => {
            assert_eq(p.len(), 32)  // SHA-256 output size

            let okm = hkdf_expand("sha256", p, info, 42)
            when okm {
                Just(output) => {
                    assert_eq(output.len(), 42)
                    // Expected: 3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865
                    output.destroy()
                }
                Nothing => {}
            }

            p.destroy()
        }
        Nothing => {}
    }

    ikm.destroy()
    salt.destroy()
    info.destroy()
    return 0
}

@test
func test_hkdf_extract_expand() -> I32 {
    let ikm = random_bytes(32)
    let salt = random_bytes(16)
    let info = Buffer.from_str("application context")

    // Extract phase
    let prk = hkdf_extract("sha256", ikm, salt)

    when prk {
        Just(p) => {
            assert_eq(p.len(), 32)

            // Expand phase - derive multiple keys
            let key1 = hkdf_expand("sha256", p, info, 32)
            let key2 = hkdf_expand("sha256", p, info, 64)

            when (key1, key2) {
                (Just(k1), Just(k2)) => {
                    assert_eq(k1.len(), 32)
                    assert_eq(k2.len(), 64)
                    k1.destroy()
                    k2.destroy()
                }
                _ => {}
            }

            p.destroy()
        }
        Nothing => {}
    }

    ikm.destroy()
    salt.destroy()
    info.destroy()
    return 0
}

// ============================================================================
// scrypt Tests
// ============================================================================

@test
func test_scrypt_basic() -> I32 {
    let password = "password"
    let salt = random_bytes(16)
    let params = ScryptParams.new(16384, 8, 1)  // N=16384, r=8, p=1

    let derived = scrypt(password, salt, 32, params)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            // scrypt might not be available on all platforms
        }
    }

    salt.destroy()
    return 0
}

@test
func test_scrypt_rfc7914_vector() -> I32 {
    // RFC 7914 Test Vector
    // Password: ""
    // Salt: ""
    // N: 16, r: 1, p: 1
    // Output length: 64

    let password = ""
    let salt = Buffer.alloc(0)
    let params = ScryptParams.new(16, 1, 1)

    let derived = scrypt(password, salt, 64, params)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 64)
            // Expected: 77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906
            key.destroy()
        }
        Nothing => {}
    }

    salt.destroy()
    return 0
}

@test
func test_scrypt_deterministic() -> I32 {
    let password = "test"
    let salt = Buffer.from_str("fixed_salt")
    let params = ScryptParams.new(1024, 8, 1)

    let key1 = scrypt(password, salt, 32, params)
    let key2 = scrypt(password, salt, 32, params)

    when (key1, key2) {
        (Just(k1), Just(k2)) => {
            assert(k1.equals(k2))
            k1.destroy()
            k2.destroy()
        }
        _ => {}
    }

    salt.destroy()
    return 0
}

// ============================================================================
// Argon2 Tests
// ============================================================================

@test
func test_argon2id_basic() -> I32 {
    let password = "password"
    let salt = random_bytes(16)
    let params = Argon2Params.new(3, 65536, 4)  // t=3, m=64MB, p=4

    let derived = argon2(Argon2Variant.Id, password, salt, 32, params)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            // Argon2 might not be available
        }
    }

    salt.destroy()
    return 0
}

@test
func test_argon2_hash_verify() -> I32 {
    let password = "secret_password"

    let hash = argon2_hash(Argon2Variant.Id, password, 3, 65536, 4)

    when hash {
        Just(h) => {
            // Verify correct password
            assert(argon2_verify(h, password))

            // Verify wrong password fails
            assert(not argon2_verify(h, "wrong_password"))
        }
        Nothing => {
            // Argon2 might not be available
        }
    }

    return 0
}

@test
func test_argon2d_variant() -> I32 {
    let password = "password"
    let salt = random_bytes(16)
    let params = Argon2Params.new(3, 65536, 1)

    let derived = argon2(Argon2Variant.D, password, salt, 32, params)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {}
    }

    salt.destroy()
    return 0
}

@test
func test_argon2i_variant() -> I32 {
    let password = "password"
    let salt = random_bytes(16)
    let params = Argon2Params.new(3, 65536, 1)

    let derived = argon2(Argon2Variant.I, password, salt, 32, params)

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {}
    }

    salt.destroy()
    return 0
}

// ============================================================================
// bcrypt Tests
// ============================================================================

@test
func test_bcrypt_hash_verify() -> I32 {
    let password = "my_secure_password"

    let hash = bcrypt_hash(password, 10)  // cost factor 10

    when hash {
        Just(h) => {
            // Hash should start with $2b$ or $2a$
            assert(h.starts_with("$2"))

            // Verify correct password
            assert(bcrypt_verify(h, password))

            // Verify wrong password fails
            assert(not bcrypt_verify(h, "wrong_password"))
        }
        Nothing => {
            // bcrypt might not be available
        }
    }

    return 0
}

@test
func test_bcrypt_different_rounds() -> I32 {
    let password = "test"

    // Lower rounds = faster but less secure
    let hash4 = bcrypt_hash(password, 4)
    let hash12 = bcrypt_hash(password, 12)

    when (hash4, hash12) {
        (Just(h4), Just(h12)) => {
            // Both should verify correctly
            assert(bcrypt_verify(h4, password))
            assert(bcrypt_verify(h12, password))

            // But they should be different hashes
            assert(h4 != h12)
        }
        _ => {}
    }

    return 0
}

@test
func test_bcrypt_unique_salts() -> I32 {
    let password = "password"

    let hash1 = bcrypt_hash(password, 10)
    let hash2 = bcrypt_hash(password, 10)

    when (hash1, hash2) {
        (Just(h1), Just(h2)) => {
            // Each hash should be unique due to random salt
            assert(h1 != h2)

            // But both should verify
            assert(bcrypt_verify(h1, password))
            assert(bcrypt_verify(h2, password))
        }
        _ => {}
    }

    return 0
}

// ============================================================================
// Edge Cases
// ============================================================================

@test
func test_kdf_empty_password() -> I32 {
    let password = ""
    let salt = Buffer.from_str("salt")

    let derived = pbkdf2(password, salt, 1000, 32, "sha256")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}

@test
func test_kdf_empty_salt() -> I32 {
    let password = "password"
    let salt = Buffer.alloc(0)

    let derived = pbkdf2(password, salt, 1000, 32, "sha256")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 32)
            key.destroy()
        }
        Nothing => {}
    }

    salt.destroy()
    return 0
}

@test
func test_kdf_large_output() -> I32 {
    let password = "password"
    let salt = random_bytes(16)

    // Derive a large key (1024 bytes)
    let derived = pbkdf2(password, salt, 1000, 1024, "sha256")

    when derived {
        Just(key) => {
            assert_eq(key.len(), 1024)
            key.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    salt.destroy()
    return 0
}
