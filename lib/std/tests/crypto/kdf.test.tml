// Tests for crypto/kdf operations
use test::{assert, assert_eq}
use std::crypto::kdf::{Argon2Variant, Argon2Params, ScryptParams, pbkdf2, pbkdf2_bytes, scrypt, scrypt_bytes, hkdf, hkdf_bytes, hkdf_extract, hkdf_expand, argon2, argon2_bytes}
use std::crypto::hash::HashAlgorithm
use std::collections::Buffer
use std::crypto::random::random_bytes

// --- Argon2Variant::name ---

@test
func test_argon2_variant_name() -> I32 {
    assert_eq(Argon2Variant::Argon2d.name(), "argon2d", "Argon2d name")
    assert_eq(Argon2Variant::Argon2i.name(), "argon2i", "Argon2i name")
    assert_eq(Argon2Variant::Argon2id.name(), "argon2id", "Argon2id name")
    return 0
}

// --- Argon2Params ---

@test
func test_argon2_params_default() -> I32 {
    let p: Argon2Params = Argon2Params::default()
    assert_eq(p.time_cost, 3 as I64, "default time_cost")
    assert_eq(p.memory_cost, 65536 as I64, "default memory_cost 64MB")
    assert_eq(p.parallelism, 4 as I64, "default parallelism")
    return 0
}

@test
func test_argon2_params_high_security() -> I32 {
    let p: Argon2Params = Argon2Params::high_security()
    assert_eq(p.time_cost, 4 as I64, "high time_cost")
    assert_eq(p.memory_cost, 131072 as I64, "high memory_cost 128MB")
    assert_eq(p.parallelism, 4 as I64, "high parallelism")
    return 0
}

@test
func test_argon2_params_low_memory() -> I32 {
    let p: Argon2Params = Argon2Params::low_memory()
    assert_eq(p.time_cost, 6 as I64, "low time_cost")
    assert_eq(p.memory_cost, 16384 as I64, "low memory_cost 16MB")
    assert_eq(p.parallelism, 2 as I64, "low parallelism")
    return 0
}

@test
func test_argon2_params_custom() -> I32 {
    let p: Argon2Params = Argon2Params::custom(10 as I64, 32768 as I64, 8 as I64)
    assert_eq(p.time_cost, 10 as I64, "custom time_cost")
    assert_eq(p.memory_cost, 32768 as I64, "custom memory_cost")
    assert_eq(p.parallelism, 8 as I64, "custom parallelism")
    return 0
}

// --- ScryptParams ---

@test
func test_scrypt_params_default() -> I32 {
    let p: ScryptParams = ScryptParams::default()
    assert_eq(p.n, 16384 as I64, "default N")
    assert_eq(p.r, 8 as I64, "default r")
    assert_eq(p.p, 1 as I64, "default p")
    assert_eq(p.maxmem, 0 as I64, "default maxmem")
    return 0
}

@test
func test_scrypt_params_high_security() -> I32 {
    let p: ScryptParams = ScryptParams::high_security()
    assert_eq(p.n, 1048576 as I64, "high N")
    assert_eq(p.r, 8 as I64, "high r")
    assert_eq(p.p, 1 as I64, "high p")
    return 0
}

@test
func test_scrypt_params_low_memory() -> I32 {
    let p: ScryptParams = ScryptParams::low_memory()
    assert_eq(p.n, 16384 as I64, "low N")
    assert_eq(p.maxmem, 33554432 as I64, "low maxmem 32MB")
    return 0
}

@test
func test_scrypt_params_custom() -> I32 {
    let p: ScryptParams = ScryptParams::custom(32768 as I64, 16 as I64, 2 as I64)
    assert_eq(p.n, 32768 as I64, "custom N")
    assert_eq(p.r, 16 as I64, "custom r")
    assert_eq(p.p, 2 as I64, "custom p")
    assert_eq(p.maxmem, 0 as I64, "custom maxmem 0")
    return 0
}

// --- Real operation tests ---

@test
func test_pbkdf2_sha256() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2("password", ref salt, 1000 as I64, 32 as I64, HashAlgorithm::Sha256)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 32 as I64, "pbkdf2 key 32 bytes")
        }
        Err(_e) => {
            assert(false, "pbkdf2 should not fail")
        }
    }
    return 0
}

@test
func test_pbkdf2_deterministic() -> I32 {
    let salt: Buffer = Buffer::from_string("fixed_salt")
    let r1 = pbkdf2("pass", ref salt, 100 as I64, 16 as I64, HashAlgorithm::Sha256)
    let r2 = pbkdf2("pass", ref salt, 100 as I64, 16 as I64, HashAlgorithm::Sha256)
    when r1 {
        Ok(k1) => {
            when r2 {
                Ok(k2) => {
                    assert_eq(k1.len(), k2.len(), "same length")
                }
                Err(_) => { assert(false, "r2 failed") }
            }
        }
        Err(_) => { assert(false, "r1 failed") }
    }
    return 0
}

@test
func test_scrypt_derive() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let params: ScryptParams = ScryptParams::default()
    let result = scrypt("password", ref salt, 32 as I64, params)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 32 as I64, "scrypt key 32 bytes")
        }
        Err(_e) => {
            assert(false, "scrypt should not fail")
        }
    }
    return 0
}

@test
func test_hkdf_sha256() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let result = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "info", 64 as I64)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 64 as I64, "hkdf key 64 bytes")
        }
        Err(_e) => {
            assert(false, "hkdf should not fail")
        }
    }
    return 0
}

// --- pbkdf2_bytes ---

@test
func test_pbkdf2_bytes() -> I32 {
    let password: Buffer = Buffer::from_string("password")
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2_bytes(ref password, ref salt, 1000 as I64, 32 as I64, HashAlgorithm::Sha256)
    assert(result.is_ok(), "pbkdf2_bytes should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 32 as I64, "pbkdf2_bytes key 32 bytes")
    return 0
}

// --- scrypt_bytes ---

@test
func test_scrypt_bytes() -> I32 {
    let password: Buffer = Buffer::from_string("password")
    let salt: Buffer = random_bytes(16 as I64)
    let params: ScryptParams = ScryptParams::default()
    let result = scrypt_bytes(ref password, ref salt, 32 as I64, ref params)
    assert(result.is_ok(), "scrypt_bytes should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 32 as I64, "scrypt_bytes key 32 bytes")
    return 0
}

// --- hkdf_bytes / hkdf_extract / hkdf_expand ---

@test
func test_hkdf_bytes() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let info: Buffer = Buffer::from_string("context info")
    let result = hkdf_bytes(HashAlgorithm::Sha256, ref ikm, ref salt, ref info, 64 as I64)
    assert(result.is_ok(), "hkdf_bytes should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 64 as I64, "hkdf_bytes key 64 bytes")
    return 0
}

@test
func test_hkdf_extract() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let result = hkdf_extract(HashAlgorithm::Sha256, ref ikm, ref salt)
    assert(result.is_ok(), "hkdf_extract should succeed")
    let prk: Buffer = result.unwrap()
    assert(prk.len() > (0 as I64), "PRK not empty")
    return 0
}

@test
func test_hkdf_expand() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let prk: Buffer = hkdf_extract(HashAlgorithm::Sha256, ref ikm, ref salt).unwrap()
    let info: Buffer = Buffer::from_string("expand info")
    let result = hkdf_expand(HashAlgorithm::Sha256, ref prk, ref info, 48 as I64)
    assert(result.is_ok(), "hkdf_expand should succeed")
    let okm: Buffer = result.unwrap()
    assert_eq(okm.len(), 48 as I64, "hkdf_expand output 48 bytes")
    return 0
}

// --- PBKDF2 with different hash algorithms ---

@test
func test_pbkdf2_sha512() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2("password", ref salt, 1000 as I64, 64 as I64, HashAlgorithm::Sha512)
    assert(result.is_ok(), "pbkdf2 sha512 should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 64 as I64, "pbkdf2 sha512 key 64 bytes")
    return 0
}

@test
func test_pbkdf2_sha384() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2("password", ref salt, 1000 as I64, 48 as I64, HashAlgorithm::Sha384)
    assert(result.is_ok(), "pbkdf2 sha384 should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 48 as I64, "pbkdf2 sha384 key 48 bytes")
    return 0
}

@test
func test_pbkdf2_sha1() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2("password", ref salt, 1000 as I64, 20 as I64, HashAlgorithm::Sha1)
    assert(result.is_ok(), "pbkdf2 sha1 should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 20 as I64, "pbkdf2 sha1 key 20 bytes")
    return 0
}

// --- HKDF with SHA512 ---

@test
func test_hkdf_sha512() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let result = hkdf(HashAlgorithm::Sha512, ref ikm, ref salt, "info", 64 as I64)
    assert(result.is_ok(), "hkdf sha512 should succeed")
    let key: Buffer = result.unwrap()
    assert_eq(key.len(), 64 as I64, "hkdf sha512 key 64 bytes")
    return 0
}

// --- HKDF determinism ---

@test
func test_hkdf_deterministic() -> I32 {
    let ikm: Buffer = Buffer::from_string("input key material")
    let salt: Buffer = Buffer::from_string("fixed_salt")
    let r1 = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "ctx", 32 as I64)
    let r2 = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "ctx", 32 as I64)
    assert(r1.is_ok(), "hkdf r1 ok")
    assert(r2.is_ok(), "hkdf r2 ok")
    let k1: Buffer = r1.unwrap()
    let k2: Buffer = r2.unwrap()
    assert_eq(k1.len(), k2.len(), "hkdf deterministic same length")
    return 0
}

// --- scrypt determinism ---

@test
func test_scrypt_deterministic() -> I32 {
    let salt: Buffer = Buffer::from_string("fixed_salt")
    let params: ScryptParams = ScryptParams::default()
    let r1 = scrypt("pass", ref salt, 32 as I64, params)
    let r2 = scrypt("pass", ref salt, 32 as I64, params)
    assert(r1.is_ok(), "scrypt r1 ok")
    assert(r2.is_ok(), "scrypt r2 ok")
    let k1: Buffer = r1.unwrap()
    let k2: Buffer = r2.unwrap()
    assert_eq(k1.len(), k2.len(), "scrypt deterministic same length")
    return 0
}

// --- argon2 ---
// NOTE: argon2/argon2_bytes may fail on OpenSSL < 3.2.
// We call them to exercise the code path for coverage regardless.

@test
func test_argon2_call() -> I32 {
    let salt: Buffer = Buffer::from_string("fixed_salt_16!!")
    let params: Argon2Params = Argon2Params::low_memory()
    let result = argon2(Argon2Variant::Argon2id, "password", ref salt, 32 as I64, ref params)
    // Either Ok or Err is fine - we just want to exercise the function
    if result.is_ok() {
        let key: Buffer = result.unwrap()
        assert_eq(key.len(), 32 as I64, "argon2 key 32 bytes")
    }
    return 0
}

@test
func test_argon2_bytes_call() -> I32 {
    let password: Buffer = Buffer::from_string("password")
    let salt: Buffer = Buffer::from_string("fixed_salt_16!!")
    let params: Argon2Params = Argon2Params::low_memory()
    let result = argon2_bytes(Argon2Variant::Argon2id, ref password, ref salt, 32 as I64, ref params)
    // Either Ok or Err is fine - we just want to exercise the function
    if result.is_ok() {
        let key: Buffer = result.unwrap()
        assert_eq(key.len(), 32 as I64, "argon2_bytes key 32 bytes")
    }
    return 0
}
