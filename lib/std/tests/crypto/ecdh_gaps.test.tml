// Tests for uncovered crypto/ecdh enum methods
use test::{assert, assert_eq}
use std::crypto::ecdh::{EcCurve, EcPointFormat}

// --- EcCurve::name ---

@test
func test_ec_curve_name() -> I32 {
    assert_eq(EcCurve::P256.name(), "prime256v1", "P256 name")
    assert_eq(EcCurve::P384.name(), "secp384r1", "P384 name")
    assert_eq(EcCurve::P521.name(), "secp521r1", "P521 name")
    assert_eq(EcCurve::Secp256k1.name(), "secp256k1", "Secp256k1 name")
    assert_eq(EcCurve::X25519.name(), "X25519", "X25519 name")
    assert_eq(EcCurve::X448.name(), "X448", "X448 name")
    return 0
}

// --- EcCurve::key_bits ---

@test
func test_ec_curve_key_bits() -> I32 {
    assert_eq(EcCurve::P256.key_bits(), 256 as I64, "P256 bits")
    assert_eq(EcCurve::P384.key_bits(), 384 as I64, "P384 bits")
    assert_eq(EcCurve::P521.key_bits(), 521 as I64, "P521 bits")
    assert_eq(EcCurve::X25519.key_bits(), 256 as I64, "X25519 bits")
    assert_eq(EcCurve::X448.key_bits(), 448 as I64, "X448 bits")
    return 0
}

// --- EcCurve::shared_secret_size ---

@test
func test_ec_curve_shared_secret_size() -> I32 {
    assert_eq(EcCurve::P256.shared_secret_size(), 32 as I64, "P256 secret")
    assert_eq(EcCurve::P384.shared_secret_size(), 48 as I64, "P384 secret")
    assert_eq(EcCurve::P521.shared_secret_size(), 66 as I64, "P521 secret")
    assert_eq(EcCurve::X25519.shared_secret_size(), 32 as I64, "X25519 secret")
    assert_eq(EcCurve::X448.shared_secret_size(), 56 as I64, "X448 secret")
    return 0
}

// --- EcCurve::is_modern ---

@test
func test_ec_curve_is_modern() -> I32 {
    assert(EcCurve::X25519.is_modern(), "X25519 modern")
    assert(EcCurve::X448.is_modern(), "X448 modern")
    assert(not EcCurve::P256.is_modern(), "P256 not modern")
    assert(not EcCurve::Secp256k1.is_modern(), "secp256k1 not modern")
    return 0
}

// --- EcCurve::from_name ---

@test
func test_ec_curve_from_name_valid() -> I32 {
    let p256: Maybe[EcCurve] = EcCurve::from_name("prime256v1")
    assert(p256.is_just(), "prime256v1 found")
    let p256b: Maybe[EcCurve] = EcCurve::from_name("P-256")
    assert(p256b.is_just(), "P-256 found")
    let x25519: Maybe[EcCurve] = EcCurve::from_name("X25519")
    assert(x25519.is_just(), "X25519 found")
    let x25519b: Maybe[EcCurve] = EcCurve::from_name("x25519")
    assert(x25519b.is_just(), "x25519 lowercase found")
    return 0
}

@test
func test_ec_curve_from_name_invalid() -> I32 {
    let result: Maybe[EcCurve] = EcCurve::from_name("invalid")
    assert(result.is_nothing(), "invalid curve is Nothing")
    return 0
}

// --- EcPointFormat::name ---

@test
func test_ec_point_format_name() -> I32 {
    assert_eq(EcPointFormat::Uncompressed.name(), "uncompressed", "Uncompressed")
    assert_eq(EcPointFormat::Compressed.name(), "compressed", "Compressed")
    assert_eq(EcPointFormat::Hybrid.name(), "hybrid", "Hybrid")
    return 0
}

// --- EcCurve Brainpool ---

@test
func test_ec_curve_brainpool() -> I32 {
    assert_eq(EcCurve::BrainpoolP256r1.name(), "brainpoolP256r1", "BP256 name")
    assert_eq(EcCurve::BrainpoolP384r1.name(), "brainpoolP384r1", "BP384 name")
    assert_eq(EcCurve::BrainpoolP512r1.name(), "brainpoolP512r1", "BP512 name")
    assert_eq(EcCurve::BrainpoolP256r1.key_bits(), 256 as I64, "BP256 bits")
    assert_eq(EcCurve::BrainpoolP512r1.key_bits(), 512 as I64, "BP512 bits")
    assert_eq(EcCurve::BrainpoolP256r1.shared_secret_size(), 32 as I64, "BP256 secret")
    assert_eq(EcCurve::BrainpoolP384r1.shared_secret_size(), 48 as I64, "BP384 secret")
    assert_eq(EcCurve::BrainpoolP512r1.shared_secret_size(), 64 as I64, "BP512 secret")
    return 0
}

// NOTE: Ecdh object, compute_secret, generate_keys, convert_ec_key,
// x25519, x448, generate_x25519_keypair, etc. are FFI-dependent
