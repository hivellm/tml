//! Tests for crypto X.509 certificate functions
//!
//! Covers certificate parsing from PEM format, subject/issuer field extraction,
//! serial number, validity dates, fingerprints, signature algorithm,
//! PEM roundtrip export, verification, and certificate store operations.
//! Requires OpenSSL runtime libraries for parsing functionality.

use test::{assert, assert_eq}
use std::crypto::x509::{X509Certificate, X509Name, X509Store, KeyUsage}

// ============================================================================
// Test certificate (self-signed RSA 2048-bit CA, valid 2026-02-10 to 2036-02-08)
//
// Subject: CN=test.example.com, O=TML Test Org, C=US, ST=California, L=San Francisco
// Issuer:  (same, self-signed)
// Serial:  6823D594E231E423C3159AB53DAF3C1EE9D7D14B
// Sig Alg: sha256WithRSAEncryption
// CA: true, KeyUsage: keyCertSign, cRLSign, digitalSignature
// ============================================================================

func get_test_cert_pem() -> Str {
    return "-----BEGIN CERTIFICATE-----\nMIIDyTCCArGgAwIBAgIUaCPVlOIx5CPDFZq1Pa88HunX0UswDQYJKoZIhvcNAQEL\nBQAwbDEZMBcGA1UEAwwQdGVzdC5leGFtcGxlLmNvbTEVMBMGA1UECgwMVE1MIFRl\nc3QgT3JnMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UE\nBwwNU2FuIEZyYW5jaXNjbzAeFw0yNjAyMTAxMTIyNTVaFw0zNjAyMDgxMTIyNTVa\nMGwxGTAXBgNVBAMMEHRlc3QuZXhhbXBsZS5jb20xFTATBgNVBAoMDFRNTCBUZXN0\nIE9yZzELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM\nDVNhbiBGcmFuY2lzY28wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC0\nCdN1Q9zDtNHRfCEkUvX1oNCOoX1HAi4jtsrQd2WRC/BmPWeZtylPy+X+PJ2t340o\ndgZ7ec5aP+/0fsrq6fA2f6VtMOeEV/kP44jkzEDmmcGLxEyl6nfbL4twyc0+IkSy\nzZgw28P809G3/NxXg+PQS2DRgVoWuaqvWoOEmx0R/jGvSrNsMwbHc1vBN525flOu\n6dPErbIKYHRJmvHF+HqxADi47jl1roBLeBia5+WGY+koWA2bq2a/JGIGgXabDgFu\nOuGmNvcEFM6lm45nCqWxwLEN2Ij81ZrUhk1JJxqfSC0YBva6mwBjP0rAqSrR5OLO\nCLd0B3RSCBVu01ejiuTfAgMBAAGjYzBhMB0GA1UdDgQWBBRH3/kmqJpIR/A28aiZ\nYQpZILLrAzAfBgNVHSMEGDAWgBRH3/kmqJpIR/A28aiZYQpZILLrAzAPBgNVHRMB\nAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAQEAegD/\nPDDhy12rpq/MC9bcq+hMlGBAFzrk1rcouu5Tlqcmv4pAJi6U8VXf4NSccHtw6uDC\nyc3PdW2PxFERnbChyhtvC9z9z6DlywVfath1WnOcABm87gLYN2H4nlLlfy5PEx8n\npEhblS7go+LmNLgobGO5Kc+oGf5ifU9VImaRcQEMCGGOiubtsiI5kv+HU0JRPwhR\nxhEe266ktBt4785HOJ3kB/yPjXNZjrHv6hWWYkyhj5DVgE1XICWRAcjq88L5dzpx\nCs053i7wUgjToNXGW7jGAxtU9AOgPQGgFhlXF1PbDBc3oj4A+fxXs1xpyyHQ2x97\nZUrbOqIoKzjUm7+kNw==\n-----END CERTIFICATE-----\n"
}

// Helper: parse cert or fail test
func parse_test_cert() -> X509Certificate {
    let pem = get_test_cert_pem()
    let result = X509Certificate::from_pem(pem)
    assert(result.is_ok(), "failed to parse test cert PEM")
    return result.unwrap()
}

// ============================================================================
// Batch 1: Parse PEM and subject/issuer field extraction
// ============================================================================

@test
func test_x509_parse_pem_succeeds() -> I32 {
    let pem = get_test_cert_pem()
    let result = X509Certificate::from_pem(pem)
    assert(result.is_ok(), "should parse valid PEM cert")
    return 0
}

@test
func test_x509_parse_invalid_pem_fails() -> I32 {
    let result = X509Certificate::from_pem("not a certificate")
    assert(result.is_err(), "should fail on invalid PEM")
    return 0
}

@test
func test_x509_parse_empty_pem_fails() -> I32 {
    let result = X509Certificate::from_pem("")
    assert(result.is_err(), "should fail on empty PEM")
    return 0
}

@test
func test_x509_subject_cn() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let cn: Str = cert.subject().cn()
    assert_eq(cn, "test.example.com", "subject CN")
    cert.destroy()
    return 0
}

@test
func test_x509_subject_org() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let org: Str = cert.subject().org()
    assert_eq(org, "TML Test Org", "subject O")
    cert.destroy()
    return 0
}

@test
func test_x509_issuer_cn_self_signed() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let cn: Str = cert.issuer().cn()
    assert_eq(cn, "test.example.com", "issuer CN matches subject")
    cert.destroy()
    return 0
}

// ============================================================================
// Batch 2: Serial number, dates, fingerprints
// ============================================================================

@test
func test_x509_serial_number() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let serial: Str = cert.serial_number()
    assert_eq(serial, "6823D594E231E423C3159AB53DAF3C1EE9D7D14B", "serial number")
    cert.destroy()
    return 0
}

@test
func test_x509_valid_from() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let from: Str = cert.valid_from()
    assert_eq(from, "2026-02-10T11:22:55Z", "not before date")
    cert.destroy()
    return 0
}

@test
func test_x509_valid_to() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let not_after: Str = cert.valid_to()
    assert_eq(not_after, "2036-02-08T11:22:55Z", "not after date")
    cert.destroy()
    return 0
}

@test
func test_x509_fingerprint_sha1() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let fp: Str = cert.fingerprint()
    assert_eq(fp, "a6:f7:ce:5f:ec:f0:78:29:8d:d3:e4:f3:63:22:75:26:1b:47:e7:5c", "SHA-1 fingerprint")
    cert.destroy()
    return 0
}

@test
func test_x509_fingerprint_sha256() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let fp: Str = cert.fingerprint256()
    assert_eq(fp, "e7:26:e7:40:00:7e:24:b3:6f:24:22:f6:86:72:0e:84:79:2a:f8:e0:34:61:c7:49:dd:74:6d:51:b3:5a:21:e7", "SHA-256 fingerprint")
    cert.destroy()
    return 0
}

// ============================================================================
// Batch 3: Signature algorithm, CA flag, key usage, PEM roundtrip
// ============================================================================

@test
func test_x509_signature_algorithm() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let alg: Str = cert.signature_algorithm()
    assert_eq(alg, "RSA-SHA256", "signature algorithm")
    cert.destroy()
    return 0
}

@test
func test_x509_is_ca() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    assert(cert.is_ca(), "test cert should be a CA")
    cert.destroy()
    return 0
}

@test
func test_x509_key_usage() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let ku: KeyUsage = cert.key_usage()
    assert(ku.digital_signature, "should have digitalSignature")
    assert(ku.key_cert_sign, "should have keyCertSign")
    assert(ku.crl_sign, "should have cRLSign")
    assert(not ku.key_encipherment, "should not have keyEncipherment")
    assert(not ku.data_encipherment, "should not have dataEncipherment")
    cert.destroy()
    return 0
}

@test
func test_x509_to_pem_roundtrip() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let pem_out: Str = cert.to_pem()
    // Re-parse the exported PEM
    let result2 = X509Certificate::from_pem(pem_out)
    assert(result2.is_ok(), "should re-parse exported PEM")
    let mut cert2: X509Certificate = result2.unwrap()
    // Check that key fields match
    assert_eq(cert2.subject().cn(), "test.example.com", "roundtrip subject CN")
    assert_eq(cert2.serial_number(), cert.serial_number(), "roundtrip serial")
    cert2.destroy()
    cert.destroy()
    return 0
}

// ============================================================================
// Batch 4: Verification, store, is_valid_now
// ============================================================================

@test
func test_x509_is_valid_now() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    // Cert valid 2026-02-10 to 2036-02-08, so it should be valid today (2026-02-10)
    assert(cert.is_valid_now(), "cert should be currently valid")
    cert.destroy()
    return 0
}

@test
func test_x509_self_signed_check_issued() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    // Self-signed cert: check_issued(self) should be true
    let issued: Bool = cert.check_issued(ref cert)
    assert(issued, "self-signed cert should pass check_issued against itself")
    cert.destroy()
    return 0
}

@test
func test_x509_store_add_and_verify() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let mut store: X509Store = X509Store::new()
    let add_result = store.add_cert(ref cert)
    assert(add_result.is_ok(), "should add cert to store")
    // Verify self-signed cert against store containing itself
    let verify_result = store.verify(ref cert)
    assert(verify_result.is_ok(), "verify should not error")
    let verified: Bool = verify_result.unwrap()
    assert(verified, "self-signed cert should verify against store containing it")
    store.destroy()
    cert.destroy()
    return 0
}

@test
func test_x509_valid_from_timestamp() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let ts: I64 = cert.valid_from_date()
    // 2026-02-10T11:22:55Z in Unix time is approximately 1770682975
    assert(ts > 1770000000, "valid_from timestamp should be reasonable")
    assert(ts < 1780000000, "valid_from timestamp should be reasonable")
    cert.destroy()
    return 0
}

@test
func test_x509_valid_to_timestamp() -> I32 {
    let mut cert: X509Certificate = parse_test_cert()
    let ts: I64 = cert.valid_to_date()
    // 2036-02-08T11:22:55Z should be roughly 10 years later
    assert(ts > 2080000000, "valid_to timestamp should be ~10 years later")
    cert.destroy()
    return 0
}
