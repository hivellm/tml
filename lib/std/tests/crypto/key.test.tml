//! Tests for crypto key management functions
//!
//! Tests key generation, import/export, and key formats.

use std::crypto::{generate_key_pair, generate_secret_key, KeyType}
use std::crypto::{SecretKey, PrivateKey, PublicKey, KeyPair}
use std::crypto::random_bytes
use std::collections::Buffer
use test::{assert, assert_eq}

// ============================================================================
// Secret Key Generation Tests
// ============================================================================

@test
func test_generate_secret_key_aes128() -> I32 {
    let key = generate_secret_key(KeyType.Aes128)

    when key {
        Just(k) => {
            assert_eq(k.len(), 16)
            k.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    return 0
}

@test
func test_generate_secret_key_aes256() -> I32 {
    let key = generate_secret_key(KeyType.Aes256)

    when key {
        Just(k) => {
            assert_eq(k.len(), 32)
            k.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    return 0
}

@test
func test_generate_secret_key_hmac() -> I32 {
    let key = generate_secret_key(KeyType.Hmac256)

    when key {
        Just(k) => {
            assert_eq(k.len(), 32)
            k.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    return 0
}

@test
func test_secret_key_uniqueness() -> I32 {
    let key1 = generate_secret_key(KeyType.Aes256)
    let key2 = generate_secret_key(KeyType.Aes256)

    when (key1, key2) {
        (Just(k1), Just(k2)) => {
            // Keys should be different
            assert(not k1.equals(k2))
            k1.destroy()
            k2.destroy()
        }
        _ => {
            assert(false)
        }
    }

    return 0
}

// ============================================================================
// Key Pair Generation Tests
// ============================================================================

@test
func test_generate_key_pair_rsa2048() -> I32 {
    let key_pair = generate_key_pair(KeyType.Rsa2048)

    when key_pair {
        Just(kp) => {
            // RSA 2048-bit private key is typically ~1200 bytes in DER format
            assert(kp.private_key.len() > 100)
            assert(kp.public_key.len() > 100)
            kp.destroy()
        }
        Nothing => {
            // RSA key generation might not be available
        }
    }

    return 0
}

@test
func test_generate_key_pair_rsa4096() -> I32 {
    let key_pair = generate_key_pair(KeyType.Rsa4096)

    when key_pair {
        Just(kp) => {
            // RSA 4096-bit keys are larger
            assert(kp.private_key.len() > 500)
            assert(kp.public_key.len() > 500)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_generate_key_pair_ec_p256() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            // P-256 private key is 32 bytes, public key is 65 bytes (uncompressed)
            assert(kp.private_key.len() > 0)
            assert(kp.public_key.len() > 0)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_generate_key_pair_ec_p384() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP384)

    when key_pair {
        Just(kp) => {
            assert(kp.private_key.len() > 0)
            assert(kp.public_key.len() > 0)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_generate_key_pair_ec_p521() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP521)

    when key_pair {
        Just(kp) => {
            assert(kp.private_key.len() > 0)
            assert(kp.public_key.len() > 0)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_generate_key_pair_ed25519() -> I32 {
    let key_pair = generate_key_pair(KeyType.Ed25519)

    when key_pair {
        Just(kp) => {
            // Ed25519 private key is 32 bytes, public key is 32 bytes
            assert_eq(kp.private_key.len(), 32)
            assert_eq(kp.public_key.len(), 32)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_generate_key_pair_x25519() -> I32 {
    let key_pair = generate_key_pair(KeyType.X25519)

    when key_pair {
        Just(kp) => {
            // X25519 keys are 32 bytes each
            assert_eq(kp.private_key.len(), 32)
            assert_eq(kp.public_key.len(), 32)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Key Export Tests
// ============================================================================

@test
func test_secret_key_export_raw() -> I32 {
    let key = generate_secret_key(KeyType.Aes256)

    when key {
        Just(k) => {
            let raw = k.export_raw()
            assert_eq(raw.len(), 32)

            // Should be able to import back
            let imported = SecretKey.from_raw(raw)
            assert(k.equals(imported))

            raw.destroy()
            imported.destroy()
            k.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    return 0
}

@test
func test_private_key_export_der() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let der = kp.private_key.export_der()
            when der {
                Just(d) => {
                    assert(d.len() > 0)
                    d.destroy()
                }
                Nothing => {}
            }
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_private_key_export_pem() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let pem = kp.private_key.export_pem()
            when pem {
                Just(p) => {
                    // PEM should start with -----BEGIN
                    assert(p.starts_with("-----BEGIN"))
                }
                Nothing => {}
            }
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_public_key_export_der() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let der = kp.public_key.export_der()
            when der {
                Just(d) => {
                    assert(d.len() > 0)
                    d.destroy()
                }
                Nothing => {}
            }
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_public_key_export_pem() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let pem = kp.public_key.export_pem()
            when pem {
                Just(p) => {
                    assert(p.starts_with("-----BEGIN"))
                }
                Nothing => {}
            }
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Key Import Tests
// ============================================================================

@test
func test_secret_key_import_raw() -> I32 {
    let raw = random_bytes(32)
    let key = SecretKey.from_raw(raw)

    assert_eq(key.len(), 32)
    assert(key.export_raw().equals(raw))

    raw.destroy()
    key.destroy()
    return 0
}

@test
func test_key_pair_roundtrip() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            // Export private key
            let der = kp.private_key.export_der()

            when der {
                Just(d) => {
                    // Import back
                    let imported = PrivateKey.from_der(d)

                    when imported {
                        Just(pk) => {
                            // Keys should be equivalent
                            let der2 = pk.export_der()
                            when der2 {
                                Just(d2) => {
                                    assert(d.equals(d2))
                                    d2.destroy()
                                }
                                Nothing => {}
                            }
                            pk.destroy()
                        }
                        Nothing => {}
                    }

                    d.destroy()
                }
                Nothing => {}
            }

            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Key Properties Tests
// ============================================================================

@test
func test_key_type_detection() -> I32 {
    let ec_key = generate_key_pair(KeyType.EcP256)
    let rsa_key = generate_key_pair(KeyType.Rsa2048)

    when ec_key {
        Just(kp) => {
            assert_eq(kp.key_type(), KeyType.EcP256)
            kp.destroy()
        }
        Nothing => {}
    }

    when rsa_key {
        Just(kp) => {
            assert_eq(kp.key_type(), KeyType.Rsa2048)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_key_bit_length() -> I32 {
    let rsa2048 = generate_key_pair(KeyType.Rsa2048)
    let rsa4096 = generate_key_pair(KeyType.Rsa4096)
    let ec256 = generate_key_pair(KeyType.EcP256)

    when rsa2048 {
        Just(kp) => {
            assert_eq(kp.bit_length(), 2048)
            kp.destroy()
        }
        Nothing => {}
    }

    when rsa4096 {
        Just(kp) => {
            assert_eq(kp.bit_length(), 4096)
            kp.destroy()
        }
        Nothing => {}
    }

    when ec256 {
        Just(kp) => {
            assert_eq(kp.bit_length(), 256)
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Key Derivation Tests
// ============================================================================

@test
func test_derive_public_from_private() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            // Derive public key from private key
            let derived_pub = kp.private_key.derive_public_key()

            when derived_pub {
                Just(pub_key) => {
                    // Should match the original public key
                    let orig_der = kp.public_key.export_der()
                    let derived_der = pub_key.export_der()

                    when (orig_der, derived_der) {
                        (Just(o), Just(d)) => {
                            assert(o.equals(d))
                            o.destroy()
                            d.destroy()
                        }
                        _ => {}
                    }

                    pub_key.destroy()
                }
                Nothing => {}
            }

            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Secure Key Handling Tests
// ============================================================================

@test
func test_key_zeroize_on_destroy() -> I32 {
    // This is hard to test directly, but we can at least verify
    // that the key is properly initialized and destroyed without errors
    let key = generate_secret_key(KeyType.Aes256)

    when key {
        Just(k) => {
            // Get a copy of the raw bytes before destroy
            let raw = k.export_raw()
            assert_eq(raw.len(), 32)

            k.destroy()
            raw.destroy()
        }
        Nothing => {
            assert(false)
        }
    }

    return 0
}

// ============================================================================
// JWK Format Tests
// ============================================================================

@test
func test_public_key_export_jwk() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let jwk = kp.public_key.export_jwk()

            when jwk {
                Just(j) => {
                    // JWK should contain kty field
                    assert(j.contains("\"kty\""))
                    // For EC keys, should have crv field
                    assert(j.contains("\"crv\""))
                }
                Nothing => {}
            }

            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_private_key_export_jwk() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let jwk = kp.private_key.export_jwk()

            when jwk {
                Just(j) => {
                    // JWK should contain kty and d (private component)
                    assert(j.contains("\"kty\""))
                    assert(j.contains("\"d\""))
                }
                Nothing => {}
            }

            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}
