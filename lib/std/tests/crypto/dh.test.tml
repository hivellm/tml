// Tests for crypto Diffie-Hellman key exchange
use test::{assert, assert_eq}
use std::crypto::dh::{DhGroup, DiffieHellman, create_dh, create_dh_group, get_dh_group_params, diffie_hellman}
use std::collections::Buffer

// --- DhGroup enum tests (pure TML, no OpenSSL) ---

@test
func test_dh_group_names() -> I32 {
    assert_eq(DhGroup::Modp1.name(), "modp1", "modp1")
    assert_eq(DhGroup::Modp2.name(), "modp2", "modp2")
    assert_eq(DhGroup::Modp5.name(), "modp5", "modp5")
    assert_eq(DhGroup::Modp14.name(), "modp14", "modp14")
    assert_eq(DhGroup::Modp15.name(), "modp15", "modp15")
    assert_eq(DhGroup::Modp16.name(), "modp16", "modp16")
    assert_eq(DhGroup::Modp17.name(), "modp17", "modp17")
    assert_eq(DhGroup::Modp18.name(), "modp18", "modp18")
    assert_eq(DhGroup::Ffdhe2048.name(), "ffdhe2048", "ffdhe2048")
    assert_eq(DhGroup::Ffdhe3072.name(), "ffdhe3072", "ffdhe3072")
    assert_eq(DhGroup::Ffdhe4096.name(), "ffdhe4096", "ffdhe4096")
    assert_eq(DhGroup::Ffdhe6144.name(), "ffdhe6144", "ffdhe6144")
    assert_eq(DhGroup::Ffdhe8192.name(), "ffdhe8192", "ffdhe8192")
    return 0
}

@test
func test_dh_group_prime_bits() -> I32 {
    assert_eq(DhGroup::Modp14.prime_bits(), 2048 as I64, "modp14 bits")
    assert_eq(DhGroup::Ffdhe2048.prime_bits(), 2048 as I64, "ffdhe2048 bits")
    assert_eq(DhGroup::Ffdhe4096.prime_bits(), 4096 as I64, "ffdhe4096 bits")
    return 0
}

@test
func test_dh_group_deprecated() -> I32 {
    assert(DhGroup::Modp1.is_deprecated(), "modp1 deprecated")
    assert(DhGroup::Modp2.is_deprecated(), "modp2 deprecated")
    assert(not DhGroup::Modp14.is_deprecated(), "modp14 not deprecated")
    assert(not DhGroup::Ffdhe2048.is_deprecated(), "ffdhe2048 not deprecated")
    return 0
}

@test
func test_dh_group_from_name() -> I32 {
    let m14: Maybe[DhGroup] = DhGroup::from_name("modp14")
    assert(m14.is_just(), "modp14 found")
    assert_eq(m14.unwrap().name(), "modp14", "modp14 roundtrip")
    let ff: Maybe[DhGroup] = DhGroup::from_name("ffdhe2048")
    assert(ff.is_just(), "ffdhe2048 found")
    assert_eq(ff.unwrap().name(), "ffdhe2048", "ffdhe2048 roundtrip")
    let invalid: Maybe[DhGroup] = DhGroup::from_name("invalid")
    assert(invalid.is_nothing(), "invalid is Nothing")
    return 0
}

// --- DH with_group and accessors (uses OpenSSL named group â€” instant, no prime gen) ---

@test
func test_dh_with_group() -> I32 {
    let dh: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    assert_eq(dh.prime_length(), 2048 as I64, "ffdhe2048 prime length")
    assert(dh.check_params(), "ffdhe2048 params valid")
    assert_eq(dh.verify_error(), 0 as I64, "no verify errors")
    let p: Buffer = dh.prime()
    assert(p.len() > (0 as I64), "prime not empty")
    let g: Buffer = dh.generator()
    assert(g.len() > (0 as I64), "generator not empty")
    let grp: Maybe[DhGroup] = dh.group()
    assert(grp.is_just(), "group should be Just")
    return 0
}

// --- DH keygen and compute_secret ---

@test
func test_dh_keygen_and_exchange() -> I32 {
    let mut alice: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    alice.generate_keys()
    let alice_pub: Buffer = alice.public_key()
    assert(alice_pub.len() > (0 as I64), "alice pub not empty")

    let mut bob: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    bob.generate_keys()
    let bob_pub: Buffer = bob.public_key()
    assert(bob_pub.len() > (0 as I64), "bob pub not empty")

    let a_secret: Buffer = alice.compute_secret(ref bob_pub).unwrap()
    let b_secret: Buffer = bob.compute_secret(ref alice_pub).unwrap()
    assert(a_secret.len() > (0 as I64), "secret not empty")
    assert_eq(a_secret.len(), b_secret.len(), "secrets same length")

    alice.destroy()
    bob.destroy()
    return 0
}

// --- DH double destroy is safe ---

@test
func test_dh_destroy_safe() -> I32 {
    let mut dh: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    dh.destroy()
    dh.destroy()
    return 0
}

// --- create_dh with custom params ---

@test
func test_dh_custom_params() -> I32 {
    let dh_source: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    let p: Buffer = dh_source.prime()
    let g: Buffer = dh_source.generator()
    let result = create_dh(ref p, ref g)
    assert(result.is_ok(), "create_dh should succeed")
    let dh: DiffieHellman = result.unwrap()
    assert(dh.check_params(), "custom params valid")
    return 0
}

// --- diffie_hellman convenience function ---

@test
func test_diffie_hellman_func() -> I32 {
    let mut dh1: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    dh1.generate_keys()
    let priv_key: Buffer = dh1.private_key()
    let prime: Buffer = dh1.prime()
    let gen: Buffer = dh1.generator()

    let mut dh2: DiffieHellman = DiffieHellman::with_group(DhGroup::Ffdhe2048).unwrap()
    dh2.generate_keys()
    let pub_key: Buffer = dh2.public_key()

    let result = diffie_hellman(ref priv_key, ref pub_key, ref prime, ref gen)
    assert(result.is_ok(), "diffie_hellman should succeed")
    let secret: Buffer = result.unwrap()
    assert(secret.len() > (0 as I64), "DH secret not empty")

    dh1.destroy()
    dh2.destroy()
    return 0
}
