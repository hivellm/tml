//! Tests for crypto Diffie-Hellman key exchange
//!
//! Tests DH key generation and shared secret computation.

use std::crypto::{DiffieHellman, DhGroup}
use std::crypto::random_bytes
use std::collections::Buffer
use test::{assert, assert_eq}

// ============================================================================
// DH Key Generation Tests
// ============================================================================

@test
func test_dh_modp2048_generate() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            // Generate key pair
            d.generate_keys()

            let public_key = d.get_public_key()
            let private_key = d.get_private_key()

            when (public_key, private_key) {
                (Just(pub_key), Just(priv_key)) => {
                    // MODP2048 keys should be 256 bytes
                    assert_eq(pub_key.len(), 256)
                    assert(priv_key.len() > 0)

                    pub_key.destroy()
                    priv_key.destroy()
                }
                _ => {
                    assert(false)
                }
            }

            d.destroy()
        }
        Nothing => {
            // DH might not be available
        }
    }

    return 0
}

@test
func test_dh_modp3072_generate() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP3072)

    when dh {
        Just(d) => {
            d.generate_keys()

            let public_key = d.get_public_key()
            when public_key {
                Just(pk) => {
                    // MODP3072 keys should be 384 bytes
                    assert_eq(pk.len(), 384)
                    pk.destroy()
                }
                Nothing => {}
            }

            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// DH Key Exchange Tests
// ============================================================================

@test
func test_dh_key_exchange() -> I32 {
    let alice = DiffieHellman.create(DhGroup.ModP2048)
    let bob = DiffieHellman.create(DhGroup.ModP2048)

    when (alice, bob) {
        (Just(a), Just(b)) => {
            // Both parties generate their key pairs
            a.generate_keys()
            b.generate_keys()

            let alice_pub = a.get_public_key()
            let bob_pub = b.get_public_key()

            when (alice_pub, bob_pub) {
                (Just(ap), Just(bp)) => {
                    // Compute shared secrets
                    let alice_secret = a.compute_secret(bp)
                    let bob_secret = b.compute_secret(ap)

                    when (alice_secret, bob_secret) {
                        (Just(as_), Just(bs)) => {
                            // Shared secrets should be equal
                            assert(as_.equals(bs))
                            assert(as_.len() > 0)

                            as_.destroy()
                            bs.destroy()
                        }
                        _ => {
                            assert(false)
                        }
                    }

                    ap.destroy()
                    bp.destroy()
                }
                _ => {}
            }

            a.destroy()
            b.destroy()
        }
        _ => {}
    }

    return 0
}

@test
func test_dh_different_parties_different_secrets() -> I32 {
    let alice = DiffieHellman.create(DhGroup.ModP2048)
    let bob = DiffieHellman.create(DhGroup.ModP2048)
    let eve = DiffieHellman.create(DhGroup.ModP2048)

    when (alice, bob, eve) {
        (Just(a), Just(b), Just(e)) => {
            a.generate_keys()
            b.generate_keys()
            e.generate_keys()

            let alice_pub = a.get_public_key()
            let bob_pub = b.get_public_key()
            let eve_pub = e.get_public_key()

            when (alice_pub, bob_pub, eve_pub) {
                (Just(ap), Just(bp), Just(ep)) => {
                    // Alice-Bob shared secret
                    let ab_secret = a.compute_secret(bp)
                    // Alice-Eve shared secret
                    let ae_secret = a.compute_secret(ep)

                    when (ab_secret, ae_secret) {
                        (Just(ab), Just(ae)) => {
                            // Different parties should have different secrets
                            assert(not ab.equals(ae))

                            ab.destroy()
                            ae.destroy()
                        }
                        _ => {}
                    }

                    ap.destroy()
                    bp.destroy()
                    ep.destroy()
                }
                _ => {}
            }

            a.destroy()
            b.destroy()
            e.destroy()
        }
        _ => {}
    }

    return 0
}

// ============================================================================
// DH with Custom Parameters Tests
// ============================================================================

@test
func test_dh_get_generator() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            let generator = d.get_generator()
            when generator {
                Just(g) => {
                    // Generator for standard groups is typically 2
                    assert(g.len() > 0)
                    g.destroy()
                }
                Nothing => {}
            }

            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_dh_get_prime() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            let prime = d.get_prime()
            when prime {
                Just(p) => {
                    // MODP2048 prime should be 256 bytes
                    assert_eq(p.len(), 256)
                    p.destroy()
                }
                Nothing => {}
            }

            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// DH Key Import Tests
// ============================================================================

@test
func test_dh_set_private_key() -> I32 {
    let dh1 = DiffieHellman.create(DhGroup.ModP2048)
    let dh2 = DiffieHellman.create(DhGroup.ModP2048)

    when (dh1, dh2) {
        (Just(d1), Just(d2)) => {
            d1.generate_keys()

            let priv_key = d1.get_private_key()
            when priv_key {
                Just(pk) => {
                    // Set the same private key on d2
                    d2.set_private_key(pk)
                    d2.generate_public_key()

                    let pub1 = d1.get_public_key()
                    let pub2 = d2.get_public_key()

                    when (pub1, pub2) {
                        (Just(p1), Just(p2)) => {
                            // Should have same public key
                            assert(p1.equals(p2))
                            p1.destroy()
                            p2.destroy()
                        }
                        _ => {}
                    }

                    pk.destroy()
                }
                Nothing => {}
            }

            d1.destroy()
            d2.destroy()
        }
        _ => {}
    }

    return 0
}

// ============================================================================
// DH Group Tests
// ============================================================================

@test
func test_dh_modp4096() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP4096)

    when dh {
        Just(d) => {
            d.generate_keys()

            let public_key = d.get_public_key()
            when public_key {
                Just(pk) => {
                    // MODP4096 keys should be 512 bytes
                    assert_eq(pk.len(), 512)
                    pk.destroy()
                }
                Nothing => {}
            }

            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// DH Error Handling Tests
// ============================================================================

@test
func test_dh_compute_without_keys() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            // Try to compute secret without generating keys
            let other_pub = random_bytes(256)
            let secret = d.compute_secret(other_pub)

            when secret {
                Just(s) => {
                    // Might succeed with random data or fail
                    s.destroy()
                }
                Nothing => {
                    // Expected to fail
                }
            }

            other_pub.destroy()
            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_dh_invalid_public_key_size() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            d.generate_keys()

            // Try to compute with wrong-sized public key
            let bad_pub = random_bytes(128)  // Should be 256 for MODP2048
            let secret = d.compute_secret(bad_pub)

            when secret {
                Just(s) => {
                    s.destroy()
                }
                Nothing => {
                    // Expected to fail
                }
            }

            bad_pub.destroy()
            d.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// DH Key Uniqueness Tests
// ============================================================================

@test
func test_dh_regenerate_keys() -> I32 {
    let dh = DiffieHellman.create(DhGroup.ModP2048)

    when dh {
        Just(d) => {
            d.generate_keys()
            let pub1 = d.get_public_key()

            d.generate_keys()
            let pub2 = d.get_public_key()

            when (pub1, pub2) {
                (Just(p1), Just(p2)) => {
                    // Keys should be different after regeneration
                    assert(not p1.equals(p2))
                    p1.destroy()
                    p2.destroy()
                }
                _ => {}
            }

            d.destroy()
        }
        Nothing => {}
    }

    return 0
}
