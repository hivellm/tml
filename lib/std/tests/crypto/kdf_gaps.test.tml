// Tests for crypto/kdf operations
use test::{assert, assert_eq}
use std::crypto::kdf::{Argon2Variant, Argon2Params, ScryptParams, pbkdf2, scrypt, hkdf, bcrypt_hash, bcrypt_verify}
use std::crypto::hash::HashAlgorithm
use std::collections::Buffer
use std::crypto::random::random_bytes

// --- Argon2Variant::name ---

@test
func test_argon2_variant_name() -> I32 {
    assert_eq(Argon2Variant::Argon2d.name(), "argon2d", "Argon2d name")
    assert_eq(Argon2Variant::Argon2i.name(), "argon2i", "Argon2i name")
    assert_eq(Argon2Variant::Argon2id.name(), "argon2id", "Argon2id name")
    return 0
}

// --- Argon2Params ---

@test
func test_argon2_params_default() -> I32 {
    let p: Argon2Params = Argon2Params::default()
    assert_eq(p.time_cost, 3 as I64, "default time_cost")
    assert_eq(p.memory_cost, 65536 as I64, "default memory_cost 64MB")
    assert_eq(p.parallelism, 4 as I64, "default parallelism")
    return 0
}

@test
func test_argon2_params_high_security() -> I32 {
    let p: Argon2Params = Argon2Params::high_security()
    assert_eq(p.time_cost, 4 as I64, "high time_cost")
    assert_eq(p.memory_cost, 131072 as I64, "high memory_cost 128MB")
    assert_eq(p.parallelism, 4 as I64, "high parallelism")
    return 0
}

@test
func test_argon2_params_low_memory() -> I32 {
    let p: Argon2Params = Argon2Params::low_memory()
    assert_eq(p.time_cost, 6 as I64, "low time_cost")
    assert_eq(p.memory_cost, 16384 as I64, "low memory_cost 16MB")
    assert_eq(p.parallelism, 2 as I64, "low parallelism")
    return 0
}

@test
func test_argon2_params_custom() -> I32 {
    let p: Argon2Params = Argon2Params::custom(10 as I64, 32768 as I64, 8 as I64)
    assert_eq(p.time_cost, 10 as I64, "custom time_cost")
    assert_eq(p.memory_cost, 32768 as I64, "custom memory_cost")
    assert_eq(p.parallelism, 8 as I64, "custom parallelism")
    return 0
}

// --- ScryptParams ---

@test
func test_scrypt_params_default() -> I32 {
    let p: ScryptParams = ScryptParams::default()
    assert_eq(p.n, 16384 as I64, "default N")
    assert_eq(p.r, 8 as I64, "default r")
    assert_eq(p.p, 1 as I64, "default p")
    assert_eq(p.maxmem, 0 as I64, "default maxmem")
    return 0
}

@test
func test_scrypt_params_high_security() -> I32 {
    let p: ScryptParams = ScryptParams::high_security()
    assert_eq(p.n, 1048576 as I64, "high N")
    assert_eq(p.r, 8 as I64, "high r")
    assert_eq(p.p, 1 as I64, "high p")
    return 0
}

@test
func test_scrypt_params_low_memory() -> I32 {
    let p: ScryptParams = ScryptParams::low_memory()
    assert_eq(p.n, 16384 as I64, "low N")
    assert_eq(p.maxmem, 33554432 as I64, "low maxmem 32MB")
    return 0
}

@test
func test_scrypt_params_custom() -> I32 {
    let p: ScryptParams = ScryptParams::custom(32768 as I64, 16 as I64, 2 as I64)
    assert_eq(p.n, 32768 as I64, "custom N")
    assert_eq(p.r, 16 as I64, "custom r")
    assert_eq(p.p, 2 as I64, "custom p")
    assert_eq(p.maxmem, 0 as I64, "custom maxmem 0")
    return 0
}

// --- Real operation tests ---

@test
func test_pbkdf2_sha256() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let result = pbkdf2("password", ref salt, 1000 as I64, 32 as I64, HashAlgorithm::Sha256)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 32 as I64, "pbkdf2 key 32 bytes")
        }
        Err(_e) => {
            assert(false, "pbkdf2 should not fail")
        }
    }
    return 0
}

@test
func test_pbkdf2_deterministic() -> I32 {
    let salt: Buffer = Buffer::from_string("fixed_salt")
    let r1 = pbkdf2("pass", ref salt, 100 as I64, 16 as I64, HashAlgorithm::Sha256)
    let r2 = pbkdf2("pass", ref salt, 100 as I64, 16 as I64, HashAlgorithm::Sha256)
    when r1 {
        Ok(k1) => {
            when r2 {
                Ok(k2) => {
                    assert_eq(k1.len(), k2.len(), "same length")
                }
                Err(_) => { assert(false, "r2 failed") }
            }
        }
        Err(_) => { assert(false, "r1 failed") }
    }
    return 0
}

@test
func test_scrypt_derive() -> I32 {
    let salt: Buffer = random_bytes(16 as I64)
    let params: ScryptParams = ScryptParams::default()
    let result = scrypt("password", ref salt, 32 as I64, params)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 32 as I64, "scrypt key 32 bytes")
        }
        Err(_e) => {
            assert(false, "scrypt should not fail")
        }
    }
    return 0
}

@test
func test_hkdf_sha256() -> I32 {
    let ikm: Buffer = random_bytes(32 as I64)
    let salt: Buffer = random_bytes(16 as I64)
    let result = hkdf(HashAlgorithm::Sha256, ref ikm, ref salt, "info", 64 as I64)
    when result {
        Ok(key) => {
            assert_eq(key.len(), 64 as I64, "hkdf key 64 bytes")
        }
        Err(_e) => {
            assert(false, "hkdf should not fail")
        }
    }
    return 0
}

// NOTE: bcrypt_hash returns empty string (OpenSSL has no native bcrypt)
// so bcrypt_hash always returns Err. bcrypt_verify also non-functional.
@test
func test_bcrypt_not_available() -> I32 {
    let result = bcrypt_hash("secret", 4 as I64)
    when result {
        Ok(_h) => {
            // If OpenSSL adds bcrypt, this would succeed
            assert(true, "bcrypt available")
        }
        Err(_e) => {
            // Expected: OpenSSL doesn't have native bcrypt
            assert(true, "bcrypt not available in OpenSSL")
        }
    }
    return 0
}
