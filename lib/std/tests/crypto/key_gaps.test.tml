// Tests for crypto/key enum, struct, and key generation operations
use test::{assert, assert_eq}
use std::crypto::key::{KeyType, KeyFormat, KeyEncoding, RsaKeyGenOptions, EcKeyGenOptions, generate_key, generate_key_pair, generate_ec_key_pair}

// --- KeyType::name ---

@test
func test_key_type_name_rsa() -> I32 {
    assert_eq(KeyType::Rsa.name(), "rsa", "Rsa name")
    return 0
}

@test
func test_key_type_name_others() -> I32 {
    assert_eq(KeyType::RsaPss.name(), "rsa-pss", "RsaPss name")
    assert_eq(KeyType::Dsa.name(), "dsa", "Dsa name")
    assert_eq(KeyType::Dh.name(), "dh", "Dh name")
    assert_eq(KeyType::Ec.name(), "ec", "Ec name")
    assert_eq(KeyType::Ed25519.name(), "ed25519", "Ed25519 name")
    assert_eq(KeyType::Ed448.name(), "ed448", "Ed448 name")
    assert_eq(KeyType::X25519.name(), "x25519", "X25519 name")
    assert_eq(KeyType::X448.name(), "x448", "X448 name")
    return 0
}

// --- KeyType::is_rsa ---

@test
func test_key_type_is_rsa() -> I32 {
    assert(KeyType::Rsa.is_rsa(), "Rsa is_rsa")
    assert(KeyType::RsaPss.is_rsa(), "RsaPss is_rsa")
    assert(not KeyType::Ec.is_rsa(), "Ec not is_rsa")
    assert(not KeyType::Ed25519.is_rsa(), "Ed25519 not is_rsa")
    return 0
}

// --- KeyType::is_ec ---

@test
func test_key_type_is_ec() -> I32 {
    assert(KeyType::Ec.is_ec(), "Ec is_ec")
    assert(KeyType::Ed25519.is_ec(), "Ed25519 is_ec")
    assert(KeyType::Ed448.is_ec(), "Ed448 is_ec")
    assert(KeyType::X25519.is_ec(), "X25519 is_ec")
    assert(KeyType::X448.is_ec(), "X448 is_ec")
    assert(not KeyType::Rsa.is_ec(), "Rsa not is_ec")
    assert(not KeyType::Dsa.is_ec(), "Dsa not is_ec")
    assert(not KeyType::Dh.is_ec(), "Dh not is_ec")
    return 0
}

// --- KeyType::from_name ---

@test
func test_key_type_from_name_valid() -> I32 {
    let rsa: Maybe[KeyType] = KeyType::from_name("rsa")
    assert(rsa.is_just(), "rsa found")
    let ec: Maybe[KeyType] = KeyType::from_name("ec")
    assert(ec.is_just(), "ec found")
    let ed: Maybe[KeyType] = KeyType::from_name("ed25519")
    assert(ed.is_just(), "ed25519 found")
    return 0
}

@test
func test_key_type_from_name_invalid() -> I32 {
    let result: Maybe[KeyType] = KeyType::from_name("invalid")
    assert(result.is_nothing(), "invalid key type is Nothing")
    return 0
}

// --- KeyFormat::name ---

@test
func test_key_format_name() -> I32 {
    assert_eq(KeyFormat::Pem.name(), "pem", "Pem name")
    assert_eq(KeyFormat::Der.name(), "der", "Der name")
    assert_eq(KeyFormat::Jwk.name(), "jwk", "Jwk name")
    assert_eq(KeyFormat::Raw.name(), "raw", "Raw name")
    return 0
}

// --- KeyEncoding::name ---

@test
func test_key_encoding_name() -> I32 {
    assert_eq(KeyEncoding::Pkcs1.name(), "pkcs1", "Pkcs1 name")
    assert_eq(KeyEncoding::Pkcs8.name(), "pkcs8", "Pkcs8 name")
    assert_eq(KeyEncoding::Spki.name(), "spki", "Spki name")
    assert_eq(KeyEncoding::Sec1.name(), "sec1", "Sec1 name")
    return 0
}

// --- RsaKeyGenOptions ---

@test
func test_rsa_key_gen_options_default() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    assert_eq(opts.modulus_length, 2048 as I64, "default modulus 2048")
    assert_eq(opts.public_exponent, 65537 as I64, "default exponent 65537")
    return 0
}

@test
func test_rsa_key_gen_options_3072() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::rsa3072()
    assert_eq(opts.modulus_length, 3072 as I64, "3072 modulus")
    assert_eq(opts.public_exponent, 65537 as I64, "3072 exponent 65537")
    return 0
}

@test
func test_rsa_key_gen_options_4096() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::rsa4096()
    assert_eq(opts.modulus_length, 4096 as I64, "4096 modulus")
    return 0
}

// --- EcKeyGenOptions ---

@test
func test_ec_key_gen_options_p256() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::p256()
    assert_eq(opts.named_curve, "P-256", "p256 curve")
    return 0
}

@test
func test_ec_key_gen_options_p384() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::p384()
    assert_eq(opts.named_curve, "P-384", "p384 curve")
    return 0
}

@test
func test_ec_key_gen_options_p521() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::p521()
    assert_eq(opts.named_curve, "P-521", "p521 curve")
    return 0
}

@test
func test_ec_key_gen_options_secp256k1() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::secp256k1()
    assert_eq(opts.named_curve, "secp256k1", "secp256k1 curve")
    return 0
}

// --- Real key generation tests ---
// NOTE: generate_key(KeyType) and generate_key_pair(KeyType, I64) have
// enum-by-value codegen ABI mismatch (i32 vs i64). Use generate_ec_key_pair instead.

@test
func test_generate_ec_key_pair_p256() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::p256()
    let result = generate_ec_key_pair(ref opts)
    when result {
        Ok(_kp) => { assert(true, "P-256 key pair generated") }
        Err(_e) => { assert(false, "P-256 key pair gen failed") }
    }
    return 0
}

@test
func test_generate_ec_key_pair_p384() -> I32 {
    let opts: EcKeyGenOptions = EcKeyGenOptions::p384()
    let result = generate_ec_key_pair(ref opts)
    when result {
        Ok(_kp) => { assert(true, "P-384 key pair generated") }
        Err(_e) => { assert(false, "P-384 key pair gen failed") }
    }
    return 0
}
