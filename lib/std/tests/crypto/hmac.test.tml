//! Tests for crypto HMAC functions
//!
//! Tests HMAC-SHA256, HMAC-SHA512, HMAC-SHA1, and streaming HMAC API.

use std::crypto::hmac::{hmac_sha256, hmac_sha512, hmac_sha384, hmac_sha1, hmac_md5}
use std::crypto::hmac::{Hmac, HmacDigest}
use std::crypto::hash::HashAlgorithm
use test::{assert, assert_eq}

// ============================================================================
// HMAC-SHA256 Tests
// ============================================================================

@test
func test_hmac_sha256_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 32 bytes = 64 hex chars
    assert_eq(hex.len(), 64 as I64, "sha256 hex length")
    assert_eq(mac.len(), 32 as I64, "sha256 digest length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_empty_message() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("key", "")
    let hex: Str = mac.to_hex()

    assert_eq(hex.len(), 64 as I64, "empty message hex length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_rfc4231_test2() -> I32 {
    // RFC 4231 Test Case 2
    // Key = "Jefe"
    // Data = "what do ya want for nothing?"
    // Expected HMAC-SHA256 = 5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843

    let mut mac: HmacDigest = hmac_sha256("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()

    assert_eq(hex, "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843", "rfc4231 test 2")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA512 Tests
// ============================================================================

@test
func test_hmac_sha512_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha512("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 64 bytes = 128 hex chars
    assert_eq(hex.len(), 128 as I64, "sha512 hex length")
    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA384 Tests
// ============================================================================

@test
func test_hmac_sha384_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha384("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 48 bytes = 96 hex chars
    assert_eq(hex.len(), 96 as I64, "sha384 hex length")
    assert_eq(mac.len(), 48 as I64, "sha384 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA1 Tests (legacy)
// ============================================================================

@test
func test_hmac_sha1_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha1("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 20 bytes = 40 hex chars
    assert_eq(hex.len(), 40 as I64, "sha1 hex length")
    assert_eq(mac.len(), 20 as I64, "sha1 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-MD5 Tests (legacy)
// ============================================================================

@test
func test_hmac_md5_basic() -> I32 {
    let mut mac: HmacDigest = hmac_md5("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 16 bytes = 32 hex chars
    assert_eq(hex.len(), 32 as I64, "md5 hex length")
    assert_eq(mac.len(), 16 as I64, "md5 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// Streaming HMAC API Tests
// ============================================================================

@test
func test_hmac_streaming_sha256() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha256, "secret")
    hmac.update("hello")
    hmac.update(" ")
    hmac.update("world")
    let mut mac: HmacDigest = hmac.digest()

    // Should match one-shot version
    let mut oneshot: HmacDigest = hmac_sha256("secret", "hello world")

    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_sha512() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha512, "key")
    hmac.update("test data")
    let mut mac: HmacDigest = hmac.digest()

    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    hmac.destroy()
    return 0
}

// ============================================================================
// Determinism Tests
// ============================================================================

@test
func test_hmac_deterministic() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message")
    let mut mac2: HmacDigest = hmac_sha256("key", "message")

    // Same key and data should produce same MAC
    assert_eq(mac1.to_hex(), mac2.to_hex(), "deterministic hmac")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_keys() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key1", "message")
    let mut mac2: HmacDigest = hmac_sha256("key2", "message")

    // Different keys should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different keys different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_data() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message1")
    let mut mac2: HmacDigest = hmac_sha256("key", "message2")

    // Different data should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different data different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}

// ============================================================================
// RFC 4231 Test Vectors - HMAC-SHA512
// ============================================================================

@test
func test_hmac_sha512_rfc4231_test2() -> I32 {
    // RFC 4231 Test Case 2
    // Key = "Jefe", Data = "what do ya want for nothing?"
    let mut mac: HmacDigest = hmac_sha512("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()
    assert_eq(hex, "164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea2505549758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737", "rfc4231 sha512 test 2")
    mac.destroy()
    return 0
}

// ============================================================================
// RFC 4231 Test Vectors - HMAC-SHA384
// ============================================================================

@test
func test_hmac_sha384_rfc4231_test2() -> I32 {
    let mut mac: HmacDigest = hmac_sha384("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()
    assert_eq(hex, "af45d2e376484031617f78d2b58a6b1b9c7ef464f5a01b47e42ec3736322445e8e2240ca5e69e2c78b3239ecfab21649", "rfc4231 sha384 test 2")
    mac.destroy()
    return 0
}

// ============================================================================
// RFC 2202 Test Vectors - HMAC-SHA1
// ============================================================================

@test
func test_hmac_sha1_rfc2202_test2() -> I32 {
    // RFC 2202 Test Case 2
    // Key = "Jefe", Data = "what do ya want for nothing?"
    let mut mac: HmacDigest = hmac_sha1("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()
    assert_eq(hex, "effcdf6ae5eb2fa2d27416d5f184df9c259a7c79", "rfc2202 sha1 test 2")
    mac.destroy()
    return 0
}

// ============================================================================
// RFC 2104 Test Vectors - HMAC-MD5
// ============================================================================

@test
func test_hmac_md5_rfc2104_test2() -> I32 {
    // Key = "Jefe", Data = "what do ya want for nothing?"
    let mut mac: HmacDigest = hmac_md5("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()
    assert_eq(hex, "750c783e6ab0b503eaa86e310a5db738", "rfc2104 md5 test 2")
    mac.destroy()
    return 0
}

// ============================================================================
// Streaming HMAC with all algorithms
// ============================================================================

@test
func test_hmac_streaming_sha384() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha384, "secret")
    hmac.update("hello ")
    hmac.update("world")
    let mut mac: HmacDigest = hmac.digest()

    let mut oneshot: HmacDigest = hmac_sha384("secret", "hello world")
    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming sha384 matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_sha1() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha1, "mykey")
    hmac.update("data")
    let mut mac: HmacDigest = hmac.digest()

    let mut oneshot: HmacDigest = hmac_sha1("mykey", "data")
    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming sha1 matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_md5() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Md5, "key")
    hmac.update("test")
    let mut mac: HmacDigest = hmac.digest()

    let mut oneshot: HmacDigest = hmac_md5("key", "test")
    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming md5 matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_multiple_updates() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha256, "key")
    hmac.update("a")
    hmac.update("b")
    hmac.update("c")
    hmac.update("d")
    hmac.update("e")
    let mut mac: HmacDigest = hmac.digest()

    let mut oneshot: HmacDigest = hmac_sha256("key", "abcde")
    assert_eq(mac.to_hex(), oneshot.to_hex(), "5 updates match oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_empty_key() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("", "hello")
    let hex: Str = mac.to_hex()
    assert_eq(hex.len(), 64 as I64, "empty key still produces valid hmac")
    mac.destroy()
    return 0
}

@test
func test_hmac_long_key() -> I32 {
    // Key longer than block size (64 bytes for SHA-256) is hashed first per RFC
    let long_key: Str = "this key is definitely longer than sixty four bytes which is the block size for sha256"
    let mut mac: HmacDigest = hmac_sha256(long_key, "test")
    let hex: Str = mac.to_hex()
    assert_eq(hex.len(), 64 as I64, "long key produces valid hmac")
    mac.destroy()
    return 0
}
