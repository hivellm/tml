//! Tests for crypto HMAC functions
//!
//! Tests HMAC-SHA256, HMAC-SHA512, HMAC-SHA1, and streaming HMAC API.

use std::crypto::hmac::{hmac_sha256, hmac_sha512, hmac_sha384, hmac_sha1, hmac_md5}
use std::crypto::hmac::{Hmac, HmacDigest}
use std::crypto::hash::HashAlgorithm
use test::{assert, assert_eq}

// ============================================================================
// HMAC-SHA256 Tests
// ============================================================================

@test
func test_hmac_sha256_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 32 bytes = 64 hex chars
    assert_eq(hex.len(), 64 as I64, "sha256 hex length")
    assert_eq(mac.len(), 32 as I64, "sha256 digest length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_empty_message() -> I32 {
    let mut mac: HmacDigest = hmac_sha256("key", "")
    let hex: Str = mac.to_hex()

    assert_eq(hex.len(), 64 as I64, "empty message hex length")

    mac.destroy()
    return 0
}

@test
func test_hmac_sha256_rfc4231_test2() -> I32 {
    // RFC 4231 Test Case 2
    // Key = "Jefe"
    // Data = "what do ya want for nothing?"
    // Expected HMAC-SHA256 = 5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843

    let mut mac: HmacDigest = hmac_sha256("Jefe", "what do ya want for nothing?")
    let hex: Str = mac.to_hex()

    assert_eq(hex, "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843", "rfc4231 test 2")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA512 Tests
// ============================================================================

@test
func test_hmac_sha512_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha512("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 64 bytes = 128 hex chars
    assert_eq(hex.len(), 128 as I64, "sha512 hex length")
    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA384 Tests
// ============================================================================

@test
func test_hmac_sha384_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha384("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 48 bytes = 96 hex chars
    assert_eq(hex.len(), 96 as I64, "sha384 hex length")
    assert_eq(mac.len(), 48 as I64, "sha384 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-SHA1 Tests (legacy)
// ============================================================================

@test
func test_hmac_sha1_basic() -> I32 {
    let mut mac: HmacDigest = hmac_sha1("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 20 bytes = 40 hex chars
    assert_eq(hex.len(), 40 as I64, "sha1 hex length")
    assert_eq(mac.len(), 20 as I64, "sha1 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// HMAC-MD5 Tests (legacy)
// ============================================================================

@test
func test_hmac_md5_basic() -> I32 {
    let mut mac: HmacDigest = hmac_md5("secret", "hello world")
    let hex: Str = mac.to_hex()

    // Length should be 16 bytes = 32 hex chars
    assert_eq(hex.len(), 32 as I64, "md5 hex length")
    assert_eq(mac.len(), 16 as I64, "md5 digest length")

    mac.destroy()
    return 0
}

// ============================================================================
// Streaming HMAC API Tests
// ============================================================================

@test
func test_hmac_streaming_sha256() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha256, "secret")
    hmac.update("hello")
    hmac.update(" ")
    hmac.update("world")
    let mut mac: HmacDigest = hmac.digest()

    // Should match one-shot version
    let mut oneshot: HmacDigest = hmac_sha256("secret", "hello world")

    assert_eq(mac.to_hex(), oneshot.to_hex(), "streaming matches oneshot")

    mac.destroy()
    oneshot.destroy()
    hmac.destroy()
    return 0
}

@test
func test_hmac_streaming_sha512() -> I32 {
    let mut hmac: Hmac = Hmac::create(HashAlgorithm::Sha512, "key")
    hmac.update("test data")
    let mut mac: HmacDigest = hmac.digest()

    assert_eq(mac.len(), 64 as I64, "sha512 digest length")

    mac.destroy()
    hmac.destroy()
    return 0
}

// ============================================================================
// Determinism Tests
// ============================================================================

@test
func test_hmac_deterministic() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message")
    let mut mac2: HmacDigest = hmac_sha256("key", "message")

    // Same key and data should produce same MAC
    assert_eq(mac1.to_hex(), mac2.to_hex(), "deterministic hmac")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_keys() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key1", "message")
    let mut mac2: HmacDigest = hmac_sha256("key2", "message")

    // Different keys should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different keys different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}

@test
func test_hmac_different_data() -> I32 {
    let mut mac1: HmacDigest = hmac_sha256("key", "message1")
    let mut mac2: HmacDigest = hmac_sha256("key", "message2")

    // Different data should produce different MACs
    assert(mac1.to_hex() != mac2.to_hex(), "different data different macs")

    mac1.destroy()
    mac2.destroy()
    return 0
}
