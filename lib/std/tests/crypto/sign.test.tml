// Tests for crypto digital signature functions
use test::{assert, assert_eq}
use std::crypto::sign::{SignatureAlgorithm, PssOptions, Signer, Verifier, Signature, sign, verify, sign_bytes, verify_bytes, sign_rsa_sha256, verify_rsa_sha256, sign_rsa_sha512, verify_rsa_sha512, sign_ecdsa_sha256, verify_ecdsa_sha256, sign_ed25519, verify_ed25519, sign_ed448, verify_ed448, sign_rsa_pss, verify_rsa_pss}
use std::crypto::key::{generate_rsa_key_pair, generate_ec_key_pair, generate_key_pair, RsaKeyGenOptions, EcKeyGenOptions, KeyPair, KeyType}
use std::collections::Buffer

// --- SignatureAlgorithm::name ---

@test
func test_signature_algorithm_names() -> I32 {
    assert_eq(SignatureAlgorithm::RsaSha256.name(), "RSA-SHA256", "RSA-SHA256")
    assert_eq(SignatureAlgorithm::RsaSha384.name(), "RSA-SHA384", "RSA-SHA384")
    assert_eq(SignatureAlgorithm::RsaSha512.name(), "RSA-SHA512", "RSA-SHA512")
    assert_eq(SignatureAlgorithm::RsaPssSha256.name(), "RSA-PSS-SHA256", "RSA-PSS-SHA256")
    assert_eq(SignatureAlgorithm::RsaPssSha384.name(), "RSA-PSS-SHA384", "RSA-PSS-SHA384")
    assert_eq(SignatureAlgorithm::RsaPssSha512.name(), "RSA-PSS-SHA512", "RSA-PSS-SHA512")
    assert_eq(SignatureAlgorithm::EcdsaSha256.name(), "ECDSA-SHA256", "ECDSA-SHA256")
    assert_eq(SignatureAlgorithm::EcdsaSha384.name(), "ECDSA-SHA384", "ECDSA-SHA384")
    assert_eq(SignatureAlgorithm::EcdsaSha512.name(), "ECDSA-SHA512", "ECDSA-SHA512")
    assert_eq(SignatureAlgorithm::Ed25519.name(), "Ed25519", "Ed25519")
    assert_eq(SignatureAlgorithm::Ed448.name(), "Ed448", "Ed448")
    return 0
}

// --- SignatureAlgorithm::is_rsa ---

@test
func test_signature_is_rsa() -> I32 {
    assert(SignatureAlgorithm::RsaSha256.is_rsa(), "RSA-SHA256 is RSA")
    assert(SignatureAlgorithm::RsaSha512.is_rsa(), "RSA-SHA512 is RSA")
    assert(SignatureAlgorithm::RsaPssSha256.is_rsa(), "RSA-PSS is RSA")
    assert(not SignatureAlgorithm::EcdsaSha256.is_rsa(), "ECDSA not RSA")
    assert(not SignatureAlgorithm::Ed25519.is_rsa(), "Ed25519 not RSA")
    return 0
}

// --- SignatureAlgorithm::is_ecdsa ---

@test
func test_signature_is_ecdsa() -> I32 {
    assert(SignatureAlgorithm::EcdsaSha256.is_ecdsa(), "ECDSA-SHA256 is ECDSA")
    assert(SignatureAlgorithm::EcdsaSha384.is_ecdsa(), "ECDSA-SHA384 is ECDSA")
    assert(not SignatureAlgorithm::RsaSha256.is_ecdsa(), "RSA not ECDSA")
    assert(not SignatureAlgorithm::Ed25519.is_ecdsa(), "Ed25519 not ECDSA")
    return 0
}

// --- SignatureAlgorithm::is_eddsa ---

@test
func test_signature_is_eddsa() -> I32 {
    assert(SignatureAlgorithm::Ed25519.is_eddsa(), "Ed25519 is EdDSA")
    assert(SignatureAlgorithm::Ed448.is_eddsa(), "Ed448 is EdDSA")
    assert(not SignatureAlgorithm::RsaSha256.is_eddsa(), "RSA not EdDSA")
    assert(not SignatureAlgorithm::EcdsaSha256.is_eddsa(), "ECDSA not EdDSA")
    return 0
}

// --- SignatureAlgorithm::is_pss ---

@test
func test_signature_is_pss() -> I32 {
    assert(SignatureAlgorithm::RsaPssSha256.is_pss(), "RSA-PSS-SHA256 is PSS")
    assert(SignatureAlgorithm::RsaPssSha384.is_pss(), "RSA-PSS-SHA384 is PSS")
    assert(SignatureAlgorithm::RsaPssSha512.is_pss(), "RSA-PSS-SHA512 is PSS")
    assert(not SignatureAlgorithm::RsaSha256.is_pss(), "RSA-SHA256 not PSS")
    assert(not SignatureAlgorithm::Ed25519.is_pss(), "Ed25519 not PSS")
    return 0
}

// --- SignatureAlgorithm::from_name ---

@test
func test_signature_from_name_valid() -> I32 {
    let result: Maybe[SignatureAlgorithm] = SignatureAlgorithm::from_name("RSA-SHA256")
    assert(result.is_just(), "RSA-SHA256 found")
    assert_eq(result.unwrap().name(), "RSA-SHA256", "round-trip name")
    return 0
}

@test
func test_signature_from_name_eddsa() -> I32 {
    let result: Maybe[SignatureAlgorithm] = SignatureAlgorithm::from_name("Ed25519")
    assert(result.is_just(), "Ed25519 found")
    assert(result.unwrap().is_eddsa(), "Ed25519 is EdDSA")
    return 0
}

@test
func test_signature_from_name_ed448() -> I32 {
    let result = SignatureAlgorithm::from_name("Ed448")
    assert(result.is_just(), "Ed448 found")
    assert(result.unwrap().is_eddsa(), "Ed448 is EdDSA")
    return 0
}

@test
func test_signature_from_name_pss_variants() -> I32 {
    let r1 = SignatureAlgorithm::from_name("RSA-PSS-SHA256")
    assert(r1.is_just(), "RSA-PSS-SHA256 found")
    assert(r1.unwrap().is_pss(), "RSA-PSS-SHA256 is PSS")
    let r2 = SignatureAlgorithm::from_name("RSA-PSS-SHA384")
    assert(r2.is_just(), "RSA-PSS-SHA384 found")
    let r3 = SignatureAlgorithm::from_name("RSA-PSS-SHA512")
    assert(r3.is_just(), "RSA-PSS-SHA512 found")
    return 0
}

@test
func test_signature_from_name_ecdsa_variants() -> I32 {
    let r1 = SignatureAlgorithm::from_name("ECDSA-SHA256")
    assert(r1.is_just(), "ECDSA-SHA256 found")
    assert(r1.unwrap().is_ecdsa(), "ECDSA-SHA256 is ECDSA")
    let r2 = SignatureAlgorithm::from_name("ECDSA-SHA384")
    assert(r2.is_just(), "ECDSA-SHA384 found")
    let r3 = SignatureAlgorithm::from_name("ECDSA-SHA512")
    assert(r3.is_just(), "ECDSA-SHA512 found")
    return 0
}

@test
func test_signature_from_name_invalid() -> I32 {
    let result: Maybe[SignatureAlgorithm] = SignatureAlgorithm::from_name("INVALID")
    assert(result.is_nothing(), "invalid returns Nothing")
    return 0
}

// --- PssOptions ---

@test
func test_pss_options_default() -> I32 {
    let opts: PssOptions = PssOptions::default()
    assert_eq(opts.salt_length, -1 as I64, "default salt_length -1")
    assert_eq(opts.mgf1_hash, "sha256", "default mgf1_hash sha256")
    return 0
}

@test
func test_pss_options_with_salt_length() -> I32 {
    let opts: PssOptions = PssOptions::with_salt_length(32 as I64)
    assert_eq(opts.salt_length, 32 as I64, "salt_length 32")
    assert_eq(opts.mgf1_hash, "sha256", "mgf1_hash sha256")
    return 0
}

// --- Signature struct methods ---

@test
func test_signature_from_bytes_and_accessors() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign(SignatureAlgorithm::RsaSha256, ref kp.private_key, "test").unwrap()

    let alg: SignatureAlgorithm = sig.algorithm()
    assert_eq(alg.name(), "RSA-SHA256", "sig algorithm name")

    let data: ref Buffer = sig.bytes()
    assert(data.len() > (0 as I64), "sig bytes not empty")

    let hex: Str = sig.to_hex()
    assert(hex.len() > (0 as I64), "hex not empty")

    let b64: Str = sig.to_base64()
    assert(b64.len() > (0 as I64), "base64 not empty")

    return 0
}

@test
func test_signature_from_hex() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign(SignatureAlgorithm::RsaSha256, ref kp.private_key, "hex test").unwrap()
    let hex: Str = sig.to_hex()

    let parsed = Signature::from_hex(hex, SignatureAlgorithm::RsaSha256)
    assert(parsed.is_ok(), "from_hex should succeed")
    let parsed_sig: Signature = parsed.unwrap()
    assert(parsed_sig.len() > (0 as I64), "parsed sig not empty")
    return 0
}

@test
func test_signature_from_base64() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign(SignatureAlgorithm::RsaSha256, ref kp.private_key, "b64 test").unwrap()
    let b64: Str = sig.to_base64()

    let parsed = Signature::from_base64(b64, SignatureAlgorithm::RsaSha256)
    assert(parsed.is_ok(), "from_base64 should succeed")
    let parsed_sig: Signature = parsed.unwrap()
    assert(parsed_sig.len() > (0 as I64), "parsed sig not empty")
    return 0
}

@test
func test_signature_from_hex_invalid() -> I32 {
    let result = Signature::from_hex("ZZZZ", SignatureAlgorithm::RsaSha256)
    assert(result.is_err(), "from_hex with invalid hex should fail")
    return 0
}

@test
func test_signature_from_base64_invalid() -> I32 {
    let result = Signature::from_base64("!!!invalid!!!", SignatureAlgorithm::RsaSha256)
    assert(result.is_err(), "from_base64 with invalid b64 should fail")
    return 0
}

@test
func test_signature_from_bytes() -> I32 {
    let buf: Buffer = Buffer::from_string("fake sig data")
    let sig: Signature = Signature::from_bytes(buf, SignatureAlgorithm::Ed25519)
    assert_eq(sig.algorithm().name(), "Ed25519", "from_bytes algorithm")
    assert(sig.len() > (0 as I64), "from_bytes has data")
    return 0
}

@test
func test_signature_from_der() -> I32 {
    let buf: Buffer = Buffer::from_string("fake DER data")
    let sig: Signature = Signature::from_der(ref buf, SignatureAlgorithm::EcdsaSha256)
    assert_eq(sig.algorithm().name(), "ECDSA-SHA256", "from_der algorithm")
    assert(sig.len() > (0 as I64), "from_der has data")
    return 0
}

// --- Signer/Verifier accessor and lifecycle tests ---

@test
func test_signer_algorithm_and_destroy() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let mut signer: Signer = Signer::new(SignatureAlgorithm::RsaSha256, ref kp.private_key).unwrap()
    let alg: SignatureAlgorithm = signer.algorithm()
    assert_eq(alg.name(), "RSA-SHA256", "signer algorithm")
    signer.destroy()
    signer.destroy()
    return 0
}

@test
func test_verifier_algorithm_and_destroy() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let mut verifier: Verifier = Verifier::new(SignatureAlgorithm::RsaSha256, ref kp.public_key).unwrap()
    let alg: SignatureAlgorithm = verifier.algorithm()
    assert_eq(alg.name(), "RSA-SHA256", "verifier algorithm")
    verifier.destroy()
    verifier.destroy()
    return 0
}

// --- sign_bytes / verify_bytes ---

@test
func test_sign_bytes_verify_bytes() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let data: Buffer = Buffer::from_string("binary data to sign")
    let sig_result = sign_bytes(SignatureAlgorithm::RsaSha256, ref kp.private_key, ref data)
    assert(sig_result.is_ok(), "sign_bytes should succeed")
    let sig: Signature = sig_result.unwrap()
    let verify_result = verify_bytes(SignatureAlgorithm::RsaSha256, ref kp.public_key, ref data, ref sig)
    assert(verify_result.is_ok(), "verify_bytes should succeed")
    assert(verify_result.unwrap(), "verify_bytes should be valid")
    return 0
}

// --- Signer::update_bytes / Verifier::update_bytes ---

@test
func test_signer_verifier_update_bytes() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let data: Buffer = Buffer::from_string("streaming bytes")

    let mut signer: Signer = Signer::new(SignatureAlgorithm::RsaSha256, ref kp.private_key).unwrap()
    signer.update_bytes(ref data)
    let sig: Signature = signer.sign().unwrap()

    let mut verifier: Verifier = Verifier::new(SignatureAlgorithm::RsaSha256, ref kp.public_key).unwrap()
    verifier.update_bytes(ref data)
    let valid: Bool = verifier.verify(ref sig).unwrap()
    assert(valid, "streaming bytes sign/verify should match")
    return 0
}

// --- RSA sign/verify operations ---

@test
func test_rsa_sha256_sign_verify() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig_result = sign(SignatureAlgorithm::RsaSha256, ref kp.private_key, "hello world")
    assert(sig_result.is_ok(), "RSA-SHA256 sign should succeed")
    let sig: Signature = sig_result.unwrap()
    assert(sig.len() > (0 as I64), "signature not empty")
    let verify_result = verify(SignatureAlgorithm::RsaSha256, ref kp.public_key, "hello world", ref sig)
    assert(verify_result.is_ok(), "RSA-SHA256 verify should succeed")
    assert(verify_result.unwrap(), "RSA-SHA256 signature should be valid")
    return 0
}

@test
func test_rsa_sha256_verify_wrong_data() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign(SignatureAlgorithm::RsaSha256, ref kp.private_key, "hello").unwrap()
    let verify_result = verify(SignatureAlgorithm::RsaSha256, ref kp.public_key, "wrong", ref sig)
    assert(verify_result.is_ok(), "verify call should succeed")
    assert(not verify_result.unwrap(), "signature should be invalid for wrong data")
    return 0
}

@test
func test_rsa_sha256_helper_functions() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign_rsa_sha256(ref kp.private_key, "test data").unwrap()
    assert(sig.len() > (0 as I64), "helper sig not empty")
    let valid: Bool = verify_rsa_sha256(ref kp.public_key, "test data", ref sig).unwrap()
    assert(valid, "helper verify should pass")
    return 0
}

// --- sign_rsa_sha512 / verify_rsa_sha512 ---

@test
func test_rsa_sha512_sign_verify() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let sig: Signature = sign_rsa_sha512(ref kp.private_key, "sha512 test").unwrap()
    assert(sig.len() > (0 as I64), "rsa sha512 sig not empty")
    let valid: Bool = verify_rsa_sha512(ref kp.public_key, "sha512 test", ref sig).unwrap()
    assert(valid, "rsa sha512 verify should pass")
    return 0
}

// --- sign_rsa_pss / verify_rsa_pss ---

@test
func test_rsa_pss_sign_verify() -> I32 {
    let opts: RsaKeyGenOptions = RsaKeyGenOptions::default()
    let mut kp: KeyPair = generate_rsa_key_pair(ref opts).unwrap()
    let pss_opts: PssOptions = PssOptions::default()
    let sig_result = sign_rsa_pss(ref kp.private_key, "pss test", ref pss_opts)
    assert(sig_result.is_ok(), "RSA-PSS sign should succeed")
    let sig: Signature = sig_result.unwrap()
    assert(sig.len() > (0 as I64), "RSA-PSS sig not empty")
    let valid: Bool = verify_rsa_pss(ref kp.public_key, "pss test", ref sig, ref pss_opts).unwrap()
    assert(valid, "RSA-PSS verify should pass")
    return 0
}

// --- sign_ecdsa_sha256 / verify_ecdsa_sha256 ---

@test
func test_ecdsa_sha256_sign_verify() -> I32 {
    let ec_opts: EcKeyGenOptions = EcKeyGenOptions::p256()
    let mut kp: KeyPair = generate_ec_key_pair(ref ec_opts).unwrap()
    let sig: Signature = sign_ecdsa_sha256(ref kp.private_key, "ecdsa test").unwrap()
    assert(sig.len() > (0 as I64), "ecdsa sig not empty")
    let valid: Bool = verify_ecdsa_sha256(ref kp.public_key, "ecdsa test", ref sig).unwrap()
    assert(valid, "ecdsa verify should pass")
    return 0
}

// --- sign_ed25519 / verify_ed25519 ---

@test
func test_ed25519_sign_verify() -> I32 {
    let mut kp: KeyPair = generate_key_pair(KeyType::Ed25519, 0).unwrap()
    let sig: Signature = sign_ed25519(ref kp.private_key, "ed25519 test data").unwrap()
    assert(sig.len() > (0 as I64), "ed25519 sig not empty")
    let valid: Bool = verify_ed25519(ref kp.public_key, "ed25519 test data", ref sig).unwrap()
    assert(valid, "ed25519 verify should pass")
    return 0
}

@test
func test_ed25519_verify_wrong_data() -> I32 {
    let mut kp: KeyPair = generate_key_pair(KeyType::Ed25519, 0).unwrap()
    let sig: Signature = sign_ed25519(ref kp.private_key, "correct data").unwrap()
    let valid: Bool = verify_ed25519(ref kp.public_key, "wrong data", ref sig).unwrap()
    assert(not valid, "ed25519 verify should fail for wrong data")
    return 0
}

// --- sign_ed448 / verify_ed448 ---

@test
func test_ed448_sign_verify() -> I32 {
    let mut kp: KeyPair = generate_key_pair(KeyType::Ed448, 0).unwrap()
    let sig: Signature = sign_ed448(ref kp.private_key, "ed448 test data").unwrap()
    assert(sig.len() > (0 as I64), "ed448 sig not empty")
    let valid: Bool = verify_ed448(ref kp.public_key, "ed448 test data", ref sig).unwrap()
    assert(valid, "ed448 verify should pass")
    return 0
}

@test
func test_ed448_verify_wrong_data() -> I32 {
    let mut kp: KeyPair = generate_key_pair(KeyType::Ed448, 0).unwrap()
    let sig: Signature = sign_ed448(ref kp.private_key, "correct").unwrap()
    let valid: Bool = verify_ed448(ref kp.public_key, "wrong", ref sig).unwrap()
    assert(not valid, "ed448 verify should fail for wrong data")
    return 0
}
