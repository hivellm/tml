//! Tests for crypto digital signature functions
//!
//! Tests ECDSA, Ed25519, RSA-PSS signatures.

use std::crypto::{Signer, Verifier, SignatureAlgorithm}
use std::crypto::{sign, verify}
use std::crypto::{generate_key_pair, KeyType}
use std::crypto::random_bytes
use std::collections::Buffer
use test::{assert, assert_eq}

// ============================================================================
// ECDSA P-256 Tests
// ============================================================================

@test
func test_ecdsa_p256_sign_verify() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Hello, World!")

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    // Verify with correct key
                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key, message, sig)
                    assert(valid)

                    sig.destroy()
                }
                Nothing => {
                    assert(false)
                }
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {
            // Key generation might not be available
        }
    }

    return 0
}

@test
func test_ecdsa_p256_wrong_key_fails() -> I32 {
    let key_pair1 = generate_key_pair(KeyType.EcP256)
    let key_pair2 = generate_key_pair(KeyType.EcP256)

    when (key_pair1, key_pair2) {
        (Just(kp1), Just(kp2)) => {
            let message = Buffer.from_str("Test message")

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp1.private_key, message)

            when signature {
                Just(sig) => {
                    // Verify with wrong public key should fail
                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp2.public_key, message, sig)
                    assert(not valid)

                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp1.destroy()
            kp2.destroy()
        }
        _ => {}
    }

    return 0
}

@test
func test_ecdsa_p256_tampered_message_fails() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Original message")

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    // Verify with tampered message
                    let tampered = Buffer.from_str("Tampered message")
                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key, tampered, sig)
                    assert(not valid)

                    tampered.destroy()
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// ECDSA P-384 Tests
// ============================================================================

@test
func test_ecdsa_p384_sign_verify() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP384)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Message for P-384")

            let signature = sign(SignatureAlgorithm.EcdsaP384Sha384, kp.private_key, message)

            when signature {
                Just(sig) => {
                    let valid = verify(SignatureAlgorithm.EcdsaP384Sha384, kp.public_key, message, sig)
                    assert(valid)
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Ed25519 Tests
// ============================================================================

@test
func test_ed25519_sign_verify() -> I32 {
    let key_pair = generate_key_pair(KeyType.Ed25519)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Ed25519 test message")

            let signature = sign(SignatureAlgorithm.Ed25519, kp.private_key, message)

            when signature {
                Just(sig) => {
                    // Ed25519 signatures are 64 bytes
                    assert_eq(sig.len(), 64)

                    let valid = verify(SignatureAlgorithm.Ed25519, kp.public_key, message, sig)
                    assert(valid)

                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_ed25519_deterministic() -> I32 {
    // Ed25519 signatures are deterministic (same key + message = same signature)
    let key_pair = generate_key_pair(KeyType.Ed25519)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Test message")

            let sig1 = sign(SignatureAlgorithm.Ed25519, kp.private_key, message)
            let sig2 = sign(SignatureAlgorithm.Ed25519, kp.private_key, message)

            when (sig1, sig2) {
                (Just(s1), Just(s2)) => {
                    assert(s1.equals(s2))
                    s1.destroy()
                    s2.destroy()
                }
                _ => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// RSA-PSS Tests
// ============================================================================

@test
func test_rsa_pss_sign_verify() -> I32 {
    let key_pair = generate_key_pair(KeyType.Rsa2048)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("RSA-PSS test message")

            let signature = sign(SignatureAlgorithm.RsaPssSha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    let valid = verify(SignatureAlgorithm.RsaPssSha256, kp.public_key, message, sig)
                    assert(valid)
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_rsa_pss_randomized() -> I32 {
    // RSA-PSS signatures are randomized (same key + message = different signatures)
    let key_pair = generate_key_pair(KeyType.Rsa2048)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Test message")

            let sig1 = sign(SignatureAlgorithm.RsaPssSha256, kp.private_key, message)
            let sig2 = sign(SignatureAlgorithm.RsaPssSha256, kp.private_key, message)

            when (sig1, sig2) {
                (Just(s1), Just(s2)) => {
                    // Signatures should be different (due to random salt)
                    assert(not s1.equals(s2))

                    // But both should verify
                    assert(verify(SignatureAlgorithm.RsaPssSha256, kp.public_key, message, s1))
                    assert(verify(SignatureAlgorithm.RsaPssSha256, kp.public_key, message, s2))

                    s1.destroy()
                    s2.destroy()
                }
                _ => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// RSA PKCS#1 v1.5 Tests
// ============================================================================

@test
func test_rsa_pkcs1_sign_verify() -> I32 {
    let key_pair = generate_key_pair(KeyType.Rsa2048)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("RSA PKCS#1 test")

            let signature = sign(SignatureAlgorithm.RsaPkcs1Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    let valid = verify(SignatureAlgorithm.RsaPkcs1Sha256, kp.public_key, message, sig)
                    assert(valid)
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Streaming Signer/Verifier Tests
// ============================================================================

@test
func test_signer_streaming() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let signer = Signer.create(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key)

            signer.update("Hello, ")
            signer.update("World!")

            let signature = signer.sign()

            when signature {
                Just(sig) => {
                    // Verify with streaming verifier
                    let verifier = Verifier.create(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key)
                    verifier.update("Hello, ")
                    verifier.update("World!")

                    let valid = verifier.verify(sig)
                    assert(valid)

                    sig.destroy()
                    verifier.destroy()
                }
                Nothing => {}
            }

            signer.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

@test
func test_signer_streaming_bytes() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let signer = Signer.create(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key)

            let chunk1 = Buffer.from_str("Part 1")
            let chunk2 = Buffer.from_str("Part 2")

            signer.update(chunk1)
            signer.update(chunk2)

            let signature = signer.sign()

            when signature {
                Just(sig) => {
                    // Verify
                    let verifier = Verifier.create(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key)
                    verifier.update(chunk1)
                    verifier.update(chunk2)

                    assert(verifier.verify(sig))

                    sig.destroy()
                    verifier.destroy()
                }
                Nothing => {}
            }

            chunk1.destroy()
            chunk2.destroy()
            signer.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Large Data Tests
// ============================================================================

@test
func test_sign_large_message() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            // Create 1MB message
            let message = random_bytes(1024 * 1024)

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key, message, sig)
                    assert(valid)
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Empty Message Tests
// ============================================================================

@test
func test_sign_empty_message() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let message = Buffer.alloc(0)

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key, message, sig)
                    assert(valid)
                    sig.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}

// ============================================================================
// Tampered Signature Tests
// ============================================================================

@test
func test_tampered_signature_fails() -> I32 {
    let key_pair = generate_key_pair(KeyType.EcP256)

    when key_pair {
        Just(kp) => {
            let message = Buffer.from_str("Test message")

            let signature = sign(SignatureAlgorithm.EcdsaP256Sha256, kp.private_key, message)

            when signature {
                Just(sig) => {
                    // Tamper with signature
                    let tampered = sig.duplicate()
                    tampered.set(0, tampered.get(0) xor 0xFF)

                    let valid = verify(SignatureAlgorithm.EcdsaP256Sha256, kp.public_key, message, tampered)
                    assert(not valid)

                    sig.destroy()
                    tampered.destroy()
                }
                Nothing => {}
            }

            message.destroy()
            kp.destroy()
        }
        Nothing => {}
    }

    return 0
}
