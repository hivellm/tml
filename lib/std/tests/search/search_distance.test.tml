//! Tests for std::search::distance module.
//!
//! Validates dot product, cosine similarity, euclidean distance,
//! normalization, and norm operations using the public API.

use test::{assert, assert_eq}
use std::search::distance::{
    dot_product,
    cosine_similarity,
    euclidean_distance,
    norm,
    normalize,
    dot_product_f32,
    cosine_similarity_f32,
    euclidean_distance_f32,
    l2_squared_f32,
    norm_f32,
    normalize_f32,
}

// Helper: approximate equality for F64
func approx_eq(a: F64, b: F64, epsilon: F64) -> Bool {
    let diff = a - b
    if diff < 0.0 {
        return (0.0 - diff) < epsilon
    }
    return diff < epsilon
}

// Helper: approximate equality for F32
func approx_eq_f32(a: F32, b: F32, epsilon: F32) -> Bool {
    let diff: F32 = a - b
    let zero: F32 = 0.0
    if diff < zero {
        return (zero - diff) < epsilon
    }
    return diff < epsilon
}

// ============================================================================
// Dot Product Tests
// ============================================================================

@test
func test_dot_product_basic() -> I32 {
    var a: [F64; 3] = [1.0, 2.0, 3.0]
    var b: [F64; 3] = [4.0, 5.0, 6.0]
    // 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32
    let result = dot_product(&a, &b, 3)
    assert(approx_eq(result, 32.0, 0.001), "dot product of [1,2,3] . [4,5,6] should be 32")
    return 0
}

@test
func test_dot_product_orthogonal() -> I32 {
    var a: [F64; 2] = [1.0, 0.0]
    var b: [F64; 2] = [0.0, 1.0]
    let result = dot_product(&a, &b, 2)
    assert(approx_eq(result, 0.0, 0.001), "orthogonal vectors should have 0 dot product")
    return 0
}

@test
func test_dot_product_self() -> I32 {
    var a: [F64; 3] = [3.0, 4.0, 0.0]
    // 9 + 16 + 0 = 25
    let result = dot_product(&a, &a, 3)
    assert(approx_eq(result, 25.0, 0.001), "self dot product should be sum of squares")
    return 0
}

// ============================================================================
// Cosine Similarity Tests
// ============================================================================

@test
func test_cosine_similarity_identical() -> I32 {
    var a: [F64; 3] = [1.0, 2.0, 3.0]
    let result = cosine_similarity(&a, &a, 3)
    assert(approx_eq(result, 1.0, 0.0001), "cosine similarity of identical vectors should be 1.0")
    return 0
}

@test
func test_cosine_similarity_orthogonal() -> I32 {
    var a: [F64; 2] = [1.0, 0.0]
    var b: [F64; 2] = [0.0, 1.0]
    let result = cosine_similarity(&a, &b, 2)
    assert(approx_eq(result, 0.0, 0.0001), "orthogonal vectors should have cosine similarity 0")
    return 0
}

@test
func test_cosine_similarity_opposite() -> I32 {
    var a: [F64; 2] = [1.0, 0.0]
    var b: [F64; 2] = [-1.0, 0.0]
    let result = cosine_similarity(&a, &b, 2)
    assert(approx_eq(result, -1.0, 0.0001), "opposite vectors should have cosine similarity -1")
    return 0
}

@test
func test_cosine_similarity_scale_invariant() -> I32 {
    var a: [F64; 3] = [1.0, 2.0, 3.0]
    var b: [F64; 3] = [10.0, 20.0, 30.0]
    let result = cosine_similarity(&a, &b, 3)
    assert(approx_eq(result, 1.0, 0.0001), "parallel vectors should have cosine similarity 1.0")
    return 0
}

// ============================================================================
// Euclidean Distance Tests
// ============================================================================

@test
func test_euclidean_distance_zero() -> I32 {
    var a: [F64; 3] = [1.0, 2.0, 3.0]
    let result = euclidean_distance(&a, &a, 3)
    assert(approx_eq(result, 0.0, 0.0001), "distance to self should be 0")
    return 0
}

@test
func test_euclidean_distance_3_4_5() -> I32 {
    var a: [F64; 2] = [0.0, 0.0]
    var b: [F64; 2] = [3.0, 4.0]
    let result = euclidean_distance(&a, &b, 2)
    assert(approx_eq(result, 5.0, 0.0001), "distance from origin to (3,4) should be 5")
    return 0
}

// ============================================================================
// Norm Tests
// ============================================================================

@test
func test_norm_basic() -> I32 {
    var v: [F64; 2] = [3.0, 4.0]
    let result = norm(&v, 2)
    assert(approx_eq(result, 5.0, 0.0001), "norm of [3,4] should be 5")
    return 0
}

@test
func test_norm_unit_vector() -> I32 {
    var v: [F64; 3] = [1.0, 0.0, 0.0]
    let result = norm(&v, 3)
    assert(approx_eq(result, 1.0, 0.0001), "norm of unit vector should be 1")
    return 0
}

// ============================================================================
// Normalize Tests (F64)
// ============================================================================

@test
func test_normalize_makes_unit() -> I32 {
    var v: [F64; 3] = [3.0, 4.0, 0.0]
    normalize(&v, 3)
    let n = norm(&v, 3)
    assert(approx_eq(n, 1.0, 0.0001), "normalized vector should have norm 1.0")
    return 0
}

@test
func test_normalize_preserves_direction() -> I32 {
    var v: [F64; 2] = [3.0, 4.0]
    var original: [F64; 2] = [3.0, 4.0]
    normalize(&v, 2)
    // After normalization, cosine similarity with original should be 1.0
    let sim = cosine_similarity(&v, &original, 2)
    assert(approx_eq(sim, 1.0, 0.0001), "normalized vector should preserve direction")
    return 0
}

// ============================================================================
// F32 Dot Product Tests
// ============================================================================

@test
func test_dot_product_f32_basic() -> I32 {
    var a: [F32; 3] = [1.0, 2.0, 3.0]
    var b: [F32; 3] = [4.0, 5.0, 6.0]
    let result: F32 = dot_product_f32(&a, &b, 3)
    let expected: F32 = 32.0
    let eps: F32 = 0.01
    assert(approx_eq_f32(result, expected, eps), "F32 dot product of [1,2,3] . [4,5,6] should be 32")
    return 0
}

@test
func test_dot_product_f32_orthogonal() -> I32 {
    var a: [F32; 2] = [1.0, 0.0]
    var b: [F32; 2] = [0.0, 1.0]
    let result: F32 = dot_product_f32(&a, &b, 2)
    let expected: F32 = 0.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 orthogonal dot product should be 0")
    return 0
}

// ============================================================================
// F32 Cosine Similarity Tests
// ============================================================================

@test
func test_cosine_similarity_f32_identical() -> I32 {
    var a: [F32; 3] = [1.0, 2.0, 3.0]
    let result: F32 = cosine_similarity_f32(&a, &a, 3)
    let expected: F32 = 1.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 cosine similarity of identical should be 1.0")
    return 0
}

@test
func test_cosine_similarity_f32_orthogonal() -> I32 {
    var a: [F32; 2] = [1.0, 0.0]
    var b: [F32; 2] = [0.0, 1.0]
    let result: F32 = cosine_similarity_f32(&a, &b, 2)
    let expected: F32 = 0.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 orthogonal cosine should be 0")
    return 0
}

@test
func test_cosine_similarity_f32_opposite() -> I32 {
    var a: [F32; 2] = [1.0, 0.0]
    var b: [F32; 2] = [-1.0, 0.0]
    let result: F32 = cosine_similarity_f32(&a, &b, 2)
    let expected: F32 = -1.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 opposite cosine should be -1")
    return 0
}

// ============================================================================
// F32 Euclidean Distance Tests
// ============================================================================

@test
func test_euclidean_distance_f32_zero() -> I32 {
    var a: [F32; 3] = [1.0, 2.0, 3.0]
    let result: F32 = euclidean_distance_f32(&a, &a, 3)
    let expected: F32 = 0.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 distance to self should be 0")
    return 0
}

@test
func test_euclidean_distance_f32_3_4_5() -> I32 {
    var a: [F32; 2] = [0.0, 0.0]
    var b: [F32; 2] = [3.0, 4.0]
    let result: F32 = euclidean_distance_f32(&a, &b, 2)
    let expected: F32 = 5.0
    let eps: F32 = 0.01
    assert(approx_eq_f32(result, expected, eps), "F32 distance (3,4) should be 5")
    return 0
}

// ============================================================================
// F32 L2 Squared Tests
// ============================================================================

@test
func test_l2_squared_f32_basic() -> I32 {
    var a: [F32; 2] = [0.0, 0.0]
    var b: [F32; 2] = [3.0, 4.0]
    let result: F32 = l2_squared_f32(&a, &b, 2)
    // 9 + 16 = 25
    let expected: F32 = 25.0
    let eps: F32 = 0.01
    assert(approx_eq_f32(result, expected, eps), "L2 squared of (3,4) should be 25")
    return 0
}

@test
func test_l2_squared_f32_zero() -> I32 {
    var a: [F32; 3] = [1.0, 2.0, 3.0]
    let result: F32 = l2_squared_f32(&a, &a, 3)
    let expected: F32 = 0.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "L2 squared to self should be 0")
    return 0
}

// ============================================================================
// F32 Norm Tests
// ============================================================================

@test
func test_norm_f32_basic() -> I32 {
    var v: [F32; 2] = [3.0, 4.0]
    let result: F32 = norm_f32(&v, 2)
    let expected: F32 = 5.0
    let eps: F32 = 0.01
    assert(approx_eq_f32(result, expected, eps), "F32 norm of [3,4] should be 5")
    return 0
}

@test
func test_norm_f32_unit() -> I32 {
    var v: [F32; 3] = [1.0, 0.0, 0.0]
    let result: F32 = norm_f32(&v, 3)
    let expected: F32 = 1.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(result, expected, eps), "F32 norm of unit vector should be 1")
    return 0
}

// ============================================================================
// F32 Normalize Tests
// ============================================================================

@test
func test_normalize_f32_makes_unit() -> I32 {
    var v: [F32; 3] = [3.0, 4.0, 0.0]
    normalize_f32(&v, 3)
    let n: F32 = norm_f32(&v, 3)
    let expected: F32 = 1.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(n, expected, eps), "F32 normalized vector should have norm 1.0")
    return 0
}

@test
func test_normalize_f32_preserves_direction() -> I32 {
    var v: [F32; 2] = [3.0, 4.0]
    var original: [F32; 2] = [3.0, 4.0]
    normalize_f32(&v, 2)
    let sim: F32 = cosine_similarity_f32(&v, &original, 2)
    let expected: F32 = 1.0
    let eps: F32 = 0.001
    assert(approx_eq_f32(sim, expected, eps), "F32 normalized should preserve direction")
    return 0
}
