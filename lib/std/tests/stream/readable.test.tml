// Tests for std::stream ByteStream reading.
use test::{assert, assert_eq}
use std::stream::byte_stream::ByteStream

@test
func test_bytestream_create_destroy() -> I32 {
    var stream: ByteStream = ByteStream::new()
    assert_eq(stream.len(), 0 as I64, "len 0")
    assert(stream.is_empty(), "empty")
    assert(stream.is_eof(), "eof")
    stream.destroy()
    return 0
}

@test
func test_bytestream_from_string() -> I32 {
    var stream: ByteStream = ByteStream::from_string("hello")
    assert_eq(stream.len(), 5 as I64, "len 5")
    assert_eq(stream.remaining(), 5 as I64, "remaining 5")
    assert(not stream.is_eof(), "not eof")
    let s: Str = stream.to_string()
    assert_eq(s, "hello", "to_string")
    stream.destroy()
    return 0
}

@test
func test_bytestream_read_basic() -> I32 {
    var stream: ByteStream = ByteStream::from_string("hello")
    var buf: [U8; 5] = [0 as U8; 5]
    let result = stream.read(mut ref buf)
    when result {
        Err(e) => return 1,
        Ok(n) => {
            assert_eq(n, 5 as I64, "read 5")
            assert_eq(buf[0] as I64, 104 as I64, "h")
            assert_eq(buf[4] as I64, 111 as I64, "o")
        },
    }
    assert(stream.is_eof(), "eof after read")
    stream.destroy()
    return 0
}

@test
func test_bytestream_get_byte() -> I32 {
    var stream: ByteStream = ByteStream::from_string("AB")
    assert_eq(stream.get(0) as I64, 65 as I64, "A")
    assert_eq(stream.get(1) as I64, 66 as I64, "B")
    assert_eq(stream.get(2) as I64, 0 as I64, "out of bounds")
    stream.destroy()
    return 0
}

@test
func test_bytestream_partial_read() -> I32 {
    var stream: ByteStream = ByteStream::from_string("hello world")
    var buf: [U8; 5] = [0 as U8; 5]
    let result1 = stream.read(mut ref buf)
    when result1 {
        Err(e) => return 1,
        Ok(n) => assert_eq(n, 5 as I64, "first read 5"),
    }
    assert_eq(stream.remaining(), 6 as I64, "6 remaining")
    assert(not stream.is_eof(), "not eof yet")
    stream.destroy()
    return 0
}
