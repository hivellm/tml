// ArrayList full coverage
use test::{assert, assert_eq}
use std::collections::class_collections::ArrayList

@test
func test_arraylist_create_empty() -> I32 {
    let list: ArrayList[I64] = ArrayList::create[I64]()
    assert_eq(list.count(), 0 as I64, "new list should be empty")
    assert(list.is_empty(), "new list should report is_empty")
    list.destroy()
    return 0
}

@test
func test_arraylist_add_get() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    list.add(30)
    assert_eq(list.count(), 3 as I64, "count should be 3")
    assert_eq(list.get(0), 10 as I64, "get(0) should be 10")
    assert_eq(list.get(1), 20 as I64, "get(1) should be 20")
    assert_eq(list.get(2), 30 as I64, "get(2) should be 30")
    list.destroy()
    return 0
}

@test
func test_arraylist_set() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    list.set(0, 99)
    assert_eq(list.get(0), 99 as I64, "set should update element")
    list.destroy()
    return 0
}

@test
func test_arraylist_clear() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(1)
    list.add(2)
    list.clear()
    assert_eq(list.count(), 0 as I64, "count should be 0 after clear")
    assert(list.is_empty(), "should be empty after clear")
    list.destroy()
    return 0
}

@test
func test_arraylist_with_capacity() -> I32 {
    var list: ArrayList[I64] = ArrayList::with_capacity[I64](100)
    assert(list.is_empty(), "new list with capacity should be empty")
    list.add(42)
    assert_eq(list.count(), 1 as I64, "count should be 1")
    list.destroy()
    return 0
}

@test
func test_arraylist_insert() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(1)
    list.add(3)
    list.insert(1, 2)
    assert_eq(list.count(), 3 as I64, "count after insert")
    assert_eq(list.get(0), 1 as I64, "element 0")
    assert_eq(list.get(1), 2 as I64, "inserted element")
    assert_eq(list.get(2), 3 as I64, "element 2")
    list.destroy()
    return 0
}

@test
func test_arraylist_remove_at() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    list.add(30)
    list.remove_at(1)
    assert_eq(list.count(), 2 as I64, "count after remove_at")
    assert_eq(list.get(0), 10 as I64, "first element")
    assert_eq(list.get(1), 30 as I64, "second element")
    list.destroy()
    return 0
}

@test
func test_arraylist_contains() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    assert(list.contains(10), "should contain 10")
    assert(not list.contains(30), "should not contain 30")
    list.destroy()
    return 0
}

@test
func test_arraylist_index_of() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    list.add(30)
    assert_eq(list.index_of(20), 1 as I64, "index_of(20) should be 1")
    assert_eq(list.index_of(99), -1 as I64, "index_of(99) should be -1")
    list.destroy()
    return 0
}

@test
func test_arraylist_remove() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(10)
    list.add(20)
    list.add(30)
    let removed = list.remove(20)
    assert(removed, "remove(20) should return true")
    assert_eq(list.count(), 2 as I64, "count after remove")
    let not_removed = list.remove(99)
    assert(not not_removed, "remove(99) should return false")
    list.destroy()
    return 0
}

@test
func test_arraylist_reverse() -> I32 {
    var list: ArrayList[I64] = ArrayList::create[I64]()
    list.add(1)
    list.add(2)
    list.add(3)
    list.reverse()
    assert_eq(list.get(0), 3 as I64, "first after reverse")
    assert_eq(list.get(1), 2 as I64, "second after reverse")
    assert_eq(list.get(2), 1 as I64, "third after reverse")
    list.destroy()
    return 0
}
