// Tests for Buffer collection type
use test
use std::collections::Buffer

// ============================================================================
// Buffer Basic Operations
// ============================================================================

@test
func test_buffer_new() -> I32 {
    let buf: Buffer = Buffer.new(64)
    assert_eq(buf.len(), 0 as I64, "new buffer should have len 0")
    let cap: I64 = buf.capacity()
    assert(cap >= (64 as I64), "capacity should be at least 64")
    buf.destroy()
    return 0
}

@test
func test_buffer_default() -> I32 {
    let buf: Buffer = Buffer.default()
    assert_eq(buf.len(), 0 as I64, "default buffer should have len 0")
    let cap: I64 = buf.capacity()
    assert(cap >= (64 as I64), "default capacity")
    buf.destroy()
    return 0
}

@test
func test_buffer_write_read_byte() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_byte(65)  // A
    buf.write_byte(66)  // B
    buf.write_byte(67)  // C
    
    assert_eq(buf.len(), 3 as I64, "len after 3 bytes")
    
    buf.reset_read()
    
    let a: I32 = buf.read_byte()
    assert_eq(a, 65, "read first byte")
    
    let b: I32 = buf.read_byte()
    assert_eq(b, 66, "read second byte")
    
    let c: I32 = buf.read_byte()
    assert_eq(c, 67, "read third byte")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_write_read_i32() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_i32(42)
    buf.write_i32(-100)
    buf.write_i32(2147483647)  // I32 MAX
    
    buf.reset_read()
    
    let v1: I32 = buf.read_i32()
    assert_eq(v1, 42, "read first i32")
    
    let v2: I32 = buf.read_i32()
    assert_eq(v2, -100, "read second i32")
    
    let v3: I32 = buf.read_i32()
    assert_eq(v3, 2147483647, "read max i32")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_write_read_i64() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_i64(1000000000000 as I64)
    buf.write_i64(-9999999999 as I64)
    
    buf.reset_read()
    
    let v1: I64 = buf.read_i64()
    assert_eq(v1, 1000000000000 as I64, "read first i64")
    
    let v2: I64 = buf.read_i64()
    assert_eq(v2, -9999999999 as I64, "read second i64")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_remaining() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_i32(1)
    buf.write_i32(2)
    buf.write_i32(3)
    
    assert_eq(buf.len(), 12 as I64, "12 bytes written")
    
    buf.reset_read()
    assert_eq(buf.remaining(), 12 as I64, "all bytes remaining")
    
    let _: I32 = buf.read_i32()
    assert_eq(buf.remaining(), 8 as I64, "8 bytes remaining")
    
    let _: I32 = buf.read_i32()
    assert_eq(buf.remaining(), 4 as I64, "4 bytes remaining")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_clear() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_i32(100)
    buf.write_i32(200)
    
    assert_eq(buf.len(), 8 as I64, "len before clear")
    
    buf.clear()
    
    assert_eq(buf.len(), 0 as I64, "len after clear")
    assert_eq(buf.remaining(), 0 as I64, "remaining after clear")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_reset_read() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_i32(42)
    
    buf.reset_read()
    let v1: I32 = buf.read_i32()
    assert_eq(v1, 42, "first read")
    
    buf.reset_read()
    let v2: I32 = buf.read_i32()
    assert_eq(v2, 42, "read after reset")
    
    buf.destroy()
    return 0
}

@test
func test_buffer_mixed_types() -> I32 {
    let buf: Buffer = Buffer.new(64)
    
    buf.write_byte(255)
    buf.write_i32(12345)
    buf.write_i64(9876543210 as I64)
    buf.write_byte(0)
    
    buf.reset_read()
    
    let b1: I32 = buf.read_byte()
    assert_eq(b1, 255, "byte 1")
    
    let i1: I32 = buf.read_i32()
    assert_eq(i1, 12345, "i32")
    
    let i2: I64 = buf.read_i64()
    assert_eq(i2, 9876543210 as I64, "i64")
    
    let b2: I32 = buf.read_byte()
    assert_eq(b2, 0, "byte 2")
    
    buf.destroy()
    return 0
}

