// LinkedList full coverage
use test::{assert, assert_eq}
use std::collections::class_collections::LinkedList

@test
func test_linkedlist_create() -> I32 {
    let list: LinkedList[I64] = LinkedList::create[I64]()
    assert_eq(list.count(), 0 as I64, "new list should be empty")
    assert(list.is_empty(), "new list should report is_empty")
    list.destroy()
    return 0
}

@test
func test_linkedlist_add_last() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(10)
    list.add_last(20)
    list.add_last(30)
    assert_eq(list.count(), 3 as I64, "count should be 3")

    let f: Maybe[I64] = list.first()
    assert(f == Just(10 as I64), "first should be 10")
    let l: Maybe[I64] = list.last()
    assert(l == Just(30 as I64), "last should be 30")
    list.destroy()
    return 0
}

@test
func test_linkedlist_add_first() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_first(30)
    list.add_first(20)
    list.add_first(10)
    assert_eq(list.count(), 3 as I64, "count should be 3")

    let f: Maybe[I64] = list.first()
    assert(f == Just(10 as I64), "first should be 10")
    let l: Maybe[I64] = list.last()
    assert(l == Just(30 as I64), "last should be 30")
    list.destroy()
    return 0
}

@test
func test_linkedlist_add() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add(10)
    list.add(20)
    assert_eq(list.count(), 2 as I64, "add should add_last")
    list.destroy()
    return 0
}

@test
func test_linkedlist_remove_first() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(10)
    list.add_last(20)
    list.add_last(30)

    let r1: Maybe[I64] = list.remove_first()
    assert(r1 == Just(10 as I64), "remove_first should return 10")
    assert_eq(list.count(), 2 as I64, "count after remove_first")
    list.destroy()
    return 0
}

@test
func test_linkedlist_remove_last() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(10)
    list.add_last(20)
    list.add_last(30)

    let r1: Maybe[I64] = list.remove_last()
    assert(r1 == Just(30 as I64), "remove_last should return 30")
    assert_eq(list.count(), 2 as I64, "count after remove_last")
    list.destroy()
    return 0
}

@test
func test_linkedlist_first_last_empty() -> I32 {
    let list: LinkedList[I64] = LinkedList::create[I64]()
    let f: Maybe[I64] = list.first()
    assert(f == Nothing, "first on empty should be Nothing")
    let l: Maybe[I64] = list.last()
    assert(l == Nothing, "last on empty should be Nothing")
    list.destroy()
    return 0
}

@test
func test_linkedlist_clear() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(1)
    list.add_last(2)
    list.add_last(3)
    list.clear()
    assert_eq(list.count(), 0 as I64, "count after clear")
    assert(list.is_empty(), "should be empty after clear")
    list.destroy()
    return 0
}

@test
func test_linkedlist_contains() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(10)
    list.add_last(20)
    list.add_last(30)
    assert(list.contains(20), "should contain 20")
    assert(not list.contains(99), "should not contain 99")
    list.destroy()
    return 0
}

@test
func test_linkedlist_remove() -> I32 {
    var list: LinkedList[I64] = LinkedList::create[I64]()
    list.add_last(10)
    list.add_last(20)
    list.add_last(30)
    let removed = list.remove(20)
    assert(removed, "remove(20) should return true")
    assert_eq(list.count(), 2 as I64, "count after remove")
    assert(not list.contains(20), "should not contain 20 after remove")

    let not_removed = list.remove(99)
    assert(not not_removed, "remove(99) should return false")
    list.destroy()
    return 0
}
