// Consolidated collections tests: HashMap and List basics
// Total @test count: 29
// Sources: hashmap.test.tml, hashmap_edge.test.tml, hashmap_iter.test.tml, list.test.tml, list_grow.test.tml
use test
use test::{assert, assert_eq}
use std::collections::{HashMap, HashMapIter}
use std::collections::List

// ============================================================================
// HashMap Basic Operations (from hashmap.test.tml)
// ============================================================================

@test
func test_hashmap_new() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)
    assert_eq(map.len(), 0 as I64, "new hashmap should have len 0")
    map.destroy()
    return 0
}

@test
func test_hashmap_default() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].default()
    assert_eq(map.len(), 0 as I64, "default hashmap should have len 0")
    map.destroy()
    return 0
}

@test
func test_hashmap_set_and_get() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(1, 100)
    map.set(2, 85)
    map.set(3, 90)

    assert_eq(map.len(), 3 as I64, "len after 3 sets")

    let v1: I32 = map.get(1)
    assert_eq(v1, 100, "get key 1")

    let v2: I32 = map.get(2)
    assert_eq(v2, 85, "get key 2")

    let v3: I32 = map.get(3)
    assert_eq(v3, 90, "get key 3")

    map.destroy()
    return 0
}

@test
func test_hashmap_has() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(1, 10)
    map.set(2, 20)

    assert(map.has(1), "has key 1")
    assert(map.has(2), "has key 2")
    assert(not map.has(3), "does not have key 3")

    map.destroy()
    return 0
}

@test
func test_hashmap_remove() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(1, 10)
    map.set(2, 20)
    map.set(3, 30)

    assert_eq(map.len(), 3 as I64, "len before remove")

    let removed: Bool = map.remove(2)
    assert(removed, "remove should return true for existing key")
    assert_eq(map.len(), 2 as I64, "len after remove")
    assert(not map.has(2), "key 2 should be gone")

    let not_found: Bool = map.remove(999)
    assert(not not_found, "remove should return false for missing key")

    map.destroy()
    return 0
}

@test
func test_hashmap_clear() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(1, 100)
    map.set(2, 200)
    map.set(3, 300)

    assert_eq(map.len(), 3 as I64, "len before clear")

    map.clear()

    assert_eq(map.len(), 0 as I64, "len after clear")
    assert(not map.has(1), "key 1 should be gone after clear")

    map.destroy()
    return 0
}

@test
func test_hashmap_update_value() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(100, 50)
    assert_eq(map.get(100), 50, "initial value")

    map.set(100, 999)
    assert_eq(map.get(100), 999, "updated value")
    assert_eq(map.len(), 1 as I64, "len should still be 1")

    map.destroy()
    return 0
}

@test
func test_hashmap_i64_keys() -> I32 {
    let map: HashMap[I64, I64] = HashMap[I64, I64].new(16)

    map.set(1000000000000 as I64, 999 as I64)
    map.set(1 as I64, 111 as I64)

    assert_eq(map.get(1000000000000 as I64), 999 as I64, "get large key")
    assert_eq(map.get(1 as I64), 111 as I64, "get small key")

    map.destroy()
    return 0
}

// ============================================================================
// HashMap Iterator (from hashmap.test.tml)
// ============================================================================

@test
func test_hashmap_iter() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    map.set(1, 10)
    map.set(2, 20)
    map.set(3, 30)

    var sum: I32 = 0
    var count: I32 = 0

    let iter: HashMapIter[I32, I32] = map.iter()
    loop (iter.has_next()) {
        let k: I32 = iter.key()
        let v: I32 = iter.value()
        sum = sum + v
        count = count + 1
        iter.next()
    }
    iter.destroy()

    assert_eq(count, 3, "should iterate 3 times")
    assert_eq(sum, 60, "sum of values")

    map.destroy()
    return 0
}

@test
func test_hashmap_iter_empty() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)

    let iter: HashMapIter[I32, I32] = map.iter()
    assert(not iter.has_next(), "empty map iter should have no next")
    iter.destroy()

    map.destroy()
    return 0
}

// ============================================================================
// HashMap with String Keys (from hashmap.test.tml)
// ============================================================================

@test
func test_hashmap_str_keys() -> I32 {
    let map: HashMap[Str, I32] = HashMap[Str, I32].new(16)

    map.set("alice", 100)
    map.set("bob", 85)
    map.set("charlie", 90)

    assert_eq(map.len(), 3 as I64, "len after 3 sets")

    let alice: I32 = map.get("alice")
    assert_eq(alice, 100, "get alice score")

    let bob: I32 = map.get("bob")
    assert_eq(bob, 85, "get bob score")

    map.destroy()
    return 0
}

@test
func test_hashmap_str_has() -> I32 {
    let map: HashMap[Str, I32] = HashMap[Str, I32].new(16)

    map.set("key1", 1)
    map.set("key2", 2)

    assert(map.has("key1"), "has key1")
    assert(map.has("key2"), "has key2")
    assert(not map.has("key3"), "does not have key3")

    map.destroy()
    return 0
}

@test
func test_hashmap_str_remove() -> I32 {
    let map: HashMap[Str, I32] = HashMap[Str, I32].new(16)

    map.set("a", 1)
    map.set("b", 2)

    let removed: Bool = map.remove("a")
    assert(removed, "remove should return true")
    assert(not map.has("a"), "a should be gone")

    map.destroy()
    return 0
}

// ============================================================================
// HashMap Edge Cases (from hashmap_edge.test.tml)
// ============================================================================

@test
func test_hashmap_many_entries() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(4)
    var i: I32 = 0
    loop (i < 50) {
        map.set(i, i * 10)
        i = i + 1
    }
    assert_eq(map.len(), 50 as I64, "50 entries")
    assert_eq(map.get(0), 0, "get key 0")
    assert_eq(map.get(25), 250, "get key 25")
    assert_eq(map.get(49), 490, "get key 49")
    map.destroy()
    return 0
}

@test
func test_hashmap_remove_reinsert() -> I32 {
    let map: HashMap[I32, I32] = HashMap[I32, I32].new(16)
    map.set(1, 10)
    map.remove(1)
    assert(not map.has(1), "key should be gone after remove")
    map.set(1, 20)
    assert(map.has(1), "key should exist after reinsert")
    assert_eq(map.get(1), 20, "value should be new value")
    map.destroy()
    return 0
}

@test
func test_hashmap_clear_reuse() -> I32 {
    let map: HashMap[Str, I32] = HashMap[Str, I32].new(16)
    map.set("x", 1)
    map.set("y", 2)
    map.clear()
    assert_eq(map.len(), 0 as I64, "empty after clear")
    map.set("z", 99)
    assert_eq(map.get("z"), 99, "can use after clear")
    assert_eq(map.len(), 1 as I64, "len is 1")
    map.destroy()
    return 0
}

// ============================================================================
// HashMap Iterator (from hashmap_iter.test.tml)
// ============================================================================

@test
func test_hashmap_iter_has_next() -> I32 {
    var m: HashMap[I32, I32] = HashMap[I32, I32].new(16)
    m.set(1, 10)
    m.set(2, 20)
    var iter: HashMapIter[I32, I32] = m.iter()
    assert(iter.has_next(), "iter should have next")
    iter.next()
    iter.next()
    assert(not iter.has_next(), "iter should be exhausted after 2 next calls")
    iter.destroy()
    m.destroy()
    return 0
}

@test
func test_hashmap_iter_key_value_consolidated() -> I32 {
    var m: HashMap[I32, I32] = HashMap[I32, I32].new(16)
    m.set(42, 100)
    var iter: HashMapIter[I32, I32] = m.iter()
    assert(iter.has_next(), "should have next")
    let k: I32 = iter.key()
    let v: I32 = iter.value()
    assert_eq(k, 42, "key should be 42")
    assert_eq(v, 100, "value should be 100")
    iter.destroy()
    m.destroy()
    return 0
}

// ============================================================================
// List[T] Tests (from list.test.tml)
// ============================================================================

@test
func test_list_new() -> I32 {
    let list: List[I32] = List[I32].new(8)
    assert(list.is_empty(), "new list should be empty")
    assert_eq(list.len(), 0 as I64, "new list len should be 0")
    list.destroy()
    return 0
}

@test
func test_list_push_and_get() -> I32 {
    let list: List[I32] = List[I32].new(8)

    list.push(10)
    list.push(20)
    list.push(30)

    assert_eq(list.len(), 3 as I64, "len after 3 pushes")
    assert(not list.is_empty(), "list should not be empty")

    let v0: I64 = list.get(0)
    assert_eq(v0, 10 as I64, "get index 0")

    let v1: I64 = list.get(1)
    assert_eq(v1, 20 as I64, "get index 1")

    let v2: I64 = list.get(2)
    assert_eq(v2, 30 as I64, "get index 2")

    list.destroy()
    return 0
}

@test
func test_list_set() -> I32 {
    let list: List[I32] = List[I32].new(8)

    list.push(1)
    list.push(2)
    list.push(3)

    list.set(1, 42)

    let v0: I64 = list.get(0)
    assert_eq(v0, 1 as I64, "index 0 unchanged")

    let v1: I64 = list.get(1)
    assert_eq(v1, 42 as I64, "index 1 changed")

    let v2: I64 = list.get(2)
    assert_eq(v2, 3 as I64, "index 2 unchanged")

    list.destroy()
    return 0
}

@test
func test_list_pop() -> I32 {
    let list: List[I32] = List[I32].new(8)

    list.push(100)
    list.push(200)
    list.push(300)

    let v1: I64 = list.pop()
    assert_eq(v1, 300 as I64, "pop should return last")
    assert_eq(list.len(), 2 as I64, "len after pop")

    let v2: I64 = list.pop()
    assert_eq(v2, 200 as I64, "pop should return 200")

    let v3: I64 = list.pop()
    assert_eq(v3, 100 as I64, "pop should return 100")

    assert(list.is_empty(), "list should be empty after popping all")

    list.destroy()
    return 0
}

@test
func test_list_first_last() -> I32 {
    let list: List[I32] = List[I32].new(8)

    list.push(1)
    list.push(2)
    list.push(3)

    let first: I64 = list.first()
    assert_eq(first, 1 as I64, "first should be 1")

    let last: I64 = list.last()
    assert_eq(last, 3 as I64, "last should be 3")

    list.destroy()
    return 0
}

@test
func test_list_clear() -> I32 {
    let list: List[I32] = List[I32].new(8)

    list.push(1)
    list.push(2)
    list.push(3)

    list.clear()

    assert(list.is_empty(), "list should be empty after clear")
    assert_eq(list.len(), 0 as I64, "len should be 0 after clear")

    // Should be able to push again
    list.push(42)
    assert_eq(list.len(), 1 as I64, "can push after clear")

    let val: I64 = list.get(0)
    assert_eq(val, 42 as I64, "value correct after clear and push")

    list.destroy()
    return 0
}

@test
func test_list_capacity() -> I32 {
    let list: List[I32] = List[I32].new(16)
    let cap: I64 = list.capacity()
    assert(cap >= (16 as I64), "capacity should be at least 16")
    list.destroy()
    return 0
}

@test
func test_list_i64() -> I32 {
    let list: List[I64] = List[I64].new(4)

    list.push(1000000000000 as I64)
    list.push(2000000000000 as I64)

    let v0: I64 = list.get(0)
    assert_eq(v0, 1000000000000 as I64, "i64 value 1")

    let v1: I64 = list.get(1)
    assert_eq(v1, 2000000000000 as I64, "i64 value 2")

    list.destroy()
    return 0
}

@test
func test_list_default() -> I32 {
    let list: List[I32] = List[I32].default()
    assert(list.is_empty(), "default list should be empty")
    let cap: I64 = list.capacity()
    assert(cap >= (8 as I64), "default capacity should be at least 8")
    list.push(42)
    let val: I64 = list.get(0)
    assert_eq(val, 42 as I64, "can use default list")
    list.destroy()
    return 0
}

// ============================================================================
// List Growth and Edge Cases (from list_grow.test.tml)
// ============================================================================

@test
func test_list_grow_beyond_capacity() -> I32 {
    let list: List[I32] = List[I32].new(2)
    list.push(1)
    list.push(2)
    list.push(3)
    list.push(4)
    list.push(5)
    assert_eq(list.len(), 5 as I64, "list should have 5 elements")
    let v4: I64 = list.get(4)
    assert_eq(v4, 5 as I64, "element beyond initial capacity")
    list.destroy()
    return 0
}

@test
func test_list_push_pop_cycle() -> I32 {
    let list: List[I32] = List[I32].new(4)
    list.push(10)
    list.push(20)
    let a: I64 = list.pop()
    assert_eq(a, 20 as I64, "pop returns 20")
    list.push(30)
    list.push(40)
    assert_eq(list.len(), 3 as I64, "len after push-pop-push-push")
    let b: I64 = list.get(2)
    assert_eq(b, 40 as I64, "last pushed element")
    list.destroy()
    return 0
}

@test
func test_list_set_overwrite() -> I32 {
    let list: List[I32] = List[I32].new(4)
    list.push(0)
    list.push(0)
    list.push(0)
    list.set(0, 100)
    list.set(1, 200)
    list.set(2, 300)
    let v0: I64 = list.get(0)
    let v1: I64 = list.get(1)
    let v2: I64 = list.get(2)
    assert_eq(v0, 100 as I64, "set index 0")
    assert_eq(v1, 200 as I64, "set index 1")
    assert_eq(v2, 300 as I64, "set index 2")
    list.destroy()
    return 0
}
