// Tests for json/types module - Json, JsonObject, JsonArray methods
use test
use std::json::types::{Json, JsonObject, JsonArray, parse_or_panic, parse}

// =============================================================================
// Json type checks
// =============================================================================

@test
func test_json_is_null() -> I32 {
    let j: Json = parse_or_panic("null")
    assert(j.is_null(), "null should be null")
    return 0
}

@test
func test_json_is_bool() -> I32 {
    let j: Json = parse_or_panic("true")
    assert(j.is_bool(), "true should be bool")
    return 0
}

@test
func test_json_is_number() -> I32 {
    let j: Json = parse_or_panic("42")
    assert(j.is_number(), "42 should be number")
    return 0
}

@test
func test_json_is_string() -> I32 {
    let j: Json = parse_or_panic("\"hello\"")
    assert(j.is_string(), "quoted string should be string")
    return 0
}

@test
func test_json_is_array() -> I32 {
    let j: Json = parse_or_panic("[1]")
    assert(j.is_array(), "[1] should be array")
    return 0
}

@test
func test_json_is_object() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1}")
    assert(j.is_object(), "{} should be object")
    return 0
}

@test
func test_json_get_type() -> I32 {
    let j: Json = parse_or_panic("42")
    let t: I32 = j.get_type()
    assert(t >= 0, "get_type should return valid type")
    return 0
}

@test
func test_json_to_string() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1}")
    let s: Str = j.to_string()
    assert(s.len() > 0, "to_string should produce output")
    return 0
}

@test
func test_json_len_array() -> I32 {
    let j: Json = parse_or_panic("[1, 2, 3]")
    let l: I64 = j.len()
    assert(l == 3, "array len should be 3")
    return 0
}

@test
func test_json_len_object() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1, \"b\": 2}")
    let l: I64 = j.len()
    assert(l == 2, "object len should be 2")
    return 0
}

// =============================================================================
// Json value accessors (safe Maybe-returning)
// =============================================================================

@test
func test_json_as_i64() -> I32 {
    let j: Json = parse_or_panic("42")
    let val: Maybe[I64] = j.as_i64()
    assert(val.is_just(), "as_i64 should be Just for number")
    return 0
}

@test
func test_json_as_f64() -> I32 {
    let j: Json = parse_or_panic("3.14")
    let val: Maybe[F64] = j.as_f64()
    assert(val.is_just(), "as_f64 should be Just for number")
    return 0
}

@test
func test_json_as_bool() -> I32 {
    let j: Json = parse_or_panic("true")
    let val: Maybe[Bool] = j.as_bool()
    assert(val.is_just(), "as_bool should be Just for bool")
    return 0
}

@test
func test_json_as_str() -> I32 {
    let j: Json = parse_or_panic("\"hello\"")
    let val: Maybe[Str] = j.as_str()
    assert(val.is_just(), "as_str should be Just for string")
    return 0
}

@test
func test_json_as_array() -> I32 {
    let j: Json = parse_or_panic("[1, 2, 3]")
    let val: Maybe[JsonArray] = j.as_array()
    assert(val.is_just(), "as_array should be Just for array")
    return 0
}

@test
func test_json_as_object() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1}")
    let val: Maybe[JsonObject] = j.as_object()
    assert(val.is_just(), "as_object should be Just for object")
    return 0
}

// =============================================================================
// Json value accessors (wrong type returns Nothing)
// =============================================================================

@test
func test_json_as_i64_wrong_type() -> I32 {
    let j: Json = parse_or_panic("\"not a number\"")
    let val: Maybe[I64] = j.as_i64()
    assert(val.is_nothing(), "as_i64 on string should be Nothing")
    return 0
}

@test
func test_json_as_bool_wrong_type() -> I32 {
    let j: Json = parse_or_panic("42")
    let val: Maybe[Bool] = j.as_bool()
    assert(val.is_nothing(), "as_bool on number should be Nothing")
    return 0
}

// =============================================================================
// Json unwrap methods (panicking)
// =============================================================================

@test
func test_json_unwrap_i64() -> I32 {
    let j: Json = parse_or_panic("42")
    let val: I64 = j.unwrap_i64()
    assert(val == 42 as I64, "unwrap_i64 should return 42")
    return 0
}

@test
func test_json_unwrap_f64() -> I32 {
    let j: Json = parse_or_panic("3.14")
    let val: F64 = j.unwrap_f64()
    assert(val > 3.0, "unwrap_f64 should return > 3")
    return 0
}

@test
func test_json_unwrap_bool() -> I32 {
    let j: Json = parse_or_panic("true")
    let val: Bool = j.unwrap_bool()
    assert(val, "unwrap_bool should return true")
    return 0
}

@test
func test_json_unwrap_str() -> I32 {
    let j: Json = parse_or_panic("\"hello\"")
    let val: Str = j.unwrap_str()
    assert(val.len() > 0, "unwrap_str should return non-empty string")
    return 0
}

// =============================================================================
// Json object field access (convenience methods)
// =============================================================================

@test
func test_json_get_field() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Alice\"}")
    let val: Maybe[Json] = j.get("name")
    assert(val.is_just(), "get name should be Just")
    return 0
}

@test
func test_json_get_field_missing() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Alice\"}")
    let val: Maybe[Json] = j.get("missing")
    assert(val.is_nothing(), "get missing should be Nothing")
    return 0
}

@test
func test_json_get_string() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Bob\"}")
    let val: Maybe[Str] = j.get_string("name")
    assert(val.is_just(), "get_string name should be Just")
    return 0
}

@test
func test_json_get_i64() -> I32 {
    let j: Json = parse_or_panic("{\"age\": 30}")
    let val: Maybe[I64] = j.get_i64("age")
    assert(val.is_just(), "get_i64 age should be Just")
    return 0
}

@test
func test_json_has() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Alice\"}")
    assert(j.has("name"), "has name should be true")
    assert(not j.has("missing"), "has missing should be false")
    return 0
}

@test
func test_json_at_method() -> I32 {
    let j: Json = parse_or_panic("[10, 20, 30]")
    let val: Maybe[Json] = j.at(1)
    assert(val.is_just(), "at(1) should be Just")
    return 0
}

@test
func test_json_at_out_of_bounds() -> I32 {
    let j: Json = parse_or_panic("[10, 20]")
    let val: Maybe[Json] = j.at(5)
    assert(val.is_nothing(), "at(5) should be Nothing for 2-elem array")
    return 0
}

// =============================================================================
// Json constructors
// =============================================================================

@test
func test_json_new_null() -> I32 {
    let j: Json = Json::new_null()
    assert(j.is_null(), "new_null should be null")
    return 0
}

@test
func test_json_new_bool() -> I32 {
    let j: Json = Json::new_bool(true)
    assert(j.is_bool(), "new_bool should be bool")
    return 0
}

@test
func test_json_int_constructor() -> I32 {
    let j: Json = Json::int(42)
    assert(j.is_number(), "int constructor should create number")
    return 0
}

@test
func test_json_string_constructor() -> I32 {
    let j: Json = Json::string("hello")
    assert(j.is_string(), "string constructor should create string")
    return 0
}

// =============================================================================
// Json path navigation
// =============================================================================

@test
func test_json_get_path_simple() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Alice\"}")
    let val: Maybe[Json] = j.get_path("name")
    assert(val.is_just(), "get_path name should be Just")
    return 0
}

@test
func test_json_get_path_nested() -> I32 {
    let j: Json = parse_or_panic("{\"user\": {\"name\": \"Alice\"}}")
    let val: Maybe[Json] = j.get_path("user.name")
    assert(val.is_just(), "get_path user.name should be Just")
    return 0
}

@test
func test_json_get_path_array_index() -> I32 {
    let j: Json = parse_or_panic("{\"items\": [10, 20, 30]}")
    let val: Maybe[Json] = j.get_path("items[1]")
    assert(val.is_just(), "get_path items[1] should be Just")
    return 0
}

@test
func test_json_get_path_string() -> I32 {
    let j: Json = parse_or_panic("{\"name\": \"Alice\"}")
    let val: Maybe[Str] = j.get_path_string("name")
    assert(val.is_just(), "get_path_string name should be Just")
    return 0
}

@test
func test_json_get_path_i64() -> I32 {
    let j: Json = parse_or_panic("{\"age\": 30}")
    let val: Maybe[I64] = j.get_path_i64("age")
    assert(val.is_just(), "get_path_i64 age should be Just")
    return 0
}

// =============================================================================
// Json key/value iteration
// =============================================================================

@test
func test_json_key_at() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1, \"b\": 2}")
    let key: Maybe[Str] = j.key_at(0)
    assert(key.is_just(), "key_at(0) should be Just")
    return 0
}

@test
func test_json_value_at() -> I32 {
    let j: Json = parse_or_panic("{\"a\": 1, \"b\": 2}")
    let val: Maybe[Json] = j.value_at(0)
    assert(val.is_just(), "value_at(0) should be Just")
    return 0
}

// =============================================================================
// parse / parse_result
// =============================================================================

@test
func test_json_parse_valid() -> I32 {
    let result: Maybe[Json] = parse("{\"key\": \"value\"}")
    assert(result.is_just(), "parse valid JSON should return Just")
    return 0
}

@test
func test_json_parse_invalid() -> I32 {
    let result: Maybe[Json] = parse("not json at all")
    assert(result.is_nothing(), "parse invalid JSON should return Nothing")
    return 0
}
