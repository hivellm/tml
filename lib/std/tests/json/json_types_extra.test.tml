// Tests for json/types - JsonNumber methods, Json::get_or
use test
use std::json::types::{Json, JsonNumber, parse_or_panic}

@test
func test_json_number_int_to_i64() -> I32 {
    let n: JsonNumber = JsonNumber::Int(42 as I64)
    let v: I64 = n.to_i64()
    assert_eq(v, 42 as I64, "Int(42).to_i64() = 42")
    return 0
}

@test
func test_json_number_float_to_f64() -> I32 {
    let n: JsonNumber = JsonNumber::Float(3.14 as F64)
    let v: F64 = n.to_f64()
    assert(v > 3.0 as F64, "Float to_f64 > 3.0")
    return 0
}

@test
func test_json_number_is_integer() -> I32 {
    let n1: JsonNumber = JsonNumber::Int(10 as I64)
    assert(n1.is_integer(), "Int is integer")
    let n2: JsonNumber = JsonNumber::Float(1.5 as F64)
    assert(not n2.is_integer(), "Float is not integer")
    return 0
}

@test
func test_json_number_to_json_string() -> I32 {
    let n: JsonNumber = JsonNumber::Int(99 as I64)
    let s: Str = n.to_json_string()
    assert(s.len() > 0, "to_json_string should produce output")
    return 0
}

// BLOCKED: Json::get_or â€” runtime panic, possibly returns wrong variant
// @test
// func test_json_get_or() -> I32 {
//     let j: Json = parse_or_panic("{\"a\": 1}")
//     let fallback: Json = parse_or_panic("99")
//     let got: Json = j.get_or("a", fallback)
//     assert(got.is_number(), "get_or existing key returns number")
//     return 0
// }
