// Thread local storage tests
// Tests for std::thread::local::LocalKey[T]
// Note: Full tests are limited due to closure capture codegen issues
// These tests verify the basic LocalKey API compiles and basic operations work
use test::{assert, assert_eq}
use std::thread::local::LocalKey

// ============================================================================
// LocalKey Creation Tests
// ============================================================================

@test
func test_local_key_new() -> I32 {
    // Create a LocalKey with an initializer
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 42)
    return 0
}

@test
func test_local_key_new_zero() -> I32 {
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 0)
    return 0
}

@test
func test_local_key_new_negative() -> I32 {
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 -100)
    return 0
}

@test
func test_local_key_new_large_value() -> I32 {
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 2147483647)
    return 0
}

// ============================================================================
// LocalKey is_initialized() Tests
// ============================================================================

@test
func test_local_key_is_initialized_before_access() -> I32 {
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 0)

    // Before first access, not initialized
    let initialized: Bool = key.is_initialized()
    assert(not initialized, "Should not be initialized before access")
    return 0
}

// ============================================================================
// Multiple LocalKey Tests
// ============================================================================

@test
func test_multiple_local_keys_creation() -> I32 {
    var key1: LocalKey[I32] = LocalKey::new(do() -> I32 1)
    var key2: LocalKey[I32] = LocalKey::new(do() -> I32 2)
    var key3: LocalKey[I32] = LocalKey::new(do() -> I32 3)

    // All should be uninitialized
    assert(not key1.is_initialized(), "key1 not initialized")
    assert(not key2.is_initialized(), "key2 not initialized")
    assert(not key3.is_initialized(), "key3 not initialized")
    return 0
}

@test
func test_local_key_with_computation() -> I32 {
    // Lazy initialization with computation
    var key: LocalKey[I32] = LocalKey::new(do() -> I32 {
        return 7 * 6
    })
    // Should not be initialized yet (lazy)
    assert(not key.is_initialized(), "Should be lazy initialized")
    return 0
}

// Note: Full access/access_mut tests require fixing closure capture codegen
// for mutable references. See compiler/src/codegen/expr/closure.cpp
