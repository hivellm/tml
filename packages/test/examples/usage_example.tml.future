// Example demonstrating the test framework package
// This shows how to use the test framework types and functions

use test

@test
func test_runner_stats() -> I32 {
    // Create empty stats
    let mut stats: TestStats = empty_stats()

    // Add some test results
    stats_add_passed(stats)
    stats_add_passed(stats)
    stats_add_failed(stats)

    // Verify counts
    assert_eq_i32(stats.total, 3, "total should be 3")
    assert_eq_i32(stats.passed, 2, "passed should be 2")
    assert_eq_i32(stats.failed, 1, "failed should be 1")

    return 0
}

@test
func test_config_creation() -> I32 {
    // Create default config
    let config: TestConfig = default_config()

    // Verify defaults
    assert_eq_bool(config.parallel, false, "parallel should be false")
    assert_eq_i32(config.threads, 1, "threads should be 1")
    assert_eq_bool(config.verbose, false, "verbose should be false")

    return 0
}

@test
func test_bench_result() -> I32 {
    // Create benchmark result
    let result: BenchResult = empty_bench_result("test_bench")

    // Verify initial values
    assert_eq_i32(result.iterations, 0, "iterations should be 0")
    assert_eq_i64(result.total_ns, 0, "total_ns should be 0")

    return 0
}

@test
func test_format_time_units() -> I32 {
    // Test time formatting
    let ns_unit: Str = format_time_ns(500)
    let us_unit: Str = format_time_ns(1500)
    let ms_unit: Str = format_time_ns(1500000)
    let s_unit: Str = format_time_ns(1500000000)

    // These should return the appropriate unit strings
    assert(str_eq(ns_unit, "ns"), "should return ns")
    assert(str_eq(us_unit, "us"), "should return us")
    assert(str_eq(ms_unit, "ms"), "should return ms")
    assert(str_eq(s_unit, "s"), "should return s")

    return 0
}

@test
func test_calculate_iterations() -> I32 {
    // Test iteration calculation
    let iters_fast: I32 = calculate_iterations(100)  // 100ns per op
    let iters_slow: I32 = calculate_iterations(10000000)  // 10ms per op

    // Fast operations should have more iterations
    assert(iters_fast > iters_slow, "fast should have more iterations")

    // Should cap at maximum
    let iters_instant: I32 = calculate_iterations(0)
    assert_eq_i32(iters_instant, 1000000, "should default to 1M")

    return 0
}

@test
func test_metadata_creation() -> I32 {
    // Create test metadata
    let metadata: TestMetadata = make_metadata(
        "test_name",
        "test_module",
        "test.tml",
        42,
        false,
        false
    )

    // Verify metadata fields
    assert(str_eq(metadata.name, "test_name"), "name should match")
    assert(str_eq(metadata.module, "test_module"), "module should match")
    assert_eq_i32(metadata.line, 42, "line should be 42")
    assert_eq_bool(metadata.should_panic, false, "should_panic should be false")
    assert_eq_bool(metadata.ignored, false, "ignored should be false")

    return 0
}

@test
func test_reporting_functions() -> I32 {
    // Test that reporting functions can be called
    // (we can't easily test output, but we verify they don't crash)

    print_test_header(5)
    print_test_ok("test1")
    print_test_failed("test2")
    print_test_ignored("test3")

    let stats: TestStats = empty_stats()
    print_test_summary(stats)

    println("Reporting functions work correctly")

    return 0
}

@test
func test_bench_timing() -> I32 {
    // Test basic benchmark timing
    let start: I64 = time_ns()

    // Do some work
    let sum: I32 = 0
    let i: I32 = 0
    loop {
        if i >= 100 {
            break
        }
        sum = sum + i
        i = i + 1
    }

    let end: I64 = time_ns()
    let duration: I64 = end - start

    // Duration should be positive
    assert(duration > 0, "duration should be positive")

    println("Benchmark timing works")

    return 0
}
