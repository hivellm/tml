use test

// ============ Integer Edge Cases ============

@test
func test_zero_operations() -> I32 {
    // Zero in arithmetic
    assert_eq_i32(0 + 0, 0, "0 + 0")
    assert_eq_i32(0 - 0, 0, "0 - 0")
    assert_eq_i32(0 * 100, 0, "0 * 100")
    assert_eq_i32(0 / 1, 0, "0 / 1")
    assert_eq_i32(0 % 5, 0, "0 % 5")

    return 0
}

@test
func test_one_operations() -> I32 {
    // Identity operations
    assert_eq_i32(1 * 42, 42, "1 * 42")
    assert_eq_i32(42 * 1, 42, "42 * 1")
    assert_eq_i32(42 / 1, 42, "42 / 1")
    assert_eq_i32(100 % 1, 0, "100 % 1")

    return 0
}

@test
func test_negative_numbers() -> I32 {
    let neg: I32 = 0 - 5

    assert_eq_i32(neg + 10, 5, "-5 + 10")
    assert_eq_i32(neg * 2, 0 - 10, "-5 * 2")
    assert_eq_i32(neg * neg, 25, "-5 * -5")

    return 0
}

// ============ Boolean Edge Cases ============

@test
func test_boolean_identity() -> I32 {
    // AND identity
    assert(true and true, "T and T")
    assert_eq_bool(true and false, false, "T and F")
    assert_eq_bool(false and true, false, "F and T")
    assert_eq_bool(false and false, false, "F and F")

    // OR identity
    assert(true or true, "T or T")
    assert(true or false, "T or F")
    assert(false or true, "F or T")
    assert_eq_bool(false or false, false, "F or F")

    return 0
}

@test
func test_not_operations() -> I32 {
    assert(not false, "not false")
    assert_eq_bool(not true, false, "not true")
    assert(not not true, "double not true")
    assert_eq_bool(not not false, false, "double not false")

    return 0
}

// ============ Comparison Edge Cases ============

@test
func test_equality_reflexive() -> I32 {
    let x: I32 = 42
    assert(x == x, "x == x")
    assert_eq_bool(x != x, false, "x != x is false")

    return 0
}

@test
func test_comparison_transitivity() -> I32 {
    let a: I32 = 1
    let b: I32 = 2
    let c: I32 = 3

    // If a < b and b < c, then a < c
    let ab: Bool = a < b
    let bc: Bool = b < c
    let ac: Bool = a < c

    assert(ab, "1 < 2")
    assert(bc, "2 < 3")
    assert(ac, "1 < 3 (transitivity)")

    return 0
}

// ============ Loop Edge Cases ============

@test
func test_zero_iterations() -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 0

    loop {
        if i >= 0 then { break }  // Immediately break
        count = count + 1
        i = i + 1
    }

    assert_eq_i32(count, 0, "zero iterations")

    return 0
}

@test
func test_single_iteration() -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 0

    loop {
        if i >= 1 then { break }
        count = count + 1
        i = i + 1
    }

    assert_eq_i32(count, 1, "single iteration")

    return 0
}

// ============ Function Edge Cases ============

func return_input(x: I32) -> I32 {
    return x
}

func return_constant() -> I32 {
    return 42
}

func always_true() -> Bool {
    return true
}

func always_false() -> Bool {
    return false
}

@test
func test_trivial_functions() -> I32 {
    assert_eq_i32(return_input(0), 0, "return 0")
    assert_eq_i32(return_input(100), 100, "return 100")
    assert_eq_i32(return_constant(), 42, "constant")
    assert(always_true(), "always true")
    assert_eq_bool(always_false(), false, "always false")

    return 0
}

// ============ Bitwise Edge Cases ============

@test
func test_bitwise_zero() -> I32 {
    assert_eq_i32(0 & 255, 0, "0 & x = 0")
    assert_eq_i32(255 & 0, 0, "x & 0 = 0")
    assert_eq_i32(0 | 255, 255, "0 | x = x")
    assert_eq_i32(0 ^ 255, 255, "0 ^ x = x")

    return 0
}

@test
func test_bitwise_self() -> I32 {
    let x: I32 = 170  // 0b10101010

    assert_eq_i32(x & x, x, "x & x = x")
    assert_eq_i32(x | x, x, "x | x = x")
    assert_eq_i32(x ^ x, 0, "x ^ x = 0")

    return 0
}

@test
func test_shift_zero() -> I32 {
    assert_eq_i32(0 << 5, 0, "0 << n = 0")
    assert_eq_i32(0 >> 5, 0, "0 >> n = 0")
    assert_eq_i32(42 << 0, 42, "x << 0 = x")
    assert_eq_i32(42 >> 0, 42, "x >> 0 = x")

    return 0
}

// ============ Boundary Values ============

@test
func test_power_of_two_boundaries() -> I32 {
    // Powers of 2
    assert_eq_i32(1 << 0, 1, "2^0")
    assert_eq_i32(1 << 1, 2, "2^1")
    assert_eq_i32(1 << 2, 4, "2^2")
    assert_eq_i32(1 << 3, 8, "2^3")
    assert_eq_i32(1 << 4, 16, "2^4")
    assert_eq_i32(1 << 10, 1024, "2^10")

    return 0
}

@test
func test_near_boundaries() -> I32 {
    // Test values near common boundaries
    assert_eq_i32(127 + 1, 128, "127 + 1")
    assert_eq_i32(255 + 1, 256, "255 + 1")
    assert_eq_i32(256 - 1, 255, "256 - 1")
    assert_eq_i32(1000 - 1, 999, "1000 - 1")

    return 0
}

// ============ Complex Expression Edge Cases ============

@test
func test_mixed_operations() -> I32 {
    // Mix of operators
    let x: I32 = 10
    let y: I32 = 3

    let result: I32 = (x + y) * (x - y)
    assert_eq_i32(result, 91, "(10+3)*(10-3) = 13*7")

    let mod_result: I32 = (x * y) % (x - y)
    assert_eq_i32(mod_result, 2, "(10*3) % 7 = 30 % 7")

    return 0
}

@test
func test_associativity() -> I32 {
    let a: I32 = 2
    let b: I32 = 3
    let c: I32 = 4

    // Addition is associative
    assert_eq_i32((a + b) + c, a + (b + c), "(a+b)+c = a+(b+c)")

    // Multiplication is associative
    assert_eq_i32((a * b) * c, a * (b * c), "(a*b)*c = a*(b*c)")

    return 0
}
