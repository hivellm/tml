use test

// ============ Parameterized Test Pattern ============
// Simulate parameterized tests by iterating through test cases

func run_add_test(a: I32, b: I32, expected: I32) -> I32 {
    let result: I32 = a + b
    return if result == expected then 0 else 1
}

@test
func test_parameterized_addition() -> I32 {
    // Test cases: (a, b, expected)
    let mut failures: I32 = 0

    failures = failures + run_add_test(0, 0, 0)
    failures = failures + run_add_test(1, 0, 1)
    failures = failures + run_add_test(0, 1, 1)
    failures = failures + run_add_test(1, 1, 2)
    failures = failures + run_add_test(5, 3, 8)
    failures = failures + run_add_test(10, 20, 30)

    assert_eq_i32(failures, 0, "all add tests pass")

    return 0
}

func run_mult_test(a: I32, b: I32, expected: I32) -> I32 {
    let result: I32 = a * b
    return if result == expected then 0 else 1
}

@test
func test_parameterized_multiplication() -> I32 {
    let mut failures: I32 = 0

    failures = failures + run_mult_test(0, 0, 0)
    failures = failures + run_mult_test(1, 0, 0)
    failures = failures + run_mult_test(0, 1, 0)
    failures = failures + run_mult_test(1, 1, 1)
    failures = failures + run_mult_test(2, 3, 6)
    failures = failures + run_mult_test(7, 8, 56)

    assert_eq_i32(failures, 0, "all mult tests pass")

    return 0
}

// ============ Table-Driven Tests ============

func test_square(x: I32, expected: I32) -> I32 {
    let actual: I32 = x * x
    return if actual == expected then 0 else 1
}

@test
func test_squares_table() -> I32 {
    let mut failures: I32 = 0

    // Table of (input, expected)
    failures = failures + test_square(0, 0)
    failures = failures + test_square(1, 1)
    failures = failures + test_square(2, 4)
    failures = failures + test_square(3, 9)
    failures = failures + test_square(4, 16)
    failures = failures + test_square(5, 25)
    failures = failures + test_square(10, 100)
    failures = failures + test_square(12, 144)

    assert_eq_i32(failures, 0, "all square tests pass")

    return 0
}

// ============ Property-Based Testing Simulation ============

func verify_add_commutative(a: I32, b: I32) -> I32 {
    // a + b == b + a
    return if (a + b) == (b + a) then 0 else 1
}

func verify_mult_commutative(a: I32, b: I32) -> I32 {
    // a * b == b * a
    return if (a * b) == (b * a) then 0 else 1
}

func verify_distributive(a: I32, b: I32, c: I32) -> I32 {
    // a * (b + c) == a * b + a * c
    let lhs: I32 = a * (b + c)
    let rhs: I32 = a * b + a * c
    return if lhs == rhs then 0 else 1
}

@test
func test_commutative_property() -> I32 {
    let mut failures: I32 = 0

    // Test various pairs
    failures = failures + verify_add_commutative(0, 0)
    failures = failures + verify_add_commutative(1, 2)
    failures = failures + verify_add_commutative(5, 10)
    failures = failures + verify_add_commutative(100, 200)

    failures = failures + verify_mult_commutative(0, 5)
    failures = failures + verify_mult_commutative(3, 7)
    failures = failures + verify_mult_commutative(11, 13)

    assert_eq_i32(failures, 0, "commutative properties hold")

    return 0
}

@test
func test_distributive_property() -> I32 {
    let mut failures: I32 = 0

    failures = failures + verify_distributive(2, 3, 4)
    failures = failures + verify_distributive(5, 6, 7)
    failures = failures + verify_distributive(0, 10, 20)
    failures = failures + verify_distributive(1, 0, 0)

    assert_eq_i32(failures, 0, "distributive property holds")

    return 0
}

// ============ Boundary Value Testing ============

func check_in_range(value: I32, min: I32, max: I32) -> I32 {
    if value < min then { return 0 }
    if value > max then { return 0 }
    return 1
}

@test
func test_boundary_values() -> I32 {
    let min: I32 = 0
    let max: I32 = 100

    // Test boundaries
    assert_eq_i32(check_in_range(0, min, max), 1, "min boundary")
    assert_eq_i32(check_in_range(100, min, max), 1, "max boundary")
    assert_eq_i32(check_in_range(50, min, max), 1, "middle value")

    // Test outside boundaries
    assert_eq_i32(check_in_range(0 - 1, min, max), 0, "below min")
    assert_eq_i32(check_in_range(101, min, max), 0, "above max")

    return 0
}

// ============ Stress Test Pattern ============

@test
func test_many_iterations() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 1

    // Sum 1 to 100
    loop {
        if i > 100 then { break }
        sum = sum + i
        i = i + 1
    }

    assert_eq_i32(sum, 5050, "sum 1-100")

    return 0
}

@test
func test_nested_operations() -> I32 {
    let mut total: I32 = 0
    let mut i: I32 = 0

    loop {
        if i >= 10 then { break }

        let mut j: I32 = 0
        loop {
            if j >= 10 then { break }
            total = total + 1
            j = j + 1
        }

        i = i + 1
    }

    assert_eq_i32(total, 100, "10 x 10 iterations")

    return 0
}
