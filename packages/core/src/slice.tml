// TML Core Library - Slice Module
//
//! Utilities for working with slices.
//!
//! A slice is a dynamically-sized view into a contiguous sequence, `[T]`.
//! Slices are a view into a block of memory represented as a pointer and a
//! length.
//!
//! This module provides types and functions for working with slices:
//!
//! - [`Slice`]: An immutable view into a contiguous sequence.
//! - [`MutSlice`]: A mutable view into a contiguous sequence.
//! - Sorting: [`sort`], [`sort_by`], [`sort_by_key`]
//! - Searching: [`binary_search`], [`binary_search_by`], [`contains`]
//! - Iterators: [`chunks`], [`windows`]
//!
//! # Examples
//!
//! Sorting a slice:
//!
//! ```tml
//! let mut data = [5, 2, 8, 1, 9]
//! let slice = data.as_mut_slice()
//! slice.sort()
//! assert_eq(data, [1, 2, 5, 8, 9])
//! ```
//!
//! Binary search:
//!
//! ```tml
//! let data = [1, 2, 3, 4, 5]
//! let slice = data.as_slice()
//! when slice.binary_search(ref 3) {
//!     Ok(index) => assert_eq(index, 2),
//!     Err(_) => panic("not found")
//! }
//! ```

use core::cmp::{Ordering, Ord, PartialEq}
use core::clone::Copy
use core::iter::Iterator

// ============================================================================
// Slice Type
// ============================================================================

/// A dynamically-sized view into a contiguous sequence, `[T]`.
///
/// Contiguous here means that elements are laid out so that every element is
/// the same distance from its neighbors.
///
/// Slices are a view into a block of memory represented as a pointer and a
/// length. This is an immutable slice - see [`MutSlice`] for the mutable
/// version.
///
/// # Examples
///
/// ```tml
/// let vec = [1, 2, 3, 4, 5]
/// let slice: Slice[I32] = vec.as_slice()
///
/// assert_eq(slice.len(), 5)
/// assert_eq(slice.get(0), Just(ref 1))
/// assert_eq(slice.first(), Just(ref 1))
/// assert_eq(slice.last(), Just(ref 5))
/// ```
pub type Slice[T] {
    data: ref T,
    len: I64
}

impl[T] Slice[T] {
    /// Returns the number of elements in the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.as_slice().len(), 3)
    /// ```
    pub func len(this) -> I64 {
        return this.len
    }

    /// Returns `true` if the slice has a length of 0.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert(a.as_slice().is_empty() == false)
    ///
    /// let b: List[I32] = []
    /// assert(b.as_slice().is_empty())
    /// ```
    pub func is_empty(this) -> Bool {
        return this.len == 0
    }

    /// Returns the first element of the slice, or `Nothing` if it is empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// assert_eq(v.as_slice().first(), Just(ref 10))
    ///
    /// let w: List[I32] = []
    /// assert_eq(w.as_slice().first(), Nothing)
    /// ```
    pub func first(this) -> Maybe[ref T] {
        if this.len == 0 {
            return Nothing
        }
        return Just(this.get(0).unwrap())
    }

    /// Returns the last element of the slice, or `Nothing` if it is empty.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// assert_eq(v.as_slice().last(), Just(ref 30))
    ///
    /// let w: List[I32] = []
    /// assert_eq(w.as_slice().last(), Nothing)
    /// ```
    pub func last(this) -> Maybe[ref T] {
        if this.len == 0 {
            return Nothing
        }
        return Just(this.get(this.len - 1).unwrap())
    }

    /// Returns a reference to an element, or `Nothing` if the index is out
    /// of bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// assert_eq(v.as_slice().get(1), Just(ref 40))
    /// assert_eq(v.as_slice().get(3), Nothing)
    /// ```
    pub func get(this, index: I64) -> Maybe[ref T] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        return Just(lowlevel { slice_get(this.data, index) })
    }

    /// Returns a mutable reference to an element, or `Nothing` if the index
    /// is out of bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [10, 40, 30]
    /// when v.as_slice().get_mut(1) {
    ///     Just(elem) => *elem = 42,
    ///     Nothing => {}
    /// }
    /// assert_eq(v, [10, 42, 30])
    /// ```
    pub func get_mut(mut this, index: I64) -> Maybe[mut ref T] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        return Just(lowlevel { slice_get_mut(this.data, index) })
    }
}

// ============================================================================
// Mutable Slice Type
// ============================================================================

/// A mutable, dynamically-sized view into a contiguous sequence, `[T]`.
///
/// This is the mutable counterpart to [`Slice`]. It provides methods for
/// in-place modification of the underlying data.
///
/// # Examples
///
/// ```tml
/// let mut vec = [5, 2, 8, 1, 9]
/// let slice: MutSlice[I32] = vec.as_mut_slice()
///
/// slice.sort()
/// assert_eq(vec, [1, 2, 5, 8, 9])
///
/// slice.reverse()
/// assert_eq(vec, [9, 8, 5, 2, 1])
/// ```
pub type MutSlice[T] {
    data: mut ref T,
    len: I64
}

impl[T] MutSlice[T] {
    /// Returns the number of elements in the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut a = [1, 2, 3]
    /// assert_eq(a.as_mut_slice().len(), 3)
    /// ```
    pub func len(this) -> I64 {
        return this.len
    }

    /// Returns `true` if the slice has a length of 0.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut a = [1, 2, 3]
    /// assert(a.as_mut_slice().is_empty() == false)
    /// ```
    pub func is_empty(this) -> Bool {
        return this.len == 0
    }

    /// Returns a reference to an element, or `Nothing` if the index is out
    /// of bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [10, 40, 30]
    /// assert_eq(v.as_mut_slice().get(1), Just(ref 40))
    /// ```
    pub func get(this, index: I64) -> Maybe[ref T] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        return Just(lowlevel { slice_get(this.data, index) })
    }

    /// Returns a mutable reference to an element, or `Nothing` if the index
    /// is out of bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut x = [0, 1, 2]
    /// when x.as_mut_slice().get_mut(1) {
    ///     Just(elem) => *elem = 42,
    ///     Nothing => {}
    /// }
    /// assert_eq(x, [0, 42, 2])
    /// ```
    pub func get_mut(mut this, index: I64) -> Maybe[mut ref T] {
        if index < 0 or index >= this.len {
            return Nothing
        }
        return Just(lowlevel { slice_get_mut(this.data, index) })
    }

    /// Swaps two elements in the slice.
    ///
    /// If `a` equals to `b`, it's guaranteed that elements won't change
    /// value.
    ///
    /// # Panics
    ///
    /// Panics if `a` or `b` are out of bounds.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = ["a", "b", "c", "d", "e"]
    /// v.as_mut_slice().swap(1, 3)
    /// assert_eq(v, ["a", "d", "c", "b", "e"])
    /// ```
    pub func swap(mut this, a: I64, b: I64) {
        if a < 0 or a >= this.len or b < 0 or b >= this.len {
            panic("slice::swap: index out of bounds")
        }
        lowlevel { slice_swap(this.data, a, b) }
    }

    /// Reverses the order of elements in the slice, in place.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [1, 2, 3]
    /// v.as_mut_slice().reverse()
    /// assert_eq(v, [3, 2, 1])
    /// ```
    pub func reverse(mut this) {
        let mut left: I64 = 0
        let mut right: I64 = this.len - 1
        loop {
            if left >= right {
                break
            }
            this.swap(left, right)
            left = left + 1
            right = right - 1
        }
    }

    /// Rotates the slice in-place such that the first `k` elements of the
    /// slice move to the end while the last `len - k` elements move to the
    /// front.
    ///
    /// After calling `rotate_left`, the element previously at index `k` will
    /// become the first element in the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f']
    /// a.as_mut_slice().rotate_left(2)
    /// assert_eq(a, ['c', 'd', 'e', 'f', 'a', 'b'])
    /// ```
    pub func rotate_left(mut this, k: I64) {
        if this.len == 0 {
            return
        }
        let k_mod: I64 = k % this.len
        if k_mod == 0 {
            return
        }
        // Reverse first k elements
        this.reverse_range(0, k_mod - 1)
        // Reverse remaining elements
        this.reverse_range(k_mod, this.len - 1)
        // Reverse entire slice
        this.reverse()
    }

    /// Rotates the slice in-place such that the last `k` elements of the
    /// slice move to the front while the first `len - k` elements move to
    /// the end.
    ///
    /// After calling `rotate_right`, the element previously at index
    /// `len - k` will become the first element in the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f']
    /// a.as_mut_slice().rotate_right(2)
    /// assert_eq(a, ['e', 'f', 'a', 'b', 'c', 'd'])
    /// ```
    pub func rotate_right(mut this, k: I64) {
        if this.len == 0 {
            return
        }
        let k_mod: I64 = k % this.len
        this.rotate_left(this.len - k_mod)
    }

    /// Reverses elements in a range [start, end].
    func reverse_range(mut this, start: I64, end: I64) {
        let mut left: I64 = start
        let mut right: I64 = end
        loop {
            if left >= right {
                break
            }
            this.swap(left, right)
            left = left + 1
            right = right - 1
        }
    }

    /// Fills `this` with elements by cloning `value`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut buf = [0, 0, 0, 0]
    /// buf.as_mut_slice().fill(1)
    /// assert_eq(buf, [1, 1, 1, 1])
    /// ```
    pub func fill(mut this, value: T) where T: Copy {
        let mut i: I64 = 0
        loop {
            if i >= this.len {
                break
            }
            lowlevel { slice_set(this.data, i, value) }
            i = i + 1
        }
    }
}

// ============================================================================
// Sorting
// ============================================================================

impl[T: Ord] MutSlice[T] {
    /// Sorts the slice in ascending order.
    ///
    /// This sort is unstable (i.e., may reorder equal elements), in-place
    /// (i.e., does not allocate), and *O*(*n* \* log(*n*)) worst-case.
    ///
    /// # Current Implementation
    ///
    /// The current implementation uses quicksort.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [5, 4, 1, 3, 2]
    /// v.as_mut_slice().sort()
    /// assert_eq(v, [1, 2, 3, 4, 5])
    /// ```
    pub func sort(mut this) {
        if this.len <= 1 {
            return
        }
        this.quicksort(0, this.len - 1)
    }

    /// Quicksort implementation.
    func quicksort(mut this, low: I64, high: I64) {
        if low < high {
            let pivot: I64 = this.partition(low, high)
            if pivot > 0 {
                this.quicksort(low, pivot - 1)
            }
            this.quicksort(pivot + 1, high)
        }
    }

    /// Partition for quicksort.
    func partition(mut this, low: I64, high: I64) -> I64 {
        let pivot_ref: ref T = this.get(high).unwrap()
        let mut i: I64 = low - 1
        let mut j: I64 = low
        loop {
            if j >= high {
                break
            }
            let current_ref: ref T = this.get(j).unwrap()
            if current_ref.le(pivot_ref) {
                i = i + 1
                this.swap(i, j)
            }
            j = j + 1
        }
        this.swap(i + 1, high)
        return i + 1
    }
}

impl[T] MutSlice[T] {
    /// Sorts the slice with a comparator function.
    ///
    /// This sort is unstable (i.e., may reorder equal elements), in-place
    /// (i.e., does not allocate), and *O*(*n* \* log(*n*)) worst-case.
    ///
    /// The comparator function must define a total ordering for the elements
    /// in the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [5, 4, 1, 3, 2]
    /// v.as_mut_slice().sort_by(do(a, b) a.cmp(b))
    /// assert_eq(v, [1, 2, 3, 4, 5])
    ///
    /// // reverse sorting
    /// v.as_mut_slice().sort_by(do(a, b) b.cmp(a))
    /// assert_eq(v, [5, 4, 3, 2, 1])
    /// ```
    pub func sort_by(mut this, compare: func(ref T, ref T) -> Ordering) {
        if this.len <= 1 {
            return
        }
        this.quicksort_by(0, this.len - 1, compare)
    }

    /// Quicksort with custom comparison.
    func quicksort_by(mut this, low: I64, high: I64, compare: func(ref T, ref T) -> Ordering) {
        if low < high {
            let pivot: I64 = this.partition_by(low, high, compare)
            if pivot > 0 {
                this.quicksort_by(low, pivot - 1, compare)
            }
            this.quicksort_by(pivot + 1, high, compare)
        }
    }

    /// Partition with custom comparison.
    func partition_by(mut this, low: I64, high: I64, compare: func(ref T, ref T) -> Ordering) -> I64 {
        let pivot_ref: ref T = this.get(high).unwrap()
        let mut i: I64 = low - 1
        let mut j: I64 = low
        loop {
            if j >= high {
                break
            }
            let current_ref: ref T = this.get(j).unwrap()
            when compare(current_ref, pivot_ref) {
                Less => {
                    i = i + 1
                    this.swap(i, j)
                },
                Equal => {
                    i = i + 1
                    this.swap(i, j)
                },
                Greater => {}
            }
            j = j + 1
        }
        this.swap(i + 1, high)
        return i + 1
    }

    /// Sorts the slice with a key extraction function.
    ///
    /// This sort is unstable (i.e., may reorder equal elements), in-place
    /// (i.e., does not allocate), and *O*(*n* \* log(*n*)) worst-case.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut v = [-5, 4, 1, -3, 2]
    /// v.as_mut_slice().sort_by_key(do(k) k.abs())
    /// assert_eq(v, [1, 2, -3, 4, -5])
    /// ```
    pub func sort_by_key[K: Ord](mut this, key_fn: func(ref T) -> K) {
        this.sort_by(do(a: ref T, b: ref T) key_fn(a).cmp(ref key_fn(b)))
    }
}

// ============================================================================
// Binary Search
// ============================================================================

impl[T: Ord] Slice[T] {
    /// Binary searches this slice for a given element.
    ///
    /// If the value is found then [`Ok`] is returned, containing the index
    /// of the matching element. If there are multiple matches, then any one
    /// of the matches could be returned.
    ///
    /// If the value is not found then [`Err`] is returned, containing the
    /// index where a matching element could be inserted while maintaining
    /// sorted order.
    ///
    /// # Examples
    ///
    /// Looks up a series of four elements. The first is found, with a
    /// uniquely determined position; the second and third are not found;
    /// the fourth could match any position in `[1, 4]`.
    ///
    /// ```tml
    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    /// let slice = s.as_slice()
    ///
    /// assert_eq(slice.binary_search(ref 13), Ok(9))
    /// assert_eq(slice.binary_search(ref 4), Err(7))
    /// assert_eq(slice.binary_search(ref 100), Err(13))
    /// let r = slice.binary_search(ref 1)
    /// assert(r == Ok(1) or r == Ok(2) or r == Ok(3) or r == Ok(4))
    /// ```
    pub func binary_search(this, target: ref T) -> Outcome[I64, I64] {
        let mut left: I64 = 0
        let mut right: I64 = this.len
        loop {
            if left >= right {
                break
            }
            let mid: I64 = left + (right - left) / 2
            let mid_ref: ref T = this.get(mid).unwrap()
            when mid_ref.cmp(target) {
                Less => left = mid + 1,
                Equal => return Ok(mid),
                Greater => right = mid
            }
        }
        return Err(left)
    }
}

impl[T] Slice[T] {
    /// Binary searches this slice with a comparator function.
    ///
    /// The comparator function should return an order code that indicates
    /// whether its argument is `Less`, `Equal` or `Greater` than the desired
    /// target.
    ///
    /// If the value is found then [`Ok`] is returned, containing the index
    /// of the matching element. If the value is not found then [`Err`] is
    /// returned, containing the index where a matching element could be
    /// inserted while maintaining sorted order.
    ///
    /// # Examples
    ///
    /// Looks up a series of four elements. The first is found, the others
    /// are not.
    ///
    /// ```tml
    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    /// let slice = s.as_slice()
    /// let seek = 13
    /// assert_eq(slice.binary_search_by(do(x) x.cmp(ref seek)), Ok(9))
    /// ```
    pub func binary_search_by(this, compare: func(ref T) -> Ordering) -> Outcome[I64, I64] {
        let mut left: I64 = 0
        let mut right: I64 = this.len
        loop {
            if left >= right {
                break
            }
            let mid: I64 = left + (right - left) / 2
            let mid_ref: ref T = this.get(mid).unwrap()
            when compare(mid_ref) {
                Less => left = mid + 1,
                Equal => return Ok(mid),
                Greater => right = mid
            }
        }
        return Err(left)
    }

    /// Binary searches this slice with a key extraction function.
    ///
    /// Assumes that the slice is sorted by the key.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
    ///          (1, 21), (2, 34), (4, 55)]
    /// let slice = s.as_slice()
    ///
    /// assert_eq(slice.binary_search_by_key(ref 13, do(x) x.1), Ok(9))
    /// assert_eq(slice.binary_search_by_key(ref 4, do(x) x.1), Err(7))
    /// ```
    pub func binary_search_by_key[K: Ord](this, key: ref K, key_fn: func(ref T) -> K) -> Outcome[I64, I64] {
        return this.binary_search_by(do(elem: ref T) key_fn(elem).cmp(key))
    }
}

// ============================================================================
// Splitting
// ============================================================================

impl[T] Slice[T] {
    /// Divides one slice into two at an index.
    ///
    /// The first will contain all indices from `[0, mid)` (excluding the
    /// index `mid` itself) and the second will contain all indices from
    /// `[mid, len)` (excluding the index `len` itself).
    ///
    /// # Panics
    ///
    /// Panics if `mid > len`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [1, 2, 3, 4, 5, 6]
    /// let (left, right) = v.as_slice().split_at(3)
    ///
    /// assert_eq(left.len(), 3)
    /// assert_eq(right.len(), 3)
    /// ```
    pub func split_at(this, mid: I64) -> (Slice[T], Slice[T]) {
        if mid < 0 or mid > this.len {
            panic("slice::split_at: index out of bounds")
        }
        let first: Slice[T] = Slice {
            data: this.data,
            len: mid
        }
        let second: Slice[T] = Slice {
            data: lowlevel { slice_offset(this.data, mid) },
            len: this.len - mid
        }
        return (first, second)
    }

    /// Returns the first `n` elements of the slice, or `Nothing` if it has
    /// fewer than `n` elements.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [1, 2, 3]
    /// let slice = v.as_slice()
    ///
    /// assert_eq(slice.take(2).len(), 2)
    /// assert_eq(slice.take(10).len(), 3)  // clamped to len
    /// ```
    pub func take(this, n: I64) -> Slice[T] {
        let count: I64 = if n > this.len then this.len else n
        return Slice {
            data: this.data,
            len: count
        }
    }

    /// Returns a slice with the first `n` elements removed.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [1, 2, 3, 4, 5]
    /// let slice = v.as_slice()
    ///
    /// assert_eq(slice.skip(2).len(), 3)
    /// assert_eq(slice.skip(10).len(), 0)  // all skipped
    /// ```
    pub func skip(this, n: I64) -> Slice[T] {
        let count: I64 = if n > this.len then this.len else n
        return Slice {
            data: lowlevel { slice_offset(this.data, count) },
            len: this.len - count
        }
    }
}

// ============================================================================
// Chunks Iterator
// ============================================================================

/// An iterator over a slice in (non-overlapping) chunks (`chunk_size`
/// elements at a time), starting at the beginning of the slice.
///
/// When the slice len is not evenly divided by the chunk size, the last
/// slice of the iteration will be the remainder.
///
/// This struct is created by the [`chunks`] method on [slices][Slice].
///
/// # Examples
///
/// ```tml
/// let slice = [1, 2, 3, 4, 5]
/// let mut iter = slice.as_slice().chunks(2)
///
/// assert_eq(iter.next().unwrap().len(), 2)  // [1, 2]
/// assert_eq(iter.next().unwrap().len(), 2)  // [3, 4]
/// assert_eq(iter.next().unwrap().len(), 1)  // [5]
/// assert(iter.next().is_nothing())
/// ```
pub type Chunks[T] {
    slice: Slice[T],
    chunk_size: I64
}

impl[T] Iterator for Chunks[T] {
    type Item = Slice[T]

    pub func next(mut this) -> Maybe[Slice[T]] {
        if this.slice.len == 0 {
            return Nothing
        }
        let chunk_len: I64 = if this.chunk_size > this.slice.len then this.slice.len else this.chunk_size
        let chunk: Slice[T] = this.slice.take(chunk_len)
        this.slice = this.slice.skip(chunk_len)
        return Just(chunk)
    }
}

impl[T] Slice[T] {
    /// Returns an iterator over `chunk_size` elements of the slice at a
    /// time, starting at the beginning of the slice.
    ///
    /// The chunks are slices and do not overlap. If `chunk_size` does not
    /// divide the length of the slice, then the last chunk will not have
    /// length `chunk_size`.
    ///
    /// # Panics
    ///
    /// Panics if `chunk_size` is 0 or negative.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let slice = [1, 2, 3, 4, 5]
    /// let mut iter = slice.as_slice().chunks(2)
    ///
    /// assert_eq(iter.next().unwrap().len(), 2)
    /// assert_eq(iter.next().unwrap().len(), 2)
    /// assert_eq(iter.next().unwrap().len(), 1)
    /// ```
    pub func chunks(this, chunk_size: I64) -> Chunks[T] {
        if chunk_size <= 0 {
            panic("slice::chunks: chunk_size must be positive")
        }
        return Chunks {
            slice: this,
            chunk_size: chunk_size
        }
    }
}

// ============================================================================
// Windows Iterator
// ============================================================================

/// An iterator over overlapping subslices of length `size`.
///
/// This struct is created by the [`windows`] method on [slices][Slice].
///
/// # Examples
///
/// ```tml
/// let slice = [1, 2, 3, 4]
/// let mut iter = slice.as_slice().windows(2)
///
/// assert_eq(iter.next().unwrap().len(), 2)  // [1, 2]
/// assert_eq(iter.next().unwrap().len(), 2)  // [2, 3]
/// assert_eq(iter.next().unwrap().len(), 2)  // [3, 4]
/// assert(iter.next().is_nothing())
/// ```
pub type Windows[T] {
    slice: Slice[T],
    window_size: I64,
    index: I64
}

impl[T] Iterator for Windows[T] {
    type Item = Slice[T]

    pub func next(mut this) -> Maybe[Slice[T]] {
        if this.index + this.window_size > this.slice.len {
            return Nothing
        }
        let window: Slice[T] = Slice {
            data: lowlevel { slice_offset(this.slice.data, this.index) },
            len: this.window_size
        }
        this.index = this.index + 1
        return Just(window)
    }
}

impl[T] Slice[T] {
    /// Returns an iterator over all contiguous windows of length `size`.
    /// The windows overlap. If the slice is shorter than `size`, the
    /// iterator returns no values.
    ///
    /// # Panics
    ///
    /// Panics if `size` is 0 or negative.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let slice = [1, 2, 3, 4]
    /// let mut iter = slice.as_slice().windows(2)
    ///
    /// // Yields [1, 2], [2, 3], [3, 4]
    /// assert_eq(iter.count(), 3)
    /// ```
    pub func windows(this, window_size: I64) -> Windows[T] {
        if window_size <= 0 {
            panic("slice::windows: window_size must be positive")
        }
        return Windows {
            slice: this,
            window_size: window_size,
            index: 0
        }
    }
}

// ============================================================================
// Contains and Search
// ============================================================================

impl[T: PartialEq] Slice[T] {
    /// Returns `true` if the slice contains an element with the given value.
    ///
    /// This operation is *O*(*n*).
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// assert(v.as_slice().contains(ref 30))
    /// assert(v.as_slice().contains(ref 50) == false)
    /// ```
    pub func contains(this, value: ref T) -> Bool {
        let mut i: I64 = 0
        loop {
            if i >= this.len {
                break
            }
            let elem: ref T = this.get(i).unwrap()
            if elem.eq(value) {
                return true
            }
            i = i + 1
        }
        return false
    }

    /// Returns `true` if `prefix` is a prefix of the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// let slice = v.as_slice()
    /// assert(slice.starts_with([10, 40].as_slice()))
    /// assert(slice.starts_with([10, 50].as_slice()) == false)
    /// ```
    pub func starts_with(this, prefix: Slice[T]) -> Bool {
        if prefix.len > this.len {
            return false
        }
        let mut i: I64 = 0
        loop {
            if i >= prefix.len {
                break
            }
            let a: ref T = this.get(i).unwrap()
            let b: ref T = prefix.get(i).unwrap()
            if not a.eq(b) {
                return false
            }
            i = i + 1
        }
        return true
    }

    /// Returns `true` if `suffix` is a suffix of the slice.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [10, 40, 30]
    /// let slice = v.as_slice()
    /// assert(slice.ends_with([40, 30].as_slice()))
    /// assert(slice.ends_with([50, 30].as_slice()) == false)
    /// ```
    pub func ends_with(this, suffix: Slice[T]) -> Bool {
        if suffix.len > this.len {
            return false
        }
        let offset: I64 = this.len - suffix.len
        let mut i: I64 = 0
        loop {
            if i >= suffix.len {
                break
            }
            let a: ref T = this.get(offset + i).unwrap()
            let b: ref T = suffix.get(i).unwrap()
            if not a.eq(b) {
                return false
            }
            i = i + 1
        }
        return true
    }
}

// ============================================================================
// Copy Operations
// ============================================================================

impl[T: Copy] MutSlice[T] {
    /// Copies all elements from `src` into `this`, using a memcpy.
    ///
    /// The length of `src` must be the same as `this`.
    ///
    /// # Panics
    ///
    /// This function will panic if the two slices have different lengths.
    ///
    /// # Examples
    ///
    /// Cloning a slice:
    ///
    /// ```tml
    /// let src = [1, 2, 3, 4]
    /// let mut dst = [0, 0, 0, 0]
    ///
    /// dst.as_mut_slice().copy_from_slice(src.as_slice())
    ///
    /// assert_eq(dst, [1, 2, 3, 4])
    /// ```
    pub func copy_from_slice(mut this, src: Slice[T]) {
        if src.len != this.len {
            panic("slice::copy_from_slice: slices must have same length")
        }
        let mut i: I64 = 0
        loop {
            if i >= this.len {
                break
            }
            let val: T = *src.get(i).unwrap()
            lowlevel { slice_set(this.data, i, val) }
            i = i + 1
        }
    }
}
