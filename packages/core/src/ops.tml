//! Overloadable operators.
//!
//! This module provides behaviors that enable operator overloading in TML.
//! When you implement these behaviors for your types, the corresponding
//! operators become available.
//!
//! # Operator Behaviors
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`Add`] | `+` | `a + b` |
//! | [`Sub`] | `-` | `a - b` |
//! | [`Mul`] | `*` | `a * b` |
//! | [`Div`] | `/` | `a / b` |
//! | [`Rem`] | `%` | `a % b` |
//! | [`Neg`] | `-` (unary) | `-a` |
//! | [`Not`] | `not` | `not a` |
//! | [`BitAnd`] | `&` | `a & b` |
//! | [`BitOr`] | `\|` | `a \| b` |
//! | [`BitXor`] | `^` | `a ^ b` |
//! | [`Shl`] | `<<` | `a << b` |
//! | [`Shr`] | `>>` | `a >> b` |
//! | [`Index`] | `[]` | `a[i]` |
//! | [`IndexMut`] | `[]` | `a[i] = x` |
//!
//! # Compound Assignment
//!
//! | Behavior | Operator | Expression |
//! |----------|----------|------------|
//! | [`AddAssign`] | `+=` | `a += b` |
//! | [`SubAssign`] | `-=` | `a -= b` |
//! | [`MulAssign`] | `*=` | `a *= b` |
//! | [`DivAssign`] | `/=` | `a /= b` |
//! | [`RemAssign`] | `%=` | `a %= b` |
//!
//! # Examples
//!
//! ## Implementing Add for a Custom Type
//!
//! ```tml
//! use core::ops::Add
//!
//! pub type Point {
//!     x: F64,
//!     y: F64
//! }
//!
//! impl Add for Point {
//!     type Output = Point
//!
//!     pub func add(this, rhs: Point) -> Point {
//!         return Point {
//!             x: this.x + rhs.x,
//!             y: this.y + rhs.y
//!         }
//!     }
//! }
//!
//! let p1 = Point { x: 1.0, y: 2.0 }
//! let p2 = Point { x: 3.0, y: 4.0 }
//! let p3 = p1 + p2  // Point { x: 4.0, y: 6.0 }
//! ```
//!
//! ## Implementing Index for a Custom Container
//!
//! ```tml
//! use core::ops::Index
//!
//! pub type Matrix {
//!     data: List[F64],
//!     rows: I64,
//!     cols: I64
//! }
//!
//! impl Index[(I64, I64)] for Matrix {
//!     type Output = F64
//!
//!     pub func index(this, idx: (I64, I64)) -> ref F64 {
//!         let (row, col) = idx
//!         return ref this.data.get(row * this.cols + col)
//!     }
//! }
//!
//! let m = Matrix { ... }
//! let value = m[(1, 2)]  // Access row 1, column 2
//! ```
//!
//! ## Mixed-Type Operations
//!
//! You can implement operators with different right-hand side types:
//!
//! ```tml
//! use core::ops::Mul
//!
//! impl Mul[F64] for Point {
//!     type Output = Point
//!
//!     pub func mul(this, scalar: F64) -> Point {
//!         return Point {
//!             x: this.x * scalar,
//!             y: this.y * scalar
//!         }
//!     }
//! }
//!
//! let p = Point { x: 1.0, y: 2.0 }
//! let scaled = p * 2.5  // Point { x: 2.5, y: 5.0 }
//! ```

// ============================================================================
// Arithmetic Operators
// ============================================================================

/// The addition operator `+`.
///
/// Types implementing `Add` can be added using the `+` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Add
///
/// pub type Complex {
///     real: F64,
///     imag: F64
/// }
///
/// impl Add for Complex {
///     type Output = Complex
///
///     pub func add(this, rhs: Complex) -> Complex {
///         return Complex {
///             real: this.real + rhs.real,
///             imag: this.imag + rhs.imag
///         }
///     }
/// }
///
/// let a = Complex { real: 1.0, imag: 2.0 }
/// let b = Complex { real: 3.0, imag: 4.0 }
/// let c = a + b  // Complex { real: 4.0, imag: 6.0 }
/// ```
///
/// # Default Rhs
///
/// The `Rhs` type parameter defaults to `Self`, meaning by default you
/// implement addition between two values of the same type.
pub behavior Add[Rhs = Self] {
    /// The resulting type after applying `+`.
    type Output

    /// Performs the `+` operation.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let sum = a.add(b)  // Equivalent to: a + b
    /// ```
    func add(this, rhs: Rhs) -> This::Output
}

/// The subtraction operator `-`.
///
/// Types implementing `Sub` can be subtracted using the `-` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Sub
///
/// impl Sub for Point {
///     type Output = Point
///
///     pub func sub(this, rhs: Point) -> Point {
///         return Point {
///             x: this.x - rhs.x,
///             y: this.y - rhs.y
///         }
///     }
/// }
///
/// let p1 = Point { x: 5.0, y: 3.0 }
/// let p2 = Point { x: 2.0, y: 1.0 }
/// let diff = p1 - p2  // Point { x: 3.0, y: 2.0 }
/// ```
pub behavior Sub[Rhs = Self] {
    /// The resulting type after applying `-`.
    type Output

    /// Performs the `-` operation.
    func sub(this, rhs: Rhs) -> This::Output
}

/// The multiplication operator `*`.
///
/// Types implementing `Mul` can be multiplied using the `*` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Mul
///
/// impl Mul for Complex {
///     type Output = Complex
///
///     pub func mul(this, rhs: Complex) -> Complex {
///         return Complex {
///             real: this.real * rhs.real - this.imag * rhs.imag,
///             imag: this.real * rhs.imag + this.imag * rhs.real
///         }
///     }
/// }
/// ```
pub behavior Mul[Rhs = Self] {
    /// The resulting type after applying `*`.
    type Output

    /// Performs the `*` operation.
    func mul(this, rhs: Rhs) -> This::Output
}

/// The division operator `/`.
///
/// Types implementing `Div` can be divided using the `/` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Div
///
/// pub type Fraction {
///     num: I64,
///     den: I64
/// }
///
/// impl Div for Fraction {
///     type Output = Fraction
///
///     pub func div(this, rhs: Fraction) -> Fraction {
///         return Fraction {
///             num: this.num * rhs.den,
///             den: this.den * rhs.num
///         }
///     }
/// }
/// ```
///
/// # Panics
///
/// Division by zero behavior depends on the implementation. Primitive
/// integer division by zero will panic.
pub behavior Div[Rhs = Self] {
    /// The resulting type after applying `/`.
    type Output

    /// Performs the `/` operation.
    func div(this, rhs: Rhs) -> This::Output
}

/// The remainder operator `%`.
///
/// Types implementing `Rem` can compute the remainder using the `%` operator.
///
/// For integers, this is the remainder after division (modulo operation).
///
/// # Examples
///
/// ```tml
/// let remainder = 17 % 5  // 2
/// ```
///
/// # Note
///
/// The behavior of `%` for negative numbers follows the same convention
/// as the underlying platform (typically truncated division remainder).
pub behavior Rem[Rhs = Self] {
    /// The resulting type after applying `%`.
    type Output

    /// Performs the `%` operation.
    func rem(this, rhs: Rhs) -> This::Output
}

// ============================================================================
// Unary Operators
// ============================================================================

/// The unary negation operator `-`.
///
/// Types implementing `Neg` can be negated using the unary `-` operator.
///
/// # Examples
///
/// ```tml
/// use core::ops::Neg
///
/// impl Neg for Point {
///     type Output = Point
///
///     pub func neg(this) -> Point {
///         return Point { x: -this.x, y: -this.y }
///     }
/// }
///
/// let p = Point { x: 1.0, y: 2.0 }
/// let neg_p = -p  // Point { x: -1.0, y: -2.0 }
/// ```
pub behavior Neg {
    /// The resulting type after applying unary `-`.
    type Output

    /// Performs the unary `-` operation.
    func neg(this) -> This::Output
}

/// The logical negation operator `not`.
///
/// Types implementing `Not` can be logically negated using the `not` operator.
///
/// # Examples
///
/// ```tml
/// let a = true
/// let b = not a  // false
/// ```
///
/// # Note
///
/// For bitwise NOT on integers, use the `BitNot` behavior (not yet implemented).
pub behavior Not {
    /// The resulting type after applying `not`.
    type Output

    /// Performs the `not` operation.
    func not(this) -> This::Output
}

// ============================================================================
// Bitwise Operators
// ============================================================================

/// The bitwise AND operator `&`.
///
/// Types implementing `BitAnd` can perform bitwise AND using the `&` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a & b  // 0b1000
/// ```
pub behavior BitAnd[Rhs = Self] {
    /// The resulting type after applying `&`.
    type Output

    /// Performs the `&` operation.
    func bitand(this, rhs: Rhs) -> This::Output
}

/// The bitwise OR operator `|`.
///
/// Types implementing `BitOr` can perform bitwise OR using the `|` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a | b  // 0b1110
/// ```
pub behavior BitOr[Rhs = Self] {
    /// The resulting type after applying `|`.
    type Output

    /// Performs the `|` operation.
    func bitor(this, rhs: Rhs) -> This::Output
}

/// The bitwise XOR operator `^`.
///
/// Types implementing `BitXor` can perform bitwise XOR using the `^` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1100
/// let b: U8 = 0b1010
/// let c = a ^ b  // 0b0110
/// ```
pub behavior BitXor[Rhs = Self] {
    /// The resulting type after applying `^`.
    type Output

    /// Performs the `^` operation.
    func bitxor(this, rhs: Rhs) -> This::Output
}

/// The left shift operator `<<`.
///
/// Types implementing `Shl` can be left-shifted using the `<<` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b0001
/// let b = a << 3  // 0b1000
/// ```
///
/// # Note
///
/// The default `Rhs` is `I32`, representing the shift amount.
pub behavior Shl[Rhs = I32] {
    /// The resulting type after applying `<<`.
    type Output

    /// Performs the `<<` operation.
    func shl(this, rhs: Rhs) -> This::Output
}

/// The right shift operator `>>`.
///
/// Types implementing `Shr` can be right-shifted using the `>>` operator.
///
/// # Examples
///
/// ```tml
/// let a: U8 = 0b1000
/// let b = a >> 3  // 0b0001
/// ```
///
/// # Note
///
/// For signed integers, this is typically an arithmetic right shift
/// (sign-extending). For unsigned integers, it's a logical right shift
/// (zero-filling).
pub behavior Shr[Rhs = I32] {
    /// The resulting type after applying `>>`.
    type Output

    /// Performs the `>>` operation.
    func shr(this, rhs: Rhs) -> This::Output
}

// ============================================================================
// Indexing Operators
// ============================================================================

/// The indexing operator `[]` for immutable access.
///
/// Types implementing `Index` can be indexed using `container[index]` syntax,
/// returning a reference to the element.
///
/// # Examples
///
/// ```tml
/// use core::ops::Index
///
/// pub type Grid[T] {
///     data: List[T],
///     width: I64
/// }
///
/// impl[T] Index[(I64, I64)] for Grid[T] {
///     type Output = T
///
///     pub func index(this, idx: (I64, I64)) -> ref T {
///         let (x, y) = idx
///         return ref this.data.get(y * this.width + x)
///     }
/// }
///
/// let grid: Grid[I64] = create_grid()
/// let value = grid[(2, 3)]  // Access element at (2, 3)
/// ```
///
/// # Panics
///
/// Implementations should panic if the index is out of bounds.
pub behavior Index[Idx] {
    /// The type of the indexed element.
    type Output

    /// Performs the indexing operation, returning a reference.
    func index(this, idx: Idx) -> ref This::Output
}

/// The indexing operator `[]` for mutable access.
///
/// Types implementing `IndexMut` can be mutably indexed, allowing assignment
/// to indexed elements: `container[index] = value`.
///
/// # Examples
///
/// ```tml
/// use core::ops::{Index, IndexMut}
///
/// impl[T] IndexMut[(I64, I64)] for Grid[T] {
///     pub func index_mut(mut this, idx: (I64, I64)) -> mut ref T {
///         let (x, y) = idx
///         return mut ref this.data.get_mut(y * this.width + x)
///     }
/// }
///
/// let mut grid: Grid[I64] = create_grid()
/// grid[(2, 3)] = 42  // Set element at (2, 3) to 42
/// ```
///
/// # Prerequisite
///
/// `IndexMut` requires `Index` to also be implemented.
pub behavior IndexMut[Idx]: Index[Idx] {
    /// Performs the mutable indexing operation, returning a mutable reference.
    func index_mut(mut this, idx: Idx) -> mut ref This::Output
}

// ============================================================================
// Assignment Operators (Compound)
// ============================================================================

/// The addition assignment operator `+=`.
///
/// Types implementing `AddAssign` can use the `+=` operator for in-place addition.
///
/// # Examples
///
/// ```tml
/// use core::ops::AddAssign
///
/// impl AddAssign for Point {
///     pub func add_assign(mut this, rhs: Point) {
///         this.x = this.x + rhs.x
///         this.y = this.y + rhs.y
///     }
/// }
///
/// let mut p = Point { x: 1.0, y: 2.0 }
/// p += Point { x: 3.0, y: 4.0 }
/// // p is now Point { x: 4.0, y: 6.0 }
/// ```
pub behavior AddAssign[Rhs = Self] {
    /// Performs the `+=` operation.
    func add_assign(mut this, rhs: Rhs)
}

/// The subtraction assignment operator `-=`.
///
/// Types implementing `SubAssign` can use the `-=` operator for in-place subtraction.
///
/// # Examples
///
/// ```tml
/// let mut x = 10
/// x -= 3  // x is now 7
/// ```
pub behavior SubAssign[Rhs = Self] {
    /// Performs the `-=` operation.
    func sub_assign(mut this, rhs: Rhs)
}

/// The multiplication assignment operator `*=`.
///
/// Types implementing `MulAssign` can use the `*=` operator for in-place multiplication.
///
/// # Examples
///
/// ```tml
/// let mut x = 5
/// x *= 3  // x is now 15
/// ```
pub behavior MulAssign[Rhs = Self] {
    /// Performs the `*=` operation.
    func mul_assign(mut this, rhs: Rhs)
}

/// The division assignment operator `/=`.
///
/// Types implementing `DivAssign` can use the `/=` operator for in-place division.
///
/// # Examples
///
/// ```tml
/// let mut x = 20
/// x /= 4  // x is now 5
/// ```
pub behavior DivAssign[Rhs = Self] {
    /// Performs the `/=` operation.
    func div_assign(mut this, rhs: Rhs)
}

/// The remainder assignment operator `%=`.
///
/// Types implementing `RemAssign` can use the `%=` operator for in-place remainder.
///
/// # Examples
///
/// ```tml
/// let mut x = 17
/// x %= 5  // x is now 2
/// ```
pub behavior RemAssign[Rhs = Self] {
    /// Performs the `%=` operation.
    func rem_assign(mut this, rhs: Rhs)
}

// ============================================================================
// Add implementations for primitives
// ============================================================================

/// `Add` implementation for `I8`.
impl Add for I8 {
    type Output = I8
    pub func add(this, rhs: I8) -> I8 { return this + rhs }
}

/// `Add` implementation for `I16`.
impl Add for I16 {
    type Output = I16
    pub func add(this, rhs: I16) -> I16 { return this + rhs }
}

/// `Add` implementation for `I32`.
impl Add for I32 {
    type Output = I32
    pub func add(this, rhs: I32) -> I32 { return this + rhs }
}

/// `Add` implementation for `I64`.
impl Add for I64 {
    type Output = I64
    pub func add(this, rhs: I64) -> I64 { return this + rhs }
}

/// `Add` implementation for `U8`.
impl Add for U8 {
    type Output = U8
    pub func add(this, rhs: U8) -> U8 { return this + rhs }
}

/// `Add` implementation for `U16`.
impl Add for U16 {
    type Output = U16
    pub func add(this, rhs: U16) -> U16 { return this + rhs }
}

/// `Add` implementation for `U32`.
impl Add for U32 {
    type Output = U32
    pub func add(this, rhs: U32) -> U32 { return this + rhs }
}

/// `Add` implementation for `U64`.
impl Add for U64 {
    type Output = U64
    pub func add(this, rhs: U64) -> U64 { return this + rhs }
}

/// `Add` implementation for `F32`.
impl Add for F32 {
    type Output = F32
    pub func add(this, rhs: F32) -> F32 { return this + rhs }
}

/// `Add` implementation for `F64`.
impl Add for F64 {
    type Output = F64
    pub func add(this, rhs: F64) -> F64 { return this + rhs }
}

// ============================================================================
// Sub implementations for primitives
// ============================================================================

/// `Sub` implementation for `I32`.
impl Sub for I32 {
    type Output = I32
    pub func sub(this, rhs: I32) -> I32 { return this - rhs }
}

/// `Sub` implementation for `I64`.
impl Sub for I64 {
    type Output = I64
    pub func sub(this, rhs: I64) -> I64 { return this - rhs }
}

/// `Sub` implementation for `F32`.
impl Sub for F32 {
    type Output = F32
    pub func sub(this, rhs: F32) -> F32 { return this - rhs }
}

/// `Sub` implementation for `F64`.
impl Sub for F64 {
    type Output = F64
    pub func sub(this, rhs: F64) -> F64 { return this - rhs }
}

// ============================================================================
// Mul implementations for primitives
// ============================================================================

/// `Mul` implementation for `I32`.
impl Mul for I32 {
    type Output = I32
    pub func mul(this, rhs: I32) -> I32 { return this * rhs }
}

/// `Mul` implementation for `I64`.
impl Mul for I64 {
    type Output = I64
    pub func mul(this, rhs: I64) -> I64 { return this * rhs }
}

/// `Mul` implementation for `F32`.
impl Mul for F32 {
    type Output = F32
    pub func mul(this, rhs: F32) -> F32 { return this * rhs }
}

/// `Mul` implementation for `F64`.
impl Mul for F64 {
    type Output = F64
    pub func mul(this, rhs: F64) -> F64 { return this * rhs }
}

// ============================================================================
// Div implementations for primitives
// ============================================================================

/// `Div` implementation for `I32`.
impl Div for I32 {
    type Output = I32
    pub func div(this, rhs: I32) -> I32 { return this / rhs }
}

/// `Div` implementation for `I64`.
impl Div for I64 {
    type Output = I64
    pub func div(this, rhs: I64) -> I64 { return this / rhs }
}

/// `Div` implementation for `F32`.
impl Div for F32 {
    type Output = F32
    pub func div(this, rhs: F32) -> F32 { return this / rhs }
}

/// `Div` implementation for `F64`.
impl Div for F64 {
    type Output = F64
    pub func div(this, rhs: F64) -> F64 { return this / rhs }
}

// ============================================================================
// Rem implementations for primitives
// ============================================================================

/// `Rem` implementation for `I32`.
impl Rem for I32 {
    type Output = I32
    pub func rem(this, rhs: I32) -> I32 { return this % rhs }
}

/// `Rem` implementation for `I64`.
impl Rem for I64 {
    type Output = I64
    pub func rem(this, rhs: I64) -> I64 { return this % rhs }
}

// ============================================================================
// Neg implementations for primitives
// ============================================================================

/// `Neg` implementation for `I32`.
impl Neg for I32 {
    type Output = I32
    pub func neg(this) -> I32 { return 0 - this }
}

/// `Neg` implementation for `I64`.
impl Neg for I64 {
    type Output = I64
    pub func neg(this) -> I64 { return 0 - this }
}

/// `Neg` implementation for `F32`.
impl Neg for F32 {
    type Output = F32
    pub func neg(this) -> F32 { return 0.0 - this }
}

/// `Neg` implementation for `F64`.
impl Neg for F64 {
    type Output = F64
    pub func neg(this) -> F64 { return 0.0 - this }
}

// ============================================================================
// Not implementation for Bool
// ============================================================================

/// `Not` implementation for `Bool`.
///
/// Enables `not true` -> `false` and `not false` -> `true`.
impl Not for Bool {
    type Output = Bool
    pub func not(this) -> Bool { return not this }
}

// ============================================================================
// Index for List[T]
// ============================================================================
// Note: This requires the List type from std::collections

// impl[T] Index[I64] for List[T] {
//     type Output = T
//     pub func index(this, idx: I64) -> ref T {
//         return ref this.get(idx)
//     }
// }

// ============================================================================
// Index for Str (character access)
// ============================================================================
// Note: Str indexing returns a character code (I32)

// impl Index[I64] for Str {
//     type Output = I32
//     pub func index(this, idx: I64) -> ref I32 {
//         return ref lowlevel { str_char_at(this, idx) }
//     }
// }
