//! Memory layout calculations.
//!
//! This module provides the [`Layout`] type, which describes the memory layout
//! requirements for a type or value - specifically its size and alignment.
//!
//! # Overview
//!
//! When allocating memory, two pieces of information are critical:
//!
//! - **Size**: How many bytes are needed
//! - **Alignment**: What byte boundary the allocation must start on
//!
//! The [`Layout`] struct encapsulates both, ensuring they're always consistent
//! and valid.
//!
//! # Alignment Rules
//!
//! Alignment must always be a power of two (1, 2, 4, 8, 16, ...). This is a
//! hardware requirement - CPUs access memory more efficiently when data is
//! properly aligned.
//!
//! # Examples
//!
//! ## Creating Layouts
//!
//! ```tml
//! use core::alloc::{Layout, LayoutError}
//!
//! // Layout for a specific type
//! let i64_layout = Layout::new[I64]()
//! assert(i64_layout.size() == 8)
//! assert(i64_layout.align() == 8)
//!
//! // Layout from explicit size and alignment
//! when Layout::from_size_align(1024, 16) {
//!     Ok(layout) => {
//!         assert(layout.size() == 1024)
//!         assert(layout.align() == 16)
//!     },
//!     Err(err) => panic("invalid layout")
//! }
//! ```
//!
//! ## Combining Layouts
//!
//! ```tml
//! // Layout for a struct with two fields
//! let field1 = Layout::new[I64]()
//! let field2 = Layout::new[I32]()
//!
//! let (combined, offset) = field1.extend(field2).unwrap()
//! // offset is where field2 starts within the combined layout
//! ```
//!
//! ## Array Layouts
//!
//! ```tml
//! // Layout for an array of 100 I64 values
//! let array_layout = Layout::array[I64](100).unwrap()
//! assert(array_layout.size() == 800)  // 100 * 8 bytes
//! ```

use core::cmp::{max, PartialEq, Eq}
use core::fmt::{Display, Debug}
use core::error::Error
use core::option::Maybe
use core::result::Outcome
use core::ptr::NonNull

// ============================================================================
// LayoutError
// ============================================================================

/// An error returned from [`Layout`] construction functions.
///
/// `LayoutError` indicates that the requested memory layout is invalid.
/// This can happen when:
///
/// - The alignment is not a power of two
/// - The alignment is zero
/// - The size, when rounded up to alignment, would overflow
///
/// # Examples
///
/// ```tml
/// use core::alloc::{Layout, LayoutError}
///
/// // Alignment must be a power of two
/// when Layout::from_size_align(100, 3) {
///     Ok(_) => panic("should have failed"),
///     Err(err) => println(err.to_string())  // "invalid layout parameters"
/// }
///
/// // Size rounded to alignment must not overflow
/// when Layout::from_size_align(I64::MAX, 8) {
///     Ok(_) => panic("should have failed"),
///     Err(err) => println(err.to_string())
/// }
/// ```
pub type LayoutError {}

impl LayoutError {
    /// Creates a new `LayoutError`.
    ///
    /// This is primarily used internally by `Layout` construction functions.
    pub func new() -> LayoutError {
        return LayoutError {}
    }
}

impl Display for LayoutError {
    pub func to_string(this) -> Str {
        return "invalid layout parameters"
    }
}

impl Debug for LayoutError {
    pub func debug_string(this) -> Str {
        return "LayoutError"
    }
}

impl Error for LayoutError {}

impl PartialEq for LayoutError {
    pub func eq(this, other: ref LayoutError) -> Bool {
        return true
    }
}

impl Eq for LayoutError {}

// ============================================================================
// Layout
// ============================================================================

/// Describes the memory layout of a type: its size and alignment.
///
/// `Layout` is the foundation of memory allocation in TML. Every allocation
/// request must specify a layout, ensuring the allocator knows exactly how
/// much memory to provide and how to align it.
///
/// # Invariants
///
/// A valid `Layout` always satisfies these invariants:
///
/// 1. `align` is a power of two (1, 2, 4, 8, ...)
/// 2. `size`, when rounded up to the nearest multiple of `align`, does not overflow
///
/// These invariants are enforced by the constructors, so if you have a `Layout`,
/// you know it's valid.
///
/// # Size vs Alignment
///
/// - **Size** is the number of bytes needed to store the value
/// - **Alignment** is the byte boundary the allocation must start on
///
/// For example, an `I64` typically has size 8 and alignment 8, meaning it needs
/// 8 bytes and must be placed at an address divisible by 8.
///
/// # Examples
///
/// ## Basic Usage
///
/// ```tml
/// use core::alloc::Layout
///
/// // Get layout for a type
/// let layout = Layout::new[I64]()
/// println("size: " + layout.size().to_string())    // "size: 8"
/// println("align: " + layout.align().to_string())  // "align: 8"
///
/// // Get layout for a value
/// let data = MyStruct { ... }
/// let layout = Layout::for_value(ref data)
/// ```
///
/// ## Creating Custom Layouts
///
/// ```tml
/// // 1KB buffer with 64-byte alignment (for cache line alignment)
/// let layout = Layout::from_size_align(1024, 64).unwrap()
///
/// // Array of 1000 elements
/// let layout = Layout::array[Element](1000).unwrap()
/// ```
///
/// ## Struct Layout Calculation
///
/// ```tml
/// // Calculate layout for a struct manually
/// let field_a = Layout::new[I32]()   // 4 bytes, align 4
/// let field_b = Layout::new[I64]()   // 8 bytes, align 8
///
/// // Extend adds padding as needed
/// let (combined, b_offset) = field_a.extend(field_b).unwrap()
/// // b_offset = 8 (4 bytes for a + 4 bytes padding)
/// // combined.size() = 16 (8 for a+padding, 8 for b)
/// // combined.align() = 8 (max of 4, 8)
/// ```
pub type Layout {
    size: I64,
    align: I64
}

impl Layout {
    // ========================================================================
    // Constructors
    // ========================================================================

    /// Creates a layout from explicit size and alignment values.
    ///
    /// # Arguments
    ///
    /// * `size` - The size in bytes (must be >= 0)
    /// * `align` - The alignment in bytes (must be a power of two)
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if:
    /// - `align` is not a power of two
    /// - `align` is zero
    /// - `size` rounded up to `align` overflows
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Valid layout
    /// let layout = Layout::from_size_align(100, 8).unwrap()
    /// assert(layout.size() == 100)
    /// assert(layout.align() == 8)
    ///
    /// // Invalid: alignment not a power of two
    /// assert(Layout::from_size_align(100, 3).is_err())
    ///
    /// // Invalid: alignment is zero
    /// assert(Layout::from_size_align(100, 0).is_err())
    /// ```
    pub func from_size_align(size: I64, align: I64) -> Outcome[Layout, LayoutError] {
        // Check that align is a power of two and non-zero
        if align <= 0 or (align & (align - 1)) != 0 {
            return Err(LayoutError::new())
        }

        // Check that size, when rounded up to align, doesn't overflow
        // The maximum size is I64::MAX - (align - 1)
        let max_size: I64 = I64::MAX - (align - 1)
        if size < 0 or size > max_size {
            return Err(LayoutError::new())
        }

        return Ok(Layout { size: size, align: align })
    }

    /// Creates a layout from size and alignment without validation.
    ///
    /// # Safety
    ///
    /// The caller must ensure:
    /// - `align` is a power of two
    /// - `align` is non-zero
    /// - `size`, when rounded up to `align`, does not overflow
    ///
    /// Violating these invariants leads to undefined behavior when the
    /// layout is used for allocation.
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Only use when you've already validated the parameters
    /// let layout = Layout::from_size_align_unchecked(1024, 16)
    /// ```
    pub func from_size_align_unchecked(size: I64, align: I64) -> Layout {
        return Layout { size: size, align: align }
    }

    /// Creates a layout describing the type `T`.
    ///
    /// This is the most common way to create a layout - it automatically
    /// determines the size and alignment from the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let i64_layout = Layout::new[I64]()
    /// assert(i64_layout.size() == 8)
    /// assert(i64_layout.align() == 8)
    ///
    /// let bool_layout = Layout::new[Bool]()
    /// assert(bool_layout.size() == 1)
    /// assert(bool_layout.align() == 1)
    /// ```
    pub func new[T]() -> Layout {
        let size: I64 = lowlevel { sizeof_type[T]() }
        let align: I64 = lowlevel { alignof_type[T]() }
        return Layout { size: size, align: align }
    }

    /// Creates a layout describing the value pointed to by `val`.
    ///
    /// For sized types, this is equivalent to `Layout::new[T]()`. For
    /// dynamically-sized types (like slices), this calculates the actual
    /// size of the specific value.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let x: I64 = 42
    /// let layout = Layout::for_value(ref x)
    /// assert(layout.size() == 8)
    /// ```
    pub func for_value[T](val: ref T) -> Layout {
        // For sized types, just use the type's layout
        return Layout::new[T]()
    }

    // ========================================================================
    // Accessors
    // ========================================================================

    /// Returns the size of this layout in bytes.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(100, 8).unwrap()
    /// assert(layout.size() == 100)
    /// ```
    pub func size(this) -> I64 {
        return this.size
    }

    /// Returns the alignment of this layout in bytes.
    ///
    /// The alignment is always a power of two.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(100, 8).unwrap()
    /// assert(layout.align() == 8)
    /// ```
    pub func align(this) -> I64 {
        return this.align
    }

    // ========================================================================
    // Calculations
    // ========================================================================

    /// Returns the amount of padding needed to align a pointer/size to this layout.
    ///
    /// Given a starting position (like the current end of an allocation),
    /// this calculates how many padding bytes are needed so that the next
    /// item would be properly aligned.
    ///
    /// # Arguments
    ///
    /// * `len` - The current position/length to align from
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(4, 8).unwrap()
    ///
    /// // If we're at position 4, we need 4 bytes of padding to reach 8
    /// assert(layout.padding_needed_for(4) == 4)
    ///
    /// // If we're at position 8, no padding needed
    /// assert(layout.padding_needed_for(8) == 0)
    ///
    /// // If we're at position 7, we need 1 byte to reach 8
    /// assert(layout.padding_needed_for(7) == 1)
    /// ```
    pub func padding_needed_for(this, len: I64) -> I64 {
        let align: I64 = this.align
        // Equivalent to: (align - (len % align)) % align
        // But using bitwise operations since align is a power of two
        let len_rounded_up: I64 = (len + align - 1) & ~(align - 1)
        return len_rounded_up - len
    }

    /// Returns a layout with the size rounded up to the alignment boundary.
    ///
    /// This is useful when allocating arrays, where each element must be
    /// properly aligned. The padded size ensures that consecutive elements
    /// in an array maintain proper alignment.
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if the padded size would overflow.
    ///
    /// # Examples
    ///
    /// ```tml
    /// // A type with size 5 and alignment 4
    /// let layout = Layout::from_size_align(5, 4).unwrap()
    /// let padded = layout.pad_to_align().unwrap()
    ///
    /// assert(padded.size() == 8)  // Rounded up to next multiple of 4
    /// assert(padded.align() == 4) // Alignment unchanged
    /// ```
    pub func pad_to_align(this) -> Outcome[Layout, LayoutError] {
        let new_size: I64 = this.size + this.padding_needed_for(this.size)
        return Layout::from_size_align(new_size, this.align)
    }

    /// Creates a layout with the alignment increased to at least `align`.
    ///
    /// The size remains unchanged, but the alignment is set to the maximum
    /// of the current alignment and the requested alignment.
    ///
    /// # Arguments
    ///
    /// * `align` - The minimum alignment (must be a power of two)
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if:
    /// - `align` is not a power of two
    /// - The size with new alignment would overflow
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(100, 4).unwrap()
    /// let aligned = layout.align_to(16).unwrap()
    ///
    /// assert(aligned.size() == 100)
    /// assert(aligned.align() == 16)
    ///
    /// // align_to never decreases alignment
    /// let still_16 = aligned.align_to(8).unwrap()
    /// assert(still_16.align() == 16)  // Not 8!
    /// ```
    pub func align_to(this, align: I64) -> Outcome[Layout, LayoutError] {
        let new_align: I64 = max(this.align, align)
        return Layout::from_size_align(this.size, new_align)
    }

    /// Extends this layout with another, returning the combined layout and offset.
    ///
    /// This is used to calculate the layout of a struct from its fields.
    /// The returned offset indicates where the second layout starts within
    /// the combined layout (accounting for padding).
    ///
    /// # Returns
    ///
    /// A tuple of:
    /// - The combined layout
    /// - The byte offset where the second layout begins
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if the combined size would overflow.
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Simulating a struct { a: I32, b: I64 }
    /// let a_layout = Layout::new[I32]()  // size=4, align=4
    /// let b_layout = Layout::new[I64]()  // size=8, align=8
    ///
    /// let (combined, b_offset) = a_layout.extend(b_layout).unwrap()
    ///
    /// // b must be at offset 8 (4 bytes for a + 4 bytes padding)
    /// assert(b_offset == 8)
    ///
    /// // Combined size is 16 (8 for a+padding, 8 for b)
    /// assert(combined.size() == 16)
    ///
    /// // Combined alignment is max(4, 8) = 8
    /// assert(combined.align() == 8)
    /// ```
    pub func extend(this, other: Layout) -> Outcome[(Layout, I64), LayoutError] {
        // Calculate the new alignment (max of both)
        let new_align: I64 = max(this.align, other.align)

        // Calculate padding needed for other's alignment
        let padding: I64 = this.padding_needed_for_align(other.align)

        // Check for overflow when calculating offset
        if this.size > I64::MAX - padding {
            return Err(LayoutError::new())
        }
        let offset: I64 = this.size + padding

        // Check for overflow when calculating new size
        if offset > I64::MAX - other.size {
            return Err(LayoutError::new())
        }
        let new_size: I64 = offset + other.size

        when Layout::from_size_align(new_size, new_align) {
            Ok(layout) => return Ok((layout, offset)),
            Err(err) => return Err(err)
        }
    }

    /// Helper: calculates padding needed from current size to reach alignment.
    func padding_needed_for_align(this, align: I64) -> I64 {
        let len: I64 = this.size
        let len_rounded_up: I64 = (len + align - 1) & ~(align - 1)
        return len_rounded_up - len
    }

    /// Creates a layout for `n` instances of this layout placed contiguously.
    ///
    /// This is similar to calculating the layout of an array `[T; n]`.
    ///
    /// # Arguments
    ///
    /// * `n` - The number of elements
    ///
    /// # Returns
    ///
    /// A tuple of:
    /// - The layout for all `n` elements
    /// - The stride (distance between element starts, including padding)
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if the total size would overflow.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let elem_layout = Layout::from_size_align(5, 4).unwrap()
    /// let (array_layout, stride) = elem_layout.repeat(10).unwrap()
    ///
    /// // Stride is 8 (5 bytes + 3 padding to align to 4)
    /// assert(stride == 8)
    ///
    /// // Total size is 10 * 8 = 80
    /// assert(array_layout.size() == 80)
    /// ```
    pub func repeat(this, n: I64) -> Outcome[(Layout, I64), LayoutError] {
        // Get the padded size (stride)
        let padded = this.pad_to_align()?
        let stride: I64 = padded.size

        // Check for overflow
        if n > 0 and stride > I64::MAX / n {
            return Err(LayoutError::new())
        }

        let total_size: I64 = stride * n

        when Layout::from_size_align(total_size, this.align) {
            Ok(layout) => return Ok((layout, stride)),
            Err(err) => return Err(err)
        }
    }

    /// Creates a layout for an array `[T; n]`.
    ///
    /// This is a convenience function that combines `Layout::new[T]()` with
    /// `repeat(n)`.
    ///
    /// # Arguments
    ///
    /// * `n` - The number of elements
    ///
    /// # Errors
    ///
    /// Returns `Err(LayoutError)` if the total size would overflow.
    ///
    /// # Examples
    ///
    /// ```tml
    /// // Layout for [I64; 100]
    /// let layout = Layout::array[I64](100).unwrap()
    /// assert(layout.size() == 800)  // 100 * 8
    /// assert(layout.align() == 8)
    ///
    /// // Empty array is valid
    /// let empty = Layout::array[I64](0).unwrap()
    /// assert(empty.size() == 0)
    /// ```
    pub func array[T](n: I64) -> Outcome[Layout, LayoutError] {
        let elem_layout: Layout = Layout::new[T]()
        let (layout, _stride) = elem_layout.repeat(n)?
        return Ok(layout)
    }

    /// Creates a dangling pointer that is suitably aligned for this layout.
    ///
    /// This returns a non-null pointer that should never be dereferenced.
    /// It's useful for representing empty allocations or as a placeholder.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(0, 8).unwrap()
    /// let ptr = layout.dangling()
    ///
    /// // The pointer is non-null but should never be dereferenced
    /// assert(not ptr.as_ptr().is_null())
    /// ```
    pub func dangling(this) -> NonNull[U8] {
        // Use the alignment as the address - it's non-zero and properly aligned
        return NonNull::new_unchecked(RawMutPtr::from_addr(this.align))
    }
}

// ============================================================================
// Trait Implementations
// ============================================================================

impl PartialEq for Layout {
    pub func eq(this, other: ref Layout) -> Bool {
        return this.size == other.size and this.align == other.align
    }
}

impl Eq for Layout {}

impl Debug for Layout {
    pub func debug_string(this) -> Str {
        return "Layout { size: " + this.size.to_string() + ", align: " + this.align.to_string() + " }"
    }
}

impl Display for Layout {
    pub func to_string(this) -> Str {
        return "Layout(size=" + this.size.to_string() + ", align=" + this.align.to_string() + ")"
    }
}
