//! Global memory allocator interface.
//!
//! This module defines the [`GlobalAlloc`] behavior, which provides a low-level
//! interface for implementing custom global memory allocators.
//!
//! # Overview
//!
//! The global allocator is responsible for all heap allocations in a TML program.
//! By default, the system allocator is used, but you can provide a custom allocator
//! by implementing [`GlobalAlloc`] and registering it with `@global_allocator`.
//!
//! # GlobalAlloc vs Allocator
//!
//! TML provides two allocator interfaces:
//!
//! | Feature | [`GlobalAlloc`] | [`Allocator`] |
//! |---------|-----------------|---------------|
//! | Purpose | System-wide default | Per-collection customization |
//! | Safety | Lowlevel behavior | Safe behavior |
//! | Error handling | Returns null on failure | Returns `AllocError` |
//! | Thread safety | Must be `Sync` | No requirement |
//! | Registration | `@global_allocator` | Passed to collections |
//!
//! Use `GlobalAlloc` when you need to replace the system allocator. Use `Allocator`
//! when you need custom allocation for specific data structures.
//!
//! # Implementing a Global Allocator
//!
//! ```tml
//! use core::alloc::{GlobalAlloc, Layout}
//!
//! pub type MyAllocator {}
//!
//! lowlevel impl GlobalAlloc for MyAllocator {
//!     lowlevel func alloc(this, layout: Layout) -> RawMutPtr[U8] {
//!         // Your allocation logic here
//!     }
//!
//!     lowlevel func dealloc(this, ptr: RawMutPtr[U8], layout: Layout) {
//!         // Your deallocation logic here
//!     }
//! }
//!
//! @global_allocator
//! pub static ALLOCATOR: MyAllocator = MyAllocator {}
//! ```
//!
//! # Safety Requirements
//!
//! Implementing `GlobalAlloc` correctly is critical for program safety:
//!
//! 1. **Never panic**: Allocator methods must not panic or unwind
//! 2. **Thread safety**: The allocator must be safe to use from multiple threads
//! 3. **Correct layouts**: Memory must be allocated with the requested size and alignment
//! 4. **No re-entrance**: Don't call allocating functions from within allocator methods
//!
//! # Memory Alignment
//!
//! All pointers returned by `alloc` must be aligned to `layout.align()`. Misaligned
//! pointers cause undefined behavior when dereferenced.

use core::alloc::Layout
use core::ptr::RawMutPtr

// ============================================================================
// GlobalAlloc Behavior
// ============================================================================

/// A memory allocator that can be registered as the global allocator.
///
/// `GlobalAlloc` is a lowlevel behavior for implementing custom memory allocators
/// that can replace the default system allocator. Types implementing this behavior
/// can be registered using the `@global_allocator` attribute.
///
/// # Required Methods
///
/// - [`alloc`]: Allocate memory with a given layout
/// - [`dealloc`]: Free previously allocated memory
///
/// # Optional Methods (with defaults)
///
/// - [`alloc_zeroed`]: Allocate and zero-initialize memory
/// - [`realloc`]: Resize an existing allocation
///
/// # Thread Safety
///
/// Global allocators must be safe to use from multiple threads simultaneously.
/// This typically means the implementation must use internal synchronization
/// (locks, atomics, etc.) to protect shared state.
///
/// # Example Implementation
///
/// ```tml
/// use core::alloc::{GlobalAlloc, Layout}
/// use core::ptr::RawMutPtr
///
/// pub type BumpAllocator {
///     start: RawMutPtr[U8],
///     end: RawMutPtr[U8],
///     current: Atomic[I64]
/// }
///
/// lowlevel impl GlobalAlloc for BumpAllocator {
///     lowlevel func alloc(this, layout: Layout) -> RawMutPtr[U8] {
///         // Simple bump allocation (not production-ready)
///         let size = layout.size()
///         let align = layout.align()
///
///         loop {
///             let current = this.current.load(Ordering::Relaxed)
///             let aligned = (current + align - 1) & ~(align - 1)
///             let new_current = aligned + size
///
///             if new_current > this.end.addr() {
///                 return RawMutPtr::null()  // Out of memory
///             }
///
///             if this.current.compare_exchange(current, new_current, Ordering::SeqCst) {
///                 return RawMutPtr::from_addr(aligned)
///             }
///         }
///     }
///
///     lowlevel func dealloc(this, ptr: RawMutPtr[U8], layout: Layout) {
///         // Bump allocator doesn't free individual allocations
///     }
/// }
/// ```
///
/// # Performance Considerations
///
/// The global allocator is on the hot path for all heap allocations. Keep
/// the implementation as efficient as possible:
///
/// - Minimize lock contention
/// - Use thread-local caches when appropriate
/// - Avoid system calls in the fast path
pub lowlevel behavior GlobalAlloc {
    /// Allocates memory as described by the given `layout`.
    ///
    /// Returns a pointer to newly-allocated memory, or a null pointer to
    /// indicate allocation failure.
    ///
    /// # Safety
    ///
    /// This is a lowlevel function. The implementation must ensure:
    ///
    /// - The returned pointer is aligned to `layout.align()`
    /// - The allocated block is at least `layout.size()` bytes
    /// - The memory is valid for reads and writes
    /// - The memory remains valid until deallocated
    ///
    /// # Errors
    ///
    /// Returns a null pointer if allocation fails. Common causes:
    ///
    /// - Out of memory
    /// - Layout size or alignment too large
    /// - System limits exceeded
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(1024, 8).unwrap()
    /// let ptr = allocator.alloc(layout)
    ///
    /// if ptr.is_null() {
    ///     panic("allocation failed")
    /// }
    ///
    /// // Use the memory...
    ///
    /// allocator.dealloc(ptr, layout)
    /// ```
    lowlevel func alloc(this, layout: Layout) -> RawMutPtr[U8]

    /// Deallocates the memory referenced by `ptr`.
    ///
    /// # Safety
    ///
    /// This is a lowlevel function. The caller must ensure:
    ///
    /// - `ptr` was returned by a previous call to `alloc` or `realloc`
    /// - `layout` is the same layout used for the allocation
    /// - The memory has not already been deallocated
    ///
    /// Violating these requirements leads to undefined behavior, including:
    ///
    /// - Double-free bugs
    /// - Use-after-free bugs
    /// - Memory corruption
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(1024, 8).unwrap()
    /// let ptr = allocator.alloc(layout)
    ///
    /// // ... use the memory ...
    ///
    /// // Deallocate with the same layout
    /// allocator.dealloc(ptr, layout)
    ///
    /// // ptr is now invalid - do not use it!
    /// ```
    lowlevel func dealloc(this, ptr: RawMutPtr[U8], layout: Layout)

    /// Allocates zero-initialized memory as described by the given `layout`.
    ///
    /// The default implementation calls `alloc` and then zeroes the memory.
    /// Override this if your allocator can provide zero-initialized memory
    /// more efficiently (e.g., by using the OS's zero-page optimization).
    ///
    /// # Safety
    ///
    /// Same requirements as `alloc`, plus the returned memory must be
    /// initialized to all zeros.
    ///
    /// # Errors
    ///
    /// Returns a null pointer if allocation fails.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::array[I64](100).unwrap()
    /// let ptr = allocator.alloc_zeroed(layout)
    ///
    /// if not ptr.is_null() {
    ///     // All 100 I64 values are guaranteed to be 0
    ///     let first = ptr.cast[I64]().read()
    ///     assert(first == 0)
    /// }
    /// ```
    lowlevel func alloc_zeroed(this, layout: Layout) -> RawMutPtr[U8] {
        let ptr: RawMutPtr[U8] = this.alloc(layout)
        if not ptr.is_null() {
            lowlevel { memset(ptr.addr(), 0, layout.size()) }
        }
        return ptr
    }

    /// Shrinks or grows a block of memory to the given `new_size`.
    ///
    /// The default implementation allocates new memory, copies the data,
    /// and frees the old allocation. Override this if your allocator can
    /// resize in place more efficiently.
    ///
    /// # Arguments
    ///
    /// * `ptr` - Pointer to the current allocation
    /// * `layout` - The layout of the current allocation
    /// * `new_size` - The desired new size
    ///
    /// # Safety
    ///
    /// This is a lowlevel function. The caller must ensure:
    ///
    /// - `ptr` was returned by a previous call to `alloc` or `realloc`
    /// - `layout` is the same layout used for that allocation
    /// - `new_size` is greater than zero
    /// - `new_size`, when rounded up to `layout.align()`, does not overflow
    ///
    /// # Behavior
    ///
    /// On success:
    /// - Returns a pointer to the resized allocation
    /// - The original `ptr` is invalidated (do not use it)
    /// - Contents are preserved up to `min(layout.size(), new_size)`
    ///
    /// On failure:
    /// - Returns a null pointer
    /// - The original allocation is unchanged
    /// - `ptr` remains valid
    ///
    /// # Examples
    ///
    /// ```tml
    /// let layout = Layout::from_size_align(100, 8).unwrap()
    /// let ptr = allocator.alloc(layout)
    ///
    /// // Grow the allocation
    /// let new_ptr = allocator.realloc(ptr, layout, 200)
    ///
    /// if new_ptr.is_null() {
    ///     // Reallocation failed - ptr is still valid
    ///     allocator.dealloc(ptr, layout)
    /// } else {
    ///     // Use new_ptr, ptr is now invalid
    ///     let new_layout = Layout::from_size_align(200, 8).unwrap()
    ///     allocator.dealloc(new_ptr, new_layout)
    /// }
    /// ```
    lowlevel func realloc(
        this,
        ptr: RawMutPtr[U8],
        layout: Layout,
        new_size: I64
    ) -> RawMutPtr[U8] {
        // Create new layout with same alignment but new size
        let new_layout_result = Layout::from_size_align(new_size, layout.align())
        when new_layout_result {
            Err(_) => return RawMutPtr::null(),
            Ok(new_layout) => {
                // Allocate new memory
                let new_ptr: RawMutPtr[U8] = this.alloc(new_layout)

                if not new_ptr.is_null() {
                    // Copy old data to new location
                    let copy_size: I64 = if layout.size() < new_size {
                        layout.size()
                    } else {
                        new_size
                    }
                    lowlevel { memcpy(new_ptr.addr(), ptr.addr(), copy_size) }

                    // Free old memory
                    this.dealloc(ptr, layout)
                }

                return new_ptr
            }
        }
    }
}
