//! Iterator source types.
//!
//! This module provides types that create iterators from scratch, rather than
//! transforming existing iterators. These are the "source" or "factory" iterators.
//!
//! # Types
//!
//! | Type | Description |
//! |------|-------------|
//! | [`Empty`] | An iterator that yields nothing |
//! | [`Once`] | An iterator that yields exactly one element |
//! | [`OnceWith`] | An iterator that yields one element computed by a closure |
//! | [`Repeat`] | An iterator that repeats an element endlessly |
//! | [`RepeatN`] | An iterator that repeats an element N times |
//! | [`RepeatWith`] | An iterator that repeats values generated by a closure |
//! | [`FromFn`] | An iterator where each element is computed by a closure |
//! | [`Successors`] | An iterator where each element is computed from the previous |
//!
//! # Functions
//!
//! These free functions create the corresponding iterator types:
//!
//! ```tml
//! use core::iter::sources::{empty, once, repeat, from_fn}
//!
//! // Empty iterator
//! let e: Empty[I32] = empty()
//!
//! // Single element
//! let o = once(42)
//!
//! // Infinite repetition
//! let r = repeat(1).take(5)
//!
//! // Generated values
//! let mut n = 0
//! let f = from_fn(do() { n = n + 1; Just(n) }).take(3)
//! ```

use core::iter::traits::Iterator
use core::clone::Duplicate

// ============================================================================
// Empty Iterator
// ============================================================================

/// An iterator that yields nothing.
///
/// This struct is created by the [`empty()`] function. See its documentation
/// for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter: Empty[I32] = empty()
///
/// assert_eq(iter.next(), Nothing)
/// ```
pub type Empty[T] {
    // Phantom field to carry the type parameter
    _phantom: Maybe[T]
}

impl[T] Iterator for Empty[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        return Nothing
    }
}

/// Creates an iterator that yields nothing.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter: Empty[I32] = empty()
/// assert_eq(iter.next(), Nothing)
/// ```
///
/// Useful as a placeholder or default:
///
/// ```tml
/// func get_values(include: Bool) -> impl Iterator[Item = I32] {
///     if include {
///         return [1, 2, 3].into_iter()
///     }
///     return empty()
/// }
/// ```
pub func empty[T]() -> Empty[T] {
    return Empty { _phantom: Nothing }
}

// ============================================================================
// Once Iterator
// ============================================================================

/// An iterator that yields exactly one element.
///
/// This struct is created by the [`once()`] function. See its documentation
/// for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter = once(42)
///
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Nothing)
/// ```
pub type Once[T] {
    value: Maybe[T]
}

impl[T] Iterator for Once[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        let result = this.value
        this.value = Nothing
        return result
    }
}

/// Creates an iterator that yields exactly one element.
///
/// This is commonly used to adapt a single value into a [`chain()`] of other
/// kinds of iteration. Maybe you have an iterator that covers almost
/// everything, but you need an extra special case. Maybe you have a function
/// which works on iterators, but you only need to process one value.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter = once(42)
///
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Nothing)
/// ```
///
/// Chaining together with another iterator:
///
/// ```tml
/// let items = once(0).chain([1, 2, 3].into_iter())
/// let collected = items.collect()
/// assert_eq(collected, [0, 1, 2, 3])
/// ```
pub func once[T](value: T) -> Once[T] {
    return Once { value: Just(value) }
}

// ============================================================================
// OnceWith Iterator
// ============================================================================

/// An iterator that yields a single element computed by a closure.
///
/// This struct is created by the [`once_with()`] function. See its
/// documentation for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let mut iter = once_with(do() { count = count + 1; count })
///
/// assert_eq(count, 0)  // Closure not called yet
/// assert_eq(iter.next(), Just(1))
/// assert_eq(count, 1)  // Now it's been called
/// assert_eq(iter.next(), Nothing)
/// ```
pub type OnceWith[F, T] {
    gen: Maybe[F]
}

impl[F, T] Iterator for OnceWith[F, T] where F: Fn() -> T {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        when this.gen {
            Just(f) => {
                this.gen = Nothing
                return Just(f())
            },
            Nothing => return Nothing
        }
    }
}

/// Creates an iterator that lazily generates a single value using a closure.
///
/// Unlike [`once()`], this function lazily evaluates the closure. This is
/// useful when the value is expensive to compute or when you want the
/// computation to happen at iteration time rather than creation time.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let mut iter = once_with(do() { count = count + 1; count })
///
/// assert_eq(count, 0)  // Closure not called yet
/// assert_eq(iter.next(), Just(1))
/// assert_eq(count, 1)  // Now it's been called
/// ```
pub func once_with[F, T](f: F) -> OnceWith[F, T] where F: Fn() -> T {
    return OnceWith { gen: Just(f) }
}

// ============================================================================
// Repeat Iterator
// ============================================================================

/// An iterator that repeats an element endlessly.
///
/// This struct is created by the [`repeat()`] function. See its documentation
/// for more details.
///
/// **Warning**: This iterator is infinite. Use [`.take(n)`] to limit it.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter = repeat(42)
///
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Just(42))
/// // ... and so on forever
/// ```
pub type Repeat[T: Duplicate] {
    value: T
}

impl[T: Duplicate] Iterator for Repeat[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        return Just(this.value.duplicate())
    }
}

/// Creates an iterator that endlessly repeats a single element.
///
/// The `repeat()` function repeats a single value over and over again.
///
/// **Warning**: This iterator is infinite. Use [`.take(n)`] to limit it.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let ones = repeat(1).take(5).collect()
/// assert_eq(ones, [1, 1, 1, 1, 1])
/// ```
///
/// Using with `zip`:
///
/// ```tml
/// let indexed = [10, 20, 30].into_iter()
///     .zip(repeat("x"))
///     .collect()
/// // [(10, "x"), (20, "x"), (30, "x")]
/// ```
pub func repeat[T: Duplicate](value: T) -> Repeat[T] {
    return Repeat { value: value }
}

// ============================================================================
// RepeatN Iterator
// ============================================================================

/// An iterator that repeats an element a fixed number of times.
///
/// This struct is created by the [`repeat_n()`] function. See its
/// documentation for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut iter = repeat_n(42, 3)
///
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Just(42))
/// assert_eq(iter.next(), Nothing)
/// ```
pub type RepeatN[T: Duplicate] {
    value: T,
    remaining: I64
}

impl[T: Duplicate] Iterator for RepeatN[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        if this.remaining <= 0 {
            return Nothing
        }
        this.remaining = this.remaining - 1
        return Just(this.value.duplicate())
    }
}

/// Creates an iterator that repeats an element exactly `n` times.
///
/// Unlike [`repeat()`], this iterator is finite and will stop after
/// yielding the element `n` times.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let threes = repeat_n(3, 4).collect()
/// assert_eq(threes, [3, 3, 3, 3])
/// ```
pub func repeat_n[T: Duplicate](value: T, n: I64) -> RepeatN[T] {
    return RepeatN { value: value, remaining: n }
}

// ============================================================================
// RepeatWith Iterator
// ============================================================================

/// An iterator that repeats values generated by a closure.
///
/// This struct is created by the [`repeat_with()`] function. See its
/// documentation for more details.
///
/// **Warning**: This iterator is infinite. Use [`.take(n)`] to limit it.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let mut iter = repeat_with(do() { count = count + 1; count })
///
/// assert_eq(iter.next(), Just(1))
/// assert_eq(iter.next(), Just(2))
/// assert_eq(iter.next(), Just(3))
/// ```
pub type RepeatWith[F, T] {
    gen: F
}

impl[F, T] Iterator for RepeatWith[F, T] where F: FnMut() -> T {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        return Just((this.gen)())
    }
}

/// Creates an iterator that endlessly generates values from a closure.
///
/// Unlike [`repeat()`], which clones a value, `repeat_with()` calls a
/// closure to generate each value. This is useful when you need each
/// value to be different or when cloning is expensive.
///
/// **Warning**: This iterator is infinite. Use [`.take(n)`] to limit it.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let values = repeat_with(do() { count = count + 1; count })
///     .take(3)
///     .collect()
/// assert_eq(values, [1, 2, 3])
/// ```
pub func repeat_with[F, T](f: F) -> RepeatWith[F, T] where F: FnMut() -> T {
    return RepeatWith { gen: f }
}

// ============================================================================
// FromFn Iterator
// ============================================================================

/// An iterator where each element is computed by a closure.
///
/// This struct is created by the [`from_fn()`] function. See its
/// documentation for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let mut iter = from_fn(do() {
///     if count < 3 {
///         count = count + 1
///         return Just(count)
///     }
///     return Nothing
/// })
///
/// assert_eq(iter.next(), Just(1))
/// assert_eq(iter.next(), Just(2))
/// assert_eq(iter.next(), Just(3))
/// assert_eq(iter.next(), Nothing)
/// ```
pub type FromFn[F, T] {
    gen: F
}

impl[F, T] Iterator for FromFn[F, T] where F: FnMut() -> Maybe[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        return (this.gen)()
    }
}

/// Creates an iterator where each element is generated by a closure.
///
/// This allows creating a custom iterator without implementing the
/// `Iterator` trait. The closure is called for each element and should
/// return `Just(value)` to yield a value, or `Nothing` to end iteration.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut count = 0
/// let values = from_fn(do() {
///     if count < 5 {
///         count = count + 1
///         return Just(count * count)
///     }
///     return Nothing
/// }).collect()
///
/// assert_eq(values, [1, 4, 9, 16, 25])
/// ```
///
/// Generating Fibonacci numbers:
///
/// ```tml
/// let mut a = 0
/// let mut b = 1
/// let fibs = from_fn(do() {
///     let current = a
///     a = b
///     b = current + b
///     return Just(current)
/// }).take(10).collect()
///
/// assert_eq(fibs, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34])
/// ```
pub func from_fn[F, T](f: F) -> FromFn[F, T] where F: FnMut() -> Maybe[T] {
    return FromFn { gen: f }
}

// ============================================================================
// Successors Iterator
// ============================================================================

/// An iterator where each element is computed from the previous one.
///
/// This struct is created by the [`successors()`] function. See its
/// documentation for more details.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let powers_of_2 = successors(Just(1), do(n) {
///     if *n < 256 {
///         return Just(*n * 2)
///     }
///     return Nothing
/// }).collect()
///
/// assert_eq(powers_of_2, [1, 2, 4, 8, 16, 32, 64, 128, 256])
/// ```
pub type Successors[T, F] {
    current: Maybe[T],
    succ: F
}

impl[T, F] Iterator for Successors[T, F] where F: FnMut(ref T) -> Maybe[T] {
    type Item = T

    pub func next(mut this) -> Maybe[T] {
        when this.current {
            Just(value) => {
                let next_val = (this.succ)(ref value)
                let result = this.current
                this.current = next_val
                return result
            },
            Nothing => return Nothing
        }
    }
}

/// Creates an iterator that repeatedly applies a function to generate successors.
///
/// Starting from an initial value (or `Nothing`), this function generates
/// the next value by applying a function to the current value. The iterator
/// ends when the function returns `Nothing`.
///
/// # Examples
///
/// Powers of 10:
///
/// ```tml
/// let powers = successors(Just(1), do(n) {
///     let next = *n * 10
///     if next <= 1000 {
///         return Just(next)
///     }
///     return Nothing
/// }).collect()
///
/// assert_eq(powers, [1, 10, 100, 1000])
/// ```
///
/// Linked list traversal (conceptual):
///
/// ```tml
/// let values = successors(first_node, do(node) node.next).collect()
/// ```
pub func successors[T, F](first: Maybe[T], succ: F) -> Successors[T, F]
    where F: FnMut(ref T) -> Maybe[T]
{
    return Successors { current: first, succ: succ }
}

// ============================================================================
// Range Iterator (already implemented in core, but documented here)
// ============================================================================

/// Range iterators are created using the `to` and `through` operators.
///
/// # Examples
///
/// Exclusive range (does not include end):
///
/// ```tml
/// let values = (0 to 5).collect()
/// assert_eq(values, [0, 1, 2, 3, 4])
/// ```
///
/// Inclusive range (includes end):
///
/// ```tml
/// let values = (0 through 5).collect()
/// assert_eq(values, [0, 1, 2, 3, 4, 5])
/// ```
///
/// Descending range:
///
/// ```tml
/// let values = (5 down_to 0).collect()
/// assert_eq(values, [5, 4, 3, 2, 1, 0])
/// ```
