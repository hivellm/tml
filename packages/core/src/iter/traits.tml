// TML Core Library - Iterator Traits
//
//! Core iterator behaviors for TML.
//!
//! This module provides the foundational traits for iteration:
//!
//! - [`Iterator`]: The core trait for types that can produce a sequence of values.
//! - [`IntoIterator`]: Conversion into an `Iterator`.
//! - [`FromIterator`]: Construction from an `Iterator`.
//! - [`Extend`]: Extend a collection with the contents of an iterator.
//!
//! # The Iterator Trait
//!
//! The [`Iterator`] trait is the heart of TML's iteration system. Any type
//! that implements `Iterator` can be used with `loop` constructs and has
//! access to a wide variety of adapter methods.
//!
//! # Examples
//!
//! Basic iteration:
//!
//! ```tml
//! let nums = [1, 2, 3, 4, 5]
//! let sum = nums.into_iter().fold(0, do(acc, x) acc + x)
//! assert_eq(sum, 15)
//! ```
//!
//! Using adapters:
//!
//! ```tml
//! let evens = [1, 2, 3, 4, 5]
//!     .into_iter()
//!     .filter(do(x) x % 2 == 0)
//!     .collect()
//! assert_eq(evens, [2, 4])
//! ```

use core::cmp::Ordering

// ============================================================================
// Iterator Behavior
// ============================================================================

/// A trait for dealing with iterators.
///
/// This is the main iterator trait. For more about the concept of iterators
/// generally, please see the [module-level documentation]. In particular, you
/// may want to know how to [implement `Iterator`][impl].
///
/// [module-level documentation]: core::iter
/// [impl]: core::iter#implementing-iterator
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// type Counter {
///     count: I64,
///     max: I64
/// }
///
/// impl Iterator for Counter {
///     type Item = I64
///
///     func next(mut this) -> Maybe[I64] {
///         if this.count < this.max {
///             this.count = this.count + 1
///             return Just(this.count)
///         }
///         return Nothing
///     }
/// }
///
/// let counter = Counter { count: 0, max: 5 }
/// let sum = counter.fold(0, do(acc, x) acc + x)
/// assert_eq(sum, 15)
/// ```
pub behavior Iterator {
    /// The type of the elements being iterated over.
    type Item

    /// Advances the iterator and returns the next value.
    ///
    /// Returns [`Nothing`] when iteration is finished. Individual iterator
    /// implementations may choose to resume iteration, and so calling `next()`
    /// again may or may not eventually start returning [`Just(item)`] again
    /// at some point.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let mut iter = a.into_iter()
    ///
    /// assert_eq(iter.next(), Just(1))
    /// assert_eq(iter.next(), Just(2))
    /// assert_eq(iter.next(), Just(3))
    /// assert_eq(iter.next(), Nothing)
    /// ```
    func next(mut this) -> Maybe[This::Item]

    /// Consumes the iterator, counting the number of iterations.
    ///
    /// This method will call [`next`] repeatedly until [`Nothing`] is
    /// encountered, returning the number of times it saw [`Just`].
    ///
    /// # Overflow Behavior
    ///
    /// The method does no guarding against overflows, so counting elements of
    /// an iterator with more than `I64::MAX` elements panics or wraps.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().count(), 3)
    ///
    /// let a = [1, 2, 3, 4, 5]
    /// assert_eq(a.into_iter().count(), 5)
    /// ```
    func count(mut this) -> I64 {
        let mut n: I64 = 0
        loop {
            when this.next() {
                Just(_) => n = n + 1,
                Nothing => break
            }
        }
        return n
    }

    /// Consumes the iterator, returning the last element.
    ///
    /// This method will evaluate the iterator until it returns [`Nothing`].
    /// While doing so, it keeps track of the current element. After
    /// [`Nothing`] is returned, `last()` will then return the last element
    /// it saw.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().last(), Just(3))
    ///
    /// let a: List[I32] = []
    /// assert_eq(a.into_iter().last(), Nothing)
    /// ```
    func last(mut this) -> Maybe[This::Item] {
        let mut result: Maybe[This::Item] = Nothing
        loop {
            when this.next() {
                Just(item) => result = Just(item),
                Nothing => break
            }
        }
        return result
    }

    /// Returns the `n`th element of the iterator.
    ///
    /// Like most indexing operations, the count starts from zero, so `nth(0)`
    /// returns the first value, `nth(1)` the second, and so on.
    ///
    /// Note that all preceding elements, as well as the returned element, will
    /// be consumed from the iterator. That means that the preceding elements
    /// will be discarded, and also that calling `nth(0)` multiple times on
    /// the same iterator will return different elements.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().nth(1), Just(2))
    /// ```
    ///
    /// Calling `nth()` multiple times doesn't rewind:
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let mut iter = a.into_iter()
    ///
    /// assert_eq(iter.nth(1), Just(2))
    /// assert_eq(iter.nth(1), Nothing)
    /// ```
    func nth(mut this, n: I64) -> Maybe[This::Item] {
        let mut i: I64 = 0
        loop {
            when this.next() {
                Just(item) => {
                    if i == n {
                        return Just(item)
                    }
                    i = i + 1
                },
                Nothing => break
            }
        }
        return Nothing
    }

    /// Advances the iterator by `n` elements.
    ///
    /// This method will eagerly skip `n` elements by calling [`next`] up to
    /// `n` times until [`Nothing`] is encountered.
    ///
    /// Returns the number of elements that were actually skipped.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3, 4, 5]
    /// let mut iter = a.into_iter()
    ///
    /// assert_eq(iter.advance_by(2), 2)
    /// assert_eq(iter.next(), Just(3))
    /// assert_eq(iter.advance_by(10), 2)  // Only 2 elements left
    /// ```
    func advance_by(mut this, n: I64) -> I64 {
        let mut skipped: I64 = 0
        loop {
            if skipped >= n {
                break
            }
            when this.next() {
                Just(_) => skipped = skipped + 1,
                Nothing => break
            }
        }
        return skipped
    }
}

// ============================================================================
// IntoIterator Behavior
// ============================================================================

/// Conversion into an [`Iterator`].
///
/// By implementing `IntoIterator` for a type, you define how it will be
/// converted to an iterator. This is common for types which describe a
/// collection of some kind.
///
/// One benefit of implementing `IntoIterator` is that your type will work
/// with TML's `for` loop syntax.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let v = [1, 2, 3]
/// let mut iter = v.into_iter()
///
/// assert_eq(iter.next(), Just(1))
/// assert_eq(iter.next(), Just(2))
/// assert_eq(iter.next(), Just(3))
/// assert_eq(iter.next(), Nothing)
/// ```
///
/// Implementing `IntoIterator` for your type:
///
/// ```tml
/// type MyCollection[T] {
///     items: List[T]
/// }
///
/// impl[T] IntoIterator for MyCollection[T] {
///     type Item = T
///     type IntoIter = ListIter[T]
///
///     func into_iter(this) -> ListIter[T] {
///         return this.items.into_iter()
///     }
/// }
/// ```
pub behavior IntoIterator {
    /// The type of the elements being iterated over.
    type Item

    /// Which kind of iterator are we turning this into?
    type IntoIter: Iterator

    /// Creates an iterator from a value.
    ///
    /// See the [module-level documentation] for more.
    ///
    /// [module-level documentation]: core::iter
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v = [1, 2, 3]
    /// let mut iter = v.into_iter()
    ///
    /// assert_eq(iter.next(), Just(1))
    /// assert_eq(iter.next(), Just(2))
    /// assert_eq(iter.next(), Just(3))
    /// assert_eq(iter.next(), Nothing)
    /// ```
    func into_iter(this) -> This::IntoIter
}

// ============================================================================
// FromIterator Behavior
// ============================================================================

/// Conversion from an [`Iterator`].
///
/// By implementing `FromIterator` for a type, you define how it will be
/// created from an iterator. This is common for types which describe a
/// collection of some kind.
///
/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead
/// used through [`Iterator::collect`] method. See [`Iterator::collect`]'s
/// documentation for more examples.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let v = [1, 2, 3]
/// let doubled: List[I32] = v.into_iter()
///     .map(do(x) x * 2)
///     .collect()
///
/// assert_eq(doubled, [2, 4, 6])
/// ```
pub behavior FromIterator[T] {
    /// Creates a value from an iterator.
    ///
    /// See the [module-level documentation] for more.
    ///
    /// [module-level documentation]: core::iter
    ///
    /// # Examples
    ///
    /// ```tml
    /// let v: List[I32] = List::from_iter([1, 2, 3].into_iter())
    /// assert_eq(v, [1, 2, 3])
    /// ```
    func from_iter[I: Iterator](iter: I) -> Self where I::Item = T
}

// ============================================================================
// Extend Behavior
// ============================================================================

/// Extend a collection with the contents of an iterator.
///
/// Iterators produce a series of values, and collections can also be thought
/// of as a series of values. The `Extend` trait bridges this gap, allowing
/// you to extend a collection by including the contents of that iterator.
///
/// # Examples
///
/// Basic usage:
///
/// ```tml
/// let mut list: List[I32] = [1, 2, 3]
/// list.extend([4, 5, 6].into_iter())
///
/// assert_eq(list, [1, 2, 3, 4, 5, 6])
/// ```
pub behavior Extend[T] {
    /// Extends a collection with the contents of an iterator.
    ///
    /// As this is the only required method for this trait, the
    /// [trait-level] docs contain more details.
    ///
    /// [trait-level]: Extend
    ///
    /// # Examples
    ///
    /// ```tml
    /// let mut list: List[I32] = [1, 2, 3]
    /// list.extend([4, 5, 6].into_iter())
    ///
    /// assert_eq(list, [1, 2, 3, 4, 5, 6])
    /// ```
    func extend[I: Iterator](mut this, iter: I) where I::Item = T
}

// ============================================================================
// Iterator Extension Methods - Core
// ============================================================================

/// Extension methods for all iterators.
impl[I: Iterator] I {
    /// Tests if any element of the iterator matches a predicate.
    ///
    /// `any()` takes a closure that returns `true` or `false`. It applies
    /// this closure to each element of the iterator, and if any of them
    /// return `true`, then so does `any()`. If they all return `false`, it
    /// returns `false`.
    ///
    /// `any()` is short-circuiting; in other words, it will stop processing
    /// as soon as it finds a `true`, given that no matter what else happens,
    /// the result will also be `true`.
    ///
    /// An empty iterator returns `false`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert(a.into_iter().any(do(x) x > 2))
    /// assert(a.into_iter().any(do(x) x > 5) == false)
    /// ```
    pub func any(mut this, predicate: func(I::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(item) => {
                    if predicate(item) {
                        return true
                    }
                },
                Nothing => break
            }
        }
        return false
    }

    /// Tests if every element of the iterator matches a predicate.
    ///
    /// `all()` takes a closure that returns `true` or `false`. It applies
    /// this closure to each element of the iterator, and if they all return
    /// `true`, then so does `all()`. If any of them return `false`, it
    /// returns `false`.
    ///
    /// `all()` is short-circuiting; in other words, it will stop processing
    /// as soon as it finds a `false`, given that no matter what else happens,
    /// the result will also be `false`.
    ///
    /// An empty iterator returns `true`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert(a.into_iter().all(do(x) x > 0))
    /// assert(a.into_iter().all(do(x) x > 2) == false)
    /// ```
    pub func all(mut this, predicate: func(I::Item) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(item) => {
                    if not predicate(item) {
                        return false
                    }
                },
                Nothing => break
            }
        }
        return true
    }

    /// Searches for an element of an iterator that satisfies a predicate.
    ///
    /// `find()` takes a closure that returns `true` or `false`. It applies
    /// this closure to each element of the iterator, and if any of them
    /// return `true`, then `find()` returns [`Just(element)`]. If they all
    /// return `false`, it returns [`Nothing`].
    ///
    /// `find()` is short-circuiting; in other words, it will stop processing
    /// as soon as the closure returns `true`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().find(do(x) *x == 2), Just(2))
    /// assert_eq(a.into_iter().find(do(x) *x == 5), Nothing)
    /// ```
    pub func find(mut this, predicate: func(ref I::Item) -> Bool) -> Maybe[I::Item] {
        loop {
            when this.next() {
                Just(item) => {
                    if predicate(ref item) {
                        return Just(item)
                    }
                },
                Nothing => break
            }
        }
        return Nothing
    }

    /// Searches for an element in an iterator, returning its index.
    ///
    /// `position()` takes a closure that returns `true` or `false`. It applies
    /// this closure to each element of the iterator, and if one of them
    /// returns `true`, then `position()` returns [`Just(index)`]. If all of
    /// them return `false`, it returns [`Nothing`].
    ///
    /// `position()` is short-circuiting; in other words, it will stop
    /// processing as soon as it finds a `true`.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().position(do(x) x == 2), Just(1))
    /// assert_eq(a.into_iter().position(do(x) x == 5), Nothing)
    /// ```
    pub func position(mut this, predicate: func(I::Item) -> Bool) -> Maybe[I64] {
        let mut idx: I64 = 0
        loop {
            when this.next() {
                Just(item) => {
                    if predicate(item) {
                        return Just(idx)
                    }
                    idx = idx + 1
                },
                Nothing => break
            }
        }
        return Nothing
    }

    /// Folds every element into an accumulator by applying an operation,
    /// returning the final result.
    ///
    /// `fold()` takes two arguments: an initial value, and a closure with two
    /// arguments: an 'accumulator', and an element. The closure returns the
    /// value that the accumulator should have for the next iteration.
    ///
    /// The initial value is the value the accumulator will have on the first
    /// call.
    ///
    /// After applying this closure to every element of the iterator, `fold()`
    /// returns the accumulator.
    ///
    /// This operation is sometimes called 'reduce' or 'inject'.
    ///
    /// Folding is useful whenever you have a collection of something, and want
    /// to produce a single value from it.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    ///
    /// // the sum of all the elements
    /// let sum = a.into_iter().fold(0, do(acc, x) acc + x)
    /// assert_eq(sum, 6)
    /// ```
    pub func fold[B](mut this, init: B, f: func(B, I::Item) -> B) -> B {
        let mut acc: B = init
        loop {
            when this.next() {
                Just(item) => acc = f(acc, item),
                Nothing => break
            }
        }
        return acc
    }

    /// Reduces the elements to a single one, by repeatedly applying a
    /// reducing operation.
    ///
    /// If the iterator is empty, returns [`Nothing`]; otherwise, returns the
    /// result of the reduction.
    ///
    /// The reducing function is a closure with two arguments: an 'accumulator',
    /// and an element. For iterators with at least one element, this is the
    /// same as [`fold()`] with the first element of the iterator as the initial
    /// accumulator value, folding every subsequent element into it.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let reduced: Maybe[I32] = (1 through 10).reduce(do(acc, e) acc + e)
    /// assert_eq(reduced, Just(55))
    ///
    /// // Which is equivalent to:
    /// let folded: I32 = (1 through 10).fold(0, do(acc, e) acc + e)
    /// assert_eq(reduced.unwrap(), folded)
    /// ```
    pub func reduce(mut this, f: func(I::Item, I::Item) -> I::Item) -> Maybe[I::Item] {
        when this.next() {
            Just(first) => {
                return Just(this.fold(first, f))
            },
            Nothing => return Nothing
        }
    }

    /// Calls a closure on each element of an iterator.
    ///
    /// This is equivalent to using a `for` loop on the iterator, although
    /// `break` and `continue` are not possible from a closure. It's generally
    /// more idiomatic to use a `for` loop, but `for_each` may be more legible
    /// when processing items at the end of longer iterator chains.
    ///
    /// # Examples
    ///
    /// ```tml
    /// (0 to 5).for_each(do(x) print(x))
    /// ```
    pub func for_each(mut this, f: func(I::Item)) {
        loop {
            when this.next() {
                Just(item) => f(item),
                Nothing => break
            }
        }
    }

    /// Transforms an iterator into a collection.
    ///
    /// `collect()` can take anything iterable, and turn it into a relevant
    /// collection. This is one of the more powerful methods in the standard
    /// library, used in a variety of contexts.
    ///
    /// The most basic pattern in which `collect()` is used is to turn one
    /// collection into another.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let doubled: List[I32] = a.into_iter().map(do(x) x * 2).collect()
    /// assert_eq(doubled, [2, 4, 6])
    /// ```
    pub func collect(mut this) -> List[I::Item] {
        let result: List[I::Item] = List::new(8)
        loop {
            when this.next() {
                Just(item) => result.push(item),
                Nothing => break
            }
        }
        return result
    }

    /// Returns the element that gives the maximum value with respect to the
    /// specified comparison function.
    ///
    /// If several elements are equally maximum, the last element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [-3, 0, 1, 5, -10]
    /// assert_eq(
    ///     a.into_iter().max_by(do(x, y) x.cmp(y)),
    ///     Just(5)
    /// )
    /// ```
    pub func max_by(mut this, compare: func(ref I::Item, ref I::Item) -> Ordering) -> Maybe[I::Item] {
        when this.next() {
            Just(first) => {
                let mut max_val: I::Item = first
                loop {
                    when this.next() {
                        Just(item) => {
                            when compare(ref item, ref max_val) {
                                Greater => max_val = item,
                                _ => {}
                            }
                        },
                        Nothing => break
                    }
                }
                return Just(max_val)
            },
            Nothing => return Nothing
        }
    }

    /// Returns the element that gives the minimum value with respect to the
    /// specified comparison function.
    ///
    /// If several elements are equally minimum, the first element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [-3, 0, 1, 5, -10]
    /// assert_eq(
    ///     a.into_iter().min_by(do(x, y) x.cmp(y)),
    ///     Just(-10)
    /// )
    /// ```
    pub func min_by(mut this, compare: func(ref I::Item, ref I::Item) -> Ordering) -> Maybe[I::Item] {
        when this.next() {
            Just(first) => {
                let mut min_val: I::Item = first
                loop {
                    when this.next() {
                        Just(item) => {
                            when compare(ref item, ref min_val) {
                                Less => min_val = item,
                                _ => {}
                            }
                        },
                        Nothing => break
                    }
                }
                return Just(min_val)
            },
            Nothing => return Nothing
        }
    }

    /// Returns the element that gives the maximum value from the specified
    /// function.
    ///
    /// If several elements are equally maximum, the last element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [-3, 0, 1, 5, -10]
    /// assert_eq(
    ///     a.into_iter().max_by_key(do(x) x.abs()),
    ///     Just(-10)
    /// )
    /// ```
    pub func max_by_key[K: Ord](mut this, key_fn: func(ref I::Item) -> K) -> Maybe[I::Item] {
        return this.max_by(do(a: ref I::Item, b: ref I::Item) key_fn(a).cmp(ref key_fn(b)))
    }

    /// Returns the element that gives the minimum value from the specified
    /// function.
    ///
    /// If several elements are equally minimum, the first element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [-3, 0, 1, 5, -10]
    /// assert_eq(
    ///     a.into_iter().min_by_key(do(x) x.abs()),
    ///     Just(0)
    /// )
    /// ```
    pub func min_by_key[K: Ord](mut this, key_fn: func(ref I::Item) -> K) -> Maybe[I::Item] {
        return this.min_by(do(a: ref I::Item, b: ref I::Item) key_fn(a).cmp(ref key_fn(b)))
    }

    /// Determines if the iterator is empty.
    ///
    /// **Note**: This method consumes the first element to check.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a: List[I32] = []
    /// assert(a.into_iter().is_empty())
    ///
    /// let b = [1, 2, 3]
    /// assert(b.into_iter().is_empty() == false)
    /// ```
    pub func is_empty(mut this) -> Bool {
        return this.next().is_nothing()
    }

    /// [Lexicographically](Ord#lexicographical-comparison) compares the
    /// elements of this [`Iterator`] with those of another with respect to
    /// the specified comparison function.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let xs = [1, 2, 3, 4]
    /// let ys = [1, 4, 9, 16]
    ///
    /// assert_eq(
    ///     xs.into_iter().cmp_by(ys.into_iter(), do(x, y) x.cmp(ref y)),
    ///     Less
    /// )
    /// ```
    pub func cmp_by[J: Iterator](mut this, other: J, compare: func(I::Item, J::Item) -> Ordering) -> Ordering where J::Item = I::Item {
        let mut other_iter = other
        loop {
            when this.next() {
                Just(a) => {
                    when other_iter.next() {
                        Just(b) => {
                            when compare(a, b) {
                                Less => return Less,
                                Greater => return Greater,
                                Equal => {}
                            }
                        },
                        Nothing => return Greater  // this is longer
                    }
                },
                Nothing => {
                    when other_iter.next() {
                        Just(_) => return Less,  // other is longer
                        Nothing => return Equal  // both exhausted
                    }
                }
            }
        }
    }

    /// Determines if the elements of this [`Iterator`] are equal to those of
    /// another with respect to the specified equality function.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let xs = [1, 2, 3, 4]
    /// let ys = [1, 2, 3, 4]
    ///
    /// assert(xs.into_iter().eq_by(ys.into_iter(), do(x, y) x == y))
    /// ```
    pub func eq_by[J: Iterator](mut this, other: J, eq_fn: func(I::Item, J::Item) -> Bool) -> Bool where J::Item = I::Item {
        let mut other_iter = other
        loop {
            when this.next() {
                Just(a) => {
                    when other_iter.next() {
                        Just(b) => {
                            if eq_fn(a, b) == false {
                                return false
                            }
                        },
                        Nothing => return false  // different lengths
                    }
                },
                Nothing => {
                    return other_iter.next().is_nothing()  // both exhausted?
                }
            }
        }
    }
}

// ============================================================================
// Numeric Iterator Extensions
// ============================================================================

/// Extension methods for iterators over `I32`.
impl[I: Iterator] I where I::Item = I32 {
    /// Sums the elements of an iterator.
    ///
    /// Takes each element, adds them together, and returns the result.
    ///
    /// An empty iterator returns the zero value of the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let sum: I32 = a.into_iter().sum()
    /// assert_eq(sum, 6)
    /// ```
    pub func sum(mut this) -> I32 {
        return this.fold(0, do(acc: I32, x: I32) acc + x)
    }

    /// Iterates over the entire iterator, multiplying all the elements.
    ///
    /// An empty iterator returns the one value of the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let product: I32 = a.into_iter().product()
    /// assert_eq(product, 6)
    /// ```
    pub func product(mut this) -> I32 {
        return this.fold(1, do(acc: I32, x: I32) acc * x)
    }

    /// Returns the maximum element of an iterator.
    ///
    /// If several elements are equally maximum, the last element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().max(), Just(3))
    ///
    /// let b: List[I32] = []
    /// assert_eq(b.into_iter().max(), Nothing)
    /// ```
    pub func max(mut this) -> Maybe[I32] {
        return this.reduce(do(a: I32, b: I32) if a > b then a else b)
    }

    /// Returns the minimum element of an iterator.
    ///
    /// If several elements are equally minimum, the first element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// assert_eq(a.into_iter().min(), Just(1))
    ///
    /// let b: List[I32] = []
    /// assert_eq(b.into_iter().min(), Nothing)
    /// ```
    pub func min(mut this) -> Maybe[I32] {
        return this.reduce(do(a: I32, b: I32) if a < b then a else b)
    }
}

/// Extension methods for iterators over `I64`.
impl[I: Iterator] I where I::Item = I64 {
    /// Sums the elements of an iterator.
    ///
    /// Takes each element, adds them together, and returns the result.
    ///
    /// An empty iterator returns the zero value of the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let sum: I64 = a.into_iter().sum()
    /// assert_eq(sum, 6)
    /// ```
    pub func sum(mut this) -> I64 {
        return this.fold(0, do(acc: I64, x: I64) acc + x)
    }

    /// Iterates over the entire iterator, multiplying all the elements.
    ///
    /// An empty iterator returns the one value of the type.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a = [1, 2, 3]
    /// let product: I64 = a.into_iter().product()
    /// assert_eq(product, 6)
    /// ```
    pub func product(mut this) -> I64 {
        return this.fold(1, do(acc: I64, x: I64) acc * x)
    }

    /// Returns the maximum element of an iterator.
    ///
    /// If several elements are equally maximum, the last element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a: List[I64] = [1, 2, 3]
    /// assert_eq(a.into_iter().max(), Just(3))
    /// ```
    pub func max(mut this) -> Maybe[I64] {
        return this.reduce(do(a: I64, b: I64) if a > b then a else b)
    }

    /// Returns the minimum element of an iterator.
    ///
    /// If several elements are equally minimum, the first element is returned.
    /// If the iterator is empty, [`Nothing`] is returned.
    ///
    /// # Examples
    ///
    /// ```tml
    /// let a: List[I64] = [1, 2, 3]
    /// assert_eq(a.into_iter().min(), Just(1))
    /// ```
    pub func min(mut this) -> Maybe[I64] {
        return this.reduce(do(a: I64, b: I64) if a < b then a else b)
    }
}
