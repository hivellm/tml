// Tests for core::result module (Outcome[T, E] enhancements)
// TODO: Enable when core module resolution is implemented
// use core::result::{OutcomeIter}

// ============================================================================
// Core Methods Tests
// ============================================================================

@test
func test_is_ok_true() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.is_ok())
}

@test
func test_is_ok_false() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.is_ok() == false)
}

@test
func test_is_err_true() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.is_err())
}

@test
func test_is_err_false() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.is_err() == false)
}

@test
func test_is_ok_and_true() {
    let o: Outcome[I32, Str] = Ok(10)
    assert(o.is_ok_and(do(x: I32) x > 5))
}

@test
func test_is_ok_and_false_predicate() {
    let o: Outcome[I32, Str] = Ok(3)
    assert(o.is_ok_and(do(x: I32) x > 5) == false)
}

@test
func test_is_ok_and_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.is_ok_and(do(x: I32) x > 5) == false)
}

@test
func test_is_err_and_true() {
    let o: Outcome[I32, Str] = Err("fatal")
    assert(o.is_err_and(do(e: Str) e == "fatal"))
}

@test
func test_is_err_and_false_predicate() {
    let o: Outcome[I32, Str] = Err("warning")
    assert(o.is_err_and(do(e: Str) e == "fatal") == false)
}

@test
func test_is_err_and_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.is_err_and(do(e: Str) e == "fatal") == false)
}

// ============================================================================
// Extracting Values Tests
// ============================================================================

@test
func test_unwrap_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert_eq(o.unwrap(), 42)
}

@test
func test_expect_ok() {
    let o: Outcome[I32, Str] = Ok(100)
    assert_eq(o.expect("should be ok"), 100)
}

@test
func test_unwrap_err_err() {
    let o: Outcome[I32, Str] = Err("error message")
    assert_eq(o.unwrap_err(), "error message")
}

@test
func test_expect_err_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert_eq(o.expect_err("should be err"), "error")
}

@test
func test_unwrap_or_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert_eq(o.unwrap_or(99), 42)
}

@test
func test_unwrap_or_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert_eq(o.unwrap_or(99), 99)
}

@test
func test_unwrap_or_else_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert_eq(o.unwrap_or_else(do(e: Str) 99), 42)
}

@test
func test_unwrap_or_else_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert_eq(o.unwrap_or_else(do(e: Str) 99), 99)
}

@test
func test_unwrap_or_default_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert_eq(o.unwrap_or_default(), 42)
}

@test
func test_unwrap_or_default_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert_eq(o.unwrap_or_default(), 0)  // Default for I32
}

// ============================================================================
// Transforming Values Tests
// ============================================================================

@test
func test_map_ok() {
    let o: Outcome[I32, Str] = Ok(10)
    let result: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
    assert(result.is_ok())
    assert_eq(result.unwrap(), 20)
}

@test
func test_map_err() {
    let o: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
    assert(result.is_err())
    assert_eq(result.unwrap_err(), "error")
}

// TODO: Enable when map/map_err type transformations are fully implemented
// These tests change the Outcome type (e.g., Outcome[I32, Str] to Outcome[Str, Str])
// which requires more complex type tracking in the codegen.

// @test
// func test_map_type_change() {
//     let o: Outcome[I32, Str] = Ok(42)
//     let result: Outcome[Str, Str] = o.map(do(x: I32) x.to_string())
//     assert_eq(result.unwrap(), "42")
// }

// @test
// func test_map_err_err() {
//     let o: Outcome[I32, Str] = Err("error")
//     let result: Outcome[I32, I32] = o.map_err(do(e: Str) e.len() as I32)
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), 5)  // len("error") = 5
// }

// @test
// func test_map_err_ok() {
//     let o: Outcome[I32, Str] = Ok(42)
//     let result: Outcome[I32, I32] = o.map_err(do(e: Str) e.len() as I32)
//     assert(result.is_ok())
//     assert_eq(result.unwrap(), 42)
// }

@test
func test_map_or_ok() {
    let o: Outcome[I32, Str] = Ok(10)
    let result: I32 = o.map_or(0, do(x: I32) x * 2)
    assert_eq(result, 20)
}

@test
func test_map_or_err() {
    let o: Outcome[I32, Str] = Err("error")
    let result: I32 = o.map_or(99, do(x: I32) x * 2)
    assert_eq(result, 99)
}

// TODO: Enable when closure result type tracking is fixed
// The closure body's result type is not being tracked correctly through casts

// @test
// func test_map_or_else_ok() {
//     let o: Outcome[I32, Str] = Ok(10)
//     let result: I32 = o.map_or_else(do(e: Str) 0, do(x: I32) x * 2)
//     assert_eq(result, 20)
// }

// @test
// func test_map_or_else_err() {
//     let o: Outcome[I32, Str] = Err("error")
//     let result: I32 = o.map_or_else(do(e: Str) e.len() as I32, do(x: I32) x * 2)
//     assert_eq(result, 5)
// }

// ============================================================================
// Chaining Operations Tests
// ============================================================================

// TODO: Enable when and_then is fully fixed
// @test
// func test_and_then_ok_to_ok() {
//     let o: Outcome[I32, Str] = Ok(10)
//     let result: Outcome[I32, Str] = o.and_then(do(x: I32) Ok(x * 2))
//     assert_eq(result.unwrap(), 20)
// }

// @test
// func test_and_then_ok_to_err() {
//     let o: Outcome[I32, Str] = Ok(10)
//     let result: Outcome[I32, Str] = o.and_then(do(x: I32) Err("failed"))
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "failed")
// }

// @test
// func test_and_then_err() {
//     let o: Outcome[I32, Str] = Err("initial error")
//     let result: Outcome[I32, Str] = o.and_then(do(x: I32) Ok(x * 2))
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "initial error")
// }

// TODO: Enable when closure result type tracking is fixed
// @test
// func test_or_else_ok() {
//     let o: Outcome[I32, Str] = Ok(42)
//     let result: Outcome[I32, I32] = o.or_else(do(e: Str) Err(e.len() as I32))
//     assert(result.is_ok())
//     assert_eq(result.unwrap(), 42)
// }

// TODO: Enable when or_else is fully fixed
// @test
// func test_or_else_err_to_ok() {
//     let o: Outcome[I32, Str] = Err("error")
//     let result: Outcome[I32, Str] = o.or_else(do(e: Str) Ok(99))
//     assert(result.is_ok())
//     assert_eq(result.unwrap(), 99)
// }

// @test
// func test_or_else_err_to_err() {
//     let o: Outcome[I32, Str] = Err("error")
//     let result: Outcome[I32, Str] = o.or_else(do(e: Str) Err("new error"))
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "new error")
// }

@test
func test_alt_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    let result: Outcome[I32, Str] = o.alt(Ok(99))
    assert_eq(result.unwrap(), 42)
}

@test
func test_alt_err() {
    let o: Outcome[I32, Str] = Err("error")
    let result: Outcome[I32, Str] = o.alt(Ok(99))
    assert_eq(result.unwrap(), 99)
}

@test
func test_also_ok_ok() {
    let a: Outcome[I32, Str] = Ok(1)
    let b: Outcome[Str, Str] = Ok("hello")
    let result: Outcome[Str, Str] = a.also(b)
    assert_eq(result.unwrap(), "hello")
}

@test
func test_also_err_ok() {
    let a: Outcome[I32, Str] = Err("error")
    let b: Outcome[Str, Str] = Ok("hello")
    let result: Outcome[Str, Str] = a.also(b)
    assert(result.is_err())
    assert_eq(result.unwrap_err(), "error")
}

// ============================================================================
// Converting to Maybe Tests
// ============================================================================

@test
func test_ok_method_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    let m: Maybe[I32] = o.ok()
    assert(m.is_just())
    assert_eq(m.unwrap(), 42)
}

@test
func test_ok_method_err() {
    let o: Outcome[I32, Str] = Err("error")
    let m: Maybe[I32] = o.ok()
    assert(m.is_nothing())
}

@test
func test_err_method_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    let m: Maybe[Str] = o.err()
    assert(m.is_nothing())
}

@test
func test_err_method_err() {
    let o: Outcome[I32, Str] = Err("error")
    let m: Maybe[Str] = o.err()
    assert(m.is_just())
    assert_eq(m.unwrap(), "error")
}

// ============================================================================
// Flattening Tests
// ============================================================================

// TODO: Enable when nested Outcome types work correctly
// The nested Outcome[Outcome[I32, Str], Str] type has size issues

// @test
// func test_flatten_ok_ok() {
//     let o: Outcome[Outcome[I32, Str], Str] = Ok(Ok(42))
//     let result: Outcome[I32, Str] = o.flatten()
//     assert_eq(result.unwrap(), 42)
// }

// @test
// func test_flatten_ok_err() {
//     let o: Outcome[Outcome[I32, Str], Str] = Ok(Err("inner error"))
//     let result: Outcome[I32, Str] = o.flatten()
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "inner error")
// }

// @test
// func test_flatten_err() {
//     let o: Outcome[Outcome[I32, Str], Str] = Err("outer error")
//     let result: Outcome[I32, Str] = o.flatten()
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "outer error")
// }

// ============================================================================
// Contains Methods Tests
// ============================================================================

@test
func test_contains_ok_true() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.contains(42))
}

@test
func test_contains_ok_false() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.contains(100) == false)
}

@test
func test_contains_err() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.contains(42) == false)
}

@test
func test_contains_err_ok() {
    let o: Outcome[I32, Str] = Ok(42)
    assert(o.contains_err("error") == false)
}

@test
func test_contains_err_err_true() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.contains_err("error"))
}

@test
func test_contains_err_err_false() {
    let o: Outcome[I32, Str] = Err("error")
    assert(o.contains_err("other") == false)
}

// ============================================================================
// Iterator Tests
// ============================================================================

// TODO: Enable when OutcomeIter::next() is implemented
// @test
// func test_iter_ok() {
//     let o: Outcome[I32, Str] = Ok(42)
//     let mut iter: OutcomeIter[I32] = o.iter()
//     let first: Maybe[I32] = iter.next()
//     assert(first.is_just())
//     assert_eq(first.unwrap(), 42)
//     let second: Maybe[I32] = iter.next()
//     assert(second.is_nothing())
// }

// @test
// func test_iter_err() {
//     let o: Outcome[I32, Str] = Err("error")
//     let mut iter: OutcomeIter[I32] = o.iter()
//     let first: Maybe[I32] = iter.next()
//     assert(first.is_nothing())
// }

// ============================================================================
// Chained Operations Tests
// ============================================================================

// TODO: Enable when and_then with if-then-else is fixed
// @test
// func test_chained_map_and_then() {
//     let o: Outcome[I32, Str] = Ok(10)
//     let mapped: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
//     let result: Outcome[I32, Str] = mapped.and_then(do(x: I32) if x > 15 then Ok(x) else Err("too small"))
//     assert(result.is_ok())
//     assert_eq(result.unwrap(), 20)
// }

// @test
// func test_chained_map_and_then_fails() {
//     let o: Outcome[I32, Str] = Ok(5)
//     let mapped: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
//     let result: Outcome[I32, Str] = mapped.and_then(do(x: I32) if x > 15 then Ok(x) else Err("too small"))
//     assert(result.is_err())
//     assert_eq(result.unwrap_err(), "too small")
// }

// @test
// func test_complex_chain_ok() {
//     let o: Outcome[I32, Str] = Ok(10)
//     let step1: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
//     let step2: Outcome[I32, Str] = step1.and_then(do(x: I32) Ok(x + 5))
//     let step3: Outcome[I32, Str] = step2.map(do(x: I32) x - 10)
//     let result: I32 = step3.unwrap_or(0)
//     assert_eq(result, 15)
// }

// @test
// func test_complex_chain_err() {
//     let o: Outcome[I32, Str] = Err("initial")
//     let step1: Outcome[I32, Str] = o.map(do(x: I32) x * 2)
//     let step2: Outcome[I32, Str] = step1.and_then(do(x: I32) Ok(x + 5))
//     let step3: Outcome[I32, Str] = step2.map(do(x: I32) x - 10)
//     let result: I32 = step3.unwrap_or(99)
//     assert_eq(result, 99)
// }

// @test
// func test_or_else_chain() {
//     let o: Outcome[I32, Str] = Err("first")
//     let step1: Outcome[I32, Str] = o.or_else(do(e: Str) Err("second"))
//     let result: Outcome[I32, Str] = step1.or_else(do(e: Str) Ok(42))
//     assert(result.is_ok())
//     assert_eq(result.unwrap(), 42)
// }
