// Tests for core::iter module

use core::iter::{Iterator, IntoIterator, FromIterator, Map, Filter, Take, Skip, Chain, Zip, Enumerate, Peekable, TakeWhile, SkipWhile}

// ============================================================================
// Basic Iterator Tests
// ============================================================================

@test
func test_iterator_count() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let count: I64 = list.iter().count()
    assert_eq(count, 5)
}

@test
func test_iterator_count_empty() {
    let list: List[I32] = []
    let count: I64 = list.iter().count()
    assert_eq(count, 0)
}

@test
func test_iterator_last() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let last: Maybe[I32] = list.iter().last()
    assert(last.is_just())
    assert_eq(last.unwrap(), 5)
}

@test
func test_iterator_last_empty() {
    let list: List[I32] = []
    let last: Maybe[I32] = list.iter().last()
    assert(last.is_nothing())
}

@test
func test_iterator_nth() {
    let list: List[I32] = [10, 20, 30, 40, 50]
    let third: Maybe[I32] = list.iter().nth(2)
    assert(third.is_just())
    assert_eq(third.unwrap(), 30)
}

@test
func test_iterator_nth_out_of_bounds() {
    let list: List[I32] = [1, 2, 3]
    let result: Maybe[I32] = list.iter().nth(10)
    assert(result.is_nothing())
}

@test
func test_iterator_advance_by() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let mut iter = list.iter()
    let skipped: I64 = iter.advance_by(3)
    assert_eq(skipped, 3)
    assert_eq(iter.next().unwrap(), 4)
}

// ============================================================================
// Map Tests
// ============================================================================

@test
func test_map_double() {
    let list: List[I32] = [1, 2, 3]
    let doubled: List[I32] = list.iter().map(do(x: I32) x * 2).collect()
    assert_eq(doubled.len(), 3)
    assert_eq(doubled.get(0).unwrap(), 2)
    assert_eq(doubled.get(1).unwrap(), 4)
    assert_eq(doubled.get(2).unwrap(), 6)
}

@test
func test_map_to_string() {
    let list: List[I32] = [1, 2, 3]
    let strings: List[Str] = list.iter().map(do(x: I32) x.to_string()).collect()
    assert_eq(strings.get(0).unwrap(), "1")
    assert_eq(strings.get(1).unwrap(), "2")
    assert_eq(strings.get(2).unwrap(), "3")
}

@test
func test_map_empty() {
    let list: List[I32] = []
    let result: List[I32] = list.iter().map(do(x: I32) x * 2).collect()
    assert_eq(result.len(), 0)
}

// ============================================================================
// Filter Tests
// ============================================================================

@test
func test_filter_even() {
    let list: List[I32] = [1, 2, 3, 4, 5, 6]
    let evens: List[I32] = list.iter().filter(do(x: ref I32) *x % 2 == 0).collect()
    assert_eq(evens.len(), 3)
    assert_eq(evens.get(0).unwrap(), 2)
    assert_eq(evens.get(1).unwrap(), 4)
    assert_eq(evens.get(2).unwrap(), 6)
}

@test
func test_filter_none_match() {
    let list: List[I32] = [1, 3, 5, 7]
    let evens: List[I32] = list.iter().filter(do(x: ref I32) *x % 2 == 0).collect()
    assert_eq(evens.len(), 0)
}

@test
func test_filter_all_match() {
    let list: List[I32] = [2, 4, 6, 8]
    let evens: List[I32] = list.iter().filter(do(x: ref I32) *x % 2 == 0).collect()
    assert_eq(evens.len(), 4)
}

// ============================================================================
// Take Tests
// ============================================================================

@test
func test_take_fewer_than_available() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let taken: List[I32] = list.iter().take(3).collect()
    assert_eq(taken.len(), 3)
    assert_eq(taken.get(0).unwrap(), 1)
    assert_eq(taken.get(1).unwrap(), 2)
    assert_eq(taken.get(2).unwrap(), 3)
}

@test
func test_take_more_than_available() {
    let list: List[I32] = [1, 2]
    let taken: List[I32] = list.iter().take(10).collect()
    assert_eq(taken.len(), 2)
}

@test
func test_take_zero() {
    let list: List[I32] = [1, 2, 3]
    let taken: List[I32] = list.iter().take(0).collect()
    assert_eq(taken.len(), 0)
}

// ============================================================================
// Skip Tests
// ============================================================================

@test
func test_skip_some() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let skipped: List[I32] = list.iter().skip(2).collect()
    assert_eq(skipped.len(), 3)
    assert_eq(skipped.get(0).unwrap(), 3)
    assert_eq(skipped.get(1).unwrap(), 4)
    assert_eq(skipped.get(2).unwrap(), 5)
}

@test
func test_skip_all() {
    let list: List[I32] = [1, 2, 3]
    let skipped: List[I32] = list.iter().skip(10).collect()
    assert_eq(skipped.len(), 0)
}

@test
func test_skip_zero() {
    let list: List[I32] = [1, 2, 3]
    let skipped: List[I32] = list.iter().skip(0).collect()
    assert_eq(skipped.len(), 3)
}

// ============================================================================
// Chain Tests
// ============================================================================

@test
func test_chain_two_lists() {
    let list1: List[I32] = [1, 2]
    let list2: List[I32] = [3, 4]
    let chained: List[I32] = list1.iter().chain(list2.iter()).collect()
    assert_eq(chained.len(), 4)
    assert_eq(chained.get(0).unwrap(), 1)
    assert_eq(chained.get(1).unwrap(), 2)
    assert_eq(chained.get(2).unwrap(), 3)
    assert_eq(chained.get(3).unwrap(), 4)
}

@test
func test_chain_empty_first() {
    let list1: List[I32] = []
    let list2: List[I32] = [1, 2]
    let chained: List[I32] = list1.iter().chain(list2.iter()).collect()
    assert_eq(chained.len(), 2)
}

@test
func test_chain_empty_second() {
    let list1: List[I32] = [1, 2]
    let list2: List[I32] = []
    let chained: List[I32] = list1.iter().chain(list2.iter()).collect()
    assert_eq(chained.len(), 2)
}

// ============================================================================
// Zip Tests
// ============================================================================

@test
func test_zip_equal_length() {
    let list1: List[I32] = [1, 2, 3]
    let list2: List[Str] = ["a", "b", "c"]
    let zipped: List[(I32, Str)] = list1.iter().zip(list2.iter()).collect()
    assert_eq(zipped.len(), 3)
    let (n1, s1) = zipped.get(0).unwrap()
    assert_eq(n1, 1)
    assert_eq(s1, "a")
}

@test
func test_zip_first_shorter() {
    let list1: List[I32] = [1, 2]
    let list2: List[I32] = [10, 20, 30]
    let zipped: List[(I32, I32)] = list1.iter().zip(list2.iter()).collect()
    assert_eq(zipped.len(), 2)  // Stops at shorter
}

@test
func test_zip_second_shorter() {
    let list1: List[I32] = [1, 2, 3]
    let list2: List[I32] = [10]
    let zipped: List[(I32, I32)] = list1.iter().zip(list2.iter()).collect()
    assert_eq(zipped.len(), 1)
}

// ============================================================================
// Enumerate Tests
// ============================================================================

@test
func test_enumerate() {
    let list: List[Str] = ["a", "b", "c"]
    let enumerated: List[(I64, Str)] = list.iter().enumerate().collect()
    assert_eq(enumerated.len(), 3)
    let (i0, v0) = enumerated.get(0).unwrap()
    let (i1, v1) = enumerated.get(1).unwrap()
    let (i2, v2) = enumerated.get(2).unwrap()
    assert_eq(i0, 0)
    assert_eq(v0, "a")
    assert_eq(i1, 1)
    assert_eq(v1, "b")
    assert_eq(i2, 2)
    assert_eq(v2, "c")
}

@test
func test_enumerate_empty() {
    let list: List[I32] = []
    let enumerated: List[(I64, I32)] = list.iter().enumerate().collect()
    assert_eq(enumerated.len(), 0)
}

// ============================================================================
// TakeWhile Tests
// ============================================================================

@test
func test_take_while() {
    let list: List[I32] = [1, 2, 3, 10, 4, 5]
    let taken: List[I32] = list.iter().take_while(do(x: ref I32) *x < 5).collect()
    assert_eq(taken.len(), 3)
    assert_eq(taken.get(0).unwrap(), 1)
    assert_eq(taken.get(1).unwrap(), 2)
    assert_eq(taken.get(2).unwrap(), 3)
}

@test
func test_take_while_none() {
    let list: List[I32] = [10, 20, 30]
    let taken: List[I32] = list.iter().take_while(do(x: ref I32) *x < 5).collect()
    assert_eq(taken.len(), 0)
}

@test
func test_take_while_all() {
    let list: List[I32] = [1, 2, 3]
    let taken: List[I32] = list.iter().take_while(do(x: ref I32) *x < 100).collect()
    assert_eq(taken.len(), 3)
}

// ============================================================================
// SkipWhile Tests
// ============================================================================

@test
func test_skip_while() {
    let list: List[I32] = [1, 2, 3, 10, 4, 5]
    let skipped: List[I32] = list.iter().skip_while(do(x: ref I32) *x < 5).collect()
    assert_eq(skipped.len(), 3)
    assert_eq(skipped.get(0).unwrap(), 10)
    assert_eq(skipped.get(1).unwrap(), 4)
    assert_eq(skipped.get(2).unwrap(), 5)
}

@test
func test_skip_while_none() {
    let list: List[I32] = [10, 20, 30]
    let skipped: List[I32] = list.iter().skip_while(do(x: ref I32) *x < 5).collect()
    assert_eq(skipped.len(), 3)
}

@test
func test_skip_while_all() {
    let list: List[I32] = [1, 2, 3]
    let skipped: List[I32] = list.iter().skip_while(do(x: ref I32) *x < 100).collect()
    assert_eq(skipped.len(), 0)
}

// ============================================================================
// Peekable Tests
// ============================================================================

@test
func test_peekable_peek() {
    let list: List[I32] = [1, 2, 3]
    let mut iter = list.iter().peekable()
    let peeked: Maybe[ref I32] = iter.peek()
    assert(peeked.is_just())
    assert_eq(*peeked.unwrap(), 1)
    // Peek again - should still be 1
    let peeked2: Maybe[ref I32] = iter.peek()
    assert_eq(*peeked2.unwrap(), 1)
    // Now consume
    let next: Maybe[I32] = iter.next()
    assert_eq(next.unwrap(), 1)
    // Peek should now be 2
    let peeked3: Maybe[ref I32] = iter.peek()
    assert_eq(*peeked3.unwrap(), 2)
}

@test
func test_peekable_empty() {
    let list: List[I32] = []
    let mut iter = list.iter().peekable()
    let peeked: Maybe[ref I32] = iter.peek()
    assert(peeked.is_nothing())
}

// ============================================================================
// any/all Tests
// ============================================================================

@test
func test_any_true() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let has_even: Bool = list.iter().any(do(x: I32) x % 2 == 0)
    assert(has_even)
}

@test
func test_any_false() {
    let list: List[I32] = [1, 3, 5, 7]
    let has_even: Bool = list.iter().any(do(x: I32) x % 2 == 0)
    assert(not has_even)
}

@test
func test_any_empty() {
    let list: List[I32] = []
    let result: Bool = list.iter().any(do(x: I32) x > 0)
    assert(not result)
}

@test
func test_all_true() {
    let list: List[I32] = [2, 4, 6, 8]
    let all_even: Bool = list.iter().all(do(x: I32) x % 2 == 0)
    assert(all_even)
}

@test
func test_all_false() {
    let list: List[I32] = [2, 4, 5, 8]
    let all_even: Bool = list.iter().all(do(x: I32) x % 2 == 0)
    assert(not all_even)
}

@test
func test_all_empty() {
    let list: List[I32] = []
    let result: Bool = list.iter().all(do(x: I32) x > 0)
    assert(result)  // Vacuously true
}

// ============================================================================
// find/position Tests
// ============================================================================

@test
func test_find_exists() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let found: Maybe[I32] = list.iter().find(do(x: ref I32) *x == 3)
    assert(found.is_just())
    assert_eq(found.unwrap(), 3)
}

@test
func test_find_not_exists() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let found: Maybe[I32] = list.iter().find(do(x: ref I32) *x == 10)
    assert(found.is_nothing())
}

@test
func test_position_exists() {
    let list: List[I32] = [10, 20, 30, 40]
    let pos: Maybe[I64] = list.iter().position(do(x: I32) x == 30)
    assert(pos.is_just())
    assert_eq(pos.unwrap(), 2)
}

@test
func test_position_not_exists() {
    let list: List[I32] = [10, 20, 30]
    let pos: Maybe[I64] = list.iter().position(do(x: I32) x == 100)
    assert(pos.is_nothing())
}

// ============================================================================
// fold/reduce Tests
// ============================================================================

@test
func test_fold_sum() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let sum: I32 = list.iter().fold(0, do(acc: I32, x: I32) acc + x)
    assert_eq(sum, 15)
}

@test
func test_fold_product() {
    let list: List[I32] = [1, 2, 3, 4]
    let product: I32 = list.iter().fold(1, do(acc: I32, x: I32) acc * x)
    assert_eq(product, 24)
}

@test
func test_fold_empty() {
    let list: List[I32] = []
    let sum: I32 = list.iter().fold(42, do(acc: I32, x: I32) acc + x)
    assert_eq(sum, 42)  // Returns init value
}

@test
func test_reduce_sum() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let sum: Maybe[I32] = list.iter().reduce(do(a: I32, b: I32) a + b)
    assert(sum.is_just())
    assert_eq(sum.unwrap(), 15)
}

@test
func test_reduce_empty() {
    let list: List[I32] = []
    let result: Maybe[I32] = list.iter().reduce(do(a: I32, b: I32) a + b)
    assert(result.is_nothing())
}

// ============================================================================
// sum/product/max/min Tests
// ============================================================================

@test
func test_sum_i32() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let sum: I32 = list.iter().sum()
    assert_eq(sum, 15)
}

@test
func test_sum_empty() {
    let list: List[I32] = []
    let sum: I32 = list.iter().sum()
    assert_eq(sum, 0)
}

@test
func test_product_i32() {
    let list: List[I32] = [1, 2, 3, 4]
    let product: I32 = list.iter().product()
    assert_eq(product, 24)
}

@test
func test_product_empty() {
    let list: List[I32] = []
    let product: I32 = list.iter().product()
    assert_eq(product, 1)
}

@test
func test_max_i32() {
    let list: List[I32] = [3, 1, 4, 1, 5, 9, 2, 6]
    let max: Maybe[I32] = list.iter().max()
    assert(max.is_just())
    assert_eq(max.unwrap(), 9)
}

@test
func test_max_empty() {
    let list: List[I32] = []
    let max: Maybe[I32] = list.iter().max()
    assert(max.is_nothing())
}

@test
func test_min_i32() {
    let list: List[I32] = [3, 1, 4, 1, 5, 9, 2, 6]
    let min: Maybe[I32] = list.iter().min()
    assert(min.is_just())
    assert_eq(min.unwrap(), 1)
}

@test
func test_min_empty() {
    let list: List[I32] = []
    let min: Maybe[I32] = list.iter().min()
    assert(min.is_nothing())
}

// ============================================================================
// for_each Tests
// ============================================================================

@test
func test_for_each() {
    let list: List[I32] = [1, 2, 3]
    let mut sum: I32 = 0
    list.iter().for_each(do(x: I32) {
        sum = sum + x
    })
    assert_eq(sum, 6)
}

// ============================================================================
// Chained Operations Tests
// ============================================================================

@test
func test_map_filter_collect() {
    let list: List[I32] = [1, 2, 3, 4, 5, 6]
    let result: List[I32] = list.iter()
        .map(do(x: I32) x * 2)
        .filter(do(x: ref I32) *x > 5)
        .collect()
    assert_eq(result.len(), 4)  // 6, 8, 10, 12
    assert_eq(result.get(0).unwrap(), 6)
    assert_eq(result.get(1).unwrap(), 8)
}

@test
func test_filter_map_take() {
    let list: List[I32] = [1, 2, 3, 4, 5, 6, 7, 8]
    let result: List[I32] = list.iter()
        .filter(do(x: ref I32) *x % 2 == 0)
        .map(do(x: I32) x * 10)
        .take(2)
        .collect()
    assert_eq(result.len(), 2)
    assert_eq(result.get(0).unwrap(), 20)
    assert_eq(result.get(1).unwrap(), 40)
}

@test
func test_enumerate_filter() {
    let list: List[Str] = ["a", "b", "c", "d"]
    let result: List[(I64, Str)] = list.iter()
        .enumerate()
        .filter(do(pair: ref (I64, Str)) (*pair).0 % 2 == 0)
        .collect()
    assert_eq(result.len(), 2)  // Indices 0 and 2
}
