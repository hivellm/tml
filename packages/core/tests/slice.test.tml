// Tests for core::slice module

use core::slice::{Slice, MutSlice, Chunks, Windows}

// ============================================================================
// Slice Basic Tests
// ============================================================================

@test
func test_slice_len() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    assert_eq(slice.len(), 5)
}

@test
func test_slice_is_empty_false() {
    let list: List[I32] = [1, 2, 3]
    let slice: Slice[I32] = list.as_slice()
    assert(slice.is_empty() == false)
}

@test
func test_slice_is_empty_true() {
    let list: List[I32] = []
    let slice: Slice[I32] = list.as_slice()
    assert(slice.is_empty())
}

@test
func test_slice_first() {
    let list: List[I32] = [10, 20, 30]
    let slice: Slice[I32] = list.as_slice()
    let first: Maybe[ref I32] = slice.first()
    assert(first.is_just())
    assert_eq(*first.unwrap(), 10)
}

@test
func test_slice_first_empty() {
    let list: List[I32] = []
    let slice: Slice[I32] = list.as_slice()
    let first: Maybe[ref I32] = slice.first()
    assert(first.is_nothing())
}

@test
func test_slice_last() {
    let list: List[I32] = [10, 20, 30]
    let slice: Slice[I32] = list.as_slice()
    let last: Maybe[ref I32] = slice.last()
    assert(last.is_just())
    assert_eq(*last.unwrap(), 30)
}

@test
func test_slice_last_empty() {
    let list: List[I32] = []
    let slice: Slice[I32] = list.as_slice()
    let last: Maybe[ref I32] = slice.last()
    assert(last.is_nothing())
}

@test
func test_slice_get_valid() {
    let list: List[I32] = [10, 20, 30]
    let slice: Slice[I32] = list.as_slice()
    let elem: Maybe[ref I32] = slice.get(1)
    assert(elem.is_just())
    assert_eq(*elem.unwrap(), 20)
}

@test
func test_slice_get_out_of_bounds() {
    let list: List[I32] = [10, 20, 30]
    let slice: Slice[I32] = list.as_slice()
    let elem: Maybe[ref I32] = slice.get(10)
    assert(elem.is_nothing())
}

@test
func test_slice_get_negative() {
    let list: List[I32] = [10, 20, 30]
    let slice: Slice[I32] = list.as_slice()
    let elem: Maybe[ref I32] = slice.get(-1)
    assert(elem.is_nothing())
}

// ============================================================================
// MutSlice Basic Tests
// ============================================================================

@test
func test_mut_slice_len() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let slice: MutSlice[I32] = list.as_mut_slice()
    assert_eq(slice.len(), 5)
}

@test
func test_mut_slice_get() {
    let mut list: List[I32] = [10, 20, 30]
    let slice: MutSlice[I32] = list.as_mut_slice()
    let elem: Maybe[ref I32] = slice.get(1)
    assert_eq(*elem.unwrap(), 20)
}

@test
func test_mut_slice_get_mut() {
    let mut list: List[I32] = [10, 20, 30]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    let elem: Maybe[mut ref I32] = slice.get_mut(1)
    *elem.unwrap() = 99
    assert_eq(*slice.get(1).unwrap(), 99)
}

// ============================================================================
// MutSlice Swap Tests
// ============================================================================

@test
func test_mut_slice_swap() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.swap(0, 4)
    assert_eq(*slice.get(0).unwrap(), 5)
    assert_eq(*slice.get(4).unwrap(), 1)
}

@test
func test_mut_slice_swap_same() {
    let mut list: List[I32] = [1, 2, 3]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.swap(1, 1)
    assert_eq(*slice.get(1).unwrap(), 2)
}

// ============================================================================
// Reverse Tests
// ============================================================================

@test
func test_reverse_odd_length() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.reverse()
    assert_eq(*slice.get(0).unwrap(), 5)
    assert_eq(*slice.get(1).unwrap(), 4)
    assert_eq(*slice.get(2).unwrap(), 3)
    assert_eq(*slice.get(3).unwrap(), 2)
    assert_eq(*slice.get(4).unwrap(), 1)
}

@test
func test_reverse_even_length() {
    let mut list: List[I32] = [1, 2, 3, 4]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.reverse()
    assert_eq(*slice.get(0).unwrap(), 4)
    assert_eq(*slice.get(1).unwrap(), 3)
    assert_eq(*slice.get(2).unwrap(), 2)
    assert_eq(*slice.get(3).unwrap(), 1)
}

@test
func test_reverse_single() {
    let mut list: List[I32] = [42]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.reverse()
    assert_eq(*slice.get(0).unwrap(), 42)
}

@test
func test_reverse_empty() {
    let mut list: List[I32] = []
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.reverse()  // Should not panic
    assert_eq(slice.len(), 0)
}

// ============================================================================
// Rotate Tests
// ============================================================================

@test
func test_rotate_left() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.rotate_left(2)
    assert_eq(*slice.get(0).unwrap(), 3)
    assert_eq(*slice.get(1).unwrap(), 4)
    assert_eq(*slice.get(2).unwrap(), 5)
    assert_eq(*slice.get(3).unwrap(), 1)
    assert_eq(*slice.get(4).unwrap(), 2)
}

@test
func test_rotate_right() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.rotate_right(2)
    assert_eq(*slice.get(0).unwrap(), 4)
    assert_eq(*slice.get(1).unwrap(), 5)
    assert_eq(*slice.get(2).unwrap(), 1)
    assert_eq(*slice.get(3).unwrap(), 2)
    assert_eq(*slice.get(4).unwrap(), 3)
}

@test
func test_rotate_left_zero() {
    let mut list: List[I32] = [1, 2, 3]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.rotate_left(0)
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(1).unwrap(), 2)
    assert_eq(*slice.get(2).unwrap(), 3)
}

@test
func test_rotate_left_full() {
    let mut list: List[I32] = [1, 2, 3]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.rotate_left(3)  // Full rotation = no change
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(1).unwrap(), 2)
    assert_eq(*slice.get(2).unwrap(), 3)
}

// ============================================================================
// Fill Tests
// ============================================================================

@test
func test_fill() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.fill(42)
    assert_eq(*slice.get(0).unwrap(), 42)
    assert_eq(*slice.get(1).unwrap(), 42)
    assert_eq(*slice.get(2).unwrap(), 42)
    assert_eq(*slice.get(3).unwrap(), 42)
    assert_eq(*slice.get(4).unwrap(), 42)
}

// ============================================================================
// Sort Tests
// ============================================================================

@test
func test_sort_unsorted() {
    let mut list: List[I32] = [5, 2, 8, 1, 9, 3]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(1).unwrap(), 2)
    assert_eq(*slice.get(2).unwrap(), 3)
    assert_eq(*slice.get(3).unwrap(), 5)
    assert_eq(*slice.get(4).unwrap(), 8)
    assert_eq(*slice.get(5).unwrap(), 9)
}

@test
func test_sort_already_sorted() {
    let mut list: List[I32] = [1, 2, 3, 4, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(4).unwrap(), 5)
}

@test
func test_sort_reverse_sorted() {
    let mut list: List[I32] = [5, 4, 3, 2, 1]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(4).unwrap(), 5)
}

@test
func test_sort_single() {
    let mut list: List[I32] = [42]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(*slice.get(0).unwrap(), 42)
}

@test
func test_sort_empty() {
    let mut list: List[I32] = []
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(slice.len(), 0)
}

@test
func test_sort_with_duplicates() {
    let mut list: List[I32] = [3, 1, 4, 1, 5, 9, 2, 6, 5]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort()
    assert_eq(*slice.get(0).unwrap(), 1)
    assert_eq(*slice.get(1).unwrap(), 1)
    assert_eq(*slice.get(2).unwrap(), 2)
    assert_eq(*slice.get(3).unwrap(), 3)
}

// ============================================================================
// Sort By Tests
// ============================================================================

@test
func test_sort_by_descending() {
    let mut list: List[I32] = [1, 5, 3, 2, 4]
    let mut slice: MutSlice[I32] = list.as_mut_slice()
    slice.sort_by(do(a: ref I32, b: ref I32) {
        if *a > *b { return Less }
        if *a < *b { return Greater }
        return Equal
    })
    assert_eq(*slice.get(0).unwrap(), 5)
    assert_eq(*slice.get(4).unwrap(), 1)
}

// ============================================================================
// Binary Search Tests
// ============================================================================

@test
func test_binary_search_found() {
    let list: List[I32] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    let slice: Slice[I32] = list.as_slice()
    let result: Outcome[I64, I64] = slice.binary_search(ref 5)
    assert(result.is_ok())
    assert_eq(result.unwrap(), 4)
}

@test
func test_binary_search_not_found() {
    let list: List[I32] = [1, 2, 4, 5, 6]
    let slice: Slice[I32] = list.as_slice()
    let result: Outcome[I64, I64] = slice.binary_search(ref 3)
    assert(result.is_err())
    assert_eq(result.unwrap_err(), 2)  // Insertion point
}

@test
func test_binary_search_first() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let result: Outcome[I64, I64] = slice.binary_search(ref 1)
    assert(result.is_ok())
    assert_eq(result.unwrap(), 0)
}

@test
func test_binary_search_last() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let result: Outcome[I64, I64] = slice.binary_search(ref 5)
    assert(result.is_ok())
    assert_eq(result.unwrap(), 4)
}

@test
func test_binary_search_empty() {
    let list: List[I32] = []
    let slice: Slice[I32] = list.as_slice()
    let result: Outcome[I64, I64] = slice.binary_search(ref 5)
    assert(result.is_err())
    assert_eq(result.unwrap_err(), 0)
}

// ============================================================================
// Split At Tests
// ============================================================================

@test
func test_split_at_middle() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let (first, second) = slice.split_at(2)
    assert_eq(first.len(), 2)
    assert_eq(second.len(), 3)
    assert_eq(*first.get(0).unwrap(), 1)
    assert_eq(*first.get(1).unwrap(), 2)
    assert_eq(*second.get(0).unwrap(), 3)
}

@test
func test_split_at_start() {
    let list: List[I32] = [1, 2, 3]
    let slice: Slice[I32] = list.as_slice()
    let (first, second) = slice.split_at(0)
    assert_eq(first.len(), 0)
    assert_eq(second.len(), 3)
}

@test
func test_split_at_end() {
    let list: List[I32] = [1, 2, 3]
    let slice: Slice[I32] = list.as_slice()
    let (first, second) = slice.split_at(3)
    assert_eq(first.len(), 3)
    assert_eq(second.len(), 0)
}

// ============================================================================
// Take and Skip Tests
// ============================================================================

@test
func test_take() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let taken: Slice[I32] = slice.take(3)
    assert_eq(taken.len(), 3)
    assert_eq(*taken.get(0).unwrap(), 1)
    assert_eq(*taken.get(2).unwrap(), 3)
}

@test
func test_take_more_than_available() {
    let list: List[I32] = [1, 2]
    let slice: Slice[I32] = list.as_slice()
    let taken: Slice[I32] = slice.take(10)
    assert_eq(taken.len(), 2)
}

@test
func test_skip() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let skipped: Slice[I32] = slice.skip(2)
    assert_eq(skipped.len(), 3)
    assert_eq(*skipped.get(0).unwrap(), 3)
}

@test
func test_skip_all() {
    let list: List[I32] = [1, 2, 3]
    let slice: Slice[I32] = list.as_slice()
    let skipped: Slice[I32] = slice.skip(10)
    assert_eq(skipped.len(), 0)
}

// ============================================================================
// Contains Tests
// ============================================================================

@test
func test_contains_true() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    assert(slice.contains(ref 3))
}

@test
func test_contains_false() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    assert(slice.contains(ref 10) == false)
}

// ============================================================================
// Starts/Ends With Tests
// ============================================================================

@test
func test_starts_with_true() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let prefix: List[I32] = [1, 2]
    let slice: Slice[I32] = list.as_slice()
    let prefix_slice: Slice[I32] = prefix.as_slice()
    assert(slice.starts_with(prefix_slice))
}

@test
func test_starts_with_false() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let prefix: List[I32] = [2, 3]
    let slice: Slice[I32] = list.as_slice()
    let prefix_slice: Slice[I32] = prefix.as_slice()
    assert(slice.starts_with(prefix_slice) == false)
}

@test
func test_ends_with_true() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let suffix: List[I32] = [4, 5]
    let slice: Slice[I32] = list.as_slice()
    let suffix_slice: Slice[I32] = suffix.as_slice()
    assert(slice.ends_with(suffix_slice))
}

@test
func test_ends_with_false() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let suffix: List[I32] = [3, 4]
    let slice: Slice[I32] = list.as_slice()
    let suffix_slice: Slice[I32] = suffix.as_slice()
    assert(slice.ends_with(suffix_slice) == false)
}

// ============================================================================
// Chunks Iterator Tests
// ============================================================================

@test
func test_chunks_exact() {
    let list: List[I32] = [1, 2, 3, 4, 5, 6]
    let slice: Slice[I32] = list.as_slice()
    let mut iter: Chunks[I32] = slice.chunks(2)

    let chunk1: Maybe[Slice[I32]] = iter.next()
    assert(chunk1.is_just())
    assert_eq(chunk1.unwrap().len(), 2)

    let chunk2: Maybe[Slice[I32]] = iter.next()
    assert(chunk2.is_just())
    assert_eq(chunk2.unwrap().len(), 2)

    let chunk3: Maybe[Slice[I32]] = iter.next()
    assert(chunk3.is_just())
    assert_eq(chunk3.unwrap().len(), 2)

    let chunk4: Maybe[Slice[I32]] = iter.next()
    assert(chunk4.is_nothing())
}

@test
func test_chunks_remainder() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let mut iter: Chunks[I32] = slice.chunks(2)

    iter.next()  // [1, 2]
    iter.next()  // [3, 4]
    let last: Maybe[Slice[I32]] = iter.next()  // [5]
    assert(last.is_just())
    assert_eq(last.unwrap().len(), 1)
}

// ============================================================================
// Windows Iterator Tests
// ============================================================================

@test
func test_windows() {
    let list: List[I32] = [1, 2, 3, 4, 5]
    let slice: Slice[I32] = list.as_slice()
    let mut iter: Windows[I32] = slice.windows(3)

    let w1: Maybe[Slice[I32]] = iter.next()
    assert(w1.is_just())
    assert_eq(w1.unwrap().len(), 3)
    assert_eq(*w1.unwrap().get(0).unwrap(), 1)

    let w2: Maybe[Slice[I32]] = iter.next()
    assert(w2.is_just())
    assert_eq(*w2.unwrap().get(0).unwrap(), 2)

    let w3: Maybe[Slice[I32]] = iter.next()
    assert(w3.is_just())
    assert_eq(*w3.unwrap().get(0).unwrap(), 3)

    let w4: Maybe[Slice[I32]] = iter.next()
    assert(w4.is_nothing())
}

// ============================================================================
// Copy From Slice Tests
// ============================================================================

@test
func test_copy_from_slice() {
    let src: List[I32] = [10, 20, 30]
    let mut dst: List[I32] = [0, 0, 0]
    let src_slice: Slice[I32] = src.as_slice()
    let mut dst_slice: MutSlice[I32] = dst.as_mut_slice()
    dst_slice.copy_from_slice(src_slice)
    assert_eq(*dst_slice.get(0).unwrap(), 10)
    assert_eq(*dst_slice.get(1).unwrap(), 20)
    assert_eq(*dst_slice.get(2).unwrap(), 30)
}
