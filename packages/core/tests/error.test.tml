// Tests for core::error module

use core::error::{Error, SimpleError, ChainedError, BoxedError, ParseError, IoError, IoErrorKind, error_chain}

// ============================================================================
// SimpleError Tests
// ============================================================================

@test
func test_simple_error_new() {
    let err: SimpleError = SimpleError::new("something went wrong")
    assert_eq(err.to_string(), "something went wrong")
}

@test
func test_simple_error_debug() {
    let err: SimpleError = SimpleError::new("test error")
    let debug: Str = err.debug_string()
    assert(debug.contains("SimpleError"))
    assert(debug.contains("test error"))
}

@test
func test_simple_error_description() {
    let err: SimpleError = SimpleError::new("error message")
    assert_eq(err.description(), "error message")
}

@test
func test_simple_error_no_source() {
    let err: SimpleError = SimpleError::new("no cause")
    let source: Maybe[ref dyn Error] = err.source()
    assert(source.is_nothing())
}

// ============================================================================
// ChainedError Tests
// ============================================================================

@test
func test_chained_error_new() {
    let inner: SimpleError = SimpleError::new("inner error")
    let outer: ChainedError[SimpleError] = ChainedError::new("outer error", inner)
    assert(outer.to_string().contains("outer error"))
    assert(outer.to_string().contains("inner error"))
}

@test
func test_chained_error_cause() {
    let inner: SimpleError = SimpleError::new("the cause")
    let outer: ChainedError[SimpleError] = ChainedError::new("the effect", inner)
    let cause: ref SimpleError = outer.cause()
    assert_eq(cause.to_string(), "the cause")
}

@test
func test_chained_error_source() {
    let inner: SimpleError = SimpleError::new("source error")
    let outer: ChainedError[SimpleError] = ChainedError::new("wrapper", inner)
    let source: Maybe[ref dyn Error] = outer.source()
    assert(source.is_just())
}

@test
func test_chained_error_debug() {
    let inner: SimpleError = SimpleError::new("inner")
    let outer: ChainedError[SimpleError] = ChainedError::new("outer", inner)
    let debug: Str = outer.debug_string()
    assert(debug.contains("ChainedError"))
    assert(debug.contains("outer"))
    assert(debug.contains("inner"))
}

// ============================================================================
// ParseError Tests
// ============================================================================

@test
func test_parse_error_new() {
    let err: ParseError = ParseError::new("invalid number")
    assert(err.to_string().contains("parse error"))
    assert(err.to_string().contains("invalid number"))
}

@test
func test_parse_error_with_position() {
    let err: ParseError = ParseError::with_position("unexpected token", 42)
    let msg: Str = err.to_string()
    assert(msg.contains("position 42"))
    assert(msg.contains("unexpected token"))
}

@test
func test_parse_error_debug() {
    let err: ParseError = ParseError::with_position("error", 10)
    let debug: Str = err.debug_string()
    assert(debug.contains("ParseError"))
    assert(debug.contains("error"))
    assert(debug.contains("10"))
}

// ============================================================================
// IoErrorKind Tests
// ============================================================================

@test
func test_io_error_kind_not_found() {
    let kind: IoErrorKind = NotFound
    assert_eq(kind.to_string(), "entity not found")
    assert_eq(kind.debug_string(), "NotFound")
}

@test
func test_io_error_kind_permission_denied() {
    let kind: IoErrorKind = PermissionDenied
    assert_eq(kind.to_string(), "permission denied")
    assert_eq(kind.debug_string(), "PermissionDenied")
}

@test
func test_io_error_kind_connection_refused() {
    let kind: IoErrorKind = ConnectionRefused
    assert_eq(kind.to_string(), "connection refused")
}

@test
func test_io_error_kind_timed_out() {
    let kind: IoErrorKind = TimedOut
    assert_eq(kind.to_string(), "operation timed out")
}

@test
func test_io_error_kind_would_block() {
    let kind: IoErrorKind = WouldBlock
    assert_eq(kind.to_string(), "operation would block")
}

@test
func test_io_error_kind_invalid_input() {
    let kind: IoErrorKind = InvalidInput
    assert_eq(kind.to_string(), "invalid input parameter")
}

@test
func test_io_error_kind_unexpected_eof() {
    let kind: IoErrorKind = UnexpectedEof
    assert_eq(kind.to_string(), "unexpected end of file")
}

@test
func test_io_error_kind_other() {
    let kind: IoErrorKind = Other
    assert_eq(kind.to_string(), "other error")
}

// ============================================================================
// IoError Tests
// ============================================================================

@test
func test_io_error_new() {
    let err: IoError = IoError::new(NotFound)
    assert_eq(err.to_string(), "entity not found")
}

@test
func test_io_error_with_message() {
    let err: IoError = IoError::with_message(NotFound, "file.txt")
    let msg: Str = err.to_string()
    assert(msg.contains("entity not found"))
    assert(msg.contains("file.txt"))
}

@test
func test_io_error_kind() {
    let err: IoError = IoError::new(PermissionDenied)
    when err.kind() {
        PermissionDenied => assert(true),
        _ => assert(false)
    }
}

@test
func test_io_error_debug() {
    let err: IoError = IoError::with_message(TimedOut, "connection to server")
    let debug: Str = err.debug_string()
    assert(debug.contains("IoError"))
    assert(debug.contains("TimedOut"))
}

// ============================================================================
// BoxedError Tests
// ============================================================================

@test
func test_boxed_error_from_simple() {
    let simple: SimpleError = SimpleError::new("boxed error")
    let boxed: BoxedError = BoxedError::new(simple)
    assert_eq(boxed.to_string(), "boxed error")
}

@test
func test_boxed_error_from_io() {
    let io_err: IoError = IoError::new(NotFound)
    let boxed: BoxedError = BoxedError::new(io_err)
    assert(boxed.to_string().contains("not found"))
}

@test
func test_boxed_error_debug() {
    let simple: SimpleError = SimpleError::new("inner")
    let boxed: BoxedError = BoxedError::new(simple)
    let debug: Str = boxed.debug_string()
    assert(debug.contains("inner"))
}

// ============================================================================
// Error Extension Methods Tests
// ============================================================================

@test
func test_context_ok() {
    let result: Outcome[I32, SimpleError] = Ok(42)
    let with_context: Outcome[I32, ChainedError[SimpleError]] = result.context("while doing something")
    assert(with_context.is_ok())
    assert_eq(with_context.unwrap(), 42)
}

@test
func test_context_err() {
    let err: SimpleError = SimpleError::new("original error")
    let result: Outcome[I32, SimpleError] = Err(err)
    let with_context: Outcome[I32, ChainedError[SimpleError]] = result.context("while processing")
    assert(with_context.is_err())
    let chained: ChainedError[SimpleError] = with_context.unwrap_err()
    assert(chained.to_string().contains("while processing"))
    assert(chained.to_string().contains("original error"))
}

@test
func test_with_context_ok() {
    let result: Outcome[I32, SimpleError] = Ok(100)
    let with_context: Outcome[I32, ChainedError[SimpleError]] = result.with_context(do() "lazy context")
    assert(with_context.is_ok())
}

@test
func test_with_context_err() {
    let err: SimpleError = SimpleError::new("base error")
    let result: Outcome[I32, SimpleError] = Err(err)
    let with_context: Outcome[I32, ChainedError[SimpleError]] = result.with_context(do() "computed context")
    assert(with_context.is_err())
    let msg: Str = with_context.unwrap_err().to_string()
    assert(msg.contains("computed context"))
}

// ============================================================================
// Error Chain Tests
// ============================================================================

@test
func test_error_chain_single() {
    let err: SimpleError = SimpleError::new("only error")
    let mut chain = error_chain(ref err)

    let first: Maybe[ref dyn Error] = chain.next()
    assert(first.is_just())

    let second: Maybe[ref dyn Error] = chain.next()
    assert(second.is_nothing())
}

@test
func test_error_chain_multiple() {
    let inner: SimpleError = SimpleError::new("root cause")
    let outer: ChainedError[SimpleError] = ChainedError::new("wrapper", inner)
    let mut chain = error_chain(ref outer)

    let first: Maybe[ref dyn Error] = chain.next()
    assert(first.is_just())  // outer

    let second: Maybe[ref dyn Error] = chain.next()
    assert(second.is_just())  // inner

    let third: Maybe[ref dyn Error] = chain.next()
    assert(third.is_nothing())  // end
}

// ============================================================================
// Error Display Format Tests
// ============================================================================

@test
func test_error_messages_human_readable() {
    // Simple error
    let simple: SimpleError = SimpleError::new("file not found")
    assert_eq(simple.to_string(), "file not found")

    // Parse error without position
    let parse1: ParseError = ParseError::new("invalid syntax")
    assert(parse1.to_string().contains("parse error"))

    // Parse error with position
    let parse2: ParseError = ParseError::with_position("missing semicolon", 25)
    assert(parse2.to_string().contains("position 25"))

    // IO error
    let io: IoError = IoError::with_message(ConnectionRefused, "localhost:8080")
    assert(io.to_string().contains("connection refused"))
    assert(io.to_string().contains("localhost:8080"))
}

// ============================================================================
// Complex Error Scenarios
// ============================================================================

@test
func test_nested_error_context() {
    // Simulate: io_error -> parse_error -> app_error
    let io_err: IoError = IoError::new(UnexpectedEof)
    let parse_err: ChainedError[IoError] = ChainedError::new("failed to parse config", io_err)
    let app_err: ChainedError[ChainedError[IoError]] = ChainedError::new("application startup failed", parse_err)

    let msg: Str = app_err.to_string()
    assert(msg.contains("application startup failed"))
    assert(msg.contains("failed to parse config"))
}

@test
func test_error_in_result_chain() {
    func step1() -> Outcome[I32, SimpleError] {
        return Ok(10)
    }

    func step2(x: I32) -> Outcome[I32, SimpleError] {
        if x > 5 {
            return Err(SimpleError::new("value too large"))
        }
        return Ok(x * 2)
    }

    let result: Outcome[I32, ChainedError[SimpleError]] = step1()
        .and_then(do(x: I32) step2(x))
        .context("during processing")

    assert(result.is_err())
    assert(result.unwrap_err().to_string().contains("value too large"))
}
