// Tests for core::option module (Maybe[T] enhancements)

use core::option::{MaybeIter}

// ============================================================================
// Core Methods Tests
// ============================================================================

@test
func test_is_just_true() {
    let m: Maybe[I32] = Just(42)
    assert(m.is_just())
}

@test
func test_is_just_false() {
    let m: Maybe[I32] = Nothing
    assert(not m.is_just())
}

@test
func test_is_nothing_true() {
    let m: Maybe[I32] = Nothing
    assert(m.is_nothing())
}

@test
func test_is_nothing_false() {
    let m: Maybe[I32] = Just(42)
    assert(not m.is_nothing())
}

@test
func test_contains_true() {
    let m: Maybe[I32] = Just(42)
    assert(m.contains(ref 42))
}

@test
func test_contains_false_different_value() {
    let m: Maybe[I32] = Just(42)
    assert(not m.contains(ref 100))
}

@test
func test_contains_false_nothing() {
    let m: Maybe[I32] = Nothing
    assert(not m.contains(ref 42))
}

// ============================================================================
// Extracting Values Tests
// ============================================================================

@test
func test_unwrap_just() {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap(), 42)
}

@test
func test_expect_just() {
    let m: Maybe[I32] = Just(100)
    assert_eq(m.expect("should have value"), 100)
}

@test
func test_unwrap_or_just() {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap_or(0), 42)
}

@test
func test_unwrap_or_nothing() {
    let m: Maybe[I32] = Nothing
    assert_eq(m.unwrap_or(99), 99)
}

@test
func test_unwrap_or_else_just() {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap_or_else(do() 99), 42)
}

@test
func test_unwrap_or_else_nothing() {
    let m: Maybe[I32] = Nothing
    assert_eq(m.unwrap_or_else(do() 99), 99)
}

@test
func test_unwrap_or_default_just() {
    let m: Maybe[I32] = Just(42)
    assert_eq(m.unwrap_or_default(), 42)
}

@test
func test_unwrap_or_default_nothing() {
    let m: Maybe[I32] = Nothing
    assert_eq(m.unwrap_or_default(), 0)  // Default for I32
}

// ============================================================================
// Transforming Values Tests
// ============================================================================

@test
func test_map_just() {
    let m: Maybe[I32] = Just(10)
    let result: Maybe[I32] = m.map(do(x: I32) x * 2)
    assert(result.is_just())
    assert_eq(result.unwrap(), 20)
}

@test
func test_map_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Maybe[I32] = m.map(do(x: I32) x * 2)
    assert(result.is_nothing())
}

@test
func test_map_type_change() {
    let m: Maybe[I32] = Just(42)
    let result: Maybe[Str] = m.map(do(x: I32) x.to_string())
    assert(result.is_just())
    assert_eq(result.unwrap(), "42")
}

@test
func test_map_or_just() {
    let m: Maybe[I32] = Just(10)
    let result: I32 = m.map_or(0, do(x: I32) x * 2)
    assert_eq(result, 20)
}

@test
func test_map_or_nothing() {
    let m: Maybe[I32] = Nothing
    let result: I32 = m.map_or(99, do(x: I32) x * 2)
    assert_eq(result, 99)
}

@test
func test_map_or_else_just() {
    let m: Maybe[I32] = Just(10)
    let result: I32 = m.map_or_else(do() 0, do(x: I32) x * 2)
    assert_eq(result, 20)
}

@test
func test_map_or_else_nothing() {
    let m: Maybe[I32] = Nothing
    let result: I32 = m.map_or_else(do() 99, do(x: I32) x * 2)
    assert_eq(result, 99)
}

// ============================================================================
// Chaining Operations Tests
// ============================================================================

@test
func test_and_then_just_to_just() {
    let m: Maybe[I32] = Just(10)
    let result: Maybe[I32] = m.and_then(do(x: I32) Just(x * 2))
    assert(result.is_just())
    assert_eq(result.unwrap(), 20)
}

@test
func test_and_then_just_to_nothing() {
    let m: Maybe[I32] = Just(10)
    let result: Maybe[I32] = m.and_then(do(x: I32) Nothing)
    assert(result.is_nothing())
}

@test
func test_and_then_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Maybe[I32] = m.and_then(do(x: I32) Just(x * 2))
    assert(result.is_nothing())
}

@test
func test_or_just() {
    let m: Maybe[I32] = Just(42)
    let result: Maybe[I32] = m.or(Just(99))
    assert_eq(result.unwrap(), 42)
}

@test
func test_or_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Maybe[I32] = m.or(Just(99))
    assert_eq(result.unwrap(), 99)
}

@test
func test_or_else_just() {
    let m: Maybe[I32] = Just(42)
    let result: Maybe[I32] = m.or_else(do() Just(99))
    assert_eq(result.unwrap(), 42)
}

@test
func test_or_else_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Maybe[I32] = m.or_else(do() Just(99))
    assert_eq(result.unwrap(), 99)
}

@test
func test_xor_just_nothing() {
    let a: Maybe[I32] = Just(42)
    let b: Maybe[I32] = Nothing
    let result: Maybe[I32] = a.xor(b)
    assert_eq(result.unwrap(), 42)
}

@test
func test_xor_nothing_just() {
    let a: Maybe[I32] = Nothing
    let b: Maybe[I32] = Just(99)
    let result: Maybe[I32] = a.xor(b)
    assert_eq(result.unwrap(), 99)
}

@test
func test_xor_both_just() {
    let a: Maybe[I32] = Just(42)
    let b: Maybe[I32] = Just(99)
    let result: Maybe[I32] = a.xor(b)
    assert(result.is_nothing())
}

@test
func test_xor_both_nothing() {
    let a: Maybe[I32] = Nothing
    let b: Maybe[I32] = Nothing
    let result: Maybe[I32] = a.xor(b)
    assert(result.is_nothing())
}

@test
func test_and_just_just() {
    let a: Maybe[I32] = Just(1)
    let b: Maybe[Str] = Just("hello")
    let result: Maybe[Str] = a.and(b)
    assert_eq(result.unwrap(), "hello")
}

@test
func test_and_nothing_just() {
    let a: Maybe[I32] = Nothing
    let b: Maybe[Str] = Just("hello")
    let result: Maybe[Str] = a.and(b)
    assert(result.is_nothing())
}

// ============================================================================
// Filtering Tests
// ============================================================================

@test
func test_filter_passes() {
    let m: Maybe[I32] = Just(10)
    let result: Maybe[I32] = m.filter(do(x: ref I32) *x > 5)
    assert(result.is_just())
    assert_eq(result.unwrap(), 10)
}

@test
func test_filter_fails() {
    let m: Maybe[I32] = Just(3)
    let result: Maybe[I32] = m.filter(do(x: ref I32) *x > 5)
    assert(result.is_nothing())
}

@test
func test_filter_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Maybe[I32] = m.filter(do(x: ref I32) *x > 5)
    assert(result.is_nothing())
}

// ============================================================================
// Converting to Other Types Tests
// ============================================================================

@test
func test_ok_or_just() {
    let m: Maybe[I32] = Just(42)
    let result: Outcome[I32, Str] = m.ok_or("error")
    assert(result.is_ok())
    assert_eq(result.unwrap(), 42)
}

@test
func test_ok_or_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Outcome[I32, Str] = m.ok_or("error")
    assert(result.is_err())
    assert_eq(result.unwrap_err(), "error")
}

@test
func test_ok_or_else_just() {
    let m: Maybe[I32] = Just(42)
    let result: Outcome[I32, Str] = m.ok_or_else(do() "error")
    assert(result.is_ok())
    assert_eq(result.unwrap(), 42)
}

@test
func test_ok_or_else_nothing() {
    let m: Maybe[I32] = Nothing
    let result: Outcome[I32, Str] = m.ok_or_else(do() "computed error")
    assert(result.is_err())
    assert_eq(result.unwrap_err(), "computed error")
}

// ============================================================================
// Zipping Tests
// ============================================================================

@test
func test_zip_both_just() {
    let a: Maybe[I32] = Just(1)
    let b: Maybe[Str] = Just("hello")
    let result: Maybe[(I32, Str)] = a.zip(b)
    assert(result.is_just())
    let (n, s) = result.unwrap()
    assert_eq(n, 1)
    assert_eq(s, "hello")
}

@test
func test_zip_first_nothing() {
    let a: Maybe[I32] = Nothing
    let b: Maybe[Str] = Just("hello")
    let result: Maybe[(I32, Str)] = a.zip(b)
    assert(result.is_nothing())
}

@test
func test_zip_second_nothing() {
    let a: Maybe[I32] = Just(1)
    let b: Maybe[Str] = Nothing
    let result: Maybe[(I32, Str)] = a.zip(b)
    assert(result.is_nothing())
}

@test
func test_zip_with_both_just() {
    let a: Maybe[I32] = Just(10)
    let b: Maybe[I32] = Just(20)
    let result: Maybe[I32] = a.zip_with(b, do(x: I32, y: I32) x + y)
    assert_eq(result.unwrap(), 30)
}

@test
func test_zip_with_one_nothing() {
    let a: Maybe[I32] = Just(10)
    let b: Maybe[I32] = Nothing
    let result: Maybe[I32] = a.zip_with(b, do(x: I32, y: I32) x + y)
    assert(result.is_nothing())
}

// ============================================================================
// Flattening Tests
// ============================================================================

@test
func test_flatten_just_just() {
    let m: Maybe[Maybe[I32]] = Just(Just(42))
    let result: Maybe[I32] = m.flatten()
    assert_eq(result.unwrap(), 42)
}

@test
func test_flatten_just_nothing() {
    let m: Maybe[Maybe[I32]] = Just(Nothing)
    let result: Maybe[I32] = m.flatten()
    assert(result.is_nothing())
}

@test
func test_flatten_nothing() {
    let m: Maybe[Maybe[I32]] = Nothing
    let result: Maybe[I32] = m.flatten()
    assert(result.is_nothing())
}

// ============================================================================
// Iterator Tests
// ============================================================================

@test
func test_iter_just() {
    let m: Maybe[I32] = Just(42)
    let mut iter: MaybeIter[I32] = m.iter()
    let first: Maybe[I32] = iter.next()
    assert(first.is_just())
    assert_eq(first.unwrap(), 42)
    let second: Maybe[I32] = iter.next()
    assert(second.is_nothing())
}

@test
func test_iter_nothing() {
    let m: Maybe[I32] = Nothing
    let mut iter: MaybeIter[I32] = m.iter()
    let first: Maybe[I32] = iter.next()
    assert(first.is_nothing())
}

// ============================================================================
// Chained Operations Tests
// ============================================================================

@test
func test_chained_map_filter() {
    let m: Maybe[I32] = Just(5)
    let result: Maybe[I32] = m
        .map(do(x: I32) x * 2)
        .filter(do(x: ref I32) *x > 5)
    assert(result.is_just())
    assert_eq(result.unwrap(), 10)
}

@test
func test_chained_and_then_or() {
    let m: Maybe[I32] = Just(0)
    let result: Maybe[I32] = m
        .and_then(do(x: I32) if x > 0 then Just(x) else Nothing)
        .or(Just(99))
    assert_eq(result.unwrap(), 99)
}

@test
func test_complex_chain() {
    let m: Maybe[I32] = Just(10)
    let result: I32 = m
        .map(do(x: I32) x * 2)       // 20
        .filter(do(x: ref I32) *x > 15)  // Just(20)
        .map(do(x: I32) x + 5)       // Just(25)
        .unwrap_or(0)
    assert_eq(result, 25)
}

@test
func test_complex_chain_fails_filter() {
    let m: Maybe[I32] = Just(5)
    let result: I32 = m
        .map(do(x: I32) x * 2)       // 10
        .filter(do(x: ref I32) *x > 15)  // Nothing (10 <= 15)
        .map(do(x: I32) x + 5)       // Nothing
        .unwrap_or(99)
    assert_eq(result, 99)
}
