// Tests for core::str module

use core::str::{len, is_empty, char_at, trim, trim_start, trim_end, starts_with, ends_with, contains, to_uppercase, to_lowercase, split, lines, chars, find, rfind, replace, replace_first, repeat, concat, join, substring, char_count}

// ============================================================================
// Basic String Properties
// ============================================================================

@test
func test_len_empty() {
    assert_eq(len(""), 0)
}

@test
func test_len_simple() {
    assert_eq(len("hello"), 5)
}

@test
func test_len_with_spaces() {
    assert_eq(len("hello world"), 11)
}

@test
func test_is_empty_true() {
    assert(is_empty(""))
}

@test
func test_is_empty_false() {
    assert(not is_empty("a"))
}

@test
func test_char_at_first() {
    let c: Maybe[Str] = char_at("hello", 0)
    assert(c.is_just())
    assert_eq(c.unwrap(), "h")
}

@test
func test_char_at_last() {
    let c: Maybe[Str] = char_at("hello", 4)
    assert(c.is_just())
    assert_eq(c.unwrap(), "o")
}

@test
func test_char_at_out_of_bounds() {
    let c: Maybe[Str] = char_at("hello", 10)
    assert(c.is_nothing())
}

@test
func test_char_at_negative() {
    let c: Maybe[Str] = char_at("hello", -1)
    assert(c.is_nothing())
}

// ============================================================================
// Trimming Tests
// ============================================================================

@test
func test_trim_both_sides() {
    assert_eq(trim("  hello  "), "hello")
}

@test
func test_trim_only_leading() {
    assert_eq(trim("  hello"), "hello")
}

@test
func test_trim_only_trailing() {
    assert_eq(trim("hello  "), "hello")
}

@test
func test_trim_no_whitespace() {
    assert_eq(trim("hello"), "hello")
}

@test
func test_trim_all_whitespace() {
    assert_eq(trim("   "), "")
}

@test
func test_trim_start() {
    assert_eq(trim_start("  hello"), "hello")
}

@test
func test_trim_start_no_leading() {
    assert_eq(trim_start("hello  "), "hello  ")
}

@test
func test_trim_end() {
    assert_eq(trim_end("hello  "), "hello")
}

@test
func test_trim_end_no_trailing() {
    assert_eq(trim_end("  hello"), "  hello")
}

// ============================================================================
// Prefix/Suffix Tests
// ============================================================================

@test
func test_starts_with_true() {
    assert(starts_with("hello world", "hello"))
}

@test
func test_starts_with_false() {
    assert(not starts_with("hello world", "world"))
}

@test
func test_starts_with_empty_prefix() {
    assert(starts_with("hello", ""))
}

@test
func test_starts_with_same_string() {
    assert(starts_with("hello", "hello"))
}

@test
func test_starts_with_longer_prefix() {
    assert(not starts_with("hi", "hello"))
}

@test
func test_ends_with_true() {
    assert(ends_with("hello world", "world"))
}

@test
func test_ends_with_false() {
    assert(not ends_with("hello world", "hello"))
}

@test
func test_ends_with_empty_suffix() {
    assert(ends_with("hello", ""))
}

@test
func test_ends_with_same_string() {
    assert(ends_with("hello", "hello"))
}

// ============================================================================
// Contains Tests
// ============================================================================

@test
func test_contains_true() {
    assert(contains("hello world", "lo wo"))
}

@test
func test_contains_at_start() {
    assert(contains("hello world", "hello"))
}

@test
func test_contains_at_end() {
    assert(contains("hello world", "world"))
}

@test
func test_contains_false() {
    assert(not contains("hello world", "xyz"))
}

@test
func test_contains_empty_substring() {
    assert(contains("hello", ""))
}

// ============================================================================
// Case Conversion Tests
// ============================================================================

@test
func test_to_uppercase() {
    assert_eq(to_uppercase("hello"), "HELLO")
}

@test
func test_to_uppercase_mixed() {
    assert_eq(to_uppercase("Hello World"), "HELLO WORLD")
}

@test
func test_to_uppercase_already_upper() {
    assert_eq(to_uppercase("HELLO"), "HELLO")
}

@test
func test_to_lowercase() {
    assert_eq(to_lowercase("HELLO"), "hello")
}

@test
func test_to_lowercase_mixed() {
    assert_eq(to_lowercase("Hello World"), "hello world")
}

@test
func test_to_lowercase_already_lower() {
    assert_eq(to_lowercase("hello"), "hello")
}

// ============================================================================
// Find Tests
// ============================================================================

@test
func test_find_exists() {
    let pos: Maybe[I64] = find("hello world", "world")
    assert(pos.is_just())
    assert_eq(pos.unwrap(), 6)
}

@test
func test_find_at_start() {
    let pos: Maybe[I64] = find("hello", "hel")
    assert(pos.is_just())
    assert_eq(pos.unwrap(), 0)
}

@test
func test_find_not_exists() {
    let pos: Maybe[I64] = find("hello", "xyz")
    assert(pos.is_nothing())
}

@test
func test_rfind_exists() {
    let pos: Maybe[I64] = rfind("hello hello", "hello")
    assert(pos.is_just())
    assert_eq(pos.unwrap(), 6)  // Last occurrence
}

@test
func test_rfind_single() {
    let pos: Maybe[I64] = rfind("hello world", "world")
    assert(pos.is_just())
    assert_eq(pos.unwrap(), 6)
}

@test
func test_rfind_not_exists() {
    let pos: Maybe[I64] = rfind("hello", "xyz")
    assert(pos.is_nothing())
}

// ============================================================================
// Replace Tests
// ============================================================================

@test
func test_replace_all() {
    assert_eq(replace("hello hello", "hello", "hi"), "hi hi")
}

@test
func test_replace_single() {
    assert_eq(replace("hello world", "world", "universe"), "hello universe")
}

@test
func test_replace_not_found() {
    assert_eq(replace("hello", "xyz", "abc"), "hello")
}

@test
func test_replace_empty_from() {
    // Replacing empty string behavior
    assert_eq(replace("hello", "", "x"), "hello")
}

@test
func test_replace_first_only() {
    assert_eq(replace_first("hello hello", "hello", "hi"), "hi hello")
}

@test
func test_replace_first_not_found() {
    assert_eq(replace_first("hello", "xyz", "abc"), "hello")
}

// ============================================================================
// Repeat Tests
// ============================================================================

@test
func test_repeat_zero() {
    assert_eq(repeat("hello", 0), "")
}

@test
func test_repeat_one() {
    assert_eq(repeat("hello", 1), "hello")
}

@test
func test_repeat_three() {
    assert_eq(repeat("ab", 3), "ababab")
}

@test
func test_repeat_empty_string() {
    assert_eq(repeat("", 5), "")
}

// ============================================================================
// Concat and Join Tests
// ============================================================================

@test
func test_concat_two() {
    assert_eq(concat("hello", " world"), "hello world")
}

@test
func test_concat_empty() {
    assert_eq(concat("hello", ""), "hello")
    assert_eq(concat("", "world"), "world")
}

@test
func test_join_simple() {
    let parts: List[Str] = ["a", "b", "c"]
    assert_eq(join(parts, ","), "a,b,c")
}

@test
func test_join_empty_separator() {
    let parts: List[Str] = ["a", "b", "c"]
    assert_eq(join(parts, ""), "abc")
}

@test
func test_join_single_element() {
    let parts: List[Str] = ["only"]
    assert_eq(join(parts, ","), "only")
}

@test
func test_join_empty_list() {
    let parts: List[Str] = []
    assert_eq(join(parts, ","), "")
}

// ============================================================================
// Substring Tests
// ============================================================================

@test
func test_substring_simple() {
    assert_eq(substring("hello world", 0, 5), "hello")
}

@test
func test_substring_middle() {
    assert_eq(substring("hello world", 6, 11), "world")
}

@test
func test_substring_to_end() {
    assert_eq(substring("hello", 2, 5), "llo")
}

@test
func test_substring_empty() {
    assert_eq(substring("hello", 2, 2), "")
}

@test
func test_substring_out_of_bounds() {
    // Should handle gracefully
    assert_eq(substring("hello", 0, 100), "hello")
}

// ============================================================================
// Split and Lines Tests
// ============================================================================

@test
func test_split_simple() {
    let parts: List[Str] = split("a,b,c", ",")
    assert_eq(parts.len(), 3)
    assert_eq(parts.get(0).unwrap(), "a")
    assert_eq(parts.get(1).unwrap(), "b")
    assert_eq(parts.get(2).unwrap(), "c")
}

@test
func test_split_no_delimiter() {
    let parts: List[Str] = split("hello", ",")
    assert_eq(parts.len(), 1)
    assert_eq(parts.get(0).unwrap(), "hello")
}

@test
func test_split_empty_string() {
    let parts: List[Str] = split("", ",")
    assert_eq(parts.len(), 1)
    assert_eq(parts.get(0).unwrap(), "")
}

@test
func test_lines_simple() {
    let l: List[Str] = lines("line1\nline2\nline3")
    assert_eq(l.len(), 3)
    assert_eq(l.get(0).unwrap(), "line1")
    assert_eq(l.get(1).unwrap(), "line2")
    assert_eq(l.get(2).unwrap(), "line3")
}

@test
func test_lines_single() {
    let l: List[Str] = lines("single line")
    assert_eq(l.len(), 1)
    assert_eq(l.get(0).unwrap(), "single line")
}

// ============================================================================
// Chars Iterator Tests
// ============================================================================

@test
func test_chars_simple() {
    let c: List[Str] = chars("abc")
    assert_eq(c.len(), 3)
    assert_eq(c.get(0).unwrap(), "a")
    assert_eq(c.get(1).unwrap(), "b")
    assert_eq(c.get(2).unwrap(), "c")
}

@test
func test_chars_empty() {
    let c: List[Str] = chars("")
    assert_eq(c.len(), 0)
}

@test
func test_char_count() {
    assert_eq(char_count("hello"), 5)
}

@test
func test_char_count_empty() {
    assert_eq(char_count(""), 0)
}
