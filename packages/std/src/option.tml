// Option/Maybe type for optional values

/// Type representing an optional value
pub type Maybe[T] {
    Just(T),
    Nothing,
}

impl[T] Maybe[T] {
    /// Returns true if the option is Just
    pub func is_some(this) -> Bool {
        when this {
            Just(_) => true,
            Nothing => false,
        }
    }

    /// Returns true if the option is Nothing
    pub func is_none(this) -> Bool {
        when this {
            Just(_) => false,
            Nothing => true,
        }
    }

    /// Unwraps the value, panicking if Nothing
    pub func unwrap(this) -> T {
        when this {
            Just(value) => value,
            Nothing => panic("called unwrap on Nothing"),
        }
    }

    /// Unwraps the value or returns a default
    pub func unwrap_or(this, default: T) -> T {
        when this {
            Just(value) => value,
            Nothing => default,
        }
    }

    /// Unwraps the value or computes it from a closure
    pub func unwrap_or_else[F](this, f: F) -> T where F: Fn() -> T {
        when this {
            Just(value) => value,
            Nothing => f(),
        }
    }

    /// Maps Maybe[T] to Maybe[U] by applying a function
    pub func map[U, F](this, f: F) -> Maybe[U] where F: Fn(T) -> U {
        when this {
            Just(value) => Just(f(value)),
            Nothing => Nothing,
        }
    }

    /// Applies a function that returns Maybe
    pub func and_then[U, F](this, f: F) -> Maybe[U] where F: Fn(T) -> Maybe[U] {
        when this {
            Just(value) => f(value),
            Nothing => Nothing,
        }
    }

    /// Returns this if Just, otherwise returns other
    pub func or(this, other: Maybe[T]) -> Maybe[T] {
        when this {
            Just(_) => this,
            Nothing => other,
        }
    }

    /// Filters the value by predicate
    pub func filter[F](this, predicate: F) -> Maybe[T] where F: Fn(T) -> Bool {
        when this {
            Just(value) => if predicate(value) then Just(value) else Nothing,
            Nothing => Nothing,
        }
    }

    /// Converts Maybe[T] to Outcome[T, E]
    pub func ok_or[E](this, err: E) -> Outcome[T, E] {
        when this {
            Just(value) => Ok(value),
            Nothing => Err(err),
        }
    }

    /// Takes the value out, leaving Nothing
    pub func take(mut this) -> Maybe[T] {
        let result: Maybe[T] = this
        this = Nothing
        result
    }
}

// Tests
@test
func test_maybe_is_some() {
    let some: Maybe[I32] = Just(42)
    let none: Maybe[I32] = Nothing

    assert!(some.is_some())
    assert!(not none.is_some())
}

@test
func test_maybe_unwrap() {
    let some: Maybe[I32] = Just(42)
    assert_eq!(some.unwrap(), 42)
}

@test
@should_panic
func test_maybe_unwrap_nothing_panics() {
    let none: Maybe[I32] = Nothing
    let _: I32 = none.unwrap()
}

@test
func test_maybe_map() {
    let some: Maybe[I32] = Just(42)
    let mapped: Maybe[I32] = some.map(do(x: I32) x * 2)
    assert_eq!(mapped.unwrap(), 84)
}
