// Hypot returns sqrt(p*p + q*q), taking care to avoid overflow

use sqrt

pub func hypot(p: F64, q: F64) -> F64 {
    // Get absolute values
    let abs_p: F64 = if p < 0.0 then -p else p
    let abs_q: F64 = if q < 0.0 then -q else q

    // Handle special cases
    if abs_p == 0.0 then return abs_q
    if abs_q == 0.0 then return abs_p

    // Scale to avoid overflow/underflow
    let max: F64 = if abs_p > abs_q then abs_p else abs_q
    let min: F64 = if abs_p > abs_q then abs_q else abs_p

    let ratio: F64 = min / max
    return max * sqrt(1.0 + ratio * ratio)
}

pub func hypot_i32(p: I32, q: I32) -> I32 {
    let abs_p: I32 = if p < 0 then -p else p
    let abs_q: I32 = if q < 0 then -q else q

    // Convert to I64 to avoid overflow
    let p64: I64 = i32_to_i64(abs_p)
    let q64: I64 = i32_to_i64(abs_q)

    let sum: I64 = p64 * p64 + q64 * q64

    // Integer square root
    if sum == 0 then return 0

    let mut guess: I64 = sum / 2
    let mut prev: I64 = 0

    loop {
        if guess == prev then break

        prev = guess
        guess = (guess + sum / guess) / 2
    }

    return i64_to_i32(guess)
}
