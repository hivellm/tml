// Exponential functions - e^x implementations

use const::{E, Ln2}
use abs
use floor

// exp(x) = e^x using Taylor series
// e^x = 1 + x + x^2/2! + x^3/3! + x^4/4! + ...
pub func exp(x: F64) -> F64 {
    if x == 0.0 then return 1.0

    // Use range reduction: e^x = e^(n*ln2) * e^(x - n*ln2)
    // where n = round(x / ln2)

    let n: I32 = f64_to_i32(x / Ln2)
    let r: F64 = x - (i32_to_f64(n) * Ln2)

    // Compute e^r using Taylor series (r is small now)
    let mut sum: F64 = 1.0
    let mut term: F64 = 1.0
    let mut i: I32 = 1

    loop {
        if i > 20 then break

        term = term * r / i32_to_f64(i)
        sum = sum + term

        let abs_term: F64 = abs(term)
        if abs_term < 0.00000001 then break

        i = i + 1
    }

    // Multiply by 2^n
    let mut result: F64 = sum
    let mut power: I32 = n

    if power > 0 then {
        let mut k: I32 = 0
        loop {
            if k >= power then break
            result = result * 2.0
            k = k + 1
        }
    } else {
        if power < 0 then {
            let mut k: I32 = 0
            loop {
                if k >= -power then break
                result = result / 2.0
                k = k + 1
            }
        }
    }

    return result
}

// exp2(x) = 2^x
pub func exp2(x: F64) -> F64 {
    // 2^x = e^(x * ln(2))
    exp(x * Ln2)
}

// expm1(x) = e^x - 1 (accurate for small x)
pub func expm1(x: F64) -> F64 {
    if x == 0.0 then return 0.0

    // For small x, use Taylor series directly for e^x - 1
    // e^x - 1 = x + x^2/2! + x^3/3! + ...
    let abs_x: F64 = abs(x)

    if abs_x < 0.1 then {
        let mut sum: F64 = x
        let mut term: F64 = x
        let mut i: I32 = 2

        loop {
            if i > 20 then break

            term = term * x / i32_to_f64(i)
            sum = sum + term

            let abs_term: F64 = abs(term)
            if abs_term < 0.00000001 then break

            i = i + 1
        }

        return sum
    } else {
        return exp(x) - 1.0
    }
}
