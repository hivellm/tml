// Bessel functions (simplified implementations)

use abs
use cos
use sin
use sqrt
use const::Pi

// Bessel function of the first kind, order 0
// Uses series expansion for small x, asymptotic for large x
pub func j0(x: F64) -> F64 {
    let abs_x: F64 = abs(x)

    if abs_x < 8.0 then {
        // Series expansion
        let y: F64 = x * x

        let ans1: F64 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7
            + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))))

        let ans2: F64 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718
            + y * (59272.64853 + y * (267.8532712 + y * 1.0))))

        return ans1 / ans2
    } else {
        // Asymptotic form
        let z: F64 = 8.0 / abs_x
        let y: F64 = z * z
        let xx: F64 = abs_x - 0.785398164

        let ans1: F64 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4
            + y * (-0.2073370639e-5 + y * 0.2093887211e-6)))

        let ans2: F64 = -0.1562499995e-1 + y * (0.1430488765e-3
            + y * (-0.6911147651e-5 + y * (0.7621095161e-6
            + y * (-0.934945152e-7))))

        return sqrt(0.636619772 / abs_x) * (cos(xx) * ans1 - z * sin(xx) * ans2)
    }
}

// Bessel function of the first kind, order 1
pub func j1(x: F64) -> F64 {
    let abs_x: F64 = abs(x)

    if abs_x < 8.0 then {
        let y: F64 = x * x

        let ans1: F64 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1
            + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))))

        let ans2: F64 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74
            + y * (99447.43394 + y * (376.9991397 + y * 1.0))))

        return ans1 / ans2
    } else {
        let z: F64 = 8.0 / abs_x
        let y: F64 = z * z
        let xx: F64 = abs_x - 2.356194491

        let ans1: F64 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4
            + y * (0.2457520174e-5 + y * (-0.240337019e-6))))

        let ans2: F64 = 0.04687499995 + y * (-0.2002690873e-3
            + y * (0.8449199096e-5 + y * (-0.88228987e-6
            + y * 0.105787412e-6)))

        let result: F64 = sqrt(0.636619772 / abs_x) * (cos(xx) * ans1 - z * sin(xx) * ans2)

        return if x < 0.0 then -result else result
    }
}

// Bessel function of the first kind, order n
pub func jn(n: I32, x: F64) -> F64 {
    if n == 0 then return j0(x)
    if n == 1 then return j1(x)

    if x == 0.0 then return 0.0

    // Use recurrence relation: J_{n+1}(x) = (2n/x)J_n(x) - J_{n-1}(x)
    let abs_n: I32 = if n < 0 then -n else n

    let mut jnm1: F64 = j1(x)
    let mut jn_val: F64 = j0(x)

    let mut i: I32 = 1
    loop {
        if i >= abs_n then break

        let jnp1: F64 = (2.0 * i32_to_f64(i) / x) * jnm1 - jn_val
        jn_val = jnm1
        jnm1 = jnp1

        i = i + 1
    }

    return jnm1
}

// Bessel function of the second kind, order 0
pub func y0(x: F64) -> F64 {
    if x < 8.0 then {
        let j0_val: F64 = j0(x)
        let y: F64 = x * x

        let ans1: F64 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6
            + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))))

        let ans2: F64 = 40076544269.0 + y * (745249964.8 + y * (7189466.438
            + y * (47447.26470 + y * (226.1030244 + y * 1.0))))

        return ans1 / ans2 + 0.636619772 * j0_val * log(x)
    } else {
        let z: F64 = 8.0 / x
        let y: F64 = z * z
        let xx: F64 = x - 0.785398164

        let ans1: F64 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4
            + y * (-0.2073370639e-5 + y * 0.2093887211e-6)))

        let ans2: F64 = -0.1562499995e-1 + y * (0.1430488765e-3
            + y * (-0.6911147651e-5 + y * (0.7621095161e-6
            - y * 0.934945152e-7)))

        return sqrt(0.636619772 / x) * (sin(xx) * ans1 + z * cos(xx) * ans2)
    }
}

// Bessel function of the second kind, order 1
pub func y1(x: F64) -> F64 {
    if x < 8.0 then {
        let j1_val: F64 = j1(x)
        let y: F64 = x * x

        let ans1: F64 = x * (-0.4900604943e13 + y * (0.1275274390e13
            + y * (-0.5153438139e11 + y * (0.7349264551e9
            + y * (-0.4237922726e7 + y * 0.8511937935e4)))))

        let ans2: F64 = 0.2499580570e14 + y * (0.4244419664e12
            + y * (0.3733650367e10 + y * (0.2245904002e8
            + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))))

        return ans1 / ans2 + 0.636619772 * (j1_val * log(x) - 1.0 / x)
    } else {
        let z: F64 = 8.0 / x
        let y: F64 = z * z
        let xx: F64 = x - 2.356194491

        let ans1: F64 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4
            + y * (0.2457520174e-5 + y * (-0.240337019e-6))))

        let ans2: F64 = 0.04687499995 + y * (-0.2002690873e-3
            + y * (0.8449199096e-5 + y * (-0.88228987e-6
            + y * 0.105787412e-6)))

        return sqrt(0.636619772 / x) * (sin(xx) * ans1 + z * cos(xx) * ans2)
    }
}

// Bessel function of the second kind, order n
pub func yn(n: I32, x: F64) -> F64 {
    if n == 0 then return y0(x)
    if n == 1 then return y1(x)

    // Use recurrence relation
    let mut ynm1: F64 = y1(x)
    let mut yn_val: F64 = y0(x)

    let mut i: I32 = 1
    loop {
        if i >= n then break

        let ynp1: F64 = (2.0 * i32_to_f64(i) / x) * ynm1 - yn_val
        yn_val = ynm1
        ynm1 = ynp1

        i = i + 1
    }

    return ynm1
}
