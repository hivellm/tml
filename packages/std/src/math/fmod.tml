// Floating-point modulo operations

use abs
use floor
use trunc

// mod returns the floating-point remainder of x/y
// The result has the same sign as x
// mod(x, y) = x - trunc(x/y) * y
pub func mod(x: F64, y: F64) -> F64 {
    if y == 0.0 then return 0.0  // Undefined
    if x == 0.0 then return 0.0

    let quotient: F64 = trunc(x / y)
    return x - quotient * y
}

// remainder returns the IEEE 754 floating-point remainder of x/y
// The result has the same sign as x and magnitude less than |y|/2
// remainder(x, y) = x - round(x/y) * y
pub func remainder(x: F64, y: F64) -> F64 {
    if y == 0.0 then return 0.0  // Undefined
    if x == 0.0 then return 0.0

    // Round to nearest integer (ties to even)
    let quotient: F64 = x / y
    let rounded: I64 = f64_to_i64(quotient)
    let frac: F64 = quotient - i64_to_f64(rounded)

    // Check if we need to round to nearest even
    let mut n: I64 = rounded
    if frac == 0.5 then {
        // Round to even
        if (rounded & 1) != 0 then {
            n = rounded + 1
        }
    } else {
        if frac == -0.5 then {
            if (rounded & 1) != 0 then {
                n = rounded - 1
            }
        } else {
            if frac > 0.5 then {
                n = rounded + 1
            } else {
                if frac < -0.5 then {
                    n = rounded - 1
                }
            }
        }
    }

    return x - i64_to_f64(n) * y
}
