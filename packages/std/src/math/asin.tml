// Arcsine function

use const::Pi
use abs
use sqrt

// asin(x) using Taylor series for small x, Newton's method for larger x
// Taylor: asin(x) = x + x^3/6 + 3x^5/40 + ...
pub func asin(x: F64) -> F64 {
    if x < -1.0 then return 0.0  // Undefined
    if x > 1.0 then return 0.0   // Undefined
    if x == 0.0 then return 0.0
    if x == 1.0 then return Pi / 2.0
    if x == -1.0 then return -Pi / 2.0

    let abs_x: F64 = abs(x)

    // For small x, use Taylor series
    if abs_x < 0.5 then {
        let mut sum: F64 = x
        let mut term: F64 = x
        let mut n: I32 = 0

        loop {
            if n >= 10 then break

            let n_f: F64 = i32_to_f64(n)
            let numerator: F64 = (2.0 * n_f + 1.0) * (2.0 * n_f + 1.0)
            let denominator: F64 = (2.0 * n_f + 2.0) * (2.0 * n_f + 3.0)

            term = term * x * x * numerator / denominator
            sum = sum + term

            let abs_term: F64 = abs(term)
            if abs_term < 0.00000001 then break

            n = n + 1
        }

        return sum
    } else {
        // Use identity: asin(x) = Ï€/2 - 2*asin(sqrt((1-x)/2))
        // or asin(x) = atan2(x, sqrt(1 - x*x))
        let sqrt_val: F64 = sqrt(1.0 - x * x)

        // Simple atan2 approximation
        if sqrt_val == 0.0 then {
            if x > 0.0 then Pi / 2.0 else -Pi / 2.0
        } else {
            // Use atan(x/sqrt(1-x^2))
            let ratio: F64 = x / sqrt_val

            // Simple atan using Taylor series
            let mut sum: F64 = ratio
            let mut term: F64 = ratio
            let mut i: I32 = 1

            loop {
                if i > 20 then break

                term = term * (-ratio) * ratio
                sum = sum + term / i32_to_f64(2 * i + 1)

                let abs_term: F64 = abs(term)
                if abs_term < 0.00000001 then break

                i = i + 1
            }

            return sum
        }
    }
}
