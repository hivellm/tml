// Error functions

use const::Pi
use abs
use exp
use sqrt

// Error function using approximation
// erf(x) = 2/√π * integral(0 to x) of e^(-t^2) dt
pub func erf(x: F64) -> F64 {
    if x == 0.0 then return 0.0

    // Use Abramowitz and Stegun approximation
    let abs_x: F64 = abs(x)
    let sign: I32 = if x < 0.0 then -1 else 1

    // Constants for approximation
    let a1: F64 = 0.254829592
    let a2: F64 = -0.284496736
    let a3: F64 = 1.421413741
    let a4: F64 = -1.453152027
    let a5: F64 = 1.061405429
    let p: F64 = 0.3275911

    let t: F64 = 1.0 / (1.0 + p * abs_x)
    let t2: F64 = t * t
    let t3: F64 = t2 * t
    let t4: F64 = t3 * t
    let t5: F64 = t4 * t

    let poly: F64 = a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5

    let result: F64 = 1.0 - poly * exp(-abs_x * abs_x)

    i32_to_f64(sign) * result
}

// Complementary error function
// erfc(x) = 1 - erf(x)
pub func erfc(x: F64) -> F64 {
    1.0 - erf(x)
}

// Inverse error function using Newton's method
pub func erfinv(x: F64) -> F64 {
    if x <= -1.0 then return 0.0  // Undefined
    if x >= 1.0 then return 0.0   // Undefined
    if x == 0.0 then return 0.0

    // Initial guess using rational approximation
    let a: F64 = 0.147
    let ln_part: F64 = log(1.0 - x * x)

    let term1: F64 = 2.0 / (Pi * a) + ln_part / 2.0
    let term2: F64 = ln_part / a

    let mut guess: F64 = sqrt(sqrt(term1 * term1 - term2) - term1)

    if x < 0.0 then {
        guess = -guess
    }

    // Newton's method refinement
    let mut i: I32 = 0
    loop {
        if i >= 3 then break

        let err: F64 = erf(guess) - x
        let derivative: F64 = 2.0 / sqrt(Pi) * exp(-guess * guess)

        if derivative != 0.0 then {
            guess = guess - err / derivative
        }

        i = i + 1
    }

    return guess
}

// Inverse complementary error function
pub func erfcinv(x: F64) -> F64 {
    erfinv(1.0 - x)
}
