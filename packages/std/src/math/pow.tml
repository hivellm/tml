// Power functions

use abs
use exp::{exp}
use log::{log}
use floor::{floor}

// Integer power using fast exponentiation by squaring
pub func pow_i32(base: I32, exp: I32) -> I32 {
    if exp < 0 then return 0
    if exp == 0 then return 1
    if base == 0 then return 0
    if base == 1 then return 1

    let mut result: I32 = 1
    let mut b: I32 = base
    let mut e: I32 = exp

    // Fast exponentiation by squaring
    loop {
        if e == 0 then break

        if (e & 1) != 0 then {
            result = result * b
        }
        b = b * b
        e = e >> 1
    }

    return result
}

// F64 power - for integer exponents (fast path)
pub func powi(x: F64, n: I32) -> F64 {
    if n == 0 then return 1.0
    if x == 0.0 then return 0.0
    if x == 1.0 then return 1.0

    let negative_exp: Bool = n < 0
    let abs_n: I32 = if n < 0 then -n else n

    let mut result: F64 = 1.0
    let mut base: F64 = x
    let mut e: I32 = abs_n

    loop {
        if e == 0 then break

        if (e & 1) != 0 then {
            result = result * base
        }
        base = base * base
        e = e >> 1
    }

    return if negative_exp then 1.0 / result else result
}

// General F64 power using exp and log
// pow(x, y) = exp(y * log(x))
pub func pow(x: F64, y: F64) -> F64 {
    // Special cases
    if y == 0.0 then return 1.0
    if x == 0.0 then {
        if y > 0.0 then return 0.0
        return 0.0  // 0^negative is undefined, return 0
    }
    if x == 1.0 then return 1.0
    if y == 1.0 then return x

    // Check if y is an integer for fast path
    let y_int: I64 = f64_to_i64(y)
    let y_frac: F64 = y - i64_to_f64(y_int)

    if y_frac == 0.0 then {
        // Integer exponent - use fast path
        if y_int >= -2147483648 then {
            if y_int <= 2147483647 then {
                return powi(x, i64_to_i32(y_int))
            }
        }
    }

    // General case: x^y = exp(y * log(x))
    // Note: x must be positive for real result
    if x < 0.0 then {
        // For negative x with non-integer y, result is complex (undefined)
        // Check if y is close to an integer
        let abs_y_frac: F64 = abs(y_frac)
        if abs_y_frac < 0.0000001 then {
            // Close enough to integer, use powi
            return powi(x, i64_to_i32(y_int))
        }
        // Return 0 for undefined case
        return 0.0
    }

    return exp(y * log(x))
}

// Pow10 returns 10^n
pub func pow10(n: I32) -> F64 {
    return powi(10.0, n)
}
