// Gamma function and related

use const::{E, Pi}
use exp
use log
use sin
use abs
use floor

// Lanczos approximation coefficients
const G: F64 = 7.0

const LANCZOS_COEF_0: F64 = 0.99999999999980993
const LANCZOS_COEF_1: F64 = 676.5203681218851
const LANCZOS_COEF_2: F64 = -1259.1392167224028
const LANCZOS_COEF_3: F64 = 771.32342877765313
const LANCZOS_COEF_4: F64 = -176.61502916214059
const LANCZOS_COEF_5: F64 = 12.507343278686905
const LANCZOS_COEF_6: F64 = -0.13857109526572012
const LANCZOS_COEF_7: F64 = 9.9843695780195716e-6
const LANCZOS_COEF_8: F64 = 1.5056327351493116e-7

// Gamma function using Lanczos approximation
pub func gamma(x: F64) -> F64 {
    if x < 0.5 then {
        // Use reflection formula: Γ(1-z) * Γ(z) = π / sin(πz)
        return Pi / (sin(Pi * x) * gamma(1.0 - x))
    }

    let z: F64 = x - 1.0

    let mut sum: F64 = LANCZOS_COEF_0
    sum = sum + LANCZOS_COEF_1 / (z + 1.0)
    sum = sum + LANCZOS_COEF_2 / (z + 2.0)
    sum = sum + LANCZOS_COEF_3 / (z + 3.0)
    sum = sum + LANCZOS_COEF_4 / (z + 4.0)
    sum = sum + LANCZOS_COEF_5 / (z + 5.0)
    sum = sum + LANCZOS_COEF_6 / (z + 6.0)
    sum = sum + LANCZOS_COEF_7 / (z + 7.0)
    sum = sum + LANCZOS_COEF_8 / (z + 8.0)

    let t: F64 = z + G + 0.5
    let sqrt_2pi: F64 = 2.506628274631000502415765284811

    sqrt_2pi * pow(t, z + 0.5) * exp(-t) * sum
}

// Natural logarithm of Gamma function
pub func lgamma(x: F64) -> (F64, I32) {
    if x < 0.0 then {
        // Use reflection formula
        let abs_gamma: F64 = abs(gamma(x))
        return (log(abs_gamma), if x < 0.0 then -1 else 1)
    }

    let gamma_val: F64 = gamma(x)
    let abs_gamma: F64 = abs(gamma_val)

    (log(abs_gamma), if gamma_val < 0.0 then -1 else 1)
}

// Helper: power function for gamma (temporary until full pow is implemented)
func pow(base: F64, exp: F64) -> F64 {
    // Simple implementation: x^y = exp(y * log(x))
    if base <= 0.0 then return 0.0
    if exp == 0.0 then return 1.0

    return exp(exp * log(base))
}
