pub type Maybe[T] {
    Just(T),
    Nothing,
}

pub func is_just[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return true,
        Nothing => return false,
    }
    return false
}

pub func is_nothing[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return false,
        Nothing => return true,
    }
    return true
}

pub func unwrap[T](m: Maybe[T]) -> T {
    when m {
        Just(val) => return val,
        Nothing => panic("called unwrap() on Nothing"),
    }
    panic("unreachable")
}

pub func expect[T](m: Maybe[T], msg: Str) -> T {
    when m {
        Just(val) => return val,
        Nothing => panic(msg),
    }
    panic("unreachable")
}

pub func unwrap_or[T](m: Maybe[T], default_val: T) -> T {
    when m {
        Just(val) => return val,
        Nothing => return default_val,
    }
    return default_val
}

pub func map[T, U](m: Maybe[T], f: func(T) -> U) -> Maybe[U] {
    when m {
        Just(val) => return Just(f(val)),
        Nothing => return Nothing,
    }
    return Nothing
}

pub func and_then[T, U](m: Maybe[T], f: func(T) -> Maybe[U]) -> Maybe[U] {
    when m {
        Just(val) => return f(val),
        Nothing => return Nothing,
    }
    return Nothing
}

pub func filter[T](m: Maybe[T], predicate: func(T) -> Bool) -> Maybe[T] {
    when m {
        Just(val) => {
        if predicate(val) {
        return Just(val)
    }
        return Nothing
    },
        Nothing => return Nothing,
    }
    return Nothing
}

pub func or_else[T](m: Maybe[T], f: func() -> Maybe[T]) -> Maybe[T] {
    when m {
        Just(val) => return Just(val),
        Nothing => return f(),
    }
    return f()
}

pub func ok_or[T, E](m: Maybe[T], err: E) -> Outcome[T, E] {
    when m {
        Just(val) => return Ok(val),
        Nothing => return Err(err),
    }
    return Err(err)
}

pub func ok_or_else[T, E](m: Maybe[T], f: func() -> E) -> Outcome[T, E] {
    when m {
        Just(val) => return Ok(val),
        Nothing => return Err(f()),
    }
    return Err(f())
}

pub type Outcome[T, E] {
    Ok(T),
    Err(E),
}

pub func is_ok[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return true,
        Err(_) => return false,
    }
    return false
}

pub func is_err[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return false,
        Err(_) => return true,
    }
    return true
}

pub func unwrap_ok[T, E](o: Outcome[T, E]) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => panic("called unwrap_ok() on Err"),
    }
    panic("unreachable")
}

pub func expect_ok[T, E](o: Outcome[T, E], msg: Str) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => panic(msg),
    }
    panic("unreachable")
}

pub func unwrap_err[T, E](o: Outcome[T, E]) -> E {
    when o {
        Ok(_) => panic("called unwrap_err() on Ok"),
        Err(e) => return e,
    }
    panic("unreachable")
}

pub func expect_err[T, E](o: Outcome[T, E], msg: Str) -> E {
    when o {
        Ok(_) => panic(msg),
        Err(e) => return e,
    }
    panic("unreachable")
}

pub func unwrap_or_ok[T, E](o: Outcome[T, E], default_val: T) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => return default_val,
    }
    return default_val
}

pub func unwrap_or_err[T, E](o: Outcome[T, E], default_val: E) -> E {
    when o {
        Ok(_) => return default_val,
        Err(e) => return e,
    }
    return default_val
}

pub func map_ok[T, U, E](o: Outcome[T, E], f: func(T) -> U) -> Outcome[U, E] {
    when o {
        Ok(val) => return Ok(f(val)),
        Err(e) => return Err(e),
    }
}

pub func map_err[T, E, F](o: Outcome[T, E], f: func(E) -> F) -> Outcome[T, F] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return Err(f(e)),
    }
}

pub func and_then_ok[T, U, E](o: Outcome[T, E], f: func(T) -> Outcome[U, E]) -> Outcome[U, E] {
    when o {
        Ok(val) => return f(val),
        Err(e) => return Err(e),
    }
}

pub func or_else_ok[T, E](o: Outcome[T, E], f: func(E) -> Outcome[T, E]) -> Outcome[T, E] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return f(e),
    }
}
