// LinkedList implementation

/// Linked list node
type Node[T] {
    value: T,
    next: Maybe[Heap[Node[T]]],
}

/// Doubly linked list
pub type LinkedList[T] {
    head: Maybe[Heap[Node[T]]],
    len: I32,
}

impl[T] LinkedList[T] {
    /// Create a new empty linked list
    pub func new() -> LinkedList[T] {
        LinkedList {
            head: Nothing,
            len: 0,
        }
    }

    /// Get the length
    pub func len(this) -> I32 {
        this.len
    }

    /// Check if list is empty
    pub func is_empty(this) -> Bool {
        this.len == 0
    }

    /// Push a value to the front
    pub func push_front(mut this, value: T) {
        // TODO: Implement push front
        this.len = this.len + 1
    }

    /// Push a value to the back
    pub func push_back(mut this, value: T) {
        // TODO: Implement push back
        this.len = this.len + 1
    }

    /// Pop a value from the front
    pub func pop_front(mut this) -> Maybe[T] {
        // TODO: Implement pop front
        if this.len > 0 then {
            this.len = this.len - 1
        }
        Nothing
    }

    /// Pop a value from the back
    pub func pop_back(mut this) -> Maybe[T] {
        // TODO: Implement pop back
        if this.len > 0 then {
            this.len = this.len - 1
        }
        Nothing
    }

    /// Get the front value
    pub func front(this) -> Maybe[ref T] {
        // TODO: Implement front
        Nothing
    }

    /// Get the back value
    pub func back(this) -> Maybe[ref T] {
        // TODO: Implement back
        Nothing
    }

    /// Clear the list
    pub func clear(mut this) {
        this.head = Nothing
        this.len = 0
    }
}

@test
func test_linkedlist_new() {
    let list: LinkedList[I32] = LinkedList::new()
    assert!(list.is_empty())
    assert_eq!(list.len(), 0)
}

@test
func test_linkedlist_push_front() {
    let mut list: LinkedList[I32] = LinkedList::new()
    list.push_front(42)
    assert_eq!(list.len(), 1)
    assert!(not list.is_empty())
}
