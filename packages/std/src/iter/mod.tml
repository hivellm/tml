// TML Standard Library - Iterator Module
// Provides: Iterator behavior and Range type

// ============================================================================
// Maybe Type (until core types are available via imports)
// ============================================================================

/// Optional value type
pub type Maybe[T] {
    Just(T),
    Nothing
}

// ============================================================================
// Iterator Behavior
// ============================================================================

/// The core iteration trait. Types that implement Iterator can be used in for-in loops.
pub behavior Iterator {
    /// The type of elements being iterated
    type Item

    /// Advances the iterator and returns the next value.
    /// Returns Nothing when iteration is complete.
    func next(mut this) -> Maybe[This::Item]
}

// ============================================================================
// IntoIterator Behavior
// ============================================================================

/// Types that can be converted into an Iterator.
pub behavior IntoIterator {
    /// The type of iterator this converts into
    type Iter

    /// Converts this value into an iterator
    func into_iter(this) -> This::Iter
}

// ============================================================================
// Range Iterator
// ============================================================================

/// An iterator over a range of integers
pub type Range {
    current: I32,
    end: I32,
    step: I32,
    inclusive: Bool
}

impl Iterator for Range {
    type Item = I32

    pub func next(mut this) -> Maybe[I32] {
        if this.inclusive {
            if this.current <= this.end {
                let value: I32 = this.current
                this.current = this.current + this.step
                return Just(value)
            } else {
                return Nothing
            }
        } else {
            if this.current < this.end {
                let value: I32 = this.current
                this.current = this.current + this.step
                return Just(value)
            } else {
                return Nothing
            }
        }
    }
}

/// Creates a range from start to end (exclusive)
pub func range(start: I32, end: I32) -> Range {
    return Range { current: start, end: end, step: 1, inclusive: false }
}

/// Creates a range from start through end (inclusive)
pub func range_inclusive(start: I32, end: I32) -> Range {
    return Range { current: start, end: end, step: 1, inclusive: true }
}

/// Creates a range with custom step
pub func range_step(start: I32, end: I32, step: I32) -> Range {
    return Range { current: start, end: end, step: step, inclusive: false }
}

// ============================================================================
// Simple Range Helpers (don't call other methods)
// ============================================================================

impl Range {
    /// Takes the first n elements from the iterator.
    /// Returns a new Range limited to n elements.
    pub func take(this, n: I32) -> Range {
        let actual_end: I32 = this.current + (n * this.step)
        let capped_end: I32 = if actual_end < this.end then actual_end else this.end
        return Range {
            current: this.current,
            end: capped_end,
            step: this.step,
            inclusive: false
        }
    }

    /// Skips the first n elements from the iterator.
    /// Returns a new Range starting n elements ahead.
    pub func skip(this, n: I32) -> Range {
        let new_current: I32 = this.current + (n * this.step)
        return Range {
            current: new_current,
            end: this.end,
            step: this.step,
            inclusive: this.inclusive
        }
    }

    /// Sums all elements in the iterator.
    pub func sum(mut this) -> I32 {
        let mut total: I32 = 0
        loop {
            when this.next() {
                Just(value) => total = total + value,
                Nothing => break
            }
        }
        return total
    }

    /// Counts the number of elements in the iterator.
    pub func count(mut this) -> I32 {
        let mut n: I32 = 0
        loop {
            when this.next() {
                Just(_) => n = n + 1,
                Nothing => break
            }
        }
        return n
    }

    /// Folds (reduces) the iterator using an accumulator function.
    /// Takes an initial value and a closure that combines the accumulator with each element.
    pub func fold(mut this, init: I32, f: func(I32, I32) -> I32) -> I32 {
        let mut acc: I32 = init
        loop {
            when this.next() {
                Just(value) => acc = f(acc, value),
                Nothing => break
            }
        }
        return acc
    }

    /// Tests if any element satisfies the predicate.
    /// Returns true if at least one element matches, false otherwise.
    pub func any(mut this, predicate: func(I32) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(value) => {
                    if predicate(value) {
                        return true
                    }
                },
                Nothing => break
            }
        }
        return false
    }

    /// Tests if all elements satisfy the predicate.
    /// Returns true only if all elements match, false otherwise.
    pub func all(mut this, predicate: func(I32) -> Bool) -> Bool {
        loop {
            when this.next() {
                Just(value) => {
                    if not predicate(value) {
                        return false
                    }
                },
                Nothing => break
            }
        }
        return true
    }
}
