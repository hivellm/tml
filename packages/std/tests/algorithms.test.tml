use test

// ============ Sorting Algorithms ============

func bubble_sort_step(a: I32, b: I32) -> I32 {
    // Returns 1 if swap needed, 0 otherwise
    return if a > b then 1 else 0
}

@test
func test_bubble_sort_comparison() -> I32 {
    // Test comparison logic
    assert_eq_i32(bubble_sort_step(5, 3), 1, "5 > 3 needs swap")
    assert_eq_i32(bubble_sort_step(3, 5), 0, "3 < 5 no swap")
    assert_eq_i32(bubble_sort_step(5, 5), 0, "equal no swap")

    return 0
}

// ============ Search Algorithms ============

func linear_search(target: I32, v1: I32, v2: I32, v3: I32, v4: I32, v5: I32) -> I32 {
    // Returns index (1-5) if found, 0 if not found
    if v1 == target then { return 1 }
    if v2 == target then { return 2 }
    if v3 == target then { return 3 }
    if v4 == target then { return 4 }
    if v5 == target then { return 5 }
    return 0
}

@test
func test_linear_search() -> I32 {
    // Search in array [10, 20, 30, 40, 50]
    assert_eq_i32(linear_search(10, 10, 20, 30, 40, 50), 1, "find 10 at pos 1")
    assert_eq_i32(linear_search(30, 10, 20, 30, 40, 50), 3, "find 30 at pos 3")
    assert_eq_i32(linear_search(50, 10, 20, 30, 40, 50), 5, "find 50 at pos 5")
    assert_eq_i32(linear_search(99, 10, 20, 30, 40, 50), 0, "99 not found")

    return 0
}

func binary_search_helper(target: I32, mid_val: I32) -> I32 {
    // Simulates one step of binary search
    // Returns: 0 = found, -1 = go left, 1 = go right
    if target == mid_val then { return 0 }
    if target < mid_val then { return 0 - 1 }
    return 1
}

@test
func test_binary_search_step() -> I32 {
    // Target at mid
    assert_eq_i32(binary_search_helper(50, 50), 0, "found at mid")

    // Target less than mid
    assert_eq_i32(binary_search_helper(25, 50), 0 - 1, "go left")

    // Target greater than mid
    assert_eq_i32(binary_search_helper(75, 50), 1, "go right")

    return 0
}

// ============ Mathematical Algorithms ============

// Check if n is prime (returns 1 for prime, 0 for not prime)
func is_prime_i32(n: I32) -> I32 {
    if n <= 1 then { return 0 }
    if n <= 3 then { return 1 }
    if n % 2 == 0 then { return 0 }

    let mut i: I32 = 3
    loop {
        if i * i > n then { break }
        if n % i == 0 then { return 0 }
        i = i + 2
    }
    return 1
}

@test
func test_is_prime() -> I32 {
    assert_eq_i32(is_prime_i32(0), 0, "0 not prime")
    assert_eq_i32(is_prime_i32(1), 0, "1 not prime")
    assert_eq_i32(is_prime_i32(2), 1, "2 is prime")
    assert_eq_i32(is_prime_i32(3), 1, "3 is prime")
    assert_eq_i32(is_prime_i32(4), 0, "4 not prime")
    assert_eq_i32(is_prime_i32(5), 1, "5 is prime")
    assert_eq_i32(is_prime_i32(17), 1, "17 is prime")
    assert_eq_i32(is_prime_i32(18), 0, "18 not prime")
    assert_eq_i32(is_prime_i32(97), 1, "97 is prime")

    return 0
}

func count_primes_up_to(n: I32) -> I32 {
    let mut count: I32 = 0
    let mut i: I32 = 2
    loop {
        if i > n then { break }
        count = count + is_prime_i32(i)
        i = i + 1
    }
    return count
}

@test
func test_count_primes() -> I32 {
    assert_eq_i32(count_primes_up_to(10), 4, "primes up to 10: 2,3,5,7")
    assert_eq_i32(count_primes_up_to(20), 8, "primes up to 20")
    assert_eq_i32(count_primes_up_to(2), 1, "primes up to 2: just 2")

    return 0
}

// ============ Array-like Operations ============

func array_sum(a: I32, b: I32, c: I32, d: I32, e: I32) -> I32 {
    return a + b + c + d + e
}

func array_max(a: I32, b: I32, c: I32, d: I32, e: I32) -> I32 {
    let mut max: I32 = a
    if b > max then { max = b }
    if c > max then { max = c }
    if d > max then { max = d }
    if e > max then { max = e }
    return max
}

func array_min(a: I32, b: I32, c: I32, d: I32, e: I32) -> I32 {
    let mut min: I32 = a
    if b < min then { min = b }
    if c < min then { min = c }
    if d < min then { min = d }
    if e < min then { min = e }
    return min
}

@test
func test_array_operations() -> I32 {
    assert_eq_i32(array_sum(1, 2, 3, 4, 5), 15, "sum [1,2,3,4,5]")
    assert_eq_i32(array_sum(10, 20, 30, 40, 50), 150, "sum [10..50]")

    assert_eq_i32(array_max(3, 1, 4, 1, 5), 5, "max [3,1,4,1,5]")
    assert_eq_i32(array_max(5, 4, 3, 2, 1), 5, "max descending")
    assert_eq_i32(array_max(1, 2, 3, 4, 5), 5, "max ascending")

    assert_eq_i32(array_min(3, 1, 4, 1, 5), 1, "min [3,1,4,1,5]")
    assert_eq_i32(array_min(5, 4, 3, 2, 1), 1, "min descending")

    return 0
}

func array_average(a: I32, b: I32, c: I32, d: I32, e: I32) -> I32 {
    return (a + b + c + d + e) / 5
}

@test
func test_array_average() -> I32 {
    assert_eq_i32(array_average(10, 10, 10, 10, 10), 10, "avg all 10s")
    assert_eq_i32(array_average(1, 2, 3, 4, 5), 3, "avg 1-5")
    assert_eq_i32(array_average(0, 0, 0, 0, 100), 20, "avg with outlier")

    return 0
}

// ============ Numeric Algorithms ============

func reverse_digits(n: I32) -> I32 {
    let mut result: I32 = 0
    let mut num: I32 = n
    loop {
        if num == 0 then { break }
        result = result * 10 + (num % 10)
        num = num / 10
    }
    return result
}

@test
func test_reverse_digits() -> I32 {
    assert_eq_i32(reverse_digits(123), 321, "reverse 123")
    assert_eq_i32(reverse_digits(1000), 1, "reverse 1000")
    assert_eq_i32(reverse_digits(12345), 54321, "reverse 12345")
    assert_eq_i32(reverse_digits(1), 1, "reverse 1")

    return 0
}

func is_palindrome_i32(n: I32) -> I32 {
    if n < 0 then { return 0 }
    return if n == reverse_digits(n) then 1 else 0
}

@test
func test_palindrome_number() -> I32 {
    assert_eq_i32(is_palindrome_i32(121), 1, "121 is palindrome")
    assert_eq_i32(is_palindrome_i32(12321), 1, "12321 is palindrome")
    assert_eq_i32(is_palindrome_i32(1), 1, "1 is palindrome")
    assert_eq_i32(is_palindrome_i32(11), 1, "11 is palindrome")
    assert_eq_i32(is_palindrome_i32(123), 0, "123 not palindrome")
    assert_eq_i32(is_palindrome_i32(10), 0, "10 not palindrome")

    return 0
}
