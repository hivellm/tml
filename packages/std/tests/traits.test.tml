use test

// Tests for Core Traits
// Tests behavior definitions and implementations
// NOTE: Simple enums (unit variants) have a known bug with pattern matching.
//       These tests focus on patterns that work correctly.

// ============================================================================
// Maybe[T] Type Tests (for Eq, Ord patterns)
// ============================================================================

type Maybe[T] {
    Just(T),
    Nothing
}

// Helper: check if Maybe is Just
func is_just[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return true,
        Nothing => return false
    }
    return false
}

// Helper: check if Maybe is Nothing
func is_nothing[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return false,
        Nothing => return true
    }
    return true
}

// Helper: unwrap Maybe with default
func unwrap_or[T](m: Maybe[T], default_val: T) -> T {
    when m {
        Just(val) => return val,
        Nothing => return default_val
    }
    return default_val
}

@test
func test_maybe_is_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert(is_just(m), "Just(42) should be Just")
    return 0
}

@test
func test_maybe_is_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    assert(is_nothing(m), "Nothing should be Nothing")
    return 0
}

@test
func test_maybe_unwrap_or_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    let val: I32 = unwrap_or(m, 0)
    assert(val == 42, "unwrap_or should return 42")
    return 0
}

@test
func test_maybe_unwrap_or_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    let val: I32 = unwrap_or(m, 99)
    assert(val == 99, "unwrap_or should return default 99")
    return 0
}

@test
func test_maybe_extract_value() -> I32 {
    let m: Maybe[I32] = Just(123)
    when m {
        Just(val) => {
            assert(val == 123, "Extracted value should be 123")
            return 0
        },
        Nothing => {
            assert(false, "Should be Just, not Nothing")
            return 1
        }
    }
    return 1
}

// ============================================================================
// Outcome[T, E] Type Tests
// ============================================================================

type Outcome[T, E] {
    Ok(T),
    Err(E)
}

// Helper: check if Outcome is Ok
func is_ok[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return true,
        Err(_) => return false
    }
    return false
}

// Helper: check if Outcome is Err
func is_err[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return false,
        Err(_) => return true
    }
    return true
}

// Helper: unwrap Outcome Ok value with default
func unwrap_or_ok[T, E](o: Outcome[T, E], default_val: T) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => return default_val
    }
    return default_val
}

@test
func test_outcome_is_ok() -> I32 {
    let o: Outcome[I32, Str] = Ok(100)
    assert(is_ok(o), "Ok(100) should be Ok")
    return 0
}

@test
func test_outcome_is_err() -> I32 {
    let o: Outcome[I32, Str] = Err("error")
    assert(is_err(o), "Err should be Err")
    return 0
}

@test
func test_outcome_unwrap_or_ok() -> I32 {
    let o: Outcome[I32, Str] = Ok(42)
    let val: I32 = unwrap_or_ok(o, 0)
    assert(val == 42, "unwrap_or_ok should return 42")
    return 0
}

@test
func test_outcome_unwrap_or_err() -> I32 {
    let o: Outcome[I32, Str] = Err("error")
    let val: I32 = unwrap_or_ok(o, 99)
    assert(val == 99, "unwrap_or_ok should return default 99")
    return 0
}

@test
func test_outcome_extract_ok_value() -> I32 {
    let o: Outcome[I32, Str] = Ok(456)
    when o {
        Ok(val) => {
            assert(val == 456, "Extracted Ok value should be 456")
            return 0
        },
        Err(_) => {
            assert(false, "Should be Ok, not Err")
            return 1
        }
    }
    return 1
}

@test
func test_outcome_extract_err_value() -> I32 {
    let o: Outcome[I32, I32] = Err(999)
    when o {
        Ok(_) => {
            assert(false, "Should be Err, not Ok")
            return 1
        },
        Err(e) => {
            assert(e == 999, "Extracted Err value should be 999")
            return 0
        }
    }
    return 1
}

// ============================================================================
// Hash-like Tests (using str_hash)
// ============================================================================

@test
func test_hash_consistency() -> I32 {
    let s1: Str = "hello"
    let s2: Str = "hello"
    let h1: I32 = str_hash(s1)
    let h2: I32 = str_hash(s2)
    assert(h1 == h2, "Same strings should have same hash")
    return 0
}

@test
func test_hash_difference() -> I32 {
    let s1: Str = "hello"
    let s2: Str = "world"
    let h1: I32 = str_hash(s1)
    let h2: I32 = str_hash(s2)
    assert(h1 != h2, "Different strings should have different hashes (usually)")
    return 0
}

// ============================================================================
// Default-like Tests
// ============================================================================

@test
func test_default_i32() -> I32 {
    let x: I32 = 0  // Default value for I32
    assert(x == 0, "Default I32 should be 0")
    return 0
}

@test
func test_default_bool() -> I32 {
    let b: Bool = false  // Default value for Bool
    assert(b == false, "Default Bool should be false")
    return 0
}

// ============================================================================
// Comparison Tests (without simple enum issues)
// ============================================================================

@test
func test_compare_less() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    assert(a < b, "5 should be less than 10")
    return 0
}

@test
func test_compare_equal() -> I32 {
    let a: I32 = 7
    let b: I32 = 7
    assert(a == b, "7 should equal 7")
    return 0
}

@test
func test_compare_greater() -> I32 {
    let a: I32 = 20
    let b: I32 = 10
    assert(a > b, "20 should be greater than 10")
    return 0
}

// ============================================================================
// Eq-like tests with Maybe
// ============================================================================

@test
func test_maybe_eq_both_just_same_value() -> I32 {
    let a: Maybe[I32] = Just(42)
    let b: Maybe[I32] = Just(42)
    let a_val: I32 = unwrap_or(a, -1)
    let b_val: I32 = unwrap_or(b, -1)
    assert(a_val == b_val, "Both Just(42) should have same value")
    return 0
}

@test
func test_maybe_eq_both_nothing() -> I32 {
    let a: Maybe[I32] = Nothing
    let b: Maybe[I32] = Nothing
    assert(is_nothing(a), "a should be Nothing")
    assert(is_nothing(b), "b should be Nothing")
    return 0
}
