// Tests for Outcome[T, E] combinators
// Tests: map_ok, map_err, and_then_ok, or_else_ok

// Define types locally (until enum variant import is fixed)
type Outcome[T, E] {
    Ok(T),
    Err(E)
}

// Combinator functions
func map_ok[T, U, E](o: Outcome[T, E], f: func(T) -> U) -> Outcome[U, E] {
    when o {
        Ok(val) => return Ok(f(val)),
        Err(e) => return Err(e)
    }
    return Err(e)
}

func map_err[T, E, F](o: Outcome[T, E], f: func(E) -> F) -> Outcome[T, F] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return Err(f(e))
    }
    return Err(f(e))
}

func and_then_ok[T, U, E](o: Outcome[T, E], f: func(T) -> Outcome[U, E]) -> Outcome[U, E] {
    when o {
        Ok(val) => return f(val),
        Err(e) => return Err(e)
    }
    return Err(e)
}

func or_else_ok[T, E](o: Outcome[T, E], f: func(E) -> Outcome[T, E]) -> Outcome[T, E] {
    when o {
        Ok(val) => return Ok(val),
        Err(e) => return f(e)
    }
    return f(e)
}

func main() {
    println("=== Outcome[T, E] Combinators Test ===")
    println("")

    // Test map_ok
    println("Testing map_ok:")
    let x: Outcome[I32, I32] = Ok(5)
    let y: Outcome[I32, I32] = map_ok(x, do(val) val * 2)
    when y {
        Ok(v) => println("  map_ok(Ok(5), *2) = Ok({})", v),
        Err(_) => println("  ERROR: Expected Ok(10), got Err")
    }

    let z: Outcome[I32, I32] = map_ok(Err(42), do(val) val * 2)
    when z {
        Ok(_) => println("  ERROR: Expected Err(42), got Ok"),
        Err(e) => println("  map_ok(Err(42), *2) = Err({})", e)
    }

    // Test map_err
    println("")
    println("Testing map_err:")
    let a: Outcome[I32, I32] = Err(5)
    let b: Outcome[I32, I32] = map_err(a, do(e) e * 2)
    when b {
        Ok(_) => println("  ERROR: Expected Err(10), got Ok"),
        Err(e) => println("  map_err(Err(5), *2) = Err({})", e)
    }

    let c: Outcome[I32, I32] = map_err(Ok(42), do(e) e * 2)
    when c {
        Ok(v) => println("  map_err(Ok(42), *2) = Ok({})", v),
        Err(_) => println("  ERROR: Expected Ok(42), got Err")
    }

    // Test and_then_ok
    println("")
    println("Testing and_then_ok:")
    let d: Outcome[I32, I32] = Ok(5)
    let e: Outcome[I32, I32] = and_then_ok(d, do(val) if val > 0 then Ok(val * 2) else Err(999))
    when e {
        Ok(v) => println("  and_then_ok(Ok(5), check>0) = Ok({})", v),
        Err(_) => println("  ERROR: Expected Ok(10), got Err")
    }

    let f: Outcome[I32, I32] = and_then_ok(d, do(val) if val > 10 then Ok(val * 2) else Err(999))
    when f {
        Ok(_) => println("  ERROR: Expected Err(999), got Ok"),
        Err(e) => println("  and_then_ok(Ok(5), check>10) = Err({})", e)
    }

    let g: Outcome[I32, I32] = and_then_ok(Err(100), do(val) Ok(val * 2))
    when g {
        Ok(_) => println("  ERROR: Expected Err(100), got Ok"),
        Err(e) => println("  and_then_ok(Err(100), f) = Err({})", e)
    }

    // Test or_else_ok
    println("")
    println("Testing or_else_ok:")
    let h: Outcome[I32, I32] = Err(5)
    let i: Outcome[I32, I32] = or_else_ok(h, do(e) Ok(0))
    when i {
        Ok(v) => println("  or_else_ok(Err(5), Ok(0)) = Ok({})", v),
        Err(_) => println("  ERROR: Expected Ok(0), got Err")
    }

    let j: Outcome[I32, I32] = Ok(42)
    let k: Outcome[I32, I32] = or_else_ok(j, do(e) Ok(0))
    when k {
        Ok(v) => println("  or_else_ok(Ok(42), Ok(0)) = Ok({})", v),
        Err(_) => println("  ERROR: Expected Ok(42), got Err")
    }

    println("")
    println("All Outcome[T, E] combinator tests completed!")
}
