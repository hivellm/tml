use test

// ============ Integer Overflow Behavior ============

@test
func test_large_numbers() -> I32 {
    let big: I32 = 1000000
    assert_eq_i32(big / 1000, 1000, "1M / 1K")
    assert_eq_i32(big % 999, 1, "1M % 999")

    return 0
}

// ============ Modulo Operations ============

func mod_positive(a: I32, b: I32) -> I32 {
    // Ensure positive modulo result
    let r: I32 = a % b
    return if r >= 0 then r else r + b
}

@test
func test_modulo() -> I32 {
    // Basic modulo
    assert_eq_i32(10 % 3, 1, "10 % 3")
    assert_eq_i32(15 % 5, 0, "15 % 5")
    assert_eq_i32(7 % 10, 7, "7 % 10")

    // Power of 2 modulo (bit masking)
    assert_eq_i32(15 % 8, 7, "15 % 8")
    assert_eq_i32(256 % 16, 0, "256 % 16")

    return 0
}

// ============ Division Operations ============

@test
func test_integer_division() -> I32 {
    // Integer division truncates
    assert_eq_i32(7 / 2, 3, "7 / 2 truncates")
    assert_eq_i32(10 / 3, 3, "10 / 3 truncates")
    assert_eq_i32(99 / 100, 0, "99 / 100 = 0")

    // Exact division
    assert_eq_i32(100 / 10, 10, "100 / 10")
    assert_eq_i32(144 / 12, 12, "144 / 12")

    return 0
}

// ============ Bit Counting ============

func count_bits(n: I32) -> I32 {
    let mut count: I32 = 0
    let mut x: I32 = n
    loop {
        if x == 0 then { break }
        count = count + (x & 1)
        x = x >> 1
    }
    return count
}

@test
func test_bit_count() -> I32 {
    assert_eq_i32(count_bits(0), 0, "bits in 0")
    assert_eq_i32(count_bits(1), 1, "bits in 1")
    assert_eq_i32(count_bits(3), 2, "bits in 3 (0b11)")
    assert_eq_i32(count_bits(7), 3, "bits in 7 (0b111)")
    assert_eq_i32(count_bits(15), 4, "bits in 15 (0b1111)")
    assert_eq_i32(count_bits(255), 8, "bits in 255")

    return 0
}

// ============ Highest Bit ============

func highest_bit_pos(n: I32) -> I32 {
    if n == 0 then { return 0 - 1 }

    let mut pos: I32 = 0
    let mut x: I32 = n
    loop {
        if x <= 1 then { break }
        x = x >> 1
        pos = pos + 1
    }
    return pos
}

@test
func test_highest_bit() -> I32 {
    assert_eq_i32(highest_bit_pos(0), 0 - 1, "highest bit of 0")
    assert_eq_i32(highest_bit_pos(1), 0, "highest bit of 1")
    assert_eq_i32(highest_bit_pos(2), 1, "highest bit of 2")
    assert_eq_i32(highest_bit_pos(4), 2, "highest bit of 4")
    assert_eq_i32(highest_bit_pos(8), 3, "highest bit of 8")
    assert_eq_i32(highest_bit_pos(15), 3, "highest bit of 15")
    assert_eq_i32(highest_bit_pos(16), 4, "highest bit of 16")

    return 0
}

// ============ Power of Two Check ============

func is_power_of_two(n: I32) -> I32 {
    if n <= 0 then { return 0 }
    return if (n & (n - 1)) == 0 then 1 else 0
}

@test
func test_power_of_two() -> I32 {
    assert_eq_i32(is_power_of_two(0), 0, "0 not power of 2")
    assert_eq_i32(is_power_of_two(1), 1, "1 is 2^0")
    assert_eq_i32(is_power_of_two(2), 1, "2 is 2^1")
    assert_eq_i32(is_power_of_two(4), 1, "4 is 2^2")
    assert_eq_i32(is_power_of_two(8), 1, "8 is 2^3")
    assert_eq_i32(is_power_of_two(16), 1, "16 is 2^4")

    assert_eq_i32(is_power_of_two(3), 0, "3 not power of 2")
    assert_eq_i32(is_power_of_two(5), 0, "5 not power of 2")
    assert_eq_i32(is_power_of_two(6), 0, "6 not power of 2")

    return 0
}

// ============ Next Power of Two ============

func next_power_of_two(n: I32) -> I32 {
    if n <= 0 then { return 1 }
    if is_power_of_two(n) == 1 then { return n }

    let mut p: I32 = 1
    loop {
        if p >= n then { break }
        p = p << 1
    }
    return p
}

@test
func test_next_power_of_two() -> I32 {
    assert_eq_i32(next_power_of_two(0), 1, "next pow2 of 0")
    assert_eq_i32(next_power_of_two(1), 1, "next pow2 of 1")
    assert_eq_i32(next_power_of_two(2), 2, "next pow2 of 2")
    assert_eq_i32(next_power_of_two(3), 4, "next pow2 of 3")
    assert_eq_i32(next_power_of_two(5), 8, "next pow2 of 5")
    assert_eq_i32(next_power_of_two(9), 16, "next pow2 of 9")

    return 0
}

// ============ Absolute Difference ============

func abs_diff(a: I32, b: I32) -> I32 {
    if a > b then {
        return a - b
    }
    return b - a
}

@test
func test_abs_diff() -> I32 {
    assert_eq_i32(abs_diff(10, 3), 7, "|10 - 3|")
    assert_eq_i32(abs_diff(3, 10), 7, "|3 - 10|")
    assert_eq_i32(abs_diff(5, 5), 0, "|5 - 5|")
    assert_eq_i32(abs_diff(0, 100), 100, "|0 - 100|")

    return 0
}

// ============ Clamp ============

func clamp(value: I32, min: I32, max: I32) -> I32 {
    if value < min then { return min }
    if value > max then { return max }
    return value
}

@test
func test_clamp() -> I32 {
    assert_eq_i32(clamp(5, 0, 10), 5, "5 in [0,10]")
    assert_eq_i32(clamp(0 - 5, 0, 10), 0, "-5 clamped to 0")
    assert_eq_i32(clamp(15, 0, 10), 10, "15 clamped to 10")
    assert_eq_i32(clamp(0, 0, 10), 0, "0 at boundary")
    assert_eq_i32(clamp(10, 0, 10), 10, "10 at boundary")

    return 0
}

// ============ Min/Max ============

func min2(a: I32, b: I32) -> I32 {
    return if a < b then a else b
}

func max2(a: I32, b: I32) -> I32 {
    return if a > b then a else b
}

func min3(a: I32, b: I32, c: I32) -> I32 {
    return min2(min2(a, b), c)
}

func max3(a: I32, b: I32, c: I32) -> I32 {
    return max2(max2(a, b), c)
}

@test
func test_min_max() -> I32 {
    assert_eq_i32(min2(3, 5), 3, "min(3,5)")
    assert_eq_i32(min2(5, 3), 3, "min(5,3)")
    assert_eq_i32(max2(3, 5), 5, "max(3,5)")
    assert_eq_i32(max2(5, 3), 5, "max(5,3)")

    assert_eq_i32(min3(1, 2, 3), 1, "min(1,2,3)")
    assert_eq_i32(min3(3, 1, 2), 1, "min(3,1,2)")
    assert_eq_i32(max3(1, 2, 3), 3, "max(1,2,3)")
    assert_eq_i32(max3(3, 1, 2), 3, "max(3,1,2)")

    return 0
}
