// Tests for Maybe and Outcome types
use test

// Define types locally (until enum variant import is fixed)
type Maybe[T] {
    Just(T),
    Nothing
}

type Outcome[T, E] {
    Ok(T),
    Err(E)
}

// Helper functions
func is_just[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return true,
        Nothing => return false
    }
    return false
}

func is_nothing[T](m: Maybe[T]) -> Bool {
    when m {
        Just(_) => return false,
        Nothing => return true
    }
    return true
}

func unwrap_or[T](m: Maybe[T], default_val: T) -> T {
    when m {
        Just(val) => return val,
        Nothing => return default_val
    }
    return default_val
}

func is_ok[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return true,
        Err(_) => return false
    }
    return false
}

func is_err[T, E](o: Outcome[T, E]) -> Bool {
    when o {
        Ok(_) => return false,
        Err(_) => return true
    }
    return true
}

func unwrap_or_ok[T, E](o: Outcome[T, E], default_val: T) -> T {
    when o {
        Ok(val) => return val,
        Err(_) => return default_val
    }
    return default_val
}

// ============================================================================
// Maybe[T] Tests
// ============================================================================

@test
func test_maybe_just_is_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    assert(is_just(m) == true, "Just should return true for is_just")
    return 0
}

@test
func test_maybe_nothing_is_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    assert(is_nothing(m) == true, "Nothing should return true for is_nothing")
    return 0
}

@test
func test_maybe_just_is_not_nothing() -> I32 {
    let m: Maybe[I32] = Just(100)
    assert(is_nothing(m) == false, "Just should return false for is_nothing")
    return 0
}

@test
func test_maybe_nothing_is_not_just() -> I32 {
    let m: Maybe[I32] = Nothing
    assert(is_just(m) == false, "Nothing should return false for is_just")
    return 0
}

@test
func test_maybe_unwrap_or_just() -> I32 {
    let m: Maybe[I32] = Just(42)
    let val: I32 = unwrap_or(m, 0)
    assert(val == 42, "unwrap_or on Just should return the value")
    return 0
}

@test
func test_maybe_unwrap_or_nothing() -> I32 {
    let m: Maybe[I32] = Nothing
    let val: I32 = unwrap_or(m, 99)
    assert(val == 99, "unwrap_or on Nothing should return the default")
    return 0
}

// ============================================================================
// Outcome[T, E] Tests
// ============================================================================

@test
func test_outcome_ok_is_ok() -> I32 {
    let o: Outcome[I32, Str] = Ok(100)
    assert(is_ok(o) == true, "Ok should return true for is_ok")
    return 0
}

@test
func test_outcome_err_is_err() -> I32 {
    let o: Outcome[I32, Str] = Err("error")
    assert(is_err(o) == true, "Err should return true for is_err")
    return 0
}

@test
func test_outcome_ok_is_not_err() -> I32 {
    let o: Outcome[I32, Str] = Ok(50)
    assert(is_err(o) == false, "Ok should return false for is_err")
    return 0
}

@test
func test_outcome_err_is_not_ok() -> I32 {
    let o: Outcome[I32, Str] = Err("fail")
    assert(is_ok(o) == false, "Err should return false for is_ok")
    return 0
}

@test
func test_outcome_unwrap_or_ok_success() -> I32 {
    let o: Outcome[I32, Str] = Ok(42)
    let val: I32 = unwrap_or_ok(o, 0)
    assert(val == 42, "unwrap_or_ok on Ok should return the value")
    return 0
}

@test
func test_outcome_unwrap_or_ok_default() -> I32 {
    let o: Outcome[I32, Str] = Err("error")
    let val: I32 = unwrap_or_ok(o, 99)
    assert(val == 99, "unwrap_or_ok on Err should return the default")
    return 0
}

// ============================================================================
// Pattern Matching Tests
// ============================================================================

@test
func test_maybe_pattern_match() -> I32 {
    let m: Maybe[I32] = Just(123)

    when m {
        Just(val) => {
            assert(val == 123, "Pattern should extract correct value")
            return 0
        },
        Nothing => {
            return 1  // Should not reach
        }
    }
    return 1
}

@test
func test_outcome_pattern_match() -> I32 {
    let o: Outcome[I32, Str] = Ok(456)

    when o {
        Ok(val) => {
            assert(val == 456, "Pattern should extract correct value")
            return 0
        },
        Err(_) => {
            return 1  // Should not reach
        }
    }
    return 1
}
