// Test 18: Go-style channels and synchronization primitives
func main() {
    // ========== MUTEX TEST ==========
    let mtx = mutex_create()

    // Lock the mutex
    mutex_lock(mtx)
    println("mutex locked")

    // Try to lock again - should fail since we hold it
    let got_lock = mutex_try_lock(mtx)
    if got_lock {
        println("error: mutex_try_lock should have failed")
    } else {
        println("mutex_try_lock correctly failed")
    }

    // Unlock
    mutex_unlock(mtx)
    println("mutex unlocked")

    // Now try_lock should succeed
    let got_lock2 = mutex_try_lock(mtx)
    if got_lock2 {
        println("mutex_try_lock succeeded")
    } else {
        println("error: mutex_try_lock should have succeeded")
    }

    mutex_unlock(mtx)
    mutex_destroy(mtx)

    // ========== CHANNEL TEST ==========
    let ch = channel_create()
    println("channel created")

    // Check initial length
    let len0 = channel_len(ch)
    println(len0)  // 0

    // Non-blocking send
    let sent1 = channel_try_send(ch, 42)
    if sent1 {
        println("sent 42")
    }

    let sent2 = channel_try_send(ch, 100)
    if sent2 {
        println("sent 100")
    }

    // Check length after sends
    let len1 = channel_len(ch)
    println(len1)  // 2

    // Non-blocking receive into temp
    let out_val = alloc(4)
    let recv1 = channel_try_recv(ch, out_val)
    if recv1 {
        println(read_i32(out_val))  // 42
    }

    let recv2 = channel_try_recv(ch, out_val)
    if recv2 {
        println(read_i32(out_val))  // 100
    }

    // Channel should be empty now
    let len2 = channel_len(ch)
    println(len2)  // 0

    // Try receive on empty channel - should fail
    let recv3 = channel_try_recv(ch, out_val)
    if recv3 {
        println("error: should not receive from empty")
    } else {
        println("correctly got nothing from empty channel")
    }

    dealloc(out_val)
    channel_close(ch)
    channel_destroy(ch)

    // ========== WAITGROUP TEST ==========
    let wg = waitgroup_create()

    // Add 3 to counter
    waitgroup_add(wg, 3)
    println("added 3 to waitgroup")

    // Mark done 3 times
    waitgroup_done(wg)
    println("done 1")
    waitgroup_done(wg)
    println("done 2")
    waitgroup_done(wg)
    println("done 3")

    // Wait should return immediately since count is 0
    waitgroup_wait(wg)
    println("waitgroup wait completed")

    waitgroup_destroy(wg)

    println("channels ok")
}
