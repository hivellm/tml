; Generated by TML Compiler
target triple = "x86_64-pc-windows-msvc"

; Runtime type declarations
%struct.tml_str = type { ptr, i64 }

; External function declarations
declare i32 @printf(ptr, ...)
declare i32 @puts(ptr)
declare i32 @putchar(i32)
declare ptr @malloc(i64)
declare void @free(ptr)
declare void @exit(i32) noreturn

; TML runtime functions
declare void @tml_panic(ptr) noreturn

; Threading runtime (tml_runtime.c)
declare ptr @tml_thread_spawn(ptr, ptr)
declare void @tml_thread_join(ptr)
declare void @tml_thread_yield()
declare void @tml_thread_sleep(i32)
declare i32 @tml_thread_id()

; Time functions
declare i32 @tml_time_ms()
declare i64 @tml_time_us()
declare i64 @tml_time_ns()
declare ptr @tml_elapsed_secs(i32)
declare i32 @tml_elapsed_ms(i32)
; Instant API (like Rust)
declare i64 @tml_instant_now()
declare i64 @tml_instant_elapsed(i64)
declare double @tml_duration_as_secs_f64(i64)
declare double @tml_duration_as_millis_f64(i64)
declare i64 @tml_duration_as_millis(i64)
declare ptr @tml_duration_format_ms(i64)
declare ptr @tml_duration_format_secs(i64)
; Black box (prevent optimization)
declare i32 @tml_black_box_i32(i32)
declare i64 @tml_black_box_i64(i64)
; SIMD operations (auto-vectorized)
declare i64 @tml_simd_sum_i32(ptr, i64)
declare i64 @tml_simd_sum_i64(ptr, i64)
declare double @tml_simd_sum_f64(ptr, i64)
declare double @tml_simd_dot_f64(ptr, ptr, i64)
declare void @tml_simd_fill_i32(ptr, i32, i64)
declare void @tml_simd_add_i32(ptr, ptr, ptr, i64)
declare void @tml_simd_mul_i32(ptr, ptr, ptr, i64)

; Float functions
declare ptr @tml_float_to_fixed(double, i32)
declare ptr @tml_float_to_precision(double, i32)
declare ptr @tml_float_to_string(double)
declare double @tml_int_to_float(i32)
declare double @tml_i64_to_float(i64)
declare i32 @tml_float_to_int(double)
declare i64 @tml_float_to_i64(double)
declare i32 @tml_float_round(double)
declare i32 @tml_float_floor(double)
declare i32 @tml_float_ceil(double)
declare double @tml_float_abs(double)
declare double @tml_float_sqrt(double)
declare double @tml_float_pow(double, i32)

; Channel runtime (Go-style)
declare ptr @tml_channel_create()
declare i32 @tml_channel_send(ptr, i32)
declare i32 @tml_channel_recv(ptr, ptr)
declare i32 @tml_channel_try_send(ptr, i32)
declare i32 @tml_channel_try_recv(ptr, ptr)
declare void @tml_channel_close(ptr)
declare void @tml_channel_destroy(ptr)
declare i32 @tml_channel_len(ptr)

; Mutex runtime
declare ptr @tml_mutex_create()
declare void @tml_mutex_lock(ptr)
declare void @tml_mutex_unlock(ptr)
declare i32 @tml_mutex_try_lock(ptr)
declare void @tml_mutex_destroy(ptr)

; WaitGroup runtime (Go-style)
declare ptr @tml_waitgroup_create()
declare void @tml_waitgroup_add(ptr, i32)
declare void @tml_waitgroup_done(ptr)
declare void @tml_waitgroup_wait(ptr)
declare void @tml_waitgroup_destroy(ptr)

; Atomic counter runtime
declare ptr @tml_atomic_counter_create(i32)
declare i32 @tml_atomic_counter_inc(ptr)
declare i32 @tml_atomic_counter_dec(ptr)
declare i32 @tml_atomic_counter_get(ptr)
declare void @tml_atomic_counter_set(ptr, i32)
declare void @tml_atomic_counter_destroy(ptr)

; List (dynamic array) runtime
declare ptr @tml_list_create(i32)
declare void @tml_list_destroy(ptr)
declare void @tml_list_push(ptr, i32)
declare i32 @tml_list_pop(ptr)
declare i32 @tml_list_get(ptr, i32)
declare void @tml_list_set(ptr, i32, i32)
declare i32 @tml_list_len(ptr)
declare i32 @tml_list_capacity(ptr)
declare void @tml_list_clear(ptr)
declare i32 @tml_list_is_empty(ptr)

; HashMap runtime
declare ptr @tml_hashmap_create()
declare void @tml_hashmap_destroy(ptr)
declare void @tml_hashmap_set(ptr, i32, i32)
declare i32 @tml_hashmap_get(ptr, i32, ptr)
declare i32 @tml_hashmap_has(ptr, i32)
declare i32 @tml_hashmap_remove(ptr, i32)
declare i32 @tml_hashmap_len(ptr)
declare void @tml_hashmap_clear(ptr)

; Buffer runtime
declare ptr @tml_buffer_create(i32)
declare void @tml_buffer_destroy(ptr)
declare void @tml_buffer_write_byte(ptr, i32)
declare void @tml_buffer_write_i32(ptr, i32)
declare i32 @tml_buffer_read_byte(ptr)
declare i32 @tml_buffer_read_i32(ptr)
declare i32 @tml_buffer_len(ptr)
declare i32 @tml_buffer_capacity(ptr)
declare i32 @tml_buffer_remaining(ptr)
declare void @tml_buffer_clear(ptr)
declare void @tml_buffer_reset_read(ptr)

; String utilities
declare i32 @tml_str_len(ptr)
declare i32 @tml_str_hash(ptr)
declare i32 @tml_str_eq(ptr, ptr)

; Format strings
@.fmt.int = private constant [4 x i8] c"%d\0A\00"
@.fmt.int.no_nl = private constant [3 x i8] c"%d\00"
@.fmt.i64 = private constant [5 x i8] c"%ld\0A\00"
@.fmt.i64.no_nl = private constant [4 x i8] c"%ld\00"
@.fmt.float = private constant [4 x i8] c"%f\0A\00"
@.fmt.float.no_nl = private constant [3 x i8] c"%f\00"
@.fmt.float3 = private constant [6 x i8] c"%.3f\0A\00"
@.fmt.float3.no_nl = private constant [5 x i8] c"%.3f\00"
@.fmt.str.no_nl = private constant [3 x i8] c"%s\00"
@.str.true = private constant [5 x i8] c"true\00"
@.str.false = private constant [6 x i8] c"false\00"
@.str.space = private constant [2 x i8] c" \00"
@.str.newline = private constant [2 x i8] c"\0A\00"


define internal i32 @tml_test_hello_world() #0 {
entry:
  %t0 = call i32 @puts(ptr @.str.0)
  %t1 = call i32 @puts(ptr @.str.1)
  %t2 = call i32 @puts(ptr @.str.2)
  ret i32 0
}

define internal i32 @tml_test_variable_declaration() #0 {
entry:
  %t3 = call i32 @puts(ptr @.str.3)
  %t4 = alloca i32
  store i32 42, ptr %t4
  %t5 = alloca i32
  store i32 100, ptr %t5
  %t6 = load i32, ptr %t4
  %t7 = icmp ne i32 %t6, 42
  br i1 %t7, label %if.then0, label %if.end2
if.then0:
  %t8 = call i32 @puts(ptr @.str.4)
  ret i32 1
if.end2:
  %t9 = load i32, ptr %t5
  %t10 = icmp ne i32 %t9, 100
  br i1 %t10, label %if.then3, label %if.end5
if.then3:
  %t11 = call i32 @puts(ptr @.str.5)
  ret i32 2
if.end5:
  %t12 = call i32 @puts(ptr @.str.6)
  ret i32 0
}

define internal i32 @tml_test_variable_assignment() #0 {
entry:
  %t13 = call i32 @puts(ptr @.str.7)
  %t14 = alloca i32
  store i32 10, ptr %t14
  store i32 20, ptr %t14
  %t15 = load i32, ptr %t14
  %t16 = icmp ne i32 %t15, 20
  br i1 %t16, label %if.then6, label %if.end8
if.then6:
  %t17 = call i32 @puts(ptr @.str.8)
  ret i32 3
if.end8:
  %t18 = load i32, ptr %t14
  %t19 = add nsw i32 %t18, 5
  store i32 %t19, ptr %t14
  %t20 = load i32, ptr %t14
  %t21 = icmp ne i32 %t20, 25
  br i1 %t21, label %if.then9, label %if.end11
if.then9:
  %t22 = call i32 @puts(ptr @.str.9)
  ret i32 4
if.end11:
  %t23 = call i32 @puts(ptr @.str.10)
  ret i32 0
}

define internal i32 @tml_test_addition() #0 {
entry:
  %t24 = call i32 @puts(ptr @.str.11)
  %t25 = add nsw i32 10, 5
  %t26 = alloca i32
  store i32 %t25, ptr %t26
  %t27 = load i32, ptr %t26
  %t28 = icmp ne i32 %t27, 15
  br i1 %t28, label %if.then12, label %if.end14
if.then12:
  %t29 = call i32 @puts(ptr @.str.12)
  ret i32 5
if.end14:
  %t30 = add nsw i32 100, 200
  %t31 = alloca i32
  store i32 %t30, ptr %t31
  %t32 = load i32, ptr %t31
  %t33 = icmp ne i32 %t32, 300
  br i1 %t33, label %if.then15, label %if.end17
if.then15:
  %t34 = call i32 @puts(ptr @.str.13)
  ret i32 6
if.end17:
  %t35 = call i32 @puts(ptr @.str.14)
  ret i32 0
}

define internal i32 @tml_test_subtraction() #0 {
entry:
  %t36 = call i32 @puts(ptr @.str.15)
  %t37 = sub nsw i32 20, 5
  %t38 = alloca i32
  store i32 %t37, ptr %t38
  %t39 = load i32, ptr %t38
  %t40 = icmp ne i32 %t39, 15
  br i1 %t40, label %if.then18, label %if.end20
if.then18:
  %t41 = call i32 @puts(ptr @.str.16)
  ret i32 7
if.end20:
  %t42 = sub nsw i32 1000, 1
  %t43 = alloca i32
  store i32 %t42, ptr %t43
  %t44 = load i32, ptr %t43
  %t45 = icmp ne i32 %t44, 999
  br i1 %t45, label %if.then21, label %if.end23
if.then21:
  %t46 = call i32 @puts(ptr @.str.17)
  ret i32 8
if.end23:
  %t47 = call i32 @puts(ptr @.str.18)
  ret i32 0
}

define internal i32 @tml_test_multiplication() #0 {
entry:
  %t48 = call i32 @puts(ptr @.str.19)
  %t49 = mul nsw i32 5, 4
  %t50 = alloca i32
  store i32 %t49, ptr %t50
  %t51 = load i32, ptr %t50
  %t52 = icmp ne i32 %t51, 20
  br i1 %t52, label %if.then24, label %if.end26
if.then24:
  %t53 = call i32 @puts(ptr @.str.20)
  ret i32 9
if.end26:
  %t54 = mul nsw i32 12, 12
  %t55 = alloca i32
  store i32 %t54, ptr %t55
  %t56 = load i32, ptr %t55
  %t57 = icmp ne i32 %t56, 144
  br i1 %t57, label %if.then27, label %if.end29
if.then27:
  %t58 = call i32 @puts(ptr @.str.21)
  ret i32 10
if.end29:
  %t59 = call i32 @puts(ptr @.str.22)
  ret i32 0
}

define internal i32 @tml_test_division() #0 {
entry:
  %t60 = call i32 @puts(ptr @.str.23)
  %t61 = sdiv i32 20, 4
  %t62 = alloca i32
  store i32 %t61, ptr %t62
  %t63 = load i32, ptr %t62
  %t64 = icmp ne i32 %t63, 5
  br i1 %t64, label %if.then30, label %if.end32
if.then30:
  %t65 = call i32 @puts(ptr @.str.24)
  ret i32 11
if.end32:
  %t66 = sdiv i32 100, 10
  %t67 = alloca i32
  store i32 %t66, ptr %t67
  %t68 = load i32, ptr %t67
  %t69 = icmp ne i32 %t68, 10
  br i1 %t69, label %if.then33, label %if.end35
if.then33:
  %t70 = call i32 @puts(ptr @.str.25)
  ret i32 12
if.end35:
  %t71 = call i32 @puts(ptr @.str.26)
  ret i32 0
}

define internal i32 @tml_test_modulo() #0 {
entry:
  %t72 = call i32 @puts(ptr @.str.27)
  %t73 = srem i32 10, 3
  %t74 = alloca i32
  store i32 %t73, ptr %t74
  %t75 = load i32, ptr %t74
  %t76 = icmp ne i32 %t75, 1
  br i1 %t76, label %if.then36, label %if.end38
if.then36:
  %t77 = call i32 @puts(ptr @.str.28)
  ret i32 13
if.end38:
  %t78 = srem i32 20, 7
  %t79 = alloca i32
  store i32 %t78, ptr %t79
  %t80 = load i32, ptr %t79
  %t81 = icmp ne i32 %t80, 6
  br i1 %t81, label %if.then39, label %if.end41
if.then39:
  %t82 = call i32 @puts(ptr @.str.29)
  ret i32 14
if.end41:
  %t83 = call i32 @puts(ptr @.str.30)
  ret i32 0
}

define internal i32 @tml_test_equality() #0 {
entry:
  %t84 = call i32 @puts(ptr @.str.31)
  %t85 = icmp eq i32 5, 5
  br i1 %t85, label %if.then42, label %if.else43
if.then42:
  %t86 = call i32 @puts(ptr @.str.32)
  br label %if.end44
if.else43:
  %t87 = call i32 @puts(ptr @.str.33)
  ret i32 15
if.end44:
  %t88 = icmp ne i32 10, 20
  br i1 %t88, label %if.then46, label %if.else47
if.then46:
  %t89 = call i32 @puts(ptr @.str.34)
  br label %if.end48
if.else47:
  %t90 = call i32 @puts(ptr @.str.35)
  ret i32 16
if.end48:
  %t91 = call i32 @puts(ptr @.str.36)
  ret i32 0
}

define internal i32 @tml_test_comparison_operators() #0 {
entry:
  %t92 = call i32 @puts(ptr @.str.37)
  %t93 = icmp sgt i32 10, 5
  br i1 %t93, label %if.then50, label %if.else51
if.then50:
  %t94 = call i32 @puts(ptr @.str.38)
  br label %if.end52
if.else51:
  %t95 = call i32 @puts(ptr @.str.39)
  ret i32 17
if.end52:
  %t96 = icmp slt i32 3, 7
  br i1 %t96, label %if.then54, label %if.else55
if.then54:
  %t97 = call i32 @puts(ptr @.str.40)
  br label %if.end56
if.else55:
  %t98 = call i32 @puts(ptr @.str.41)
  ret i32 18
if.end56:
  %t99 = icmp sge i32 10, 10
  br i1 %t99, label %if.then58, label %if.else59
if.then58:
  %t100 = call i32 @puts(ptr @.str.42)
  br label %if.end60
if.else59:
  %t101 = call i32 @puts(ptr @.str.43)
  ret i32 19
if.end60:
  %t102 = icmp sle i32 5, 5
  br i1 %t102, label %if.then62, label %if.else63
if.then62:
  %t103 = call i32 @puts(ptr @.str.44)
  br label %if.end64
if.else63:
  %t104 = call i32 @puts(ptr @.str.45)
  ret i32 20
if.end64:
  %t105 = call i32 @puts(ptr @.str.46)
  ret i32 0
}

define internal i32 @tml_test_if_else() #0 {
entry:
  %t106 = call i32 @puts(ptr @.str.47)
  %t107 = alloca i32
  store i32 10, ptr %t107
  %t108 = load i32, ptr %t107
  %t109 = icmp sgt i32 %t108, 5
  br i1 %t109, label %if.then66, label %if.else67
if.then66:
  br label %if.end68
if.else67:
  br label %if.end68
if.end68:
  %t110 = phi i32 [ 1, %if.then66 ], [ 0, %if.else67 ]
  %t111 = alloca i32
  store i32 %t110, ptr %t111
  %t112 = load i32, ptr %t111
  %t113 = icmp ne i32 %t112, 1
  br i1 %t113, label %if.then70, label %if.end72
if.then70:
  %t114 = call i32 @puts(ptr @.str.48)
  ret i32 21
if.end72:
  %t115 = alloca i32
  store i32 3, ptr %t115
  %t116 = load i32, ptr %t115
  %t117 = icmp sgt i32 %t116, 5
  br i1 %t117, label %if.then73, label %if.else74
if.then73:
  br label %if.end75
if.else74:
  br label %if.end75
if.end75:
  %t118 = phi i32 [ 1, %if.then73 ], [ 0, %if.else74 ]
  %t119 = alloca i32
  store i32 %t118, ptr %t119
  %t120 = load i32, ptr %t119
  %t121 = icmp ne i32 %t120, 0
  br i1 %t121, label %if.then77, label %if.end79
if.then77:
  %t122 = call i32 @puts(ptr @.str.49)
  ret i32 22
if.end79:
  %t123 = call i32 @puts(ptr @.str.50)
  ret i32 0
}

define internal i32 @tml_test_nested_if() #0 {
entry:
  %t124 = call i32 @puts(ptr @.str.51)
  %t125 = alloca i32
  store i32 10, ptr %t125
  %t126 = alloca i32
  store i32 20, ptr %t126
  %t127 = load i32, ptr %t125
  %t128 = icmp sgt i32 %t127, 5
  br i1 %t128, label %if.then80, label %if.else81
if.then80:
  %t129 = load i32, ptr %t126
  %t130 = icmp sgt i32 %t129, 15
  br i1 %t130, label %if.then83, label %if.else84
if.then83:
  br label %if.end85
if.else84:
  br label %if.end85
if.end85:
  %t131 = phi i32 [ 2, %if.then83 ], [ 1, %if.else84 ]
  br label %if.end82
if.else81:
  br label %if.end82
if.end82:
  %t132 = phi i32 [ %t131, %if.then80 ], [ 0, %if.else81 ]
  %t133 = alloca i32
  store i32 %t132, ptr %t133
  %t134 = load i32, ptr %t133
  %t135 = icmp ne i32 %t134, 2
  br i1 %t135, label %if.then88, label %if.end90
if.then88:
  %t136 = call i32 @puts(ptr @.str.52)
  ret i32 23
if.end90:
  %t137 = call i32 @puts(ptr @.str.53)
  ret i32 0
}

define internal i32 @tml_test_complex_expressions() #0 {
entry:
  %t138 = call i32 @puts(ptr @.str.54)
  %t139 = add nsw i32 10, 5
  %t140 = mul nsw i32 %t139, 2
  %t141 = alloca i32
  store i32 %t140, ptr %t141
  %t142 = load i32, ptr %t141
  %t143 = icmp ne i32 %t142, 30
  br i1 %t143, label %if.then91, label %if.end93
if.then91:
  %t144 = call i32 @puts(ptr @.str.55)
  ret i32 24
if.end93:
  %t145 = add nsw i32 20, 10
  %t146 = sub nsw i32 100, %t145
  %t147 = alloca i32
  store i32 %t146, ptr %t147
  %t148 = load i32, ptr %t147
  %t149 = icmp ne i32 %t148, 70
  br i1 %t149, label %if.then94, label %if.end96
if.then94:
  %t150 = call i32 @puts(ptr @.str.56)
  ret i32 25
if.end96:
  %t151 = mul nsw i32 5, 4
  %t152 = sdiv i32 10, 2
  %t153 = add nsw i32 %t151, %t152
  %t154 = alloca i32
  store i32 %t153, ptr %t154
  %t155 = load i32, ptr %t154
  %t156 = icmp ne i32 %t155, 25
  br i1 %t156, label %if.then97, label %if.end99
if.then97:
  %t157 = call i32 @puts(ptr @.str.57)
  ret i32 26
if.end99:
  %t158 = call i32 @puts(ptr @.str.58)
  ret i32 0
}

define i32 @tml_main() #0 {
entry:
  %t159 = call i32 @puts(ptr @.str.59)
  %t160 = alloca i32
  store i32 0, ptr %t160
  %t161 = call i32 @tml_test_hello_world()
  store i32 %t161, ptr %t160
  %t162 = load i32, ptr %t160
  %t163 = icmp ne i32 %t162, 0
  br i1 %t163, label %if.then100, label %if.end102
if.then100:
  %t164 = load i32, ptr %t160
  ret i32 %t164
if.end102:
  %t165 = call i32 @tml_test_variable_declaration()
  store i32 %t165, ptr %t160
  %t166 = load i32, ptr %t160
  %t167 = icmp ne i32 %t166, 0
  br i1 %t167, label %if.then103, label %if.end105
if.then103:
  %t168 = load i32, ptr %t160
  ret i32 %t168
if.end105:
  %t169 = call i32 @tml_test_variable_assignment()
  store i32 %t169, ptr %t160
  %t170 = load i32, ptr %t160
  %t171 = icmp ne i32 %t170, 0
  br i1 %t171, label %if.then106, label %if.end108
if.then106:
  %t172 = load i32, ptr %t160
  ret i32 %t172
if.end108:
  %t173 = call i32 @tml_test_addition()
  store i32 %t173, ptr %t160
  %t174 = load i32, ptr %t160
  %t175 = icmp ne i32 %t174, 0
  br i1 %t175, label %if.then109, label %if.end111
if.then109:
  %t176 = load i32, ptr %t160
  ret i32 %t176
if.end111:
  %t177 = call i32 @tml_test_subtraction()
  store i32 %t177, ptr %t160
  %t178 = load i32, ptr %t160
  %t179 = icmp ne i32 %t178, 0
  br i1 %t179, label %if.then112, label %if.end114
if.then112:
  %t180 = load i32, ptr %t160
  ret i32 %t180
if.end114:
  %t181 = call i32 @tml_test_multiplication()
  store i32 %t181, ptr %t160
  %t182 = load i32, ptr %t160
  %t183 = icmp ne i32 %t182, 0
  br i1 %t183, label %if.then115, label %if.end117
if.then115:
  %t184 = load i32, ptr %t160
  ret i32 %t184
if.end117:
  %t185 = call i32 @tml_test_division()
  store i32 %t185, ptr %t160
  %t186 = load i32, ptr %t160
  %t187 = icmp ne i32 %t186, 0
  br i1 %t187, label %if.then118, label %if.end120
if.then118:
  %t188 = load i32, ptr %t160
  ret i32 %t188
if.end120:
  %t189 = call i32 @tml_test_modulo()
  store i32 %t189, ptr %t160
  %t190 = load i32, ptr %t160
  %t191 = icmp ne i32 %t190, 0
  br i1 %t191, label %if.then121, label %if.end123
if.then121:
  %t192 = load i32, ptr %t160
  ret i32 %t192
if.end123:
  %t193 = call i32 @tml_test_equality()
  store i32 %t193, ptr %t160
  %t194 = load i32, ptr %t160
  %t195 = icmp ne i32 %t194, 0
  br i1 %t195, label %if.then124, label %if.end126
if.then124:
  %t196 = load i32, ptr %t160
  ret i32 %t196
if.end126:
  %t197 = call i32 @tml_test_comparison_operators()
  store i32 %t197, ptr %t160
  %t198 = load i32, ptr %t160
  %t199 = icmp ne i32 %t198, 0
  br i1 %t199, label %if.then127, label %if.end129
if.then127:
  %t200 = load i32, ptr %t160
  ret i32 %t200
if.end129:
  %t201 = call i32 @tml_test_if_else()
  store i32 %t201, ptr %t160
  %t202 = load i32, ptr %t160
  %t203 = icmp ne i32 %t202, 0
  br i1 %t203, label %if.then130, label %if.end132
if.then130:
  %t204 = load i32, ptr %t160
  ret i32 %t204
if.end132:
  %t205 = call i32 @tml_test_nested_if()
  store i32 %t205, ptr %t160
  %t206 = load i32, ptr %t160
  %t207 = icmp ne i32 %t206, 0
  br i1 %t207, label %if.then133, label %if.end135
if.then133:
  %t208 = load i32, ptr %t160
  ret i32 %t208
if.end135:
  %t209 = call i32 @tml_test_complex_expressions()
  store i32 %t209, ptr %t160
  %t210 = load i32, ptr %t160
  %t211 = icmp ne i32 %t210, 0
  br i1 %t211, label %if.then136, label %if.end138
if.then136:
  %t212 = load i32, ptr %t160
  ret i32 %t212
if.end138:
  %t213 = call i32 @puts(ptr @.str.60)
  ret i32 0
}
; String constants
@.str.0 = private constant [25 x i8] c"--- Hello World Test ---\00"
@.str.1 = private constant [12 x i8] c"Hello, TML!\00"
@.str.2 = private constant [16 x i8] c"Hello World: OK\00"
@.str.3 = private constant [29 x i8] c"--- Variable Declaration ---\00"
@.str.4 = private constant [21 x i8] c"FAIL: x should be 42\00"
@.str.5 = private constant [22 x i8] c"FAIL: y should be 100\00"
@.str.6 = private constant [25 x i8] c"Variable declaration: OK\00"
@.str.7 = private constant [28 x i8] c"--- Variable Assignment ---\00"
@.str.8 = private constant [38 x i8] c"FAIL: x should be 20 after assignment\00"
@.str.9 = private constant [21 x i8] c"FAIL: x should be 25\00"
@.str.10 = private constant [24 x i8] c"Variable assignment: OK\00"
@.str.11 = private constant [17 x i8] c"--- Addition ---\00"
@.str.12 = private constant [26 x i8] c"FAIL: 10 + 5 should be 15\00"
@.str.13 = private constant [30 x i8] c"FAIL: 100 + 200 should be 300\00"
@.str.14 = private constant [13 x i8] c"Addition: OK\00"
@.str.15 = private constant [20 x i8] c"--- Subtraction ---\00"
@.str.16 = private constant [26 x i8] c"FAIL: 20 - 5 should be 15\00"
@.str.17 = private constant [29 x i8] c"FAIL: 1000 - 1 should be 999\00"
@.str.18 = private constant [16 x i8] c"Subtraction: OK\00"
@.str.19 = private constant [23 x i8] c"--- Multiplication ---\00"
@.str.20 = private constant [25 x i8] c"FAIL: 5 * 4 should be 20\00"
@.str.21 = private constant [28 x i8] c"FAIL: 12 * 12 should be 144\00"
@.str.22 = private constant [19 x i8] c"Multiplication: OK\00"
@.str.23 = private constant [17 x i8] c"--- Division ---\00"
@.str.24 = private constant [25 x i8] c"FAIL: 20 / 4 should be 5\00"
@.str.25 = private constant [28 x i8] c"FAIL: 100 / 10 should be 10\00"
@.str.26 = private constant [13 x i8] c"Division: OK\00"
@.str.27 = private constant [15 x i8] c"--- Modulo ---\00"
@.str.28 = private constant [25 x i8] c"FAIL: 10 % 3 should be 1\00"
@.str.29 = private constant [25 x i8] c"FAIL: 20 % 7 should be 6\00"
@.str.30 = private constant [11 x i8] c"Modulo: OK\00"
@.str.31 = private constant [17 x i8] c"--- Equality ---\00"
@.str.32 = private constant [11 x i8] c"5 == 5: OK\00"
@.str.33 = private constant [23 x i8] c"FAIL: 5 should equal 5\00"
@.str.34 = private constant [13 x i8] c"10 != 20: OK\00"
@.str.35 = private constant [29 x i8] c"FAIL: 10 should not equal 20\00"
@.str.36 = private constant [13 x i8] c"Equality: OK\00"
@.str.37 = private constant [29 x i8] c"--- Comparison Operators ---\00"
@.str.38 = private constant [11 x i8] c"10 > 5: OK\00"
@.str.39 = private constant [34 x i8] c"FAIL: 10 should be greater than 5\00"
@.str.40 = private constant [10 x i8] c"3 < 7: OK\00"
@.str.41 = private constant [30 x i8] c"FAIL: 3 should be less than 7\00"
@.str.42 = private constant [13 x i8] c"10 >= 10: OK\00"
@.str.43 = private constant [25 x i8] c"FAIL: 10 should be >= 10\00"
@.str.44 = private constant [11 x i8] c"5 <= 5: OK\00"
@.str.45 = private constant [23 x i8] c"FAIL: 5 should be <= 5\00"
@.str.46 = private constant [25 x i8] c"Comparison operators: OK\00"
@.str.47 = private constant [16 x i8] c"--- If/Else ---\00"
@.str.48 = private constant [27 x i8] c"FAIL: x > 5 should be true\00"
@.str.49 = private constant [28 x i8] c"FAIL: y > 5 should be false\00"
@.str.50 = private constant [12 x i8] c"If/Else: OK\00"
@.str.51 = private constant [18 x i8] c"--- Nested If ---\00"
@.str.52 = private constant [32 x i8] c"FAIL: nested if should return 2\00"
@.str.53 = private constant [14 x i8] c"Nested if: OK\00"
@.str.54 = private constant [28 x i8] c"--- Complex Expressions ---\00"
@.str.55 = private constant [32 x i8] c"FAIL: (10 + 5) * 2 should be 30\00"
@.str.56 = private constant [35 x i8] c"FAIL: 100 - (20 + 10) should be 70\00"
@.str.57 = private constant [38 x i8] c"FAIL: (5 * 4) + (10 / 2) should be 25\00"
@.str.58 = private constant [24 x i8] c"Complex expressions: OK\00"
@.str.59 = private constant [33 x i8] c"=== Core Language Test Suite ===\00"
@.str.60 = private constant [40 x i8] c"=== All core language tests passed! ===\00"

; Entry point
define i32 @main(i32 %argc, ptr %argv) {
entry:
  %ret = call i32 @tml_main()
  ret i32 %ret
}

; Function attributes for optimization
attributes #0 = { nounwind mustprogress willreturn }
