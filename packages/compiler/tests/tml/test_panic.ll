; Generated by TML Compiler
target triple = "x86_64-pc-windows-msvc"

; Runtime type declarations
%struct.tml_str = type { ptr, i64 }

; External function declarations
declare i32 @printf(ptr, ...)
declare i32 @puts(ptr)
declare i32 @putchar(i32)
declare ptr @malloc(i64)
declare void @free(ptr)
declare void @exit(i32) noreturn

; TML runtime functions
declare void @tml_panic(ptr) noreturn

; Threading runtime (tml_runtime.c)
declare ptr @tml_thread_spawn(ptr, ptr)
declare void @tml_thread_join(ptr)
declare void @tml_thread_yield()
declare void @tml_thread_sleep(i32)
declare i32 @tml_thread_id()

; Time functions
declare i32 @tml_time_ms()
declare i64 @tml_time_us()
declare i64 @tml_time_ns()
declare ptr @tml_elapsed_secs(i32)
declare i32 @tml_elapsed_ms(i32)
; Instant API (like Rust)
declare i64 @tml_instant_now()
declare i64 @tml_instant_elapsed(i64)
declare double @tml_duration_as_secs_f64(i64)
declare double @tml_duration_as_millis_f64(i64)
declare i64 @tml_duration_as_millis(i64)
declare ptr @tml_duration_format_ms(i64)
declare ptr @tml_duration_format_secs(i64)
; Black box (prevent optimization)
declare i32 @tml_black_box_i32(i32)
declare i64 @tml_black_box_i64(i64)
; SIMD operations (auto-vectorized)
declare i64 @tml_simd_sum_i32(ptr, i64)
declare i64 @tml_simd_sum_i64(ptr, i64)
declare double @tml_simd_sum_f64(ptr, i64)
declare double @tml_simd_dot_f64(ptr, ptr, i64)
declare void @tml_simd_fill_i32(ptr, i32, i64)
declare void @tml_simd_add_i32(ptr, ptr, ptr, i64)
declare void @tml_simd_mul_i32(ptr, ptr, ptr, i64)

; Float functions
declare ptr @tml_float_to_fixed(double, i32)
declare ptr @tml_float_to_precision(double, i32)
declare ptr @tml_float_to_string(double)
declare double @tml_int_to_float(i32)
declare double @tml_i64_to_float(i64)
declare i32 @tml_float_to_int(double)
declare i64 @tml_float_to_i64(double)
declare i32 @tml_float_round(double)
declare i32 @tml_float_floor(double)
declare i32 @tml_float_ceil(double)
declare double @tml_float_abs(double)
declare double @tml_float_sqrt(double)
declare double @tml_float_pow(double, i32)

; Channel runtime (Go-style)
declare ptr @tml_channel_create()
declare i32 @tml_channel_send(ptr, i32)
declare i32 @tml_channel_recv(ptr, ptr)
declare i32 @tml_channel_try_send(ptr, i32)
declare i32 @tml_channel_try_recv(ptr, ptr)
declare void @tml_channel_close(ptr)
declare void @tml_channel_destroy(ptr)
declare i32 @tml_channel_len(ptr)

; Mutex runtime
declare ptr @tml_mutex_create()
declare void @tml_mutex_lock(ptr)
declare void @tml_mutex_unlock(ptr)
declare i32 @tml_mutex_try_lock(ptr)
declare void @tml_mutex_destroy(ptr)

; WaitGroup runtime (Go-style)
declare ptr @tml_waitgroup_create()
declare void @tml_waitgroup_add(ptr, i32)
declare void @tml_waitgroup_done(ptr)
declare void @tml_waitgroup_wait(ptr)
declare void @tml_waitgroup_destroy(ptr)

; Atomic counter runtime
declare ptr @tml_atomic_counter_create(i32)
declare i32 @tml_atomic_counter_inc(ptr)
declare i32 @tml_atomic_counter_dec(ptr)
declare i32 @tml_atomic_counter_get(ptr)
declare void @tml_atomic_counter_set(ptr, i32)
declare void @tml_atomic_counter_destroy(ptr)

; List (dynamic array) runtime
declare ptr @tml_list_create(i32)
declare void @tml_list_destroy(ptr)
declare void @tml_list_push(ptr, i32)
declare i32 @tml_list_pop(ptr)
declare i32 @tml_list_get(ptr, i32)
declare void @tml_list_set(ptr, i32, i32)
declare i32 @tml_list_len(ptr)
declare i32 @tml_list_capacity(ptr)
declare void @tml_list_clear(ptr)
declare i32 @tml_list_is_empty(ptr)

; HashMap runtime
declare ptr @tml_hashmap_create()
declare void @tml_hashmap_destroy(ptr)
declare void @tml_hashmap_set(ptr, i32, i32)
declare i32 @tml_hashmap_get(ptr, i32, ptr)
declare i32 @tml_hashmap_has(ptr, i32)
declare i32 @tml_hashmap_remove(ptr, i32)
declare i32 @tml_hashmap_len(ptr)
declare void @tml_hashmap_clear(ptr)

; Buffer runtime
declare ptr @tml_buffer_create(i32)
declare void @tml_buffer_destroy(ptr)
declare void @tml_buffer_write_byte(ptr, i32)
declare void @tml_buffer_write_i32(ptr, i32)
declare i32 @tml_buffer_read_byte(ptr)
declare i32 @tml_buffer_read_i32(ptr)
declare i32 @tml_buffer_len(ptr)
declare i32 @tml_buffer_capacity(ptr)
declare i32 @tml_buffer_remaining(ptr)
declare void @tml_buffer_clear(ptr)
declare void @tml_buffer_reset_read(ptr)

; String utilities
declare i32 @tml_str_len(ptr)
declare i32 @tml_str_hash(ptr)
declare i32 @tml_str_eq(ptr, ptr)

; Format strings
@.fmt.int = private constant [4 x i8] c"%d\0A\00"
@.fmt.int.no_nl = private constant [3 x i8] c"%d\00"
@.fmt.i64 = private constant [5 x i8] c"%ld\0A\00"
@.fmt.i64.no_nl = private constant [4 x i8] c"%ld\00"
@.fmt.float = private constant [4 x i8] c"%f\0A\00"
@.fmt.float.no_nl = private constant [3 x i8] c"%f\00"
@.fmt.float3 = private constant [6 x i8] c"%.3f\0A\00"
@.fmt.float3.no_nl = private constant [5 x i8] c"%.3f\00"
@.fmt.str.no_nl = private constant [3 x i8] c"%s\00"
@.str.true = private constant [5 x i8] c"true\00"
@.str.false = private constant [6 x i8] c"false\00"
@.str.space = private constant [2 x i8] c" \00"
@.str.newline = private constant [2 x i8] c"\0A\00"


define void @tml_main() #0 {
entry:
  %t0 = call i32 @puts(ptr @.str.0)
  call void @tml_panic(ptr @.str.1)
  unreachable
  %t1 = call i32 @puts(ptr @.str.2)
}
; String constants
@.str.0 = private constant [15 x i8] c"About to panic\00"
@.str.1 = private constant [21 x i8] c"This is a test panic\00"
@.str.2 = private constant [22 x i8] c"This should not print\00"

; Entry point
define i32 @main(i32 %argc, ptr %argv) {
entry:
  %ret = call i32 @tml_main()
  ret i32 %ret
}

; Function attributes for optimization
attributes #0 = { nounwind mustprogress willreturn }
