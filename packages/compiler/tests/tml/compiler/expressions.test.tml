use test

// ============ Arithmetic Expressions ============

@test
func test_basic_arithmetic() -> I32 {
    // Simple operations
    assert_eq_i32(1 + 1, 2, "1+1")
    assert_eq_i32(5 - 3, 2, "5-3")
    assert_eq_i32(4 * 3, 12, "4*3")
    assert_eq_i32(10 / 2, 5, "10/2")
    assert_eq_i32(10 % 3, 1, "10%3")

    return 0
}

@test
func test_operator_precedence() -> I32 {
    // Multiplication before addition
    assert_eq_i32(2 + 3 * 4, 14, "2+3*4")
    assert_eq_i32(10 - 2 * 3, 4, "10-2*3")

    // Division before subtraction
    assert_eq_i32(10 - 6 / 2, 7, "10-6/2")

    // With parentheses
    assert_eq_i32((2 + 3) * 4, 20, "(2+3)*4")
    assert_eq_i32(2 * (3 + 4), 14, "2*(3+4)")

    return 0
}

@test
func test_nested_parentheses() -> I32 {
    assert_eq_i32(((1 + 2) * 3), 9, "((1+2)*3)")
    assert_eq_i32((2 * (3 + (4 - 1))), 12, "(2*(3+(4-1)))")
    assert_eq_i32(((10 - 5) * (4 - 2)), 10, "((10-5)*(4-2))")

    return 0
}

// ============ Unary Operations ============

@test
func test_unary_minus() -> I32 {
    assert_eq_i32(-5, 0 - 5, "-5")
    assert_eq_i32(-10 + 15, 5, "-10+15")
    assert_eq_i32(5 + -3, 2, "5+-3")

    let x: I32 = 10
    let neg_x: I32 = 0 - x
    assert_eq_i32(neg_x, -10, "-x")

    return 0
}

// ============ Boolean Expressions ============

@test
func test_comparison_ops() -> I32 {
    // Less than
    let r1: I32 = if 3 < 5 then 1 else 0
    assert_eq_i32(r1, 1, "3 < 5")

    // Greater than
    let r2: I32 = if 5 > 3 then 1 else 0
    assert_eq_i32(r2, 1, "5 > 3")

    // Equal
    let r3: I32 = if 5 == 5 then 1 else 0
    assert_eq_i32(r3, 1, "5 == 5")

    // Not equal
    let r4: I32 = if 5 != 3 then 1 else 0
    assert_eq_i32(r4, 1, "5 != 3")

    // Less or equal
    let r5: I32 = if 5 <= 5 then 1 else 0
    assert_eq_i32(r5, 1, "5 <= 5")

    // Greater or equal
    let r6: I32 = if 5 >= 5 then 1 else 0
    assert_eq_i32(r6, 1, "5 >= 5")

    return 0
}

@test
func test_logical_ops() -> I32 {
    // AND
    let r1: I32 = if true and true then 1 else 0
    assert_eq_i32(r1, 1, "T and T")

    let r2: I32 = if true and false then 1 else 0
    assert_eq_i32(r2, 0, "T and F")

    // OR
    let r3: I32 = if true or false then 1 else 0
    assert_eq_i32(r3, 1, "T or F")

    let r4: I32 = if false or false then 1 else 0
    assert_eq_i32(r4, 0, "F or F")

    // NOT
    let r5: I32 = if not false then 1 else 0
    assert_eq_i32(r5, 1, "not F")

    let r6: I32 = if not true then 1 else 0
    assert_eq_i32(r6, 0, "not T")

    return 0
}

@test
func test_complex_boolean() -> I32 {
    let x: I32 = 5
    let y: I32 = 10

    let r1: I32 = if x > 0 and y > 0 then 1 else 0
    assert_eq_i32(r1, 1, "both positive")

    let r2: I32 = if x > 10 or y > 5 then 1 else 0
    assert_eq_i32(r2, 1, "at least one true")

    let r3: I32 = if not (x > 10) then 1 else 0
    assert_eq_i32(r3, 1, "not x > 10")

    return 0
}

// ============ If Expressions ============

@test
func test_if_expression() -> I32 {
    let x: I32 = if true then 10 else 20
    assert_eq_i32(x, 10, "if true")

    let y: I32 = if false then 10 else 20
    assert_eq_i32(y, 20, "if false")

    return 0
}

@test
func test_if_with_vars() -> I32 {
    let a: I32 = 5
    let b: I32 = 10

    let max: I32 = if a > b then a else b
    assert_eq_i32(max, 10, "max(5, 10)")

    let min: I32 = if a < b then a else b
    assert_eq_i32(min, 5, "min(5, 10)")

    return 0
}

@test
func test_conditional_assignment() -> I32 {
    let x: I32 = 5

    // Simple conditional
    let positive: Bool = x > 0
    assert(positive, "5 > 0")

    // Result computed from condition
    let abs_x: I32 = if x >= 0 then x else 0 - x
    assert_eq_i32(abs_x, 5, "abs(5)")

    return 0
}

// ============ Bitwise Expressions ============

@test
func test_bitwise_and() -> I32 {
    assert_eq_i32(0xFF & 0x0F, 0x0F, "0xFF & 0x0F")
    assert_eq_i32(0b1010 & 0b1100, 0b1000, "1010 & 1100")
    assert_eq_i32(0 & 255, 0, "0 & 255")

    return 0
}

@test
func test_bitwise_or() -> I32 {
    assert_eq_i32(0xF0 | 0x0F, 0xFF, "0xF0 | 0x0F")
    assert_eq_i32(0b1010 | 0b0101, 0b1111, "1010 | 0101")
    assert_eq_i32(0 | 255, 255, "0 | 255")

    return 0
}

@test
func test_bitwise_xor() -> I32 {
    assert_eq_i32(0xFF ^ 0xFF, 0, "0xFF ^ 0xFF")
    assert_eq_i32(0b1010 ^ 0b1100, 0b0110, "1010 ^ 1100")
    assert_eq_i32(0 ^ 255, 255, "0 ^ 255")

    return 0
}

@test
func test_bitwise_shift() -> I32 {
    assert_eq_i32(1 << 4, 16, "1 << 4")
    assert_eq_i32(16 >> 2, 4, "16 >> 2")
    assert_eq_i32(8 << 1, 16, "8 << 1")
    assert_eq_i32(32 >> 3, 4, "32 >> 3")

    return 0
}
