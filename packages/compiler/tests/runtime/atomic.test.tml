use test

// Atomic Operation Tests

@test
func test_atomic_store_load() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 42)
    let value: I32 = atomic_load(ptr)
    assert_eq_i32(value, 42, "Should load stored value")
    dealloc(ptr)
    0
}

@test
func test_atomic_add() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 10)
    let old: I32 = atomic_add(ptr, 5)
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 10, "Should return old value")
    assert_eq_i32(new, 15, "Should have new value 15")
    dealloc(ptr)
    0
}

@test
func test_atomic_sub() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 20)
    let old: I32 = atomic_sub(ptr, 7)
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 20, "Should return old value")
    assert_eq_i32(new, 13, "Should have new value 13")
    dealloc(ptr)
    0
}

@test
func test_atomic_exchange() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 100)
    let old: I32 = atomic_exchange(ptr, 200)
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 100, "Should return old value")
    assert_eq_i32(new, 200, "Should have new value 200")
    dealloc(ptr)
    0
}

@test
func test_atomic_cas_success() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 50)
    let success: Bool = atomic_cas(ptr, 50, 100)
    let value: I32 = atomic_load(ptr)
    assert_eq_bool(success, true, "CAS should succeed")
    assert_eq_i32(value, 100, "Value should be updated to 100")
    dealloc(ptr)
    0
}

@test
func test_atomic_cas_failure() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 50)
    let success: Bool = atomic_cas(ptr, 99, 100)
    let value: I32 = atomic_load(ptr)
    assert_eq_bool(success, false, "CAS should fail")
    assert_eq_i32(value, 50, "Value should remain 50")
    dealloc(ptr)
    0
}

@test
func test_atomic_cas_val() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 75)
    let old: I32 = atomic_cas_val(ptr, 75, 150)
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 75, "Should return old value")
    assert_eq_i32(new, 150, "Should have new value 150")
    dealloc(ptr)
    0
}

@test
func test_atomic_and() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 15)  // 1111 in binary
    let old: I32 = atomic_and(ptr, 7)  // 0111 in binary
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 15, "Should return old value")
    assert_eq_i32(new, 7, "Should have new value 7 (1111 & 0111 = 0111)")
    dealloc(ptr)
    0
}

@test
func test_atomic_or() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 8)  // 1000 in binary
    let old: I32 = atomic_or(ptr, 4)  // 0100 in binary
    let new: I32 = atomic_load(ptr)
    assert_eq_i32(old, 8, "Should return old value")
    assert_eq_i32(new, 12, "Should have new value 12 (1000 | 0100 = 1100)")
    dealloc(ptr)
    0
}

@test
func test_atomic_increment_pattern() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    atomic_store(ptr, 0)

    // Increment 10 times
    let mut i: I32 = 0
    loop {
        if i >= 10 then break
        atomic_add(ptr, 1)
        i = i + 1
    }

    let result: I32 = atomic_load(ptr)
    assert_eq_i32(result, 10, "Should have incremented to 10")
    dealloc(ptr)
    0
}

@test
func test_fence_basic() -> I32 {
    fence()
    0
}

@test
func test_fence_acquire() -> I32 {
    fence_acquire()
    0
}

@test
func test_fence_release() -> I32 {
    fence_release()
    0
}

@test
func test_spinlock_basic() -> I32 {
    let lock: mut ref I32 = alloc(1)
    atomic_store(lock, 0)  // Initialize lock to unlocked

    spin_lock(lock)
    // Critical section
    spin_unlock(lock)

    dealloc(lock)
    0
}

@test
func test_spin_trylock_success() -> I32 {
    let lock: mut ref I32 = alloc(1)
    atomic_store(lock, 0)  // Initialize lock to unlocked

    let acquired: Bool = spin_trylock(lock)
    assert_eq_bool(acquired, true, "Should acquire unlocked lock")

    spin_unlock(lock)
    dealloc(lock)
    0
}
