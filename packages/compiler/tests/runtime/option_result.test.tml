// Test Maybe[T] and Outcome[T,E] types
use test

// ============ Maybe Type ============

type Maybe[T] {
    Just(T),
    Nothing,
}

func is_just[T](opt: Maybe[T]) -> Bool {
    return when opt {
        Just(_) => true,
        Nothing => false
    }
}

func is_nothing[T](opt: Maybe[T]) -> Bool {
    return when opt {
        Just(_) => false,
        Nothing => true
    }
}

func unwrap_or[T](opt: Maybe[T], default: T) -> T {
    return when opt {
        Just(v) => v,
        Nothing => default
    }
}

@test
func test_maybe_creation() -> I32 {
    let some: Maybe[I32] = Just(42)
    let none: Maybe[I32] = Nothing

    assert(is_just(some), "Just should be just")
    assert(is_nothing(none), "Nothing should be nothing")
    return 0
}

@test
func test_maybe_unwrap() -> I32 {
    let some: Maybe[I32] = Just(100)
    let none: Maybe[I32] = Nothing

    // Use manual comparison since generic assert_eq may not work with I32
    let val1: I32 = unwrap_or(some, 0)
    assert(val1 == 100, "unwrap Just returns value")
    let val2: I32 = unwrap_or(none, -1)
    assert(val2 == -1, "unwrap Nothing returns default")
    return 0
}

func safe_divide(a: I32, b: I32) -> Maybe[I32] {
    if b == 0 then {
        return Nothing
    }
    return Just(a / b)
}

@test
func test_maybe_safe_divide() -> I32 {
    let good: Maybe[I32] = safe_divide(10, 2)
    let bad: Maybe[I32] = safe_divide(10, 0)

    let val: I32 = unwrap_or(good, 0)
    assert(val == 5, "10/2 = 5")
    assert(is_nothing(bad), "division by zero returns Nothing")
    return 0
}

// ============ Outcome Type ============

type Outcome[T, E] {
    Ok(T),
    Err(E),
}

func is_ok[T, E](res: Outcome[T, E]) -> Bool {
    return when res {
        Ok(_) => true,
        Err(_) => false
    }
}

func is_err[T, E](res: Outcome[T, E]) -> Bool {
    return when res {
        Ok(_) => false,
        Err(_) => true
    }
}

func unwrap_outcome[T, E](res: Outcome[T, E], default: T) -> T {
    return when res {
        Ok(v) => v,
        Err(_) => default
    }
}

@test
func test_outcome_creation() -> I32 {
    let ok: Outcome[I32, Str] = Ok(42)
    let err: Outcome[I32, Str] = Err("error message")

    assert(is_ok(ok), "Ok should be ok")
    assert(is_err(err), "Err should be err")
    return 0
}

@test
func test_outcome_unwrap() -> I32 {
    let ok: Outcome[I32, Str] = Ok(100)
    let err: Outcome[I32, Str] = Err("failed")

    let val1: I32 = unwrap_outcome(ok, 0)
    assert(val1 == 100, "unwrap Ok returns value")
    let val2: I32 = unwrap_outcome(err, -1)
    assert(val2 == -1, "unwrap Err returns default")
    return 0
}

func parse_positive(s: Str) -> Outcome[I32, Str] {
    if str_eq(s, "42") then {
        return Ok(42)
    }
    if str_eq(s, "100") then {
        return Ok(100)
    }
    return Err("invalid input")
}

@test
func test_outcome_parsing() -> I32 {
    let good: Outcome[I32, Str] = parse_positive("42")
    let bad: Outcome[I32, Str] = parse_positive("xyz")

    assert(is_ok(good), "42 should parse")
    assert(is_err(bad), "xyz should fail")
    let val: I32 = unwrap_outcome(good, 0)
    assert(val == 42, "parsed value should be 42")
    return 0
}
