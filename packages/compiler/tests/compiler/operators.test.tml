use test

// ============ Arithmetic Operators ============

@test
func test_arithmetic_basic() -> I32 {
    // Addition
    assert_eq(5 + 3, 8, "5 + 3 should equal 8")
    assert_eq(0 + 0, 0, "0 + 0 should equal 0")
    assert_eq(-5 + 3, -2, "-5 + 3 should equal -2")

    // Subtraction
    assert_eq(10 - 3, 7, "10 - 3 should equal 7")
    assert_eq(3 - 10, -7, "3 - 10 should equal -7")
    assert_eq(0 - 5, -5, "0 - 5 should equal -5")

    // Multiplication
    assert_eq(4 * 3, 12, "4 * 3 should equal 12")
    assert_eq(-4 * 3, -12, "-4 * 3 should equal -12")
    assert_eq(-4 * -3, 12, "-4 * -3 should equal 12")
    assert_eq(0 * 100, 0, "0 * 100 should equal 0")

    // Division
    assert_eq(12 / 3, 4, "12 / 3 should equal 4")
    assert_eq(10 / 3, 3, "10 / 3 should equal 3 (integer division)")
    assert_eq(-12 / 3, -4, "-12 / 3 should equal -4")

    // Modulo
    assert_eq(10 % 3, 1, "10 % 3 should equal 1")
    assert_eq(12 % 4, 0, "12 % 4 should equal 0")
    assert_eq(7 % 2, 1, "7 % 2 should equal 1")

    return 0
}

@test
func test_arithmetic_compound() -> I32 {
    // Compound expressions
    assert_eq(2 + 3 * 4, 14, "2 + 3 * 4 should equal 14 (precedence)")
    assert_eq((2 + 3) * 4, 20, "(2 + 3) * 4 should equal 20")
    assert_eq(10 - 2 - 3, 5, "10 - 2 - 3 should equal 5 (left associative)")
    assert_eq(100 / 10 / 2, 5, "100 / 10 / 2 should equal 5")

    // Complex expressions
    let a: I32 = 5
    let b: I32 = 3
    let c: I32 = 2
    assert_eq(a * b + c, 17, "5 * 3 + 2 should equal 17")
    assert_eq(a + b * c, 11, "5 + 3 * 2 should equal 11")
    assert_eq((a + b) * c, 16, "(5 + 3) * 2 should equal 16")

    return 0
}

// ============ Comparison Operators ============

@test
func test_comparison_equality() -> I32 {
    // Equal
    assert(5 == 5, "5 == 5 should be true")
    assert(not (5 == 6), "5 == 6 should be false")
    assert(0 == 0, "0 == 0 should be true")
    assert(-1 == -1, "-1 == -1 should be true")

    // Not equal
    assert(5 != 6, "5 != 6 should be true")
    assert(not (5 != 5), "5 != 5 should be false")

    return 0
}

@test
func test_comparison_relational() -> I32 {
    // Less than
    assert(3 < 5, "3 < 5 should be true")
    assert(not (5 < 3), "5 < 3 should be false")
    assert(not (5 < 5), "5 < 5 should be false")

    // Less than or equal
    assert(3 <= 5, "3 <= 5 should be true")
    assert(5 <= 5, "5 <= 5 should be true")
    assert(not (6 <= 5), "6 <= 5 should be false")

    // Greater than
    assert(5 > 3, "5 > 3 should be true")
    assert(not (3 > 5), "3 > 5 should be false")
    assert(not (5 > 5), "5 > 5 should be false")

    // Greater than or equal
    assert(5 >= 3, "5 >= 3 should be true")
    assert(5 >= 5, "5 >= 5 should be true")
    assert(not (3 >= 5), "3 >= 5 should be false")

    return 0
}

// ============ Logical Operators ============

@test
func test_logical_and() -> I32 {
    assert(true and true, "true and true should be true")
    assert(not (true and false), "true and false should be false")
    assert(not (false and true), "false and true should be false")
    assert(not (false and false), "false and false should be false")

    // Short-circuit evaluation
    let x: I32 = 5
    assert(x > 0 and x < 10, "5 > 0 and 5 < 10 should be true")
    assert(not (x > 10 and x < 20), "5 > 10 and 5 < 20 should be false")

    return 0
}

@test
func test_logical_or() -> I32 {
    assert(true or true, "true or true should be true")
    assert(true or false, "true or false should be true")
    assert(false or true, "false or true should be true")
    assert(not (false or false), "false or false should be false")

    // Short-circuit evaluation
    let x: I32 = 5
    assert(x < 0 or x > 0, "5 < 0 or 5 > 0 should be true")
    assert(not (x < 0 or x > 10), "5 < 0 or 5 > 10 should be false")

    return 0
}

@test
func test_logical_not() -> I32 {
    assert(not false, "not false should be true")
    assert(not (not true), "not (not true) should be true")

    let x: I32 = 5
    assert(not (x < 0), "not (5 < 0) should be true")
    assert(not (x > 10), "not (5 > 10) should be true")

    return 0
}

@test
func test_logical_compound() -> I32 {
    let a: Bool = true
    let b: Bool = false
    let c: Bool = true

    // Compound expressions
    assert(a and c, "true and true should be true")
    assert(a or b, "true or false should be true")
    assert(not b, "not false should be true")

    // Mixed precedence
    assert((a or b) and c, "(true or false) and true should be true")
    assert(a and (b or c), "true and (false or true) should be true")
    assert(not (b and c), "not (false and true) should be true")

    return 0
}

// ============ Bitwise Operators ============

@test
func test_bitwise_and() -> I32 {
    assert_eq(0b1010 & 0b1100, 0b1000, "1010 & 1100 should equal 1000")
    assert_eq(0xFF & 0x0F, 0x0F, "0xFF & 0x0F should equal 0x0F")
    assert_eq(0 & 255, 0, "0 & 255 should equal 0")
    return 0
}

@test
func test_bitwise_or() -> I32 {
    assert_eq(0b1010 | 0b0101, 0b1111, "1010 | 0101 should equal 1111")
    assert_eq(0xF0 | 0x0F, 0xFF, "0xF0 | 0x0F should equal 0xFF")
    assert_eq(0 | 255, 255, "0 | 255 should equal 255")
    return 0
}

@test
func test_bitwise_xor() -> I32 {
    assert_eq(0b1010 ^ 0b1100, 0b0110, "1010 ^ 1100 should equal 0110")
    assert_eq(0xFF ^ 0xFF, 0, "0xFF ^ 0xFF should equal 0")
    assert_eq(0 ^ 255, 255, "0 ^ 255 should equal 255")
    return 0
}

@test
func test_bitwise_shift() -> I32 {
    // Left shift
    assert_eq(1 << 4, 16, "1 << 4 should equal 16")
    assert_eq(3 << 2, 12, "3 << 2 should equal 12")

    // Right shift
    assert_eq(16 >> 2, 4, "16 >> 2 should equal 4")
    assert_eq(255 >> 4, 15, "255 >> 4 should equal 15")

    return 0
}
