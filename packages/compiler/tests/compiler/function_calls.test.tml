use test

// ============ Basic Function Calls ============

func identity(x: I32) -> I32 {
    return x
}

func add(a: I32, b: I32) -> I32 {
    return a + b
}

func multiply(a: I32, b: I32) -> I32 {
    return a * b
}

@test
func test_basic_calls() -> I32 {
    assert_eq(identity(42), 42, "identity")
    assert_eq(add(3, 4), 7, "add")
    assert_eq(multiply(6, 7), 42, "multiply")

    return 0
}

// ============ Nested Function Calls ============

func square(x: I32) -> I32 {
    return multiply(x, x)
}

func cube(x: I32) -> I32 {
    return multiply(x, square(x))
}

@test
func test_nested_calls() -> I32 {
    assert_eq(square(5), 25, "square 5")
    assert_eq(cube(3), 27, "cube 3")
    assert_eq(add(square(2), square(3)), 13, "2^2 + 3^2")

    return 0
}

// ============ Functions as Parameters ============

func double(x: I32) -> I32 {
    return multiply(x, 2)
}

func triple(x: I32) -> I32 {
    return multiply(x, 3)
}

func apply_twice(x: I32, first_result: I32) -> I32 {
    // Simulates f(f(x)) where f is double
    return double(first_result)
}

@test
func test_function_composition() -> I32 {
    // double(double(5)) = double(10) = 20
    let r1: I32 = double(5)
    let r2: I32 = double(r1)
    assert_eq(r2, 20, "double twice")

    // triple(triple(2)) = triple(6) = 18
    let r3: I32 = triple(2)
    let r4: I32 = triple(r3)
    assert_eq(r4, 18, "triple twice")

    return 0
}

// ============ Multiple Parameters ============

func sum_three(a: I32, b: I32, c: I32) -> I32 {
    return a + b + c
}

func sum_four(a: I32, b: I32, c: I32, d: I32) -> I32 {
    return a + b + c + d
}

func sum_five(a: I32, b: I32, c: I32, d: I32, e: I32) -> I32 {
    return a + b + c + d + e
}

@test
func test_multiple_params() -> I32 {
    assert_eq(sum_three(1, 2, 3), 6, "sum 3")
    assert_eq(sum_four(1, 2, 3, 4), 10, "sum 4")
    assert_eq(sum_five(1, 2, 3, 4, 5), 15, "sum 5")

    return 0
}

// ============ Return Value Usage ============

@test
func test_return_in_expression() -> I32 {
    let result: I32 = add(multiply(2, 3), multiply(4, 5))
    assert_eq(result, 26, "(2*3) + (4*5)")

    let complex: I32 = sum_three(square(2), square(3), square(4))
    assert_eq(complex, 29, "4 + 9 + 16")

    return 0
}

// ============ Boolean Functions ============

func is_positive(x: I32) -> Bool {
    return x > 0
}

func is_zero(x: I32) -> Bool {
    return x == 0
}

func is_negative(x: I32) -> Bool {
    return x < 0
}

@test
func test_bool_functions() -> I32 {
    assert(is_positive(5), "5 positive")
    assert(is_zero(0), "0 is zero")
    assert(is_negative(0 - 3), "-3 negative")

    assert_eq(is_positive(0), false, "0 not positive")
    assert_eq(is_negative(5), false, "5 not negative")

    return 0
}

// ============ Early Return ============

func abs_value(x: I32) -> I32 {
    if x >= 0 then {
        return x
    }
    return 0 - x
}

func sign(x: I32) -> I32 {
    if x > 0 then { return 1 }
    if x < 0 then { return 0 - 1 }
    return 0
}

@test
func test_early_return() -> I32 {
    assert_eq(abs_value(5), 5, "abs(5)")
    assert_eq(abs_value(0 - 5), 5, "abs(-5)")
    assert_eq(abs_value(0), 0, "abs(0)")

    assert_eq(sign(10), 1, "sign(10)")
    assert_eq(sign(0 - 10), 0 - 1, "sign(-10)")
    assert_eq(sign(0), 0, "sign(0)")

    return 0
}

// ============ Chain of Calls ============

func increment(x: I32) -> I32 {
    return x + 1
}

func decrement(x: I32) -> I32 {
    return x - 1
}

@test
func test_call_chain() -> I32 {
    let mut x: I32 = 0
    x = increment(x)
    x = increment(x)
    x = increment(x)
    assert_eq(x, 3, "3 increments")

    x = decrement(x)
    assert_eq(x, 2, "after decrement")

    return 0
}

// ============ Conditional Function Calls ============

func safe_div(a: I32, b: I32) -> I32 {
    if b == 0 then {
        return 0
    }
    return a / b
}

@test
func test_safe_division() -> I32 {
    assert_eq(safe_div(10, 2), 5, "10 / 2")
    assert_eq(safe_div(10, 0), 0, "10 / 0 safe")
    assert_eq(safe_div(100, 10), 10, "100 / 10")

    return 0
}
