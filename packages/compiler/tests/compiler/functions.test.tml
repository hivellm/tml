use test

// ============ Basic Functions ============

func add(a: I32, b: I32) -> I32 {
    return a + b
}

func multiply(a: I32, b: I32) -> I32 {
    return a * b
}

func identity(x: I32) -> I32 {
    return x
}

func constant_five() -> I32 {
    return 5
}

@test
func test_basic_functions() -> I32 {
    assert_eq(add(2, 3), 5, "add(2, 3) should equal 5")
    assert_eq(add(0, 0), 0, "add(0, 0) should equal 0")
    assert_eq(add(-5, 5), 0, "add(-5, 5) should equal 0")

    assert_eq(multiply(3, 4), 12, "multiply(3, 4) should equal 12")
    assert_eq(multiply(0, 100), 0, "multiply(0, 100) should equal 0")

    assert_eq(identity(42), 42, "identity(42) should equal 42")
    assert_eq(constant_five(), 5, "constant_five() should equal 5")

    return 0
}

// ============ Function Composition ============

func double(x: I32) -> I32 {
    return x * 2
}

func increment(x: I32) -> I32 {
    return x + 1
}

func square(x: I32) -> I32 {
    return x * x
}

@test
func test_function_composition() -> I32 {
    // Nested calls
    assert_eq(double(increment(5)), 12, "double(increment(5)) should equal 12")
    assert_eq(increment(double(5)), 11, "increment(double(5)) should equal 11")
    assert_eq(square(double(3)), 36, "square(double(3)) should equal 36")

    // Triple nesting
    assert_eq(double(double(double(2))), 16, "double(double(double(2))) should equal 16")
    assert_eq(increment(increment(increment(0))), 3, "increment 3 times should equal 3")

    return 0
}

// ============ Recursion ============

func factorial(n: I32) -> I32 {
    if n <= 1 then {
        return 1
    }
    return n * factorial(n - 1)
}

func fibonacci(n: I32) -> I32 {
    if n <= 1 then {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

func sum_to_n(n: I32) -> I32 {
    if n <= 0 then {
        return 0
    }
    return n + sum_to_n(n - 1)
}

@test
func test_recursion() -> I32 {
    // Factorial
    assert_eq(factorial(0), 1, "factorial(0) should equal 1")
    assert_eq(factorial(1), 1, "factorial(1) should equal 1")
    assert_eq(factorial(5), 120, "factorial(5) should equal 120")
    assert_eq(factorial(6), 720, "factorial(6) should equal 720")

    // Fibonacci
    assert_eq(fibonacci(0), 0, "fibonacci(0) should equal 0")
    assert_eq(fibonacci(1), 1, "fibonacci(1) should equal 1")
    assert_eq(fibonacci(10), 55, "fibonacci(10) should equal 55")

    // Sum
    assert_eq(sum_to_n(0), 0, "sum_to_n(0) should equal 0")
    assert_eq(sum_to_n(5), 15, "sum_to_n(5) should equal 15")
    assert_eq(sum_to_n(10), 55, "sum_to_n(10) should equal 55")

    return 0
}

// ============ Multiple Parameters ============

func three_params(a: I32, b: I32, c: I32) -> I32 {
    return a + b + c
}

func mixed_operations(a: I32, b: I32, c: I32, d: I32) -> I32 {
    return (a + b) * (c - d)
}

@test
func test_multiple_params() -> I32 {
    assert_eq(three_params(1, 2, 3), 6, "three_params(1, 2, 3) should equal 6")
    assert_eq(three_params(0, 0, 0), 0, "three_params(0, 0, 0) should equal 0")

    assert_eq(mixed_operations(2, 3, 10, 5), 25, "(2+3) * (10-5) should equal 25")
    assert_eq(mixed_operations(1, 1, 5, 5), 0, "(1+1) * (5-5) should equal 0")

    return 0
}

// ============ Early Return ============

func abs_value(x: I32) -> I32 {
    if x >= 0 then {
        return x
    }
    return 0 - x
}

func clamp(value: I32, min: I32, max: I32) -> I32 {
    if value < min then {
        return min
    }
    if value > max then {
        return max
    }
    return value
}

func sign(x: I32) -> I32 {
    if x > 0 then {
        return 1
    }
    if x < 0 then {
        return -1
    }
    return 0
}

@test
func test_early_return() -> I32 {
    // Absolute value
    assert_eq(abs_value(5), 5, "abs_value(5) should equal 5")
    assert_eq(abs_value(-5), 5, "abs_value(-5) should equal 5")
    assert_eq(abs_value(0), 0, "abs_value(0) should equal 0")

    // Clamp
    assert_eq(clamp(5, 0, 10), 5, "clamp(5, 0, 10) should equal 5")
    assert_eq(clamp(-5, 0, 10), 0, "clamp(-5, 0, 10) should equal 0")
    assert_eq(clamp(15, 0, 10), 10, "clamp(15, 0, 10) should equal 10")

    // Sign
    assert_eq(sign(10), 1, "sign(10) should equal 1")
    assert_eq(sign(-10), -1, "sign(-10) should equal -1")
    assert_eq(sign(0), 0, "sign(0) should equal 0")

    return 0
}

// ============ Boolean Functions ============

func is_even(n: I32) -> Bool {
    return n % 2 == 0
}

func is_positive(n: I32) -> Bool {
    return n > 0
}

func both_positive(a: I32, b: I32) -> Bool {
    let a_pos: Bool = is_positive(a)
    let b_pos: Bool = is_positive(b)
    return a_pos and b_pos
}

@test
func test_boolean_functions() -> I32 {
    // Test is_even
    assert(is_even(4), "4 should be even")
    assert(is_even(0), "0 should be even")
    assert_eq(is_even(5), false, "5 should not be even")
    assert_eq(is_even(7), false, "7 should not be even")

    // Test is_positive
    assert(is_positive(5), "5 should be positive")
    assert_eq(is_positive(-5), false, "-5 should not be positive")
    assert_eq(is_positive(0), false, "0 should not be positive")

    // Test both_positive
    assert(both_positive(3, 4), "both_positive(3, 4) should be true")
    assert_eq(both_positive(-1, 4), false, "both_positive(-1, 4) should be false")
    assert_eq(both_positive(3, -1), false, "both_positive(3, -1) should be false")
    assert_eq(both_positive(-1, -1), false, "both_positive(-1, -1) should be false")

    return 0
}
