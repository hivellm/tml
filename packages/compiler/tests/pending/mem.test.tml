use test
use core::mem

// Memory Operation Tests

@test
func test_alloc_dealloc_basic() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    dealloc(ptr)
    return 0
}

@test
func test_write_read_i32() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    write_i32(ptr, 42)
    let value: I32 = read_i32(ptr)
    assert_eq(value, 42, "Should read back written value")
    dealloc(ptr)
    return 0
}

@test
func test_write_read_negative() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    write_i32(ptr, -100)
    let value: I32 = read_i32(ptr)
    assert_eq(value, -100, "Should read back negative value")
    dealloc(ptr)
    return 0
}

@test
func test_write_read_zero() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    write_i32(ptr, 0)
    let value: I32 = read_i32(ptr)
    assert_eq(value, 0, "Should read back zero")
    dealloc(ptr)
    return 0
}

@test
func test_multiple_writes() -> I32 {
    let ptr: mut ref I32 = alloc(1)
    write_i32(ptr, 10)
    write_i32(ptr, 20)
    write_i32(ptr, 30)
    let value: I32 = read_i32(ptr)
    assert_eq(value, 30, "Should read latest written value")
    dealloc(ptr)
    return 0
}

@test
func test_ptr_offset_basic() -> I32 {
    let ptr: mut ref I32 = alloc(3)

    // Write to different offsets
    write_i32(ptr, 10)
    let ptr1: mut ref I32 = ptr_offset(ptr, 1)
    write_i32(ptr1, 20)
    let ptr2: mut ref I32 = ptr_offset(ptr, 2)
    write_i32(ptr2, 30)

    // Read back from different offsets
    let val0: I32 = read_i32(ptr)
    let val1: I32 = read_i32(ptr1)
    let val2: I32 = read_i32(ptr2)

    assert_eq(val0, 10, "First element should be 10")
    assert_eq(val1, 20, "Second element should be 20")
    assert_eq(val2, 30, "Third element should be 30")

    dealloc(ptr)
    return 0
}

@test
func test_array_simulation() -> I32 {
    let size: I32 = 5
    let arr: mut ref I32 = alloc(size)

    // Initialize array
    let mut i: I32 = 0
    loop {
        if i >= size then break
        let ptr: mut ref I32 = ptr_offset(arr, i)
        write_i32(ptr, i * 10)
        i = i + 1
    }

    // Verify array contents
    let mut sum: I32 = 0
    let mut j: I32 = 0
    loop {
        if j >= size then break
        let ptr: mut ref I32 = ptr_offset(arr, j)
        let value: I32 = read_i32(ptr)
        sum = sum + value
        j = j + 1
    }

    // Sum should be 0 + 10 + 20 + 30 + 40 = 100
    assert_eq(sum, 100, "Array sum should be 100")

    dealloc(arr)
    return 0
}
