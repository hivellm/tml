use test

// ============================================================================
// Comprehensive Control Flow Tests
// Tests if/else, loop, for, when, break, continue, return
// ============================================================================

// ============================================================================
// If/Else Expressions
// ============================================================================

@test
func test_if_true_branch() -> I32 {
    let result: I32 = if true { 42 } else { 0 }
    assert_eq(result, 42, "if true should take true branch")
    return 0
}

@test
func test_if_false_branch() -> I32 {
    let result: I32 = if false { 42 } else { 0 }
    assert_eq(result, 0, "if false should take false branch")
    return 0
}

@test
func test_if_condition_expression() -> I32 {
    let x: I32 = 10
    let result: I32 = if x > 5 { 1 } else { 0 }
    assert_eq(result, 1, "10 > 5 should be true")
    return 0
}

@test
func test_if_nested() -> I32 {
    let x: I32 = 15
    let result: I32 = if x > 10 {
        if x > 20 { 3 } else { 2 }
    } else {
        1
    }
    assert_eq(result, 2, "nested if should work correctly")
    return 0
}

@test
func test_if_else_if_chain() -> I32 {
    let x: I32 = 2
    let result: I32 = if x == 1 {
        10
    } else {
        if x == 2 {
            20
        } else {
            30
        }
    }
    assert_eq(result, 20, "else-if chain should match x == 2")
    return 0
}

@test
func test_if_with_complex_condition() -> I32 {
    let a: I32 = 5
    let b: I32 = 10
    let c: I32 = 15
    // a < b and b < c
    let result: I32 = if a < b and b < c { 1 } else { 0 }
    assert_eq(result, 1, "5 < 10 and 10 < 15 should be true")
    return 0
}

@test
func test_if_or_condition() -> I32 {
    let x: I32 = 0
    let result: I32 = if x == 0 or x == 1 { 1 } else { 0 }
    assert_eq(result, 1, "x == 0 or x == 1 should be true when x = 0")
    return 0
}

// ============================================================================
// Loop with Break
// ============================================================================

@test
func test_loop_with_immediate_break() -> I32 {
    let mut counter: I32 = 0
    loop {
        counter = counter + 1
        break
    }
    assert_eq(counter, 1, "loop should execute once before break")
    return 0
}

@test
func test_loop_counting() -> I32 {
    let mut counter: I32 = 0
    loop {
        counter = counter + 1
        if counter >= 5 then break
    }
    assert_eq(counter, 5, "loop should count to 5")
    return 0
}

@test
func test_loop_sum() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 1
    loop {
        sum = sum + i
        i = i + 1
        if i > 10 then break
    }
    // 1 + 2 + 3 + ... + 10 = 55
    assert_eq(sum, 55, "sum of 1 to 10 should be 55")
    return 0
}

@test
func test_nested_loops() -> I32 {
    let mut outer_count: I32 = 0
    let mut inner_count: I32 = 0

    loop {
        outer_count = outer_count + 1
        let mut j: I32 = 0
        loop {
            j = j + 1
            inner_count = inner_count + 1
            if j >= 3 then break
        }
        if outer_count >= 2 then break
    }
    // outer runs 2 times, inner runs 3 times each = 6 total
    assert_eq(inner_count, 6, "nested loops should run 6 times total")
    return 0
}

// ============================================================================
// Loop with Continue
// ============================================================================

@test
func test_loop_with_continue() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 0
    loop {
        i = i + 1
        if i > 10 then break
        // Skip even numbers
        if i % 2 == 0 then continue
        sum = sum + i
    }
    // 1 + 3 + 5 + 7 + 9 = 25
    assert_eq(sum, 25, "sum of odd numbers 1-10 should be 25")
    return 0
}

@test
func test_loop_skip_multiples() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 0
    loop {
        i = i + 1
        if i > 15 then break
        // Skip multiples of 3
        if i % 3 == 0 then continue
        sum = sum + i
    }
    // 1+2+4+5+7+8+10+11+13+14 = 75
    assert_eq(sum, 75, "sum excluding multiples of 3 should be 75")
    return 0
}

// ============================================================================
// When Expression (Pattern Matching)
// ============================================================================

@test
func test_when_integer_match() -> I32 {
    let x: I32 = 2
    let result: I32 = when x {
        1 => 10,
        2 => 20,
        3 => 30,
        _ => 0,
    }
    assert_eq(result, 20, "when should match 2 => 20")
    return 0
}

@test
func test_when_default_case() -> I32 {
    let x: I32 = 100
    let result: I32 = when x {
        1 => 10,
        2 => 20,
        _ => 99,
    }
    assert_eq(result, 99, "when should fall through to default")
    return 0
}

@test
func test_when_first_match() -> I32 {
    let x: I32 = 1
    let result: I32 = when x {
        1 => 100,
        _ => 0,
    }
    assert_eq(result, 100, "when should match first case")
    return 0
}

@test
func test_when_bool() -> I32 {
    let flag: Bool = true
    let result: I32 = when flag {
        true => 1,
        false => 0,
    }
    assert_eq(result, 1, "when true should return 1")
    return 0
}

// ============================================================================
// Early Return
// ============================================================================

func helper_early_return(x: I32) -> I32 {
    if x < 0 {
        return -1
    }
    if x == 0 {
        return 0
    }
    return x * 2
}

@test
func test_early_return_negative() -> I32 {
    let result: I32 = helper_early_return(-5)
    assert_eq(result, -1, "negative input should return -1")
    return 0
}

@test
func test_early_return_zero() -> I32 {
    let result: I32 = helper_early_return(0)
    assert_eq(result, 0, "zero input should return 0")
    return 0
}

@test
func test_early_return_positive() -> I32 {
    let result: I32 = helper_early_return(5)
    assert_eq(result, 10, "positive input should return doubled")
    return 0
}

// ============================================================================
// Complex Control Flow
// ============================================================================

func fibonacci(n: I32) -> I32 {
    if n <= 1 {
        return n
    }
    let mut a: I32 = 0
    let mut b: I32 = 1
    let mut i: I32 = 2
    loop {
        if i > n then break
        let temp: I32 = a + b
        a = b
        b = temp
        i = i + 1
    }
    return b
}

@test
func test_fibonacci_0() -> I32 {
    let result: I32 = fibonacci(0)
    assert_eq(result, 0, "fib(0) should be 0")
    return 0
}

@test
func test_fibonacci_1() -> I32 {
    let result: I32 = fibonacci(1)
    assert_eq(result, 1, "fib(1) should be 1")
    return 0
}

@test
func test_fibonacci_10() -> I32 {
    let result: I32 = fibonacci(10)
    assert_eq(result, 55, "fib(10) should be 55")
    return 0
}

func factorial(n: I32) -> I32 {
    if n <= 1 {
        return 1
    }
    let mut result: I32 = 1
    let mut i: I32 = 2
    loop {
        if i > n then break
        result = result * i
        i = i + 1
    }
    return result
}

@test
func test_factorial_0() -> I32 {
    let result: I32 = factorial(0)
    assert_eq(result, 1, "0! should be 1")
    return 0
}

@test
func test_factorial_5() -> I32 {
    let result: I32 = factorial(5)
    assert_eq(result, 120, "5! should be 120")
    return 0
}

func is_prime(n: I32) -> Bool {
    if n < 2 {
        return false
    }
    if n == 2 {
        return true
    }
    if n % 2 == 0 {
        return false
    }
    let mut i: I32 = 3
    loop {
        if i * i > n then break
        if n % i == 0 {
            return false
        }
        i = i + 2
    }
    return true
}

@test
func test_is_prime_small() -> I32 {
    assert_eq(is_prime(0), false, "0 is not prime")
    assert_eq(is_prime(1), false, "1 is not prime")
    assert_eq(is_prime(2), true, "2 is prime")
    assert_eq(is_prime(3), true, "3 is prime")
    assert_eq(is_prime(4), false, "4 is not prime")
    assert_eq(is_prime(5), true, "5 is prime")
    return 0
}

@test
func test_is_prime_larger() -> I32 {
    assert_eq(is_prime(17), true, "17 is prime")
    assert_eq(is_prime(18), false, "18 is not prime")
    assert_eq(is_prime(97), true, "97 is prime")
    assert_eq(is_prime(100), false, "100 is not prime")
    return 0
}

// ============================================================================
// Break and Continue in Nested Contexts
// ============================================================================

@test
func test_break_in_nested_if() -> I32 {
    let mut sum: I32 = 0
    let mut i: I32 = 0
    loop {
        i = i + 1
        if i > 10 {
            break
        }
        sum = sum + i
    }
    assert_eq(sum, 55, "sum should be 55")
    return 0
}

@test
func test_multiple_breaks() -> I32 {
    let mut result: I32 = 0
    let mut i: I32 = 0
    loop {
        i = i + 1
        if i == 3 {
            result = 30
            break
        }
        if i == 5 {
            result = 50
            break
        }
        if i > 10 {
            result = 100
            break
        }
    }
    assert_eq(result, 30, "should break at i == 3")
    return 0
}
