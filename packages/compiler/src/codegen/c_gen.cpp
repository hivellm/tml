// C code generator for TML
// Generates portable C99 code from TML AST

#include "tml/codegen/c_gen.hpp"
#include <algorithm>
#include <cctype>
#include <functional>

namespace tml::codegen {

CCodeGen::CCodeGen(const types::TypeEnv& env, CGenOptions options)
    : env_(env), options_(std::move(options)) {
    // Initialize type mapping
    type_map_ = {
        {"I8", "int8_t"},
        {"I16", "int16_t"},
        {"I32", "int32_t"},
        {"I64", "int64_t"},
        {"I128", "__int128"},
        {"U8", "uint8_t"},
        {"U16", "uint16_t"},
        {"U32", "uint32_t"},
        {"U64", "uint64_t"},
        {"U128", "unsigned __int128"},
        {"F32", "float"},
        {"F64", "double"},
        {"Bool", "bool"},
        {"Char", "uint32_t"},  // Unicode codepoint
        {"Str", "tml_str_t"},
        {"Unit", "void"},
    };
}

void CCodeGen::emit(const std::string& code) {
    output_ << code;
}

void CCodeGen::emit_line(const std::string& code) {
    emit_indent();
    output_ << code << "\n";
}

void CCodeGen::emit_indent() {
    for (int i = 0; i < indent_level_; ++i) {
        output_ << "    ";
    }
}

void CCodeGen::push_indent() {
    ++indent_level_;
}

void CCodeGen::pop_indent() {
    if (indent_level_ > 0) --indent_level_;
}

auto CCodeGen::fresh_temp() -> std::string {
    return "_t" + std::to_string(temp_counter_++);
}

auto CCodeGen::mangle_name(const std::string& name) -> std::string {
    // Simple name mangling - prefix with tml_ and escape special chars
    std::string result = options_.runtime_prefix;
    for (char c : name) {
        if (std::isalnum(c) || c == '_') {
            result += c;
        } else {
            result += '_';
        }
    }
    return result;
}

// Make a name safe for use in C (handle reserved keywords)
static std::string safe_name(const std::string& name) {
    // C/C++ reserved keywords that might be used as TML identifiers
    if (name == "this" || name == "auto" || name == "register" || name == "volatile" ||
        name == "extern" || name == "static" || name == "inline" ||
        name == "restrict" || name == "sizeof" || name == "typedef" ||
        name == "union" || name == "unsigned" || name == "signed" ||
        name == "goto" || name == "switch" || name == "case" ||
        name == "default" || name == "do" || name == "int" ||
        name == "long" || name == "short" || name == "float" ||
        name == "double" || name == "char" || name == "void" ||
        name == "class" || name == "template" || name == "virtual" ||
        name == "private" || name == "public" || name == "protected" ||
        name == "new" || name == "delete" || name == "namespace") {
        return "_" + name;
    }
    return name;
}

void CCodeGen::report_error(const std::string& msg, const SourceSpan& span) {
    errors_.push_back(CodegenError{msg, span, {}});
}

auto CCodeGen::translate_type(const parser::Type& type) -> std::string {
    if (type.is<parser::NamedType>()) {
        const auto& named = type.as<parser::NamedType>();
        if (!named.path.segments.empty()) {
            const auto& name = named.path.segments.back();
            auto it = type_map_.find(name);
            if (it != type_map_.end()) {
                return it->second;
            }
            // User-defined type
            return mangle_name(name);
        }
    } else if (type.is<parser::RefType>()) {
        const auto& ref = type.as<parser::RefType>();
        return translate_type_ptr(ref.inner) + "*";
    } else if (type.is<parser::PtrType>()) {
        const auto& ptr = type.as<parser::PtrType>();
        return translate_type_ptr(ptr.inner) + "*";
    } else if (type.is<parser::ArrayType>()) {
        // Arrays become pointers in C
        const auto& arr = type.as<parser::ArrayType>();
        return translate_type_ptr(arr.element) + "*";
    } else if (type.is<parser::SliceType>()) {
        (void)type.as<parser::SliceType>();  // Unused but validates type
        return "tml_slice_t";  // Fat pointer struct
    } else if (type.is<parser::TupleType>()) {
        // Tuples become anonymous structs
        return "tml_tuple_t";
    } else if (type.is<parser::FuncType>()) {
        // Function types become function pointers
        return "void*";  // Simplified
    }
    return "void";
}

auto CCodeGen::translate_type_ptr(const parser::TypePtr& type) -> std::string {
    if (!type) return "void";
    return translate_type(*type);
}

void CCodeGen::emit_runtime_header() {
    output_ << "/* Generated by TML Compiler */\n";
    output_ << "#include <stdint.h>\n";
    output_ << "#include <stdbool.h>\n";
    output_ << "#include <stdio.h>\n";
    output_ << "#include <stdlib.h>\n";
    output_ << "#include <string.h>\n\n";

    output_ << "/* TML Runtime Types */\n";
    output_ << "typedef struct { const char* data; size_t len; } tml_str_t;\n";
    output_ << "typedef struct { void* data; size_t len; } tml_slice_t;\n\n";

    output_ << "/* TML Runtime Functions */\n";
    output_ << "static void tml_print(tml_str_t s) {\n";
    output_ << "    fwrite(s.data, 1, s.len, stdout);\n";
    output_ << "    putchar('\\n');\n";
    output_ << "}\n\n";

    output_ << "static void tml_print_i32(int32_t n) {\n";
    output_ << "    printf(\"%d\\n\", n);\n";
    output_ << "}\n\n";

    output_ << "static void tml_print_bool(bool b) {\n";
    output_ << "    printf(\"%s\\n\", b ? \"true\" : \"false\");\n";
    output_ << "}\n\n";

    output_ << "static tml_str_t tml_str_from_literal(const char* s) {\n";
    output_ << "    return (tml_str_t){ .data = s, .len = strlen(s) };\n";
    output_ << "}\n\n";
}

void CCodeGen::emit_runtime_footer() {
    // Entry point wrapper
    output_ << "\n/* Entry Point */\n";
    output_ << "int main(int argc, char** argv) {\n";
    output_ << "    (void)argc; (void)argv;\n";

    // If main returns an integer type, use it as exit code
    if (main_return_type_ == "int32_t" || main_return_type_ == "int" ||
        main_return_type_ == "int8_t" || main_return_type_ == "int16_t" ||
        main_return_type_ == "int64_t") {
        output_ << "    return (int)tml_main();\n";
    } else if (main_return_type_ == "uint8_t" || main_return_type_ == "uint16_t" ||
               main_return_type_ == "uint32_t" || main_return_type_ == "uint64_t") {
        output_ << "    return (int)tml_main();\n";
    } else {
        output_ << "    tml_main();\n";
        output_ << "    return 0;\n";
    }

    output_ << "}\n";
}

auto CCodeGen::generate(const parser::Module& module) -> Result<std::string, std::vector<CodegenError>> {
    errors_.clear();
    output_.str("");
    forward_decls_.str("");
    type_defs_.str("");
    func_defs_.str("");

    emit_runtime_header();

    // First pass: collect forward declarations
    output_ << "/* Forward Declarations */\n";
    for (const auto& decl : module.decls) {
        if (decl->is<parser::FuncDecl>()) {
            const auto& func = decl->as<parser::FuncDecl>();
            // Forward declare functions
            std::string ret_type = func.return_type ? translate_type_ptr(*func.return_type) : "void";

            // Track main's return type for entry point
            if (func.name == "main") {
                main_return_type_ = ret_type;
            }

            output_ << ret_type << " " << mangle_name(func.name) << "(";
            for (size_t i = 0; i < func.params.size(); ++i) {
                if (i > 0) output_ << ", ";
                output_ << translate_type_ptr(func.params[i].type);
                if (func.params[i].pattern && func.params[i].pattern->is<parser::IdentPattern>()) {
                    output_ << " " << safe_name(func.params[i].pattern->as<parser::IdentPattern>().name);
                }
            }
            if (func.params.empty()) {
                output_ << "void";
            }
            output_ << ");\n";
        } else if (decl->is<parser::StructDecl>()) {
            const auto& s = decl->as<parser::StructDecl>();
            output_ << "typedef struct " << mangle_name(s.name) << " " << mangle_name(s.name) << ";\n";
        }
    }
    output_ << "\n";

    // Second pass: type definitions
    output_ << "/* Type Definitions */\n";
    for (const auto& decl : module.decls) {
        if (decl->is<parser::StructDecl>()) {
            gen_struct_decl(decl->as<parser::StructDecl>());
        } else if (decl->is<parser::EnumDecl>()) {
            gen_enum_decl(decl->as<parser::EnumDecl>());
        }
    }
    output_ << "\n";

    // Third pass: function definitions
    output_ << "/* Function Definitions */\n";
    for (const auto& decl : module.decls) {
        if (decl->is<parser::FuncDecl>()) {
            gen_func_decl(decl->as<parser::FuncDecl>());
        }
    }

    // Check if we have a main function
    bool has_main = false;
    for (const auto& decl : module.decls) {
        if (decl->is<parser::FuncDecl>() && decl->as<parser::FuncDecl>().name == "main") {
            has_main = true;
            break;
        }
    }

    if (has_main) {
        emit_runtime_footer();
    }

    if (!errors_.empty()) {
        return errors_;
    }

    return output_.str();
}

void CCodeGen::gen_decl(const parser::Decl& decl) {
    if (decl.is<parser::FuncDecl>()) {
        gen_func_decl(decl.as<parser::FuncDecl>());
    } else if (decl.is<parser::StructDecl>()) {
        gen_struct_decl(decl.as<parser::StructDecl>());
    } else if (decl.is<parser::EnumDecl>()) {
        gen_enum_decl(decl.as<parser::EnumDecl>());
    } else if (decl.is<parser::TraitDecl>()) {
        gen_trait_decl(decl.as<parser::TraitDecl>());
    } else if (decl.is<parser::ImplDecl>()) {
        gen_impl_decl(decl.as<parser::ImplDecl>());
    } else if (decl.is<parser::TypeAliasDecl>()) {
        gen_type_alias(decl.as<parser::TypeAliasDecl>());
    }
}

void CCodeGen::gen_func_decl(const parser::FuncDecl& func) {
    current_func_ = func.name;

    if (options_.emit_comments) {
        output_ << "/* func " << func.name << " */\n";
    }

    // Return type
    std::string ret_type = func.return_type ? translate_type_ptr(*func.return_type) : "void";
    output_ << ret_type << " " << mangle_name(func.name) << "(";

    // Parameters
    if (func.params.empty()) {
        output_ << "void";
    } else {
        for (size_t i = 0; i < func.params.size(); ++i) {
            if (i > 0) output_ << ", ";
            output_ << translate_type_ptr(func.params[i].type);
            if (func.params[i].pattern && func.params[i].pattern->is<parser::IdentPattern>()) {
                output_ << " " << safe_name(func.params[i].pattern->as<parser::IdentPattern>().name);
            } else {
                output_ << " _p" << i;
            }
        }
    }
    output_ << ")";

    // Body
    if (func.body.has_value()) {
        output_ << " {\n";
        push_indent();

        const auto& block = func.body.value();
        for (const auto& stmt : block.stmts) {
            gen_stmt(*stmt);
        }

        // Trailing expression becomes return
        if (block.expr.has_value()) {
            const auto& trailing_expr = *block.expr.value();
            // If the trailing expression is already a return, don't add another
            if (trailing_expr.is<parser::ReturnExpr>()) {
                std::string expr_code = gen_expr(trailing_expr);
                emit_line(expr_code + ";");
            } else if (trailing_expr.is<parser::IfExpr>()) {
                // If expression as trailing - might be statement or value
                std::string expr_code = gen_expr(trailing_expr);
                // Check if it looks like an if-statement (starts with "if")
                bool is_if_statement = expr_code.substr(0, 2) == "if";
                if (is_if_statement) {
                    // If-statement doesn't need return or semicolon
                    emit_line(expr_code);
                } else {
                    // Ternary expression - needs semicolon
                    if (ret_type != "void") {
                        emit_line("return " + expr_code + ";");
                    } else {
                        emit_line(expr_code + ";");
                    }
                }
            } else {
                std::string expr_code = gen_expr(trailing_expr);
                if (ret_type != "void") {
                    emit_line("return " + expr_code + ";");
                } else {
                    emit_line(expr_code + ";");
                }
            }
        }

        pop_indent();
        output_ << "}\n\n";
    } else {
        output_ << ";\n";
    }

    current_func_.clear();
}

void CCodeGen::gen_struct_decl(const parser::StructDecl& s) {
    output_ << "struct " << mangle_name(s.name) << " {\n";
    push_indent();

    for (const auto& field : s.fields) {
        emit_indent();
        output_ << translate_type_ptr(field.type) << " " << field.name << ";\n";
    }

    pop_indent();
    output_ << "};\n\n";
}

void CCodeGen::gen_enum_decl(const parser::EnumDecl& e) {
    // Generate tag enum
    output_ << "typedef enum {\n";
    push_indent();
    for (size_t i = 0; i < e.variants.size(); ++i) {
        emit_indent();
        output_ << mangle_name(e.name) << "_" << e.variants[i].name;
        if (i + 1 < e.variants.size()) output_ << ",";
        output_ << "\n";
    }
    pop_indent();
    output_ << "} " << mangle_name(e.name) << "_tag_t;\n\n";

    // Generate variant structs if needed
    for (const auto& variant : e.variants) {
        if (variant.tuple_fields.has_value() || variant.struct_fields.has_value()) {
            output_ << "typedef struct {\n";
            push_indent();

            if (variant.tuple_fields.has_value()) {
                for (size_t i = 0; i < variant.tuple_fields->size(); ++i) {
                    emit_indent();
                    output_ << translate_type_ptr((*variant.tuple_fields)[i]) << " _" << i << ";\n";
                }
            }
            if (variant.struct_fields.has_value()) {
                for (const auto& field : *variant.struct_fields) {
                    emit_indent();
                    output_ << translate_type_ptr(field.type) << " " << field.name << ";\n";
                }
            }

            pop_indent();
            output_ << "} " << mangle_name(e.name) << "_" << variant.name << "_t;\n\n";
        }
    }

    // Generate main enum struct
    output_ << "typedef struct {\n";
    push_indent();
    emit_line(mangle_name(e.name) + "_tag_t tag;");
    emit_line("union {");
    push_indent();
    for (const auto& variant : e.variants) {
        if (variant.tuple_fields.has_value() || variant.struct_fields.has_value()) {
            emit_line(mangle_name(e.name) + "_" + variant.name + "_t " + variant.name + ";");
        }
    }
    pop_indent();
    emit_line("} data;");
    pop_indent();
    output_ << "} " << mangle_name(e.name) << ";\n\n";
}

void CCodeGen::gen_trait_decl(const parser::TraitDecl& t) {
    // Traits become vtable structs
    output_ << "typedef struct " << mangle_name(t.name) << "_vtable {\n";
    push_indent();

    for (const auto& method : t.methods) {
        emit_indent();
        std::string ret_type = method.return_type ? translate_type_ptr(*method.return_type) : "void";
        output_ << ret_type << " (*" << method.name << ")(void* self";
        for (size_t i = 1; i < method.params.size(); ++i) {
            output_ << ", " << translate_type_ptr(method.params[i].type);
        }
        output_ << ");\n";
    }

    pop_indent();
    output_ << "} " << mangle_name(t.name) << "_vtable_t;\n\n";
}

void CCodeGen::gen_impl_decl(const parser::ImplDecl& impl) {
    // Generate method implementations
    for (const auto& method : impl.methods) {
        // Add self parameter type
        gen_func_decl(method);
    }
}

void CCodeGen::gen_type_alias(const parser::TypeAliasDecl& alias) {
    output_ << "typedef " << translate_type_ptr(alias.type) << " " << mangle_name(alias.name) << ";\n\n";
}

void CCodeGen::gen_stmt(const parser::Stmt& stmt) {
    if (stmt.is<parser::LetStmt>()) {
        gen_let_stmt(stmt.as<parser::LetStmt>());
    } else if (stmt.is<parser::ExprStmt>()) {
        gen_expr_stmt(stmt.as<parser::ExprStmt>());
    }
}

void CCodeGen::gen_let_stmt(const parser::LetStmt& let) {
    std::string type_str = let.type_annotation ? translate_type_ptr(*let.type_annotation) : "auto";
    std::string var_name = "_unknown";

    if (let.pattern->is<parser::IdentPattern>()) {
        var_name = safe_name(let.pattern->as<parser::IdentPattern>().name);
    }

    emit_indent();

    // Use explicit type or infer from initializer
    if (let.type_annotation) {
        output_ << translate_type_ptr(*let.type_annotation);
    } else {
        // C doesn't have auto, so we need to infer
        // For now, default to int32_t for simplicity
        output_ << "int32_t";
    }

    output_ << " " << var_name;

    if (let.init.has_value()) {
        output_ << " = " << gen_expr(*let.init.value());
    }

    output_ << ";\n";
}

void CCodeGen::gen_expr_stmt(const parser::ExprStmt& expr) {
    emit_line(gen_expr(*expr.expr) + ";");
}

auto CCodeGen::gen_expr(const parser::Expr& expr) -> std::string {
    if (expr.is<parser::LiteralExpr>()) {
        return gen_literal(expr.as<parser::LiteralExpr>());
    } else if (expr.is<parser::IdentExpr>()) {
        return gen_ident(expr.as<parser::IdentExpr>());
    } else if (expr.is<parser::BinaryExpr>()) {
        return gen_binary(expr.as<parser::BinaryExpr>());
    } else if (expr.is<parser::UnaryExpr>()) {
        return gen_unary(expr.as<parser::UnaryExpr>());
    } else if (expr.is<parser::CallExpr>()) {
        return gen_call(expr.as<parser::CallExpr>());
    } else if (expr.is<parser::MethodCallExpr>()) {
        return gen_method_call(expr.as<parser::MethodCallExpr>());
    } else if (expr.is<parser::FieldExpr>()) {
        return gen_field(expr.as<parser::FieldExpr>());
    } else if (expr.is<parser::IndexExpr>()) {
        return gen_index(expr.as<parser::IndexExpr>());
    } else if (expr.is<parser::IfExpr>()) {
        return gen_if(expr.as<parser::IfExpr>());
    } else if (expr.is<parser::BlockExpr>()) {
        return gen_block(expr.as<parser::BlockExpr>());
    } else if (expr.is<parser::ReturnExpr>()) {
        return gen_return(expr.as<parser::ReturnExpr>());
    } else if (expr.is<parser::StructExpr>()) {
        return gen_struct_expr(expr.as<parser::StructExpr>());
    } else if (expr.is<parser::TupleExpr>()) {
        return gen_tuple(expr.as<parser::TupleExpr>());
    } else if (expr.is<parser::ArrayExpr>()) {
        return gen_array(expr.as<parser::ArrayExpr>());
    } else if (expr.is<parser::LoopExpr>()) {
        return gen_loop(expr.as<parser::LoopExpr>());
    } else if (expr.is<parser::ForExpr>()) {
        return gen_for(expr.as<parser::ForExpr>());
    } else if (expr.is<parser::WhileExpr>()) {
        const auto& w = expr.as<parser::WhileExpr>();
        // while cond { body } -> while (cond) { body }
        std::string result = "while (" + gen_expr(*w.condition) + ") {\n";
        push_indent();
        result += gen_expr(*w.body);
        pop_indent();
        emit_indent();
        result += "\n}";
        return result;
    } else if (expr.is<parser::BreakExpr>()) {
        const auto& b = expr.as<parser::BreakExpr>();
        if (b.value.has_value()) {
            return "break /* value: " + gen_expr(*b.value.value()) + " */";
        }
        return "break";
    } else if (expr.is<parser::ContinueExpr>()) {
        return "continue";
    } else if (expr.is<parser::RangeExpr>()) {
        const auto& r = expr.as<parser::RangeExpr>();
        // Ranges are typically used in for loops, generate a comment for now
        std::string start = r.start.has_value() ? gen_expr(*r.start.value()) : "0";
        std::string end = r.end.has_value() ? gen_expr(*r.end.value()) : "/* open */";
        return "/* range " + start + (r.inclusive ? " through " : " to ") + end + " */";
    } else if (expr.is<parser::WhenExpr>()) {
        return gen_when(expr.as<parser::WhenExpr>());
    } else if (expr.is<parser::CastExpr>()) {
        const auto& c = expr.as<parser::CastExpr>();
        return "((" + translate_type_ptr(c.target) + ")" + gen_expr(*c.expr) + ")";
    } else if (expr.is<parser::ClosureExpr>()) {
        return gen_closure(expr.as<parser::ClosureExpr>());
    }

    report_error("Unsupported expression type", expr.span);
    return "/* unsupported */";
}

auto CCodeGen::gen_literal(const parser::LiteralExpr& lit) -> std::string {
    switch (lit.token.kind) {
        case lexer::TokenKind::IntLiteral:
            return std::string(lit.token.lexeme);
        case lexer::TokenKind::FloatLiteral:
            return std::string(lit.token.lexeme);
        case lexer::TokenKind::StringLiteral:
            return "tml_str_from_literal(\"" + std::string(lit.token.string_value().value) + "\")";
        case lexer::TokenKind::CharLiteral:
            return "'" + std::string(lit.token.lexeme) + "'";
        case lexer::TokenKind::BoolLiteral:
            return lit.token.lexeme == "true" ? "true" : "false";
        default:
            return "0";
    }
}

auto CCodeGen::gen_ident(const parser::IdentExpr& ident) -> std::string {
    // Check if it's a builtin function
    if (ident.name == "print") {
        return "tml_print";
    }
    if (ident.name == "println") {
        return "tml_print";
    }
    if (ident.name == "print_i32") {
        return "tml_print_i32";
    }
    if (ident.name == "print_bool") {
        return "tml_print_bool";
    }
    // Handle C/C++ reserved keywords
    return safe_name(ident.name);
}

auto CCodeGen::gen_binary(const parser::BinaryExpr& bin) -> std::string {
    std::string left = gen_expr(*bin.left);
    std::string right = gen_expr(*bin.right);
    std::string op;

    switch (bin.op) {
        case parser::BinaryOp::Add: op = " + "; break;
        case parser::BinaryOp::Sub: op = " - "; break;
        case parser::BinaryOp::Mul: op = " * "; break;
        case parser::BinaryOp::Div: op = " / "; break;
        case parser::BinaryOp::Mod: op = " % "; break;
        case parser::BinaryOp::Eq: op = " == "; break;
        case parser::BinaryOp::Ne: op = " != "; break;
        case parser::BinaryOp::Lt: op = " < "; break;
        case parser::BinaryOp::Gt: op = " > "; break;
        case parser::BinaryOp::Le: op = " <= "; break;
        case parser::BinaryOp::Ge: op = " >= "; break;
        case parser::BinaryOp::And: op = " && "; break;
        case parser::BinaryOp::Or: op = " || "; break;
        case parser::BinaryOp::BitAnd: op = " & "; break;
        case parser::BinaryOp::BitOr: op = " | "; break;
        case parser::BinaryOp::BitXor: op = " ^ "; break;
        case parser::BinaryOp::Shl: op = " << "; break;
        case parser::BinaryOp::Shr: op = " >> "; break;
        case parser::BinaryOp::Assign: op = " = "; break;
        case parser::BinaryOp::AddAssign: op = " += "; break;
        case parser::BinaryOp::SubAssign: op = " -= "; break;
        case parser::BinaryOp::MulAssign: op = " *= "; break;
        case parser::BinaryOp::DivAssign: op = " /= "; break;
        case parser::BinaryOp::ModAssign: op = " %= "; break;
        default: op = " ? "; break;
    }

    return "(" + left + op + right + ")";
}

auto CCodeGen::gen_unary(const parser::UnaryExpr& unary) -> std::string {
    std::string operand = gen_expr(*unary.operand);

    switch (unary.op) {
        case parser::UnaryOp::Neg: return "(-" + operand + ")";
        case parser::UnaryOp::Not: return "(!" + operand + ")";
        case parser::UnaryOp::BitNot: return "(~" + operand + ")";
        case parser::UnaryOp::Ref: return "(&" + operand + ")";
        case parser::UnaryOp::RefMut: return "(&" + operand + ")";
        case parser::UnaryOp::Deref: return "(*" + operand + ")";
        default: return operand;
    }
}

auto CCodeGen::gen_call(const parser::CallExpr& call) -> std::string {
    std::string callee;

    // If callee is an identifier, mangle the name for user-defined functions
    if (call.callee->is<parser::IdentExpr>()) {
        const auto& ident = call.callee->as<parser::IdentExpr>();
        // Check for builtin functions
        if (ident.name == "print" || ident.name == "println") {
            callee = "tml_print";
        } else if (ident.name == "print_i32") {
            callee = "tml_print_i32";
        } else if (ident.name == "print_bool") {
            callee = "tml_print_bool";
        } else {
            // User-defined function - mangle the name
            callee = mangle_name(ident.name);
        }
    } else {
        callee = gen_expr(*call.callee);
    }

    std::string result = callee + "(";

    for (size_t i = 0; i < call.args.size(); ++i) {
        if (i > 0) result += ", ";
        result += gen_expr(*call.args[i]);
    }

    result += ")";
    return result;
}

auto CCodeGen::gen_method_call(const parser::MethodCallExpr& call) -> std::string {
    std::string receiver = gen_expr(*call.receiver);
    std::string result = receiver + "." + call.method + "(";

    for (size_t i = 0; i < call.args.size(); ++i) {
        if (i > 0) result += ", ";
        result += gen_expr(*call.args[i]);
    }

    result += ")";
    return result;
}

auto CCodeGen::gen_field(const parser::FieldExpr& field) -> std::string {
    return gen_expr(*field.object) + "." + field.field;
}

auto CCodeGen::gen_index(const parser::IndexExpr& index) -> std::string {
    return gen_expr(*index.object) + "[" + gen_expr(*index.index) + "]";
}

auto CCodeGen::gen_if(const parser::IfExpr& if_expr) -> std::string {
    std::string cond = gen_expr(*if_expr.condition);
    std::stringstream ss;

    // Helper to check if expression is a value (can be used in ternary)
    // Control flow (break, continue, return) and blocks with statements can't be in ternary
    std::function<bool(const parser::Expr&)> is_value_expr = [&is_value_expr](const parser::Expr& expr) -> bool {
        // Control flow expressions can't be in ternary
        if (expr.is<parser::BreakExpr>() ||
            expr.is<parser::ContinueExpr>() ||
            expr.is<parser::ReturnExpr>() ||
            expr.is<parser::LoopExpr>() ||
            expr.is<parser::ForExpr>() ||
            expr.is<parser::WhileExpr>()) {
            return false;
        }
        // For blocks, check if it's a simple value block
        if (expr.is<parser::BlockExpr>()) {
            const auto& block = expr.as<parser::BlockExpr>();
            // Block must have no statements and a value trailing expression
            if (!block.stmts.empty() || !block.expr.has_value()) {
                return false;
            }
            // Recursively check the trailing expression
            return is_value_expr(*block.expr.value());
        }
        // Nested if expressions - recursively check
        if (expr.is<parser::IfExpr>()) {
            const auto& nested_if = expr.as<parser::IfExpr>();
            if (!is_value_expr(*nested_if.then_branch)) return false;
            if (nested_if.else_branch.has_value() &&
                !is_value_expr(*nested_if.else_branch.value())) return false;
        }
        return true;
    };

    // Helper to extract value from expression (unwrap simple blocks)
    auto extract_value = [this](const parser::Expr& expr) -> std::string {
        if (expr.is<parser::BlockExpr>()) {
            const auto& block = expr.as<parser::BlockExpr>();
            if (block.stmts.empty() && block.expr.has_value()) {
                return gen_expr(*block.expr.value());
            }
        }
        return gen_expr(expr);
    };

    bool then_is_value = is_value_expr(*if_expr.then_branch);
    bool else_is_value = !if_expr.else_branch.has_value() ||
                         is_value_expr(*if_expr.else_branch.value());

    // For value expressions, use ternary (if we have else)
    if (then_is_value && else_is_value && if_expr.else_branch.has_value()) {
        std::string then_code = extract_value(*if_expr.then_branch);
        std::string else_code = extract_value(*if_expr.else_branch.value());
        return "((" + cond + ") ? (" + then_code + ") : (" + else_code + "))";
    }

    // For control flow or no else, generate if statement
    ss << "if (" << cond << ") ";
    ss << gen_expr(*if_expr.then_branch);

    if (if_expr.else_branch.has_value()) {
        ss << " else ";
        ss << gen_expr(*if_expr.else_branch.value());
    }

    return ss.str();
}

auto CCodeGen::gen_block(const parser::BlockExpr& block) -> std::string {
    std::stringstream ss;
    ss << "{\n";
    push_indent();

    // Generate all statements
    for (const auto& stmt : block.stmts) {
        if (stmt->is<parser::LetStmt>()) {
            const auto& let = stmt->as<parser::LetStmt>();
            std::string var_name = "_unknown";
            if (let.pattern->is<parser::IdentPattern>()) {
                var_name = safe_name(let.pattern->as<parser::IdentPattern>().name);
            }

            for (int i = 0; i < indent_level_; ++i) ss << "    ";
            if (let.type_annotation) {
                ss << translate_type_ptr(*let.type_annotation);
            } else {
                ss << "int32_t";
            }
            ss << " " << var_name;
            if (let.init.has_value()) {
                ss << " = " << gen_expr(*let.init.value());
            }
            ss << ";\n";
        } else if (stmt->is<parser::ExprStmt>()) {
            const auto& expr_stmt = stmt->as<parser::ExprStmt>();
            for (int i = 0; i < indent_level_; ++i) ss << "    ";
            ss << gen_expr(*expr_stmt.expr) << ";\n";
        }
    }

    // Trailing expression
    if (block.expr.has_value()) {
        for (int i = 0; i < indent_level_; ++i) ss << "    ";
        ss << gen_expr(*block.expr.value()) << ";\n";
    }

    pop_indent();
    for (int i = 0; i < indent_level_; ++i) ss << "    ";
    ss << "}";
    return ss.str();
}

auto CCodeGen::gen_return(const parser::ReturnExpr& ret) -> std::string {
    if (ret.value.has_value()) {
        return "return " + gen_expr(*ret.value.value());
    }
    return "return";
}

auto CCodeGen::gen_struct_expr(const parser::StructExpr& s) -> std::string {
    std::string name = s.path.segments.empty() ? "anon" : s.path.segments.back();
    std::string result = "(" + mangle_name(name) + "){ ";

    for (size_t i = 0; i < s.fields.size(); ++i) {
        if (i > 0) result += ", ";
        result += "." + s.fields[i].first + " = " + gen_expr(*s.fields[i].second);
    }

    result += " }";
    return result;
}

auto CCodeGen::gen_tuple(const parser::TupleExpr& tuple) -> std::string {
    // Tuples become compound literals or separate variables
    if (tuple.elements.size() == 1) {
        return gen_expr(*tuple.elements[0]);
    }

    std::string result = "/* tuple */{ ";
    for (size_t i = 0; i < tuple.elements.size(); ++i) {
        if (i > 0) result += ", ";
        result += gen_expr(*tuple.elements[i]);
    }
    result += " }";
    return result;
}

auto CCodeGen::gen_array(const parser::ArrayExpr& arr) -> std::string {
    if (std::holds_alternative<std::vector<parser::ExprPtr>>(arr.kind)) {
        const auto& elements = std::get<std::vector<parser::ExprPtr>>(arr.kind);
        std::string result = "{ ";
        for (size_t i = 0; i < elements.size(); ++i) {
            if (i > 0) result += ", ";
            result += gen_expr(*elements[i]);
        }
        result += " }";
        return result;
    } else {
        // Repeat expression [expr; count]
        const auto& [expr, count] = std::get<std::pair<parser::ExprPtr, parser::ExprPtr>>(arr.kind);
        return "/* array repeat */ { " + gen_expr(*expr) + " }";
    }
}

auto CCodeGen::gen_loop(const parser::LoopExpr& loop) -> std::string {
    // loop { body } -> while (1) { body }
    std::stringstream ss;
    ss << "while (1) ";
    ss << gen_expr(*loop.body);
    return ss.str();
}

auto CCodeGen::gen_for(const parser::ForExpr& for_expr) -> std::string {
    // for x in start to end { body } -> for (int x = start; x < end; x++) { body }
    std::stringstream ss;

    std::string var_name = "_i";
    if (for_expr.pattern->is<parser::IdentPattern>()) {
        var_name = safe_name(for_expr.pattern->as<parser::IdentPattern>().name);
    }

    // Check if iter is a range expression
    if (for_expr.iter->is<parser::RangeExpr>()) {
        const auto& range = for_expr.iter->as<parser::RangeExpr>();
        std::string start = range.start.has_value() ? gen_expr(*range.start.value()) : "0";
        std::string end = range.end.has_value() ? gen_expr(*range.end.value()) : "0";
        std::string cmp = range.inclusive ? "<=" : "<";

        ss << "for (int32_t " << var_name << " = " << start << "; "
           << var_name << " " << cmp << " " << end << "; "
           << "++" << var_name << ") ";
    } else {
        // Generic iterator - use a while loop with iterator pattern
        ss << "/* for " << var_name << " in ... */ for (int32_t " << var_name << " = 0; "
           << var_name << " < 10; ++" << var_name << ") ";
    }

    ss << gen_expr(*for_expr.body);
    return ss.str();
}

auto CCodeGen::gen_when(const parser::WhenExpr& when) -> std::string {
    // when expr { pat => body, ... } -> switch-like or if-else chain
    std::stringstream ss;
    std::string scrutinee = gen_expr(*when.scrutinee);
    std::string temp = fresh_temp();

    // Use if-else chain for pattern matching
    ss << "({ int32_t " << temp << " = 0; ";

    bool first = true;
    for (const auto& arm : when.arms) {
        if (!first) {
            ss << " else ";
        }
        first = false;

        // Check pattern type
        if (arm.pattern->is<parser::LiteralPattern>()) {
            const auto& lit = arm.pattern->as<parser::LiteralPattern>();
            ss << "if (" << scrutinee << " == " << std::string(lit.literal.lexeme) << ") { ";
        } else if (arm.pattern->is<parser::IdentPattern>()) {
            const auto& ident = arm.pattern->as<parser::IdentPattern>();
            if (ident.name == "_") {
                // Wildcard pattern - matches everything
                ss << "{ ";
            } else {
                // Binding pattern - bind and always match
                ss << "{ int32_t " << safe_name(ident.name) << " = " << scrutinee << "; ";
            }
        } else if (arm.pattern->is<parser::WildcardPattern>()) {
            ss << "{ ";
        } else {
            ss << "if (1) { /* pattern */ ";
        }

        // Add guard if present
        if (arm.guard.has_value()) {
            ss << "if (" << gen_expr(*arm.guard.value()) << ") ";
        }

        ss << temp << " = " << gen_expr(*arm.body) << "; }";
    }

    ss << " " << temp << "; })";
    return ss.str();
}

auto CCodeGen::gen_closure(const parser::ClosureExpr& closure) -> std::string {
    // Closures in C require function pointers or nested functions (GCC extension)
    // For now, generate an inline comment and the body
    std::stringstream ss;
    ss << "/* closure */ ";

    // If it's a simple single-expression closure, just return the expression
    ss << "(" << gen_expr(*closure.body) << ")";

    return ss.str();
}

} // namespace tml::codegen
