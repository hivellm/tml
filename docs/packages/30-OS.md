# TML Standard Library: OS

> `std::os` â€” Operating system information and utilities (Node.js-style).

## Overview

Provides OS-level queries, environment variable access, process control, child process spawning, signal handling, and anonymous pipes. The API follows Node.js `os` module conventions where applicable.

## Import

```tml
use std::os::{arch, platform, hostname, env_get, exec}
use std::os::subprocess::{Command, Stdio}
use std::os::signal
use std::os::pipe::Pipe
```

---

## Constants

| Constant | Description |
|----------|-------------|
| `EOL` | Platform line ending (`"\r\n"` or `"\n"`) |
| `DEV_NULL` | Null device path (`"/dev/null"` or `"NUL"`) |
| `PRIORITY_LOW` | Process priority level (19) |
| `PRIORITY_BELOW_NORMAL` | Process priority level (10) |
| `PRIORITY_NORMAL` | Process priority level (0) |
| `PRIORITY_ABOVE_NORMAL` | Process priority level (-7) |
| `PRIORITY_HIGH` | Process priority level (-14) |
| `PRIORITY_HIGHEST` | Process priority level (-20) |

---

## System Information

```tml
func arch() -> Str              // "x64", "arm64", etc.
func platform() -> Str          // "win32", "linux", "darwin"
func os_type() -> Str           // "Windows_NT", "Linux", "Darwin"
func machine() -> Str           // Machine hardware name
func release() -> Str           // OS release string
func version() -> Str           // OS version string
func hostname() -> Str
func homedir() -> Str
func tmpdir() -> Str
func uptime() -> F64            // System uptime in seconds
func totalmem() -> I64          // Total memory in bytes
func freemem() -> I64           // Free memory in bytes
func endianness() -> Str        // "LE" or "BE"
func cpu_count() -> I64
func cpu_model(index: I64) -> Str
func cpu_speed(index: I64) -> I64  // MHz
func loadavg_1() -> F64
func loadavg_5() -> F64
func loadavg_15() -> F64
func username() -> Str
func uid() -> I64
func gid() -> I64
func shell() -> Str
func pid() -> I64
```

## Environment Variables

```tml
func env_get(name: Str) -> Maybe[Str]
func env_set(name: Str, value: Str) -> Bool
func env_unset(name: Str) -> Bool
```

## Process Control

```tml
func args_count() -> I64
func args_get(index: I64) -> Str
func process_exit(code: I64)
func current_dir() -> Str
func set_current_dir(path: Str)
func exec(command: Str) -> Str         // Run shell command, return stdout
func exec_status(command: Str) -> I32  // Run shell command, return exit code
func get_priority(pid: I64) -> I64
func set_priority(pid: I64, priority: I64)
```

---

## Subprocess

Child process spawning with piped I/O.

```tml
struct Stdio { }  // Opaque; use class methods below
func Stdio::inherit() -> Stdio
func Stdio::piped() -> Stdio
func Stdio::null() -> Stdio
```

```tml
struct Output {
    stdout: Str,
    stderr: Str,
    status: I32,
}
```

```tml
func Command::new(program: Str) -> Command
func arg(mut self, value: Str) -> mut ref Command
func stdout(mut self, cfg: Stdio) -> mut ref Command
func stderr(mut self, cfg: Stdio) -> mut ref Command
func output(mut self) -> Outcome[Output, Str]
```

---

## Signal Handling

```tml
// Constants
const SIGINT: I32
const SIGTERM: I32
const SIGHUP: I32
const SIGUSR1: I32
const SIGUSR2: I32
const SIGALRM: I32

func signal::register(signum: I32)   // Register handler for signal
func signal::check(signum: I32) -> Bool  // Check if signal was received
func signal::reset(signum: I32)      // Clear received flag
```

---

## Pipe

Anonymous pipe for inter-process or inter-thread communication.

```tml
struct Pipe {
    read_fd: I32,
    write_fd: I32,
}

func Pipe::create() -> Outcome[Pipe, Str]
func close(mut self)
```

---

## Example

```tml
use std::os::{hostname, platform, cpu_count, env_get, exec}
use std::os::subprocess::{Command, Stdio}

func main() {
    print("Host: {hostname()} ({platform()})\n")
    print("CPUs: {cpu_count()}\n")

    when env_get("HOME") {
        Just(home) -> print("Home: {home}\n"),
        Nothing -> print("Home: unknown\n"),
    }

    // Run a subprocess
    var cmd = Command::new("echo")
    cmd.arg("hello from subprocess").stdout(Stdio::piped())
    when cmd.output() {
        Ok(out) -> print("Output: {out.stdout}\n"),
        Err(e) -> print("Error: {e}\n"),
    }
}
```
