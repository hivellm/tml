# std::fs — File System

## 1. Overview

The `std::fs` package provides file system operations: reading, writing, creating, and manipulating files and directories.

```tml
use std::fs
use std::fs.{File, read_to_string, write_string}
```

## 2. Capabilities

```tml
// Required capabilities
caps: [io::file]           // Full file access
caps: [io::file.read]      // Read-only access
caps: [io::file.write]     // Write access
```

## 3. Core Types

### 3.1 File

```tml
pub type File {
    handle: RawHandle,
    path: PathBuf,
}

extend File {
    /// Open file for reading
    pub func open(path: impl AsRef[Path]) -> Outcome[This, IoError]
    effects: [io::file.read]

    /// Create file for writing (truncates if exists)
    pub func create(path: impl AsRef[Path]) -> Outcome[This, IoError]
    effects: [io::file.write]

    /// Open with custom options
    pub func open_with(path: impl AsRef[Path], opts: OpenOptions) -> Outcome[This, IoError]
    effects: [io::file]

    /// Get file metadata
    pub func metadata(this) -> Outcome[Metadata, IoError]
    effects: [io::file.read]

    /// Sync all data to disk
    pub func sync_all(this) -> Outcome[Unit, IoError]
    effects: [io::file.write]

    /// Sync data (not metadata) to disk
    pub func sync_data(this) -> Outcome[Unit, IoError]
    effects: [io::file.write]

    /// Set file length
    pub func set_len(this, size: U64) -> Outcome[Unit, IoError]
    effects: [io::file.write]

    /// Get current position
    pub func position(this) -> Outcome[U64, IoError]

    /// Seek to position
    pub func seek(this, pos: SeekFrom) -> Outcome[U64, IoError]
}

extend File with Read { ... }
extend File with Write { ... }
extend File with Disposable { ... }
```

### 3.2 OpenOptions

```tml
pub type OpenOptions {
    read: Bool,
    write: Bool,
    append: Bool,
    truncate: Bool,
    create: Bool,
    create_new: Bool,
    mode: Maybe[U32],  // Unix permissions
}

extend OpenOptions {
    pub func new() -> This {
        return This {
            read: false,
            write: false,
            append: false,
            truncate: false,
            create: false,
            create_new: false,
            mode: Nothing,
        }
    }

    pub func read(this) -> This { this.read = true; this }
    pub func write(this) -> This { this.write = true; this }
    pub func append(this) -> This { this.append = true; this }
    pub func truncate(this) -> This { this.truncate = true; this }
    pub func create(this) -> This { this.create = true; this }
    pub func create_new(this) -> This { this.create_new = true; this }
    pub func mode(this, mode: U32) -> This { this.mode = Just(mode); this }

    pub func open(this, path: impl AsRef[Path]) -> Outcome[File, IoError]
    effects: [io::file]
}
```

### 3.3 Metadata

```tml
pub type Metadata {
    file_type: FileType,
    size: U64,
    permissions: Permissions,
    modified: Maybe[SystemTime],
    accessed: Maybe[SystemTime],
    created: Maybe[SystemTime],
}

extend Metadata {
    pub func is_file(this) -> Bool
    pub func is_dir(this) -> Bool
    pub func is_symlink(this) -> Bool
    pub func len(this) -> U64
    pub func permissions(this) -> Permissions
    pub func modified(this) -> Outcome[SystemTime, IoError]
    pub func accessed(this) -> Outcome[SystemTime, IoError]
    pub func created(this) -> Outcome[SystemTime, IoError]
}

pub type FileType = File | Directory | Symlink | Other

pub type Permissions {
    readonly: Bool,
    @when(unix)
    mode: U32,
}
```

### 3.4 Path and PathBuf

```tml
// Borrowed path (like ref str)
pub type Path {
    inner: [U8],
}

// Owned path (like String)
pub type PathBuf {
    inner: List[U8],
}

extend Path {
    pub func new(s: ref str) -> ref This
    pub func as_str(this) -> ref str
    pub func to_path_buf(this) -> PathBuf
    pub func parent(this) -> Maybe[ref Path]
    pub func file_name(this) -> Maybe[ref str]
    pub func file_stem(this) -> Maybe[ref str]
    pub func extension(this) -> Maybe[ref str]
    pub func join(this, path: impl AsRef[Path]) -> PathBuf
    pub func with_extension(this, ext: ref str) -> PathBuf
    pub func is_absolute(this) -> Bool
    pub func is_relative(this) -> Bool
    pub func exists(this) -> Bool effects: [io::file.read]
    pub func is_file(this) -> Bool effects: [io::file.read]
    pub func is_dir(this) -> Bool effects: [io::file.read]
    pub func components(this) -> Components
}

extend PathBuf {
    pub func new() -> This
    pub func from(s: impl Into[String]) -> This
    pub func push(this, path: impl AsRef[Path])
    pub func pop(this) -> Bool
    pub func set_file_name(this, name: ref str)
    pub func set_extension(this, ext: ref str) -> Bool
    pub func as_path(this) -> ref Path
}
```

### 3.5 DirEntry

```tml
pub type DirEntry {
    path: PathBuf,
    metadata: Maybe[Metadata],
}

extend DirEntry {
    pub func path(this) -> ref Path
    pub func file_name(this) -> ref str
    pub func metadata(this) -> Outcome[Metadata, IoError]
    pub func file_type(this) -> Outcome[FileType, IoError]
}
```

## 4. Convenience Functions

### 4.1 Read Functions

```tml
/// Read entire file as string
pub func read_to_string(path: impl AsRef[Path]) -> Outcome[String, IoError]
effects: [io::file.read]
{
    let mut file = File.open(path)!
    let mut contents = String.new()
    file.read_to_string(mut ref contents)!
    return Ok(contents)
}

/// Read entire file as bytes
pub func read(path: impl AsRef[Path]) -> Outcome[List[U8], IoError]
effects: [io::file.read]
{
    let mut file = File.open(path)!
    let mut contents = List.new()
    file.read_to_end(mut ref contents)!
    return Ok(contents)
}

/// Read file lines
pub func read_lines(path: impl AsRef[Path]) -> Outcome[Lines, IoError]
effects: [io::file.read]
```

### 4.2 Write Functions

```tml
/// Write string to file (creates or truncates)
pub func write_string(path: impl AsRef[Path], contents: ref str) -> Outcome[Unit, IoError]
effects: [io::file.write]
{
    let mut file = File.create(path)!
    file.write_all(contents.as_bytes())!
    return Ok(unit)
}

/// Write bytes to file
pub func write(path: impl AsRef[Path], contents: ref [U8]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Append to file
pub func append(path: impl AsRef[Path], contents: ref [U8]) -> Outcome[Unit, IoError]
effects: [io::file.write]
```

### 4.3 Directory Functions

```tml
/// Create directory
pub func create_dir(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Create directory and all parents
pub func create_dir_all(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Remove empty directory
pub func remove_dir(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Remove directory and all contents
pub func remove_dir_all(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Read directory entries
pub func read_dir(path: impl AsRef[Path]) -> Outcome[ReadDir, IoError]
effects: [io::file.read]

/// Get current directory
pub func current_dir() -> Outcome[PathBuf, IoError]
effects: [io::file.read]

/// Set current directory
pub func set_current_dir(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]
```

### 4.4 File Operations

```tml
/// Copy file
pub func copy(from: impl AsRef[Path], to: impl AsRef[Path]) -> Outcome[U64, IoError]
effects: [io::file]

/// Rename/move file
pub func rename(from: impl AsRef[Path], to: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Remove file
pub func remove_file(path: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Get file metadata
pub func metadata(path: impl AsRef[Path]) -> Outcome[Metadata, IoError]
effects: [io::file.read]

/// Get symlink metadata (doesn't follow)
pub func symlink_metadata(path: impl AsRef[Path]) -> Outcome[Metadata, IoError]
effects: [io::file.read]

/// Check if path exists
pub func exists(path: impl AsRef[Path]) -> Bool
effects: [io::file.read]

/// Canonicalize path (resolve symlinks, make absolute)
pub func canonicalize(path: impl AsRef[Path]) -> Outcome[PathBuf, IoError]
effects: [io::file.read]
```

### 4.5 Symlink Operations

```tml
/// Create symlink
@when(unix)
pub func symlink(original: impl AsRef[Path], link: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

@when(windows)
pub func symlink_file(original: impl AsRef[Path], link: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

@when(windows)
pub func symlink_dir(original: impl AsRef[Path], link: impl AsRef[Path]) -> Outcome[Unit, IoError]
effects: [io::file.write]

/// Read symlink target
pub func read_link(path: impl AsRef[Path]) -> Outcome[PathBuf, IoError]
effects: [io::file.read]
```

## 5. Iterators

### 5.1 ReadDir

```tml
pub type ReadDir {
    inner: RawDirIter,
}

extend ReadDir with Iterator {
    type Item = Outcome[DirEntry, IoError]

    func next(this) -> Maybe[Outcome[DirEntry, IoError]]
    effects: [io::file.read]
}
```

### 5.2 WalkDir

```tml
/// Recursive directory walker
pub type WalkDir {
    root: PathBuf,
    follow_links: Bool,
    max_depth: Maybe[U64],
    min_depth: U64,
}

extend WalkDir {
    pub func new(root: impl AsRef[Path]) -> This
    pub func follow_links(this, follow: Bool) -> This
    pub func max_depth(this, depth: U64) -> This
    pub func min_depth(this, depth: U64) -> This
}

extend WalkDir with IntoIterator {
    type Item = Outcome[DirEntry, IoError]
    type IntoIter = WalkDirIter
}
```

### 5.3 Glob

```tml
/// Pattern matching for paths
pub func glob(pattern: ref str) -> Outcome[Glob, PatternError]
effects: [io::file.read]

pub type Glob { ... }

extend Glob with Iterator {
    type Item = Outcome[PathBuf, IoError]
}

// Usage
loop path in glob("src/**/*.tml")! {
    println(path!.to_string())
}
```

## 6. Temp Files

```tml
pub type TempFile {
    file: File,
    path: PathBuf,
    persist: Bool,
}

extend TempFile {
    /// Create temp file in system temp dir
    pub func new() -> Outcome[This, IoError]
    effects: [io::file.write]

    /// Create temp file in specific directory
    pub func new_in(dir: impl AsRef[Path]) -> Outcome[This, IoError]
    effects: [io::file.write]

    /// Get path to temp file
    pub func path(this) -> ref Path

    /// Keep file after TempFile is dropped
    pub func persist(this) -> PathBuf

    /// Get inner File
    pub func as_file(this) -> ref File
    pub func as_file_mut(this) -> mut ref File
}

extend TempFile with Disposable {
    func drop(this) {
        if not this.persist {
            remove_file(this.path).ok()
        }
    }
}

pub type TempDir {
    path: PathBuf,
    persist: Bool,
}

extend TempDir {
    pub func new() -> Outcome[This, IoError]
    effects: [io::file.write]

    pub func new_in(dir: impl AsRef[Path]) -> Outcome[This, IoError]
    effects: [io::file.write]

    pub func path(this) -> ref Path
    pub func persist(this) -> PathBuf
}
```

## 7. Error Types

```tml
pub type IoError {
    kind: IoErrorKind,
    message: Maybe[String],
    source: Maybe[Heap[dyn Error]],
}

pub type IoErrorKind =
    | NotFound
    | PermissionDenied
    | AlreadyExists
    | NotADirectory
    | IsADirectory
    | DirectoryNotEmpty
    | WouldBlock
    | InvalidInput
    | InvalidData
    | TimedOut
    | Interrupted
    | UnexpectedEof
    | BrokenPipe
    | Other

extend IoError {
    pub func kind(this) -> IoErrorKind
    pub func from_raw_os_error(code: I32) -> This
    pub func raw_os_error(this) -> Maybe[I32]
}
```

## 8. Examples

### 8.1 Basic File Operations

```tml
mod example
caps: [io::file]

use std::fs.{File, read_to_string, write_string}

pub func main() -> Outcome[Unit, Error] {
    // Read file
    let content = read_to_string("input.txt")!
    println("Read: " + content)

    // Write file
    write_string("output.txt", "Hello, TML!")!

    // Append to file
    let file = File.open_with("log.txt",
        OpenOptions.new().write().append().create()
    )!
    file.write_all(b"New log entry\n")!

    return Ok(unit)
}
```

### 8.2 Directory Traversal

```tml
mod walker
caps: [io::file.read]

use std::fs.{read_dir, WalkDir}

pub func list_tml_files(dir: ref Path) -> Outcome[List[PathBuf], IoError] {
    var files = List.new()

    loop entry in WalkDir.new(dir).max_depth(5) {
        let entry = entry!
        if entry.path().extension() == Just("tml") {
            files.push(entry.path().to_path_buf())
        }
    }

    return Ok(files)
}
```

### 8.3 Temp Files

```tml
mod temp_example
caps: [io::file]

use std::fs.{TempFile, TempDir}

pub func process_with_temp() -> Outcome[Unit, Error] {
    // Create temp file
    let temp = TempFile.new()!
    temp.as_file_mut().write_all(b"temporary data")!

    // Use temp file path
    process_file(temp.path())!

    // File is automatically deleted when temp goes out of scope
    return Ok(unit)
}
```

---

*Next: [02-NET.md](./02-NET.md) — Networking*
