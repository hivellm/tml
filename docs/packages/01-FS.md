# std.fs — File System

## 1. Overview

The `std.fs` package provides file system operations: reading, writing, creating, and manipulating files and directories.

```tml
import std.fs
import std.fs.{File, read_to_string, write_string}
```

## 2. Capabilities

```tml
// Required capabilities
caps: [io.file]           // Full file access
caps: [io.file.read]      // Read-only access
caps: [io.file.write]     // Write access
```

## 3. Core Types

### 3.1 File

```tml
public type File {
    handle: RawHandle,
    path: PathBuf,
}

extend File {
    /// Open file for reading
    public func open(path: impl AsRef[Path]) -> Result[This, IoError]
    effects: [io.file.read]

    /// Create file for writing (truncates if exists)
    public func create(path: impl AsRef[Path]) -> Result[This, IoError]
    effects: [io.file.write]

    /// Open with custom options
    public func open_with(path: impl AsRef[Path], opts: OpenOptions) -> Result[This, IoError]
    effects: [io.file]

    /// Get file metadata
    public func metadata(this) -> Result[Metadata, IoError]
    effects: [io.file.read]

    /// Sync all data to disk
    public func sync_all(this) -> Result[Unit, IoError]
    effects: [io.file.write]

    /// Sync data (not metadata) to disk
    public func sync_data(this) -> Result[Unit, IoError]
    effects: [io.file.write]

    /// Set file length
    public func set_len(this, size: U64) -> Result[Unit, IoError]
    effects: [io.file.write]

    /// Get current position
    public func position(this) -> Result[U64, IoError]

    /// Seek to position
    public func seek(this, pos: SeekFrom) -> Result[U64, IoError]
}

extend File with Read { ... }
extend File with Write { ... }
extend File with Drop { ... }
```

### 3.2 OpenOptions

```tml
public type OpenOptions {
    read: Bool,
    write: Bool,
    append: Bool,
    truncate: Bool,
    create: Bool,
    create_new: Bool,
    mode: Option[U32],  // Unix permissions
}

extend OpenOptions {
    public func new() -> This {
        return This {
            read: false,
            write: false,
            append: false,
            truncate: false,
            create: false,
            create_new: false,
            mode: None,
        }
    }

    public func read(this) -> This { this.read = true; this }
    public func write(this) -> This { this.write = true; this }
    public func append(this) -> This { this.append = true; this }
    public func truncate(this) -> This { this.truncate = true; this }
    public func create(this) -> This { this.create = true; this }
    public func create_new(this) -> This { this.create_new = true; this }
    public func mode(this, mode: U32) -> This { this.mode = Some(mode); this }

    public func open(this, path: impl AsRef[Path]) -> Result[File, IoError]
    effects: [io.file]
}
```

### 3.3 Metadata

```tml
public type Metadata {
    file_type: FileType,
    size: U64,
    permissions: Permissions,
    modified: Option[SystemTime],
    accessed: Option[SystemTime],
    created: Option[SystemTime],
}

extend Metadata {
    public func is_file(this) -> Bool
    public func is_dir(this) -> Bool
    public func is_symlink(this) -> Bool
    public func len(this) -> U64
    public func permissions(this) -> Permissions
    public func modified(this) -> Result[SystemTime, IoError]
    public func accessed(this) -> Result[SystemTime, IoError]
    public func created(this) -> Result[SystemTime, IoError]
}

public type FileType = File | Directory | Symlink | Other

public type Permissions {
    readonly: Bool,
    #[cfg(unix)]
    mode: U32,
}
```

### 3.4 Path and PathBuf

```tml
// Borrowed path (like &str)
public type Path {
    inner: [U8],
}

// Owned path (like String)
public type PathBuf {
    inner: List[U8],
}

extend Path {
    public func new(s: &str) -> &This
    public func as_str(this) -> &str
    public func to_path_buf(this) -> PathBuf
    public func parent(this) -> Option[&Path]
    public func file_name(this) -> Option[&str]
    public func file_stem(this) -> Option[&str]
    public func extension(this) -> Option[&str]
    public func join(this, path: impl AsRef[Path]) -> PathBuf
    public func with_extension(this, ext: &str) -> PathBuf
    public func is_absolute(this) -> Bool
    public func is_relative(this) -> Bool
    public func exists(this) -> Bool effects: [io.file.read]
    public func is_file(this) -> Bool effects: [io.file.read]
    public func is_dir(this) -> Bool effects: [io.file.read]
    public func components(this) -> Components
}

extend PathBuf {
    public func new() -> This
    public func from(s: impl Into[String]) -> This
    public func push(this, path: impl AsRef[Path])
    public func pop(this) -> Bool
    public func set_file_name(this, name: &str)
    public func set_extension(this, ext: &str) -> Bool
    public func as_path(this) -> &Path
}
```

### 3.5 DirEntry

```tml
public type DirEntry {
    path: PathBuf,
    metadata: Option[Metadata],
}

extend DirEntry {
    public func path(this) -> &Path
    public func file_name(this) -> &str
    public func metadata(this) -> Result[Metadata, IoError]
    public func file_type(this) -> Result[FileType, IoError]
}
```

## 4. Convenience Functions

### 4.1 Read Functions

```tml
/// Read entire file as string
public func read_to_string(path: impl AsRef[Path]) -> Result[String, IoError]
effects: [io.file.read]
{
    let mut file = File.open(path)?
    let mut contents = String.new()
    file.read_to_string(&mut contents)?
    return Ok(contents)
}

/// Read entire file as bytes
public func read(path: impl AsRef[Path]) -> Result[List[U8], IoError]
effects: [io.file.read]
{
    let mut file = File.open(path)?
    let mut contents = List.new()
    file.read_to_end(&mut contents)?
    return Ok(contents)
}

/// Read file lines
public func read_lines(path: impl AsRef[Path]) -> Result[Lines, IoError]
effects: [io.file.read]
```

### 4.2 Write Functions

```tml
/// Write string to file (creates or truncates)
public func write_string(path: impl AsRef[Path], contents: &str) -> Result[Unit, IoError]
effects: [io.file.write]
{
    let mut file = File.create(path)?
    file.write_all(contents.as_bytes())?
    return Ok(unit)
}

/// Write bytes to file
public func write(path: impl AsRef[Path], contents: &[U8]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Append to file
public func append(path: impl AsRef[Path], contents: &[U8]) -> Result[Unit, IoError]
effects: [io.file.write]
```

### 4.3 Directory Functions

```tml
/// Create directory
public func create_dir(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Create directory and all parents
public func create_dir_all(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Remove empty directory
public func remove_dir(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Remove directory and all contents
public func remove_dir_all(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Read directory entries
public func read_dir(path: impl AsRef[Path]) -> Result[ReadDir, IoError]
effects: [io.file.read]

/// Get current directory
public func current_dir() -> Result[PathBuf, IoError]
effects: [io.file.read]

/// Set current directory
public func set_current_dir(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]
```

### 4.4 File Operations

```tml
/// Copy file
public func copy(from: impl AsRef[Path], to: impl AsRef[Path]) -> Result[U64, IoError]
effects: [io.file]

/// Rename/move file
public func rename(from: impl AsRef[Path], to: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Remove file
public func remove_file(path: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Get file metadata
public func metadata(path: impl AsRef[Path]) -> Result[Metadata, IoError]
effects: [io.file.read]

/// Get symlink metadata (doesn't follow)
public func symlink_metadata(path: impl AsRef[Path]) -> Result[Metadata, IoError]
effects: [io.file.read]

/// Check if path exists
public func exists(path: impl AsRef[Path]) -> Bool
effects: [io.file.read]

/// Canonicalize path (resolve symlinks, make absolute)
public func canonicalize(path: impl AsRef[Path]) -> Result[PathBuf, IoError]
effects: [io.file.read]
```

### 4.5 Symlink Operations

```tml
/// Create symlink
#[cfg(unix)]
public func symlink(original: impl AsRef[Path], link: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

#[cfg(windows)]
public func symlink_file(original: impl AsRef[Path], link: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

#[cfg(windows)]
public func symlink_dir(original: impl AsRef[Path], link: impl AsRef[Path]) -> Result[Unit, IoError]
effects: [io.file.write]

/// Read symlink target
public func read_link(path: impl AsRef[Path]) -> Result[PathBuf, IoError]
effects: [io.file.read]
```

## 5. Iterators

### 5.1 ReadDir

```tml
public type ReadDir {
    inner: RawDirIter,
}

extend ReadDir with Iterator {
    type Item = Result[DirEntry, IoError]

    func next(this) -> Option[Result[DirEntry, IoError]]
    effects: [io.file.read]
}
```

### 5.2 WalkDir

```tml
/// Recursive directory walker
public type WalkDir {
    root: PathBuf,
    follow_links: Bool,
    max_depth: Option[U64],
    min_depth: U64,
}

extend WalkDir {
    public func new(root: impl AsRef[Path]) -> This
    public func follow_links(this, follow: Bool) -> This
    public func max_depth(this, depth: U64) -> This
    public func min_depth(this, depth: U64) -> This
}

extend WalkDir with IntoIterator {
    type Item = Result[DirEntry, IoError]
    type IntoIter = WalkDirIter
}
```

### 5.3 Glob

```tml
/// Pattern matching for paths
public func glob(pattern: &str) -> Result[Glob, PatternError]
effects: [io.file.read]

public type Glob { ... }

extend Glob with Iterator {
    type Item = Result[PathBuf, IoError]
}

// Usage
loop path in glob("src/**/*.tml")? {
    println(path?.to_string())
}
```

## 6. Temp Files

```tml
public type TempFile {
    file: File,
    path: PathBuf,
    persist: Bool,
}

extend TempFile {
    /// Create temp file in system temp dir
    public func new() -> Result[This, IoError]
    effects: [io.file.write]

    /// Create temp file in specific directory
    public func new_in(dir: impl AsRef[Path]) -> Result[This, IoError]
    effects: [io.file.write]

    /// Get path to temp file
    public func path(this) -> &Path

    /// Keep file after TempFile is dropped
    public func persist(this) -> PathBuf

    /// Get inner File
    public func as_file(this) -> &File
    public func as_file_mut(this) -> &mut File
}

extend TempFile with Drop {
    func drop(this) {
        if not this.persist {
            remove_file(this.path).ok()
        }
    }
}

public type TempDir {
    path: PathBuf,
    persist: Bool,
}

extend TempDir {
    public func new() -> Result[This, IoError]
    effects: [io.file.write]

    public func new_in(dir: impl AsRef[Path]) -> Result[This, IoError]
    effects: [io.file.write]

    public func path(this) -> &Path
    public func persist(this) -> PathBuf
}
```

## 7. Error Types

```tml
public type IoError {
    kind: IoErrorKind,
    message: Option[String],
    source: Option[Box[dyn Error]],
}

public type IoErrorKind =
    | NotFound
    | PermissionDenied
    | AlreadyExists
    | NotADirectory
    | IsADirectory
    | DirectoryNotEmpty
    | WouldBlock
    | InvalidInput
    | InvalidData
    | TimedOut
    | Interrupted
    | UnexpectedEof
    | BrokenPipe
    | Other

extend IoError {
    public func kind(this) -> IoErrorKind
    public func from_raw_os_error(code: I32) -> This
    public func raw_os_error(this) -> Option[I32]
}
```

## 8. Examples

### 8.1 Basic File Operations

```tml
module example
caps: [io.file]

import std.fs.{File, read_to_string, write_string}

public func main() -> Result[Unit, Error] {
    // Read file
    let content = read_to_string("input.txt")?
    println("Read: " + content)

    // Write file
    write_string("output.txt", "Hello, TML!")?

    // Append to file
    let file = File.open_with("log.txt",
        OpenOptions.new().write().append().create()
    )?
    file.write_all(b"New log entry\n")?

    return Ok(unit)
}
```

### 8.2 Directory Traversal

```tml
module walker
caps: [io.file.read]

import std.fs.{read_dir, WalkDir}

public func list_tml_files(dir: &Path) -> Result[List[PathBuf], IoError] {
    var files = List.new()

    loop entry in WalkDir.new(dir).max_depth(5) {
        let entry = entry?
        if entry.path().extension() == Some("tml") {
            files.push(entry.path().to_path_buf())
        }
    }

    return Ok(files)
}
```

### 8.3 Temp Files

```tml
module temp_example
caps: [io.file]

import std.fs.{TempFile, TempDir}

public func process_with_temp() -> Result[Unit, Error] {
    // Create temp file
    let temp = TempFile.new()?
    temp.as_file_mut().write_all(b"temporary data")?

    // Use temp file path
    process_file(temp.path())?

    // File is automatically deleted when temp goes out of scope
    return Ok(unit)
}
```

---

*Next: [02-NET.md](./02-NET.md) — Networking*
