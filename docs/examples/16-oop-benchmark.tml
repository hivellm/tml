//! Example 16: OOP Virtual Dispatch Benchmark
//!
//! This example benchmarks virtual method dispatch vs direct calls
//! to measure the overhead of OOP polymorphism.

// ============================================================================
// Base Classes and Interfaces
// ============================================================================

/// Interface for shape calculations
interface IShape {
    func area(this) -> F64
    func perimeter(this) -> F64
}

/// Abstract base class for shapes
abstract class Shape implements IShape {
    name: Str

    abstract func area(this) -> F64
    abstract func perimeter(this) -> F64

    virtual func description(this) -> Str {
        return this.name
    }
}

/// Circle implementation
class Circle extends Shape {
    radius: F64

    static func create(radius: F64) -> Circle {
        return Circle { name: "Circle", radius: radius }
    }

    override func area(this) -> F64 {
        return 3.14159265359 * this.radius * this.radius
    }

    override func perimeter(this) -> F64 {
        return 2.0 * 3.14159265359 * this.radius
    }
}

/// Rectangle implementation
class Rectangle extends Shape {
    width: F64
    height: F64

    static func create(width: F64, height: F64) -> Rectangle {
        return Rectangle { name: "Rectangle", width: width, height: height }
    }

    override func area(this) -> F64 {
        return this.width * this.height
    }

    override func perimeter(this) -> F64 {
        return 2.0 * (this.width + this.height)
    }
}

/// Triangle implementation
class Triangle extends Shape {
    base_: F64
    height: F64
    side_a: F64
    side_b: F64

    static func create(base_: F64, height: F64, side_a: F64, side_b: F64) -> Triangle {
        return Triangle {
            name: "Triangle",
            base_: base_,
            height: height,
            side_a: side_a,
            side_b: side_b
        }
    }

    override func area(this) -> F64 {
        return 0.5 * this.base_ * this.height
    }

    override func perimeter(this) -> F64 {
        return this.base_ + this.side_a + this.side_b
    }
}

// ============================================================================
// Sealed Class (No Virtual Dispatch Overhead)
// ============================================================================

/// A sealed class allows compiler to devirtualize all calls
sealed class Point {
    x: F64
    y: F64

    static func create(x: F64, y: F64) -> Point {
        return Point { x: x, y: y }
    }

    func distance_from_origin(this) -> F64 {
        return (this.x * this.x + this.y * this.y)
    }

    func distance_to(this, other: Point) -> F64 {
        let dx = this.x - other.x
        let dy = this.y - other.y
        return (dx * dx + dy * dy)
    }
}

// ============================================================================
// Value Class (Stack Allocated, No vtable)
// ============================================================================

/// Value classes are stack-allocated with no vtable pointer
@value
sealed class Vector2D {
    x: F64
    y: F64

    static func create(x: F64, y: F64) -> Vector2D {
        return Vector2D { x: x, y: y }
    }

    func magnitude(this) -> F64 {
        return (this.x * this.x + this.y * this.y)
    }

    func add(this, other: Vector2D) -> Vector2D {
        return Vector2D { x: this.x + other.x, y: this.y + other.y }
    }

    func dot(this, other: Vector2D) -> F64 {
        return this.x * other.x + this.y * other.y
    }
}

// ============================================================================
// Benchmarks
// ============================================================================

/// Direct method calls (no polymorphism)
@bench
func bench_direct_calls() {
    let circle = Circle::create(5.0)
    let mut total = 0.0

    loop i in 0 to 10000 {
        total = total + circle.area()
        total = total + circle.perimeter()
    }

    assert(total > 0.0)
}

/// Virtual dispatch through base class reference
@bench
func bench_virtual_dispatch() {
    let shapes: [Shape] = [
        Circle::create(5.0) as Shape,
        Rectangle::create(3.0, 4.0) as Shape,
        Triangle::create(3.0, 4.0, 5.0, 5.0) as Shape
    ]

    let mut total = 0.0

    loop i in 0 to 10000 {
        loop shape in shapes {
            total = total + shape.area()
            total = total + shape.perimeter()
        }
    }

    assert(total > 0.0)
}

/// Interface dispatch
@bench
func bench_interface_dispatch() {
    let shapes: [dyn IShape] = [
        Circle::create(5.0) as dyn IShape,
        Rectangle::create(3.0, 4.0) as dyn IShape,
        Triangle::create(3.0, 4.0, 5.0, 5.0) as dyn IShape
    ]

    let mut total = 0.0

    loop i in 0 to 10000 {
        loop shape in shapes {
            total = total + shape.area()
            total = total + shape.perimeter()
        }
    }

    assert(total > 0.0)
}

/// Sealed class (devirtualized by compiler)
@bench
func bench_sealed_class() {
    let p1 = Point::create(3.0, 4.0)
    let p2 = Point::create(6.0, 8.0)
    let mut total = 0.0

    loop i in 0 to 10000 {
        total = total + p1.distance_from_origin()
        total = total + p1.distance_to(p2)
    }

    assert(total > 0.0)
}

/// Value class (stack allocated, no vtable)
@bench
func bench_value_class() {
    let v1 = Vector2D::create(3.0, 4.0)
    let v2 = Vector2D::create(1.0, 2.0)
    let mut total = 0.0

    loop i in 0 to 10000 {
        total = total + v1.magnitude()
        let v3 = v1.add(v2)
        total = total + v1.dot(v2)
    }

    assert(total > 0.0)
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_virtual_dispatch_correctness() {
    let circle = Circle::create(5.0)
    let rect = Rectangle::create(3.0, 4.0)

    // Direct calls
    assert(circle.area() > 78.0 and circle.area() < 79.0)
    assert_eq(rect.area(), 12.0)

    // Through base class
    let shape: Shape = circle as Shape
    assert(shape.area() > 78.0 and shape.area() < 79.0)

    // Through interface
    let ishape: dyn IShape = rect as dyn IShape
    assert_eq(ishape.area(), 12.0)
}

@test
func test_sealed_and_value_classes() {
    // Sealed class
    let p = Point::create(3.0, 4.0)
    assert_eq(p.distance_from_origin(), 25.0) // 3^2 + 4^2 = 25

    // Value class
    let v1 = Vector2D::create(1.0, 2.0)
    let v2 = Vector2D::create(3.0, 4.0)
    let v3 = v1.add(v2)
    assert_eq(v3.x, 4.0)
    assert_eq(v3.y, 6.0)
    assert_eq(v1.dot(v2), 11.0) // 1*3 + 2*4 = 11
}
