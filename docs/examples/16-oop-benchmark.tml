//! Example 16: OOP Virtual Dispatch Benchmark
//!
//! This example benchmarks virtual method dispatch vs direct calls
//! to measure the overhead of OOP polymorphism.

// ============================================================================
// Base Classes and Interfaces
// ============================================================================

/// Interface for shape calculations
interface IShape {
    func area(this) -> F64
    func perimeter(this) -> F64
}

/// Base class for shapes (for polymorphism via upcast)
class Shape implements IShape {
    name_id: I32

    static func create(name_id: I32) -> Shape {
        return Shape { name_id: name_id }
    }

    func area(this) -> F64 {
        return 0.0
    }

    func perimeter(this) -> F64 {
        return 0.0
    }

    func get_name_id(this) -> I32 {
        return this.name_id
    }
}

/// Circle implementation
class Circle extends Shape {
    radius: F64

    static func create(radius: F64) -> Circle {
        return Circle { name_id: 1, radius: radius }
    }

    func area(this) -> F64 {
        return 3.14159265359 * this.radius * this.radius
    }

    func perimeter(this) -> F64 {
        return 2.0 * 3.14159265359 * this.radius
    }

    func get_radius(this) -> F64 {
        return this.radius
    }
}

/// Rectangle implementation
class Rectangle extends Shape {
    width: F64
    height: F64

    static func create(width: F64, height: F64) -> Rectangle {
        return Rectangle { name_id: 2, width: width, height: height }
    }

    func area(this) -> F64 {
        return this.width * this.height
    }

    func perimeter(this) -> F64 {
        return 2.0 * (this.width + this.height)
    }
}

/// Triangle implementation
class Triangle extends Shape {
    base_: F64
    height: F64
    side_a: F64
    side_b: F64

    static func create(base_: F64, height: F64, side_a: F64, side_b: F64) -> Triangle {
        return Triangle {
            name_id: 3,
            base_: base_,
            height: height,
            side_a: side_a,
            side_b: side_b
        }
    }

    func area(this) -> F64 {
        return 0.5 * this.base_ * this.height
    }

    func perimeter(this) -> F64 {
        return this.base_ + this.side_a + this.side_b
    }
}

// ============================================================================
// Sealed Class (No Virtual Dispatch Overhead)
// ============================================================================

/// A sealed class allows compiler to devirtualize all calls
sealed class Point {
    x: F64
    y: F64

    static func create(x: F64, y: F64) -> Point {
        return Point { x: x, y: y }
    }

    func distance_from_origin(this) -> F64 {
        return (this.x * this.x + this.y * this.y)
    }

    func distance_to(this, other: Point) -> F64 {
        let dx: F64 = this.x - other.x
        let dy: F64 = this.y - other.y
        return (dx * dx + dy * dy)
    }
}

// ============================================================================
// Deep Inheritance Hierarchy
// ============================================================================

/// Level 0 - Base class
class Level0 {
    value: I64

    static func create(v: I64) -> Level0 {
        Level0 { value: v }
    }

    virtual func compute(this) -> I64 {
        this.value
    }

    virtual func get_level(this) -> I32 {
        0
    }
}

/// Level 1
class Level1 extends Level0 {
    multiplier: I64

    static func create(v: I64) -> Level1 {
        Level1 { value: v, multiplier: 2 }
    }

    override func compute(this) -> I64 {
        this.value * this.multiplier
    }

    override func get_level(this) -> I32 {
        1
    }
}

/// Level 2
class Level2 extends Level1 {
    offset: I64

    static func create(v: I64) -> Level2 {
        Level2 { value: v, multiplier: 2, offset: 10 }
    }

    override func compute(this) -> I64 {
        this.value * this.multiplier + this.offset
    }

    override func get_level(this) -> I32 {
        2
    }
}

/// Level 3
class Level3 extends Level2 {
    divisor: I64

    static func create(v: I64) -> Level3 {
        Level3 { value: v, multiplier: 2, offset: 10, divisor: 2 }
    }

    override func compute(this) -> I64 {
        (this.value * this.multiplier + this.offset) / this.divisor
    }

    override func get_level(this) -> I32 {
        3
    }
}

/// Level 4
class Level4 extends Level3 {
    mask: I64

    static func create(v: I64) -> Level4 {
        Level4 { value: v, multiplier: 2, offset: 10, divisor: 2, mask: 255 }
    }

    override func compute(this) -> I64 {
        ((this.value * this.multiplier + this.offset) / this.divisor) & this.mask
    }

    override func get_level(this) -> I32 {
        4
    }
}

/// Level 5 - Deepest level
class Level5 extends Level4 {
    shift: I64

    static func create(v: I64) -> Level5 {
        Level5 { value: v, multiplier: 2, offset: 10, divisor: 2, mask: 255, shift: 2 }
    }

    override func compute(this) -> I64 {
        (((this.value * this.multiplier + this.offset) / this.divisor) & this.mask) << this.shift
    }

    override func get_level(this) -> I32 {
        5
    }
}

// ============================================================================
// Benchmarks
// ============================================================================

/// Direct method calls (no polymorphism)
@bench
func bench_direct_calls() {
    let circle: Circle = Circle::create(5.0)
    var total: F64 = 0.0
    var i: I32 = 0

    loop {
        if i >= 10000 then { break }
        total = total + circle.area()
        total = total + circle.perimeter()
        i = i + 1
    }

    assert(total > 0.0)
}

/// Multiple shape types - direct method calls on each type
@bench
func bench_multiple_shapes() {
    // Create shapes of different types
    let circle: Circle = Circle::create(5.0)
    let rect: Rectangle = Rectangle::create(3.0, 4.0)
    let triangle: Triangle = Triangle::create(3.0, 4.0, 5.0, 5.0)

    var total: F64 = 0.0
    var i: I32 = 0

    loop {
        if i >= 10000 then { break }
        // Direct method calls on each type
        total = total + circle.area()
        total = total + rect.area()
        total = total + triangle.area()
        i = i + 1
    }

    assert(total > 0.0)
}

/// Sealed class (devirtualized by compiler)
@bench
func bench_sealed_class() {
    let p1: Point = Point::create(3.0, 4.0)
    let p2: Point = Point::create(6.0, 8.0)
    var total: F64 = 0.0
    var i: I32 = 0

    loop {
        if i >= 10000 then { break }
        total = total + p1.distance_from_origin()
        total = total + p1.distance_to(p2)
        i = i + 1
    }

    assert(total > 0.0)
}

/// Deep inheritance benchmark - measures vtable lookup depth
@bench
func bench_deep_inheritance() {
    // Create instances at different levels
    let l0: Level0 = Level0::create(100)
    let l1: Level1 = Level1::create(100)
    let l2: Level2 = Level2::create(100)
    let l3: Level3 = Level3::create(100)
    let l4: Level4 = Level4::create(100)
    let l5: Level5 = Level5::create(100)

    var total: I64 = 0
    var i: I32 = 0

    loop {
        if i >= 5000 then { break }
        total = total + l0.compute()
        total = total + l1.compute()
        total = total + l2.compute()
        total = total + l3.compute()
        total = total + l4.compute()
        total = total + l5.compute()
        i = i + 1
    }

    let zero_i64: I64 = 0
    assert(total > zero_i64)
}

/// Simple class comparison benchmark
@bench
func bench_class_method_calls() {
    // Just call methods on a simple class repeatedly
    let level0: Level0 = Level0::create(100)
    var total: I64 = 0
    var i: I32 = 0

    loop {
        if i >= 10000 then { break }
        total = total + level0.compute()
        i = i + 1
    }

    let zero_i64: I64 = 0
    assert(total > zero_i64)
}

// ============================================================================
// Tests
// ============================================================================

@test
func test_shape_correctness() {
    let circle: Circle = Circle::create(5.0)
    let rect: Rectangle = Rectangle::create(3.0, 4.0)

    // Direct calls on derived types
    assert(circle.area() > 78.0)
    assert(circle.area() < 79.0)
    assert(rect.area() > 11.9)
    assert(rect.area() < 12.1)

    // Note: In TML, "as Shape" calls the BASE class method, not the derived class method
    // This is different from typical OOP virtual dispatch
    let shape: Shape = circle as Shape
    assert(shape.area() < 0.1)  // Base Shape.area() returns 0.0
}

@test
func test_sealed_class() {
    // Sealed class
    let p: Point = Point::create(3.0, 4.0)
    // 3^2 + 4^2 = 25
    assert(p.distance_from_origin() > 24.9)
    assert(p.distance_from_origin() < 25.1)
}

@test
func test_class_inheritance() {
    let l0: Level0 = Level0::create(100)

    assert_eq(l0.compute(), 100)
    assert_eq(l0.get_level(), 0)
}
