// TML Example 12: Memory and Ownership
// Demonstrates ownership, borrowing, and smart pointers

module memory

// ============================================
// OWNERSHIP BASICS
// ============================================

func ownership_demo() {
    // Each value has one owner
    let s1 = String.from("hello")

    // Move: ownership transfers (s1 is no longer valid)
    let s2 = s1
    // println(s1)  // ERROR: s1 moved to s2

    // Duplicate: create a deep copy (both valid)
    let s3 = String.from("world")
    let s4 = s3.duplicate()
    println(s3)  // OK: s3 still valid
    println(s4)  // OK: s4 is a copy

    // Copy types (primitives) are copied, not moved
    let x = 42
    let y = x
    println(x.to_string())  // OK: I32 implements Copy
    println(y.to_string())
}

// ============================================
// BORROWING (REFERENCES)
// ============================================

func borrowing_demo() {
    let s = String.from("hello")

    // Immutable borrow with ref
    let len = calculate_length(ref s)
    println(s)  // OK: s still valid after borrow

    // Multiple immutable borrows allowed
    let r1 = ref s
    let r2 = ref s
    println(r1 + " " + r2)  // OK

    // Mutable borrow with mut ref
    var text = String.from("hello")
    append_world(mut ref text)
    println(text)  // "hello world"
}

func calculate_length(s: ref String) -> U64 {
    return s.len()
}

func append_world(s: mut ref String) {
    s.push(" world")
}

// ============================================
// BORROW RULES
// ============================================

func borrow_rules_demo() {
    var s = String.from("hello")

    // Rule 1: Only ONE mutable borrow at a time
    let r1 = mut ref s
    // let r2 = mut ref s  // ERROR: second mutable borrow
    r1.push("!")

    // Rule 2: Cannot mix mutable and immutable borrows
    let r3 = ref s
    let r4 = ref s
    // let r5 = mut ref s  // ERROR: can't borrow as mutable

    println(r3 + " " + r4)

    // After immutable borrows are done, can borrow mutably again
    let r6 = mut ref s
    r6.push("!")
}

// ============================================
// LIFETIMES (INFERRED)
// ============================================

// TML infers lifetimes - no explicit annotations needed

// Returns a reference to the longer string
func longest(a: ref String, b: ref String) -> ref String {
    if a.len() > b.len() then a else b
}

func lifetime_demo() {
    let s1 = String.from("hello")
    let s2 = String.from("world!")

    let result = longest(ref s1, ref s2)
    println("Longest: " + result)
}

// Compiler automatically infers that the returned reference
// must live as long as both input references

// ============================================
// SMART POINTERS
// ============================================

import std.shared { Shared }
import std.cell { RefCell }
import std.sync { Sync, Mutex }

func smart_pointer_demo() {
    // Heap: heap allocation with single owner
    let boxed: Heap[I32] = Heap.new(42)
    println(boxed.to_string())

    // Shared: reference counting (single-threaded)
    let shared: Shared[String] = Shared.new("shared data")
    let copy1 = shared.duplicate()  // Increments reference count
    let copy2 = shared.duplicate()
    println("Ref count: " + Shared.strong_count(ref shared).to_string())

    // RefCell: interior mutability
    let cell: RefCell[I32] = RefCell.new(0)
    {
        var borrow = cell.borrow_mut()
        borrow += 1
    }
    println("Cell value: " + cell.borrow().to_string())

    // Shared[RefCell[T]]: shared mutable data
    let shared_mut: Shared[RefCell[List[I32]]] = Shared.new(RefCell.new(List.new()))
    shared_mut.borrow_mut().push(1)
    shared_mut.borrow_mut().push(2)
}

// ============================================
// THREAD-SAFE SMART POINTERS
// ============================================

async func thread_safe_demo() {
    // Sync: atomic reference counting (thread-safe Shared)
    let data: Sync[String] = Sync.new("shared across threads")

    let handles = List.new()
    loop i in 0 to 5 {
        let data_copy = data.duplicate()
        let handle = spawn async {
            println("Thread " + i.to_string() + ": " + data_copy)
        }
        handles.push(handle)
    }

    // Wait for all threads
    loop h in handles {
        await h
    }

    // Sync[Mutex[T]]: thread-safe mutable data
    let counter: Sync[Mutex[I32]] = Sync.new(Mutex.new(0))

    let handles2 = List.new()
    loop _ in 0 to 10 {
        let counter_copy = counter.duplicate()
        let handle = spawn async {
            var guard = counter_copy.lock()
            guard += 1
        }
        handles2.push(handle)
    }

    loop h in handles2 {
        await h
    }

    println("Counter: " + counter.lock().to_string())
}

// ============================================
// DROP AND CLEANUP
// ============================================

type FileHandle {
    path: String,
    handle: RawHandle,
}

// Implement Disposable for automatic cleanup
extend FileHandle with Disposable {
    func drop(this) {
        println("Closing file: " + this.path)
        close_raw_handle(this.handle)
    }
}

func drop_demo() {
    {
        let file = FileHandle {
            path: "test.txt",
            handle: open_raw("test.txt"),
        }
        // Use file...
    }  // file is dropped here, drop() is called automatically
}

// ============================================
// MOVE SEMANTICS IN FUNCTIONS
// ============================================

func takes_ownership(s: String) {
    println(s)
    // s is dropped when function ends
}

func gives_ownership() -> String {
    let s = String.from("hello")
    return s  // ownership transferred to caller
}

func takes_and_gives_back(s: String) -> String {
    s + " world"  // return ownership with modification
}

func move_demo() {
    let s1 = String.from("hello")
    takes_ownership(s1)
    // s1 no longer valid here

    let s2 = gives_ownership()
    println(s2)  // s2 valid

    let s3 = String.from("hello")
    let s4 = takes_and_gives_back(s3)
    // s3 invalid, s4 valid
    println(s4)
}

// Placeholder types and functions
type RawHandle = U64
func open_raw(path: String) -> RawHandle { return 0 }
func close_raw_handle(h: RawHandle) {}

public func main() {
    ownership_demo()
    borrowing_demo()
    borrow_rules_demo()
    lifetime_demo()
    smart_pointer_demo()
    drop_demo()
    move_demo()
}
