// TML Example 14: Stable IDs for LLM Integration
// Demonstrates @id annotations for precise code references

module stable_ids

// ============================================
// STABLE ID BASICS
// ============================================

// Every declaration can have a stable ID
@id("user-type")
type User {
    @id("user-name")
    name: String,

    @id("user-email")
    email: String,

    @id("user-age")
    age: U32,
}

@id("greet-user")
func greet(user: &User) -> String {
    return "Hello, " + user.name + "!"
}

// ============================================
// IDs ON COMPLEX STRUCTURES
// ============================================

@id("order-status")
type OrderStatus =
    @id("status-pending")
    | Pending

    @id("status-processing")
    | Processing

    @id("status-shipped")
    | Shipped { tracking: String }

    @id("status-delivered")
    | Delivered { date: DateTime }

    @id("status-cancelled")
    | Cancelled { reason: String }

@id("order-type")
type Order {
    @id("order-id-field")
    id: U64,

    @id("order-items")
    items: List[OrderItem],

    @id("order-status-field")
    status: OrderStatus,

    @id("order-total")
    total: F64,
}

// ============================================
// IDS ON FUNCTIONS AND BLOCKS
// ============================================

@id("process-order")
func process_order(order: &mut Order) -> Result[Unit, OrderError] {
    @id("validate-items")
    {
        loop item in order.items {
            if item.quantity == 0 then {
                return Err(OrderError.InvalidQuantity)
            }
        }
    }

    @id("calculate-total")
    {
        var total = 0.0
        loop item in order.items {
            total += item.price * item.quantity as F64
        }
        order.total = total
    }

    @id("update-status")
    order.status = OrderStatus.Processing

    return Ok(())
}

// ============================================
// IDS ON TRAIT IMPLEMENTATIONS
// ============================================

@id("printable-trait")
trait Printable {
    @id("print-method")
    func print(this)
}

@id("user-printable-impl")
extend User with Printable {
    @id("user-print")
    func print(this) {
        println("User: " + this.name + " <" + this.email + ">")
    }
}

// ============================================
// LLM PATCH EXAMPLE
// ============================================

// An LLM can generate precise patches using IDs:
//
// PATCH @id("calculate-total"):
// {
//     var total = 0.0
//     loop item in order.items {
//         let item_total = item.price * item.quantity as F64
//         let discount = calculate_discount(item)
//         total += item_total - discount
//     }
//     order.total = total
// }

// ============================================
// ID REFERENCES IN COMMENTS
// ============================================

// The function @ref("greet-user") uses the name field
// from @ref("user-type") to create a greeting message.
//
// See also:
// - @ref("user-printable-impl") for formatted output
// - @ref("process-order") for order handling

// ============================================
// HIERARCHICAL IDS
// ============================================

@id("api")
module api {
    @id("api.handlers")
    module handlers {
        @id("api.handlers.user-create")
        func create_user(data: UserData) -> Result[User, ApiError] {
            // Implementation
            return Ok(User { name: data.name, email: data.email, age: 0 })
        }

        @id("api.handlers.user-update")
        func update_user(id: U64, data: UserData) -> Result[User, ApiError] {
            // Implementation
            return Ok(User { name: data.name, email: data.email, age: 0 })
        }
    }

    @id("api.middleware")
    module middleware {
        @id("api.middleware.auth")
        func authenticate(request: &Request) -> Result[UserId, AuthError] {
            // Check token
            return Ok(UserId(1))
        }
    }
}

// ============================================
// IDS FOR TESTING
// ============================================

@id("test-user-creation")
#[test]
func test_create_user() {
    @id("test-setup")
    let user = User {
        name: "Alice",
        email: "alice@example.com",
        age: 30,
    }

    @id("test-assertion-name")
    assert_eq(user.name, "Alice")

    @id("test-assertion-email")
    assert_eq(user.email, "alice@example.com")
}

// ============================================
// CANONICAL IR WITH IDS
// ============================================

// The compiler generates Canonical IR preserving IDs:
//
// (module stable_ids
//   (type @id("user-type") User
//     (field @id("user-name") name String)
//     (field @id("user-email") email String)
//     (field @id("user-age") age U32))
//
//   (func @id("greet-user") greet
//     (param user (ref User))
//     (result String)
//     (block
//       (return (concat "Hello, "
//         (field-get user name)
//         "!")))))

// ============================================
// SUPPORTING TYPES
// ============================================

type OrderItem {
    product_id: U64,
    price: F64,
    quantity: U32,
}

type OrderError = InvalidQuantity | OutOfStock | PaymentFailed
type DateTime = U64  // Simplified
type UserData { name: String, email: String }
type ApiError = NotFound | Unauthorized | BadRequest
type AuthError = InvalidToken | Expired
type Request {}
type UserId(U64)

func calculate_discount(item: &OrderItem) -> F64 {
    return 0.0
}

public func main() {
    let user = User {
        name: "Alice",
        email: "alice@example.com",
        age: 30,
    }

    println(greet(&user))
    user.print()
}
