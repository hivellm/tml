# TML v1.0 — Intermediate Representation

> **See also**: [RFC-0007-IR](../rfcs/RFC-0007-IR.md) for the normative IR specification, implementation status, and JSON/Protobuf schemas.

## 1. Purpose

The canonical IR serves for:
- **Semantic diff** — compare real changes, not cosmetic ones
- **Automatic merge** — combine patches from different sources
- **LLM analysis** — consistent and predictable structure

## 2. Principles

### 2.1 Normalization

Different code that does the same thing → same IR:

```tml
// Source A
type Point { y: F64, x: F64 }

// Source B
type Point { x: F64, y: F64 }

// IR (fields sorted alphabetically)
(type Point
  (field x F64)
  (field y F64))
```

### 2.2 Determinism

Same input → same output, always.

## 3. S-Expression Format

### 3.1 Module

```lisp
(module mylib.math
  (imports
    (import std.io))
  (items
    (func ...)
    (type ...)))
```

### 3.2 Functions

```lisp
(func add
  (vis public)
  (generics
    (param T (bounds [Numeric])))
  (params
    (param a T)
    (param b T))
  (return T)
  (body
    (return (+ (var a) (var b)))))
```

### 3.3 Types

```lisp
; Struct
(type Point
  (vis public)
  (kind struct)
  (fields
    (field x F64 (vis public))
    (field y F64 (vis public))))

; Enum
(type Maybe
  (vis public)
  (generics (param T))
  (kind enum)
  (variants
    (variant Just (T))
    (variant Nothing)))

; Alias
(type UserId
  (vis public)
  (kind alias)
  (target U64))
```

### 3.4 Behaviors

```lisp
(behavior Equal
  (vis public)
  (methods
    (method eq
      (params (param this This) (param other This))
      (return Bool)
      (default nil))
    (method ne
      (params (param this This) (param other This))
      (return Bool)
      (default
        (not (call eq (var this) (var other)))))))
```

### 3.5 Extend

```lisp
(extend
  (target Point)
  (behavior Equal)
  (methods
    (method eq
      (params (param this This) (param other This))
      (return Bool)
      (body
        (and
          (== (field-get (var this) x) (field-get (var other) x))
          (== (field-get (var this) y) (field-get (var other) y)))))))
```

### 3.6 Expressions

```lisp
; Literals
(lit 42 I32)
(lit 3.14 F64)
(lit "hello" String)
(lit true Bool)

; Variables
(var x)
(var this)

; Operations
(+ (var a) (var b))
(- (var x))
(not (var flag))
(and (var a) (var b))

; Calls
(call func-name (var arg1) (var arg2))
(method-call (var obj) method-name (var arg))

; Field access
(field-get (var point) x)
(field-set (var point) x (lit 5.0 F64))

; Indexing
(index (var array) (lit 0 U64))

; Construction
(struct Point (x (lit 1.0 F64)) (y (lit 2.0 F64)))
(variant Just (lit 42 I32))

; Control flow
(if (var cond)
    (then (var x))
    (else (var y)))

(when (var value)
  (arm (pattern Just x) (var x))
  (arm (pattern Nothing) (lit 0 I32)))

(loop-in item (var items)
  (body (call process (var item))))

(loop-while (var running)
  (body (call tick)))

; Closures
(closure
  (params (param x I32))
  (body (* (var x) (lit 2 I32))))

; Try
(try (call risky))

; Block
(block
  (let x (lit 42 I32))
  (let y (+ (var x) (lit 1 I32)))
  (var y))
```

### 3.7 Statements

```lisp
; Let binding
(let x (lit 42 I32))
(let y I64 (lit 100 I64))

; Var binding
(var-mut count (lit 0 I32))

; Assignment
(assign (var count) (+ (var count) (lit 1 I32)))

; Return
(return (var result))

; Break/Continue
(break)
(continue)
```

### 3.8 Patterns

```lisp
; Literal
(pattern-lit 42)

; Binding
(pattern-bind x)

; Wildcard
(pattern-wild)

; Struct
(pattern-struct Point
  (x (pattern-bind px))
  (y (pattern-lit 0.0)))

; Enum variant
(pattern-variant Just (pattern-bind value))
(pattern-variant Nothing)

; Tuple
(pattern-tuple
  (pattern-bind a)
  (pattern-bind b))
```

## 4. JSON Format

### 4.1 Schema

```json
{
  "module": {
    "name": "mylib.math",
    "imports": [
      {"path": "std.io", "alias": null}
    ],
    "items": [...]
  }
}
```

### 4.2 Function in JSON

```json
{
  "kind": "func",
  "name": "add",
  "visibility": "public",
  "generics": [
    {"name": "T", "bounds": ["Numeric"]}
  ],
  "params": [
    {"name": "a", "type": {"ref": "T"}},
    {"name": "b", "type": {"ref": "T"}}
  ],
  "return": {"ref": "T"},
  "body": {
    "kind": "return",
    "value": {
      "kind": "binary",
      "op": "+",
      "left": {"kind": "var", "name": "a"},
      "right": {"kind": "var", "name": "b"}
    }
  }
}
```

### 4.3 Type in JSON

```json
{
  "kind": "type",
  "name": "Point",
  "visibility": "public",
  "type_kind": "struct",
  "fields": [
    {"name": "x", "type": "F64", "visibility": "public"},
    {"name": "y", "type": "F64", "visibility": "public"}
  ]
}
```

## 5. Canonicalization

### 5.1 Ordering Rules

| Element | Primary Order | Secondary Order | Preserves Semantics |
|---------|---------------|-----------------|---------------------|
| Struct fields | Alphabetical by name | N/A | Yes |
| Enum variants | Alphabetical by name | N/A | Yes |
| Behavior methods | Alphabetical by name | N/A | Yes |
| Imports | Alphabetical by path | Public before private | Yes |
| Directives | Alphabetical | N/A | Yes |
| Module items | By kind (see 6.2) | Alphabetical by name | Yes |
| Function parameters | **Preserved** | N/A | **Significant** |
| Generic parameters | **Preserved** | N/A | **Significant** |
| When arms | **Preserved** | N/A | **Significant** |

### 5.2 Item Kind Ordering

Within a module, items are ordered by kind, then alphabetically:

1. `const` declarations
2. `type` declarations (structs, enums, aliases)
3. `behavior` declarations
4. `extend` blocks
5. `func` declarations

```lisp
; Canonical module ordering
(module example
  (items
    ; 1. Constants first
    (const MAX_SIZE ...)
    (const VERSION ...)
    ; 2. Types second
    (type Config ...)
    (type User ...)
    ; 3. Behaviors third
    (behavior Validate ...)
    ; 4. Extends fourth
    (extend ...)
    ; 5. Functions last
    (func init ...)
    (func process ...)))
```

### 5.3 Expression Normalization

#### Associativity

Left-associative operators normalize left-to-right:
```tml
// Source variations
a + b + c
(a + b) + c

// IR: canonical form (left-associative)
(+ (+ (var a) (var b)) (var c))
```

Right-associative operators (`**`) normalize right-to-left:
```tml
// Source
a ** b ** c

// IR: right-associative
(** (var a) (** (var b) (var c)))
```

#### Commutative Operators

Operand order is **preserved** (NOT reordered) for commutative operators:
```tml
// Source
b + a

// IR: preserves source order for predictable diffs
(+ (var b) (var a))
```

#### Literal Normalization

All numeric literals normalize to canonical form:
```tml
0xFF        → (lit 255 I32)
0b1010      → (lit 10 I32)
1_000_000   → (lit 1000000 I32)
3.14f32     → (lit 3.14 F32)
```

### 5.4 Desugaring Rules

```tml
// Compound assignment
x += 1
// IR:
(assign (var x) (+ (var x) (lit 1 I32)))

// Method call
point.distance(other)
// IR:
(call Point.distance (var point) (var other))

// If expression
if x > 0 then x else -x
// IR:
(if (> (var x) (lit 0 I32))
    (then (var x))
    (else (- (var x))))

// Error propagation
value!
// IR:
(try (var value))

// Range (exclusive)
0 to 10
// IR:
(range (lit 0 I32) (lit 10 I32) exclusive)

// Range (inclusive)
0 through 10
// IR:
(range (lit 0 I32) (lit 10 I32) inclusive)
```

### 5.5 Determinism Guarantee

The IR output MUST be byte-for-byte identical for semantically identical input:

```bash
# This MUST always produce identical output
tml ir src/lib.tml > a.ir
tml ir src/lib.tml > b.ir
diff a.ir b.ir  # No differences

# Even after reformatting source
tml fmt src/lib.tml
tml ir src/lib.tml > c.ir
diff a.ir c.ir  # No differences
```

### 5.6 Semantic Preservation

**Applied transformations** (no semantic change):

| Transformation | Description |
|----------------|-------------|
| Whitespace removal | All formatting stripped |
| Comment removal | Comments not in IR |
| Field reordering | Alphabetical, construction order irrelevant |
| Import sorting | Alphabetical, import order irrelevant |
| Literal normalization | `0xFF` → `255`, same value |
| Constant folding | `2 + 3` → `5` (literals only) |

**NOT applied** (would change semantics):

| Transformation | Reason |
|----------------|--------|
| Dead code elimination | Debugging, side effects |
| Expression reordering | Side effect order matters |
| Function inlining | Separate compilation |
| Short-circuit evaluation | Must preserve runtime behavior |

## 6. Diff and Merge

### 6.1 Semantic Diff

```bash
tml diff v1.tml v2.tml
```

Output:
```diff
Module mylib.math

+ (func new_function ...)

~ (func add)
  - (return (+ (var a) (var b)))
  + (return (call safe_add (var a) (var b)))

- (func removed)
```

### 6.2 Merge

```bash
tml merge base.tml.ir left.tml.ir right.tml.ir
```

Automatic merge if:
- Changes in different items
- Compatible changes in the same item

Conflict if:
- Same item modified in incompatible ways

## 7. Tools

### 7.1 Convert Source → IR

```bash
tml ir src/lib.tml --output lib.tml.ir
tml ir src/lib.tml --format json --output lib.tml.ir.json
```

### 7.2 Convert IR → Source

```bash
tml unir lib.tml.ir --output lib.tml
```

### 7.3 Validate IR

```bash
tml check-ir lib.tml.ir
```

### 7.4 Compare IRs

```bash
tml ir-diff a.tml.ir b.tml.ir
```

## 8. File Extensions

| Extension | Description |
|-----------|-------------|
| `.tml` | Source code |
| `.tml.ir` | IR in S-expression |
| `.tml.ir.json` | IR in JSON |
| `.tml.ir.pb` | IR in Protobuf (binary) |
| `.tml.patch` | IR patch |

## 9. Schema Specifications

For JSON Schema and Protobuf specifications:
- **JSON Schema**: [`rfcs/ir/tml-ir.schema.json`](../rfcs/ir/tml-ir.schema.json) (909 lines)
- **Protobuf Schema**: [`rfcs/ir/tml-ir.proto`](../rfcs/ir/tml-ir.proto) (587 lines)
- **Version History**: [`rfcs/ir/VERSION.md`](../rfcs/ir/VERSION.md)

See [RFC-0007-IR](../rfcs/RFC-0007-IR.md) for complete IR specification and implementation status.

---

*Previous: [07-MODULES.md](./07-MODULES.md)*
*Next: [09-CLI.md](./09-CLI.md) — Toolchain CLI*
