# TML v1.0 — Intermediate Representation

## 1. Purpose

The canonical IR serves for:
- **Semantic diff** — compare real changes, not cosmetic ones
- **Automatic merge** — combine patches from different sources
- **Surgical patches** — modify code via stable IDs
- **LLM analysis** — consistent and predictable structure

## 2. Principles

### 2.1 Normalization

Different code that does the same thing → same IR:

```tml
// Source A
type Point { y: F64, x: F64 }

// Source B
type Point { x: F64, y: F64 }

// IR (fields sorted alphabetically)
(type Point @id1
  (field x F64)
  (field y F64))
```

### 2.2 Stable IDs

Every named element has a unique ID:

```tml
func add@a1b2c3d4(a: I32, b: I32) -> I32 {
    return a + b
}
```

### 2.3 Determinism

Same input → same output, always.

## 3. S-Expression Format

### 3.1 Module

```lisp
(module mylib.math @mod001
  (caps [io.file])
  (imports
    (import std.io))
  (items
    (func ...)
    (type ...)))
```

### 3.2 Functions

```lisp
(func add @fn001
  (vis public)
  (generics
    (param T (bounds [Numeric])))
  (params
    (param a T)
    (param b T))
  (return T)
  (effects [pure])
  (body
    (return (+ (var a) (var b)))))
```

### 3.3 Types

```lisp
; Struct
(type Point @ty001
  (vis public)
  (kind struct)
  (fields
    (field x F64 (vis public))
    (field y F64 (vis public))))

; Enum
(type Option @ty002
  (vis public)
  (generics (param T))
  (kind enum)
  (variants
    (variant Some (T))
    (variant None)))

; Alias
(type UserId @ty003
  (vis public)
  (kind alias)
  (target U64))
```

### 3.4 Traits

```lisp
(trait Eq @tr001
  (vis public)
  (methods
    (method eq
      (params (param this This) (param other This))
      (return Bool)
      (default nil))
    (method ne
      (params (param this This) (param other This))
      (return Bool)
      (default
        (not (call eq (var this) (var other)))))))
```

### 3.5 Extend

```lisp
(extend @ext001
  (target Point)
  (trait Eq)
  (methods
    (method eq @m001
      (params (param this This) (param other This))
      (return Bool)
      (body
        (and
          (== (field-get (var this) x) (field-get (var other) x))
          (== (field-get (var this) y) (field-get (var other) y)))))))
```

### 3.6 Expressions

```lisp
; Literals
(lit 42 I32)
(lit 3.14 F64)
(lit "hello" String)
(lit true Bool)

; Variables
(var x)
(var this)

; Operations
(+ (var a) (var b))
(- (var x))
(not (var flag))
(and (var a) (var b))

; Calls
(call func-name (var arg1) (var arg2))
(method-call (var obj) method-name (var arg))

; Field access
(field-get (var point) x)
(field-set (var point) x (lit 5.0 F64))

; Indexing
(index (var array) (lit 0 U64))

; Construction
(struct Point (x (lit 1.0 F64)) (y (lit 2.0 F64)))
(variant Some (lit 42 I32))

; Control flow
(if (var cond)
    (then (var x))
    (else (var y)))

(when (var value)
  (arm (pattern Some x) (var x))
  (arm (pattern None) (lit 0 I32)))

(loop-in item (var items)
  (body (call process (var item))))

(loop-while (var running)
  (body (call tick)))

; Closures
(closure
  (params (param x I32))
  (body (* (var x) (lit 2 I32))))

; Try
(try (call risky))

; Block
(block
  (let x (lit 42 I32))
  (let y (+ (var x) (lit 1 I32)))
  (var y))
```

### 3.7 Statements

```lisp
; Let binding
(let x (lit 42 I32))
(let y I64 (lit 100 I64))

; Var binding
(var-mut count (lit 0 I32))

; Assignment
(assign (var count) (+ (var count) (lit 1 I32)))

; Return
(return (var result))

; Break/Continue
(break)
(continue)
```

### 3.8 Patterns

```lisp
; Literal
(pattern-lit 42)

; Binding
(pattern-bind x)

; Wildcard
(pattern-wild)

; Struct
(pattern-struct Point
  (x (pattern-bind px))
  (y (pattern-lit 0.0)))

; Enum variant
(pattern-variant Some (pattern-bind value))
(pattern-variant None)

; Tuple
(pattern-tuple
  (pattern-bind a)
  (pattern-bind b))
```

## 4. JSON Format

### 4.1 Schema

```json
{
  "module": {
    "name": "mylib.math",
    "id": "@mod001",
    "caps": ["io.file"],
    "imports": [
      {"path": "std.io", "alias": null}
    ],
    "items": [...]
  }
}
```

### 4.2 Function in JSON

```json
{
  "kind": "func",
  "name": "add",
  "id": "@fn001",
  "visibility": "public",
  "generics": [
    {"name": "T", "bounds": ["Numeric"]}
  ],
  "params": [
    {"name": "a", "type": {"ref": "T"}},
    {"name": "b", "type": {"ref": "T"}}
  ],
  "return": {"ref": "T"},
  "effects": ["pure"],
  "body": {
    "kind": "return",
    "value": {
      "kind": "binary",
      "op": "+",
      "left": {"kind": "var", "name": "a"},
      "right": {"kind": "var", "name": "b"}
    }
  }
}
```

### 4.3 Type in JSON

```json
{
  "kind": "type",
  "name": "Point",
  "id": "@ty001",
  "visibility": "public",
  "type_kind": "struct",
  "fields": [
    {"name": "x", "type": "F64", "visibility": "public"},
    {"name": "y", "type": "F64", "visibility": "public"}
  ]
}
```

## 5. Stable IDs

### 5.1 Generation

IDs are 8-character hexadecimal hashes:

```tml
func example() -> I32  // @a1b2c3d4
```

Based on:
- Module path
- Item name
- Type signature
- Sequential number (for disambiguation)

### 5.2 Preservation

IDs survive:
- Local variable renaming
- Reformatting
- Field reordering
- Changes to other items

IDs change if:
- Item is deleted and recreated
- Type signature changes fundamentally

### 5.3 Usage in Patches

```diff
# Patch references by ID, not by name or line
@@ @fn001 @@
- (return (+ (var a) (var b)))
+ (return (- (var a) (var b)))
```

## 6. Canonicalization

### 6.1 Ordering Rules

| Element | Ordering |
|---------|----------|
| Struct fields | Alphabetical |
| Enum variants | Alphabetical |
| Imports | Alphabetical |
| Module items | By type, then alphabetical |
| Function parameters | Original (significant) |
| Generics | Original (significant) |

### 6.2 Expression Normalization

```tml
// Source: various forms
a + b + c
(a + b) + c

// IR: canonical form (left-associative)
(+ (+ (var a) (var b)) (var c))
```

### 6.3 Desugaring

```tml
// Source: sugar
if x > 0 then x else -x

// IR: expanded
(if (> (var x) (lit 0 I32))
    (then (var x))
    (else (- (var x))))
```

```tml
// Source: method call
point.distance(other)

// IR: explicit function
(call Point.distance (var point) (var other))
```

## 7. Diff and Merge

### 7.1 Semantic Diff

```bash
tml diff v1.tml v2.tml
```

Output:
```diff
Module mylib.math

+ (func new_function @fn002 ...)

~ (func add @fn001)
  - (return (+ (var a) (var b)))
  + (return (call safe_add (var a) (var b)))

- (func removed @fn003)
```

### 7.2 Merge

```bash
tml merge base.tml.ir left.tml.ir right.tml.ir
```

Automatic merge if:
- Changes in different items (by ID)
- Compatible changes in the same item

Conflict if:
- Same item modified in incompatible ways

## 8. Tools

### 8.1 Convert Source → IR

```bash
tml ir src/lib.tml --output lib.tml.ir
tml ir src/lib.tml --format json --output lib.tml.ir.json
```

### 8.2 Convert IR → Source

```bash
tml unir lib.tml.ir --output lib.tml
```

### 8.3 Validate IR

```bash
tml check-ir lib.tml.ir
```

### 8.4 Compare IRs

```bash
tml ir-diff a.tml.ir b.tml.ir
```

## 9. File Extensions

| Extension | Description |
|-----------|-------------|
| `.tml` | Source code |
| `.tml.ir` | IR in S-expression |
| `.tml.ir.json` | IR in JSON |
| `.tml.patch` | IR patch |

---

*Previous: [07-MODULES.md](./07-MODULES.md)*
*Next: [09-CLI.md](./09-CLI.md) — Toolchain CLI*
