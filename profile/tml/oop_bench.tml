// OOP Benchmarks (TML)
//
// Tests object-oriented programming overhead: class creation, virtual dispatch,
// inheritance, method calls.

// ============================================================================
// Simple class (no inheritance)
// ============================================================================

class Point {
    x: F64
    y: F64

    static func create() -> Point {
        return Point { x: 0.0, y: 0.0 }
    }

    static func with_coords(x: F64, y: F64) -> Point {
        return Point { x: x, y: y }
    }

    func distance_squared(this) -> F64 {
        return this.x * this.x + this.y * this.y
    }

    func add(this, other: Point) -> Point {
        return Point { x: this.x + other.x, y: this.y + other.y }
    }
}

// ============================================================================
// Virtual dispatch hierarchy
// ============================================================================

class Circle {
    radius: F64

    static func create(r: F64) -> Circle {
        return Circle { radius: r }
    }

    func area(this) -> F64 {
        return 3.14159265359 * this.radius * this.radius
    }

    func perimeter(this) -> F64 {
        return 2.0 * 3.14159265359 * this.radius
    }
}

class Rectangle {
    width: F64
    height: F64

    static func create(w: F64, h: F64) -> Rectangle {
        return Rectangle { width: w, height: h }
    }

    func area(this) -> F64 {
        return this.width * this.height
    }

    func perimeter(this) -> F64 {
        return 2.0 * (this.width + this.height)
    }
}

// ============================================================================
// Deep inheritance simulation (using composition)
// ============================================================================

class Level1 {
    value: I64

    static func create() -> Level1 {
        return Level1 { value: 1 }
    }

    func compute(this, x: I64) -> I64 {
        return x + this.value
    }
}

class Level2 {
    level1: Level1
    value: I64

    static func create() -> Level2 {
        return Level2 { level1: Level1::create(), value: 1 }
    }

    func compute(this, x: I64) -> I64 {
        return this.level1.compute(x) + this.value
    }
}

class Level3 {
    level2: Level2
    value: I64

    static func create() -> Level3 {
        return Level3 { level2: Level2::create(), value: 1 }
    }

    func compute(this, x: I64) -> I64 {
        return this.level2.compute(x) + this.value
    }
}

class Level4 {
    level3: Level3
    value: I64

    static func create() -> Level4 {
        return Level4 { level3: Level3::create(), value: 1 }
    }

    func compute(this, x: I64) -> I64 {
        return this.level3.compute(x) + this.value
    }
}

// ============================================================================
// Benchmarks - return results to prevent dead code elimination
// ============================================================================

func bench_object_creation(iterations: I64) -> I64 {
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        let ix: I64 = i % 100
        let iy: I64 = (i + 1) % 100
        let p: Point = Point::with_coords(ix as F64, iy as F64)
        sum = sum + p.distance_squared()
        i = i + 1
    }
    return sum as I64
}

func bench_method_call(iterations: I64) -> I64 {
    let p: Point = Point::with_coords(3.0, 4.0)
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + p.distance_squared()
        i = i + 1
    }
    return sum as I64
}

func bench_method_chaining(iterations: I64) -> I64 {
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        let p: Point = Point::with_coords(1.0, 2.0)
        let result: Point = p.add(Point::with_coords(2.0, 3.0)).add(Point::with_coords(3.0, 4.0))
        sum = sum + result.distance_squared()
        i = i + 1
    }
    return sum as I64
}

func bench_circle_dispatch(iterations: I64) -> I64 {
    let c: Circle = Circle::create(5.0)
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + c.area() + c.perimeter()
        i = i + 1
    }
    return sum as I64
}

func bench_rectangle_dispatch(iterations: I64) -> I64 {
    let r: Rectangle = Rectangle::create(3.0, 4.0)
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + r.area() + r.perimeter()
        i = i + 1
    }
    return sum as I64
}

func bench_deep_composition(iterations: I64) -> I64 {
    let obj: Level4 = Level4::create()
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + obj.compute(i % 100)
        i = i + 1
    }
    return sum
}

func bench_stack_allocation(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let p: Point = Point::with_coords(i as F64, i as F64)
        sum = sum + (p.x + p.y) as I64
        i = i + 1
    }
    return sum
}

// Helper to run and print a benchmark
func run_bench(name: Str, iterations: I64, runs: I32, bench_fn: func(I64) -> I64) {
    // Warmup
    let _w: I64 = bench_fn(iterations / 10)

    var best_ns: I64 = 9223372036854775807  // I64 max
    var run: I32 = 0
    loop (run < runs) {
        let start: I64 = time_ns()
        let result: I64 = bench_fn(iterations)
        let end: I64 = time_ns()
        let elapsed: I64 = end - start

        // Debug: print timing info for first run
        if run == 0 {
            println("    [DEBUG] start=" + start.to_string() + " end=" + end.to_string() + " elapsed=" + elapsed.to_string() + " result=" + result.to_string())
        }

        if elapsed < best_ns {
            best_ns = elapsed
        }
        run = run + 1
    }

    let per_op: I64 = best_ns / iterations
    let ops_sec: I64 = if best_ns > 0 {
        (iterations * 1000000000) / best_ns
    } else {
        0
    }

    println("  " + name + ":")
    println("    best_ns=" + best_ns.to_string())
    println("    " + per_op.to_string() + " ns/op")
    println("    " + ops_sec.to_string() + " ops/sec")
    println("")
}

func main() -> I32 {
    println("")
    println("================================================================")
    println("  OOP Benchmarks (TML)")
    println("================================================================")
    println("")

    let ITERATIONS: I64 = 10000000  // 10M

    run_bench("Object Creation (stack)", ITERATIONS, 10, bench_object_creation)
    run_bench("Method Call (non-virtual)", ITERATIONS, 10, bench_method_call)
    run_bench("Method Chaining", ITERATIONS, 10, bench_method_chaining)
    run_bench("Circle Method Calls", ITERATIONS, 10, bench_circle_dispatch)
    run_bench("Rectangle Method Calls", ITERATIONS, 10, bench_rectangle_dispatch)
    run_bench("Deep Composition (4 levels)", ITERATIONS, 10, bench_deep_composition)
    run_bench("Stack Allocation", ITERATIONS, 10, bench_stack_allocation)

    return 0
}
