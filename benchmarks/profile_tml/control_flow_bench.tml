// Control Flow Benchmarks (TML)
//
// Tests branching and loop performance.

use std::time::Instant

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// Simple if/else chain
func bench_if_else_chain(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let x: I64 = i % 100
        if x < 25 {
            sum = sum + 1
        } else if x < 50 {
            sum = sum + 2
        } else if x < 75 {
            sum = sum + 3
        } else {
            sum = sum + 4
        }
        i = i + 1
    }
    sum
}

// Deeply nested if
func bench_nested_if(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let x: I64 = i % 16
        if (x & 1) != 0 {
            if (x & 2) != 0 {
                if (x & 4) != 0 {
                    if (x & 8) != 0 {
                        sum = sum + 15
                    } else {
                        sum = sum + 7
                    }
                } else {
                    sum = sum + 3
                }
            } else {
                sum = sum + 1
            }
        } else {
            sum = sum + 0
        }
        i = i + 1
    }
    sum
}

// When expression (like switch dense)
func bench_when_dense(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let x: I64 = i % 10
        // Using if-else chain since when may not be fully optimized yet
        if x == 0 { sum = sum + 0 }
        else if x == 1 { sum = sum + 1 }
        else if x == 2 { sum = sum + 2 }
        else if x == 3 { sum = sum + 3 }
        else if x == 4 { sum = sum + 4 }
        else if x == 5 { sum = sum + 5 }
        else if x == 6 { sum = sum + 6 }
        else if x == 7 { sum = sum + 7 }
        else if x == 8 { sum = sum + 8 }
        else if x == 9 { sum = sum + 9 }
        else { sum = sum + 10 }
        i = i + 1
    }
    sum
}

// Switch sparse (using if-else)
func bench_when_sparse(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let x: I64 = (i * 100) % 1000
        if x == 0 { sum = sum + 0 }
        else if x == 100 { sum = sum + 1 }
        else if x == 200 { sum = sum + 2 }
        else if x == 300 { sum = sum + 3 }
        else if x == 400 { sum = sum + 4 }
        else if x == 500 { sum = sum + 5 }
        else if x == 600 { sum = sum + 6 }
        else if x == 700 { sum = sum + 7 }
        else if x == 800 { sum = sum + 8 }
        else if x == 900 { sum = sum + 9 }
        else { sum = sum + 10 }
        i = i + 1
    }
    sum
}

// Simple loop
func bench_loop(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + i
        i = i + 1
    }
    sum
}

// Nested loops (matrix style)
func bench_nested_loops(iterations: I64) -> I64 {
    var sum: I64 = 0
    let n: I64 = 1000
    var rounds: I64 = iterations / (n * n)
    if rounds < 1 { rounds = 1 }

    var r: I64 = 0
    loop (r < rounds) {
        var i: I64 = 0
        loop (i < n) {
            var j: I64 = 0
            loop (j < n) {
                sum = sum + (i * n + j)
                j = j + 1
            }
            i = i + 1
        }
        r = r + 1
    }
    sum
}

// Loop with continue
func bench_loop_continue(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        if i % 2 == 0 {
            i = i + 1
            continue
        }
        sum = sum + i
        i = i + 1
    }
    sum
}

// Ternary/conditional expression chain
func bench_ternary_chain(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let x: I64 = i % 100
        let val: I64 = if x < 25 { 1 } else if x < 50 { 2 } else if x < 75 { 3 } else { 4 }
        sum = sum + val
        i = i + 1
    }
    sum
}

// Boolean short-circuit AND
func bench_short_circuit_and(iterations: I64) -> I64 {
    var count: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        if (i % 2 == 0) and (i % 3 == 0) and (i % 5 == 0) {
            count = count + 1
        }
        i = i + 1
    }
    count
}

// Boolean short-circuit OR
func bench_short_circuit_or(iterations: I64) -> I64 {
    var count: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        if (i % 2 == 0) or (i % 3 == 0) or (i % 5 == 0) {
            count = count + 1
        }
        i = i + 1
    }
    count
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  Control Flow Benchmarks (TML)\n")
    print("================================================================\n\n")

    let ITERATIONS: I64 = 10000000    // 10M
    let NESTED_ITER: I64 = 1000000    // 1M for nested loops

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 10) {
        let _: I64 = bench_if_else_chain(1000)
        warmup = warmup + 1
    }

    // If-Else Chain
    var start: Instant = Instant::now()
    let _ie: I64 = bench_if_else_chain(ITERATIONS)
    run_and_print("If-Else Chain (4 branches)", ITERATIONS, start.elapsed().as_nanos())

    // Nested If
    start = Instant::now()
    let _ni: I64 = bench_nested_if(ITERATIONS)
    run_and_print("Nested If (4 levels)", ITERATIONS, start.elapsed().as_nanos())

    // When Dense
    start = Instant::now()
    let _wd: I64 = bench_when_dense(ITERATIONS)
    run_and_print("When Dense (10 cases)", ITERATIONS, start.elapsed().as_nanos())

    // When Sparse
    start = Instant::now()
    let _ws: I64 = bench_when_sparse(ITERATIONS)
    run_and_print("When Sparse (10 cases)", ITERATIONS, start.elapsed().as_nanos())

    // Loop
    start = Instant::now()
    let _lp: I64 = bench_loop(ITERATIONS)
    run_and_print("Loop", ITERATIONS, start.elapsed().as_nanos())

    // Nested Loops
    start = Instant::now()
    let _nl: I64 = bench_nested_loops(NESTED_ITER)
    run_and_print("Nested Loops (1000x1000)", NESTED_ITER, start.elapsed().as_nanos())

    // Loop + Continue
    start = Instant::now()
    let _lc: I64 = bench_loop_continue(ITERATIONS)
    run_and_print("Loop + Continue", ITERATIONS, start.elapsed().as_nanos())

    // Ternary Chain
    start = Instant::now()
    let _tc: I64 = bench_ternary_chain(ITERATIONS)
    run_and_print("Ternary Chain", ITERATIONS, start.elapsed().as_nanos())

    // Short-Circuit AND
    start = Instant::now()
    let _sa: I64 = bench_short_circuit_and(ITERATIONS)
    run_and_print("Short-Circuit AND", ITERATIONS, start.elapsed().as_nanos())

    // Short-Circuit OR
    start = Instant::now()
    let _so: I64 = bench_short_circuit_or(ITERATIONS)
    run_and_print("Short-Circuit OR", ITERATIONS, start.elapsed().as_nanos())

    0
}
