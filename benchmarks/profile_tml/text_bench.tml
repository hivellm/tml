// Text/StringBuilder Benchmarks (TML)
//
// Tests Text type for efficient string building.
// Compares with C++ stringstream and string patterns.

use std::text::Text
use std::time::Instant

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// Text append (O(1) amortized)
func bench_text_append(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 10)
    var i: I64 = 0
    loop (i < iterations) {
        t.push_str("item")
        t.push_str(i.to_string())
        t.push_str(",")
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Str naive append (O(n^2) worst case)
func bench_str_naive_append(iterations: I64) -> I64 {
    var s: Str = ""
    var i: I64 = 0
    loop (i < iterations) {
        s = s + "ab"
        i = i + 1
    }
    s.len() as I64
}

// Build JSON-like structure with Text
func bench_build_json(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 40)
    t.push_str("{\"items\":[")
    var i: I64 = 0
    loop (i < iterations) {
        if i > 0 {
            t.push_str(",")
        }
        t.push_str("{\"id\":")
        t.push_str(i.to_string())
        t.push_str(",\"name\":\"item")
        t.push_str(i.to_string())
        t.push_str("\"}")
        i = i + 1
    }
    t.push_str("]}")
    let len: I64 = t.len()
    t.drop()
    len
}

// Build HTML-like structure
func bench_build_html(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 50)
    t.push_str("<ul>\n")
    var i: I64 = 0
    loop (i < iterations) {
        // Uses push_formatted: single FFI call for prefix + int + suffix
        t.push_formatted("  <li>Item ", i, "</li>\n")
        i = i + 1
    }
    t.push_str("</ul>\n")
    let len: I64 = t.len()
    t.drop()
    len
}

// Build CSV-like data (optimized: single FFI call per row)
func bench_build_csv(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 30)
    t.push_str("id,name,value\n")
    var i: I64 = 0
    loop (i < iterations) {
        // Uses push_log: all 6 operations in 1 FFI call
        t.push_log("", i, ",item", i, ",", i * 100, "\n")
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Small appends (1 char equivalent) - optimized version using push
func bench_small_appends(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations)
    var i: I64 = 0
    loop (i < iterations) {
        t.push(120)  // 'x' = 120 ASCII - uses direct byte push
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Small appends using push_str for comparison
func bench_small_appends_str(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations)
    var i: I64 = 0
    loop (i < iterations) {
        t.push_str("x")  // Uses FFI string handling
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Small appends using fill_char batch operation (single FFI call)
func bench_small_appends_batch(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations)
    t.fill_char(120, iterations)  // 'x' = 120 ASCII - single FFI call for all N chars
    let len: I64 = t.len()
    t.drop()
    len
}

// Small appends using raw pointer (C++ style - register-based loop)
func bench_small_appends_raw(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations)
    let data: *U8 = t.data_ptr()  // Get raw pointer once
    var len: I64 = 0
    loop (len < iterations) {
        // Store directly to memory - no FFI, no checks
        lowlevel { store_byte(data, len, 120) }
        len = len + 1
    }
    t.set_len(len)  // Update length once at end
    let final_len: I64 = t.len()
    t.drop()
    final_len
}

// Number formatting
func bench_number_formatting(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 20)
    var i: I64 = 0
    loop (i < iterations) {
        t.push_str(i.to_string())
        t.push_str(":")
        // Approximation of i * 3.14159 as integer
        let approx_float: I64 = ((i * 314159) / 100000)
        t.push_str(approx_float.to_string())
        t.push_str("; ")
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Log messages (optimized: single FFI call per iteration)
func bench_log_messages(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(iterations * 64)
    var i: I64 = 0
    loop (i < iterations) {
        // Uses push_log: 7 operations in 1 FFI call
        t.push_log("[", i, "] INFO: Processing item #", i, " with value ", i * 42, "\n")
        i = i + 1
    }
    let len: I64 = t.len()
    t.drop()
    len
}

// Path building (reuses single Text to match C++ benchmark)
// Optimized: uses push_path to reduce 5 FFI calls to 1 per iteration
func bench_path_building(iterations: I64) -> I64 {
    let t: Text = Text::with_capacity(100)
    var last_len: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        t.clear()
        // Uses push_path: s1 + n1 + s2 + n2 + s3 in one FFI call
        t.push_path("/home/user/projects/app/src/module", i % 100, "/file", i, ".txt")
        last_len = t.len()
        i = i + 1
    }
    t.drop()
    last_len
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  Text/StringBuilder Benchmarks (TML)\n")
    print("================================================================\n\n")

    let BUILD_ITER: I64 = 100000     // 100K for build ops
    let APPEND_ITER: I64 = 1000000   // 1M for simple appends
    let NAIVE_ITER: I64 = 10000      // 10K for O(n^2) operations

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 10) {
        let t: Text = Text::with_capacity(100)
        t.push_str("test")
        t.drop()
        warmup = warmup + 1
    }

    // Text Append (O(1) amortized)
    var start: Instant = Instant::now()
    let _ta: I64 = bench_text_append(BUILD_ITER)
    run_and_print("Text Append (O(1) amortized)", BUILD_ITER, start.elapsed().as_nanos())

    // Str Naive Append (O(n^2)) - fewer iterations!
    start = Instant::now()
    let _sn: I64 = bench_str_naive_append(NAIVE_ITER)
    run_and_print("Str Naive Append (O(n^2))", NAIVE_ITER, start.elapsed().as_nanos())

    // Build JSON
    start = Instant::now()
    let _bj: I64 = bench_build_json(BUILD_ITER / 10)
    run_and_print("Build JSON (10K items)", BUILD_ITER / 10, start.elapsed().as_nanos())

    // Build HTML
    start = Instant::now()
    let _bh: I64 = bench_build_html(BUILD_ITER / 10)
    run_and_print("Build HTML (10K items)", BUILD_ITER / 10, start.elapsed().as_nanos())

    // Build CSV
    start = Instant::now()
    let _bc: I64 = bench_build_csv(BUILD_ITER / 10)
    run_and_print("Build CSV (10K rows)", BUILD_ITER / 10, start.elapsed().as_nanos())

    // Small Appends (push byte - optimized)
    start = Instant::now()
    let _sm: I64 = bench_small_appends(APPEND_ITER)
    run_and_print("Small Appends push()", APPEND_ITER, start.elapsed().as_nanos())

    // Small Appends (push_str - for comparison)
    start = Instant::now()
    let _sm2: I64 = bench_small_appends_str(APPEND_ITER)
    run_and_print("Small Appends push_str()", APPEND_ITER, start.elapsed().as_nanos())

    // Small Appends (batch - single FFI call)
    start = Instant::now()
    let _sm3: I64 = bench_small_appends_batch(APPEND_ITER)
    run_and_print("Small Appends fill_char() batch", APPEND_ITER, start.elapsed().as_nanos())

    // Small Appends (raw pointer - C++ style)
    start = Instant::now()
    let _sm4: I64 = bench_small_appends_raw(APPEND_ITER)
    run_and_print("Small Appends raw ptr", APPEND_ITER, start.elapsed().as_nanos())

    // Number Formatting
    start = Instant::now()
    let _nf: I64 = bench_number_formatting(BUILD_ITER)
    run_and_print("Number Formatting", BUILD_ITER, start.elapsed().as_nanos())

    // Log Messages
    start = Instant::now()
    let _lm: I64 = bench_log_messages(BUILD_ITER)
    run_and_print("Log Messages", BUILD_ITER, start.elapsed().as_nanos())

    // Path Building
    start = Instant::now()
    let _pb: I64 = bench_path_building(BUILD_ITER)
    run_and_print("Path Building", BUILD_ITER, start.elapsed().as_nanos())

    print("Note: Text uses O(1) amortized append, Str uses O(n^2) naive.\n")
    print("For fair comparison with C++, compare Text times with string+reserve.\n")

    0
}
