// Memory Benchmarks (TML)
//
// Tests struct creation, memory access patterns.
// Uses fixed-size arrays and sealed classes.

use std::time::Instant

// Test structures (same sizes as C++)
sealed class SmallStruct {
    a: I64
    b: I64

    static func create(a_val: I64, b_val: I64) -> SmallStruct {
        SmallStruct { a: a_val, b: b_val }
    }
}

sealed class MediumStruct {
    a: I64
    b: I64
    c: I64
    d: I64
    x: F64
    y: F64
    z: F64
    w: F64

    static func create(a_val: I64, b_val: I64, c_val: I64, d_val: I64) -> MediumStruct {
        MediumStruct {
            a: a_val, b: b_val, c: c_val, d: d_val,
            x: 1.0, y: 2.0, z: 3.0, w: 4.0
        }
    }
}

// Nested structures
sealed class Point {
    x: F64
    y: F64

    static func create(x_val: F64, y_val: F64) -> Point {
        Point { x: x_val, y: y_val }
    }
}

sealed class Triangle {
    ax: F64
    ay: F64
    bx: F64
    by: F64
    cx: F64
    cy: F64

    static func create() -> Triangle {
        Triangle {
            ax: 0.0, ay: 0.0,
            bx: 1.0, by: 0.0,
            cx: 0.5, cy: 1.0
        }
    }
}

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// Stack struct creation (small)
func bench_stack_struct_small(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let s: SmallStruct = SmallStruct::create(i, i + 1)
        sum = sum + s.a + s.b
        i = i + 1
    }
    sum
}

// Stack struct creation (medium)
func bench_stack_struct_medium(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let s: MediumStruct = MediumStruct::create(i, i + 1, i + 2, i + 3)
        sum = sum + s.a + s.d
        i = i + 1
    }
    sum
}

// Sequential access through array
func bench_sequential_access(iterations: I64) -> I64 {
    var data: [I64; 10000] = [0; 10000]
    var i: I64 = 0
    loop (i < 10000) {
        data[i as U64] = i
        i = i + 1
    }

    var sum: I64 = 0
    i = 0
    loop (i < iterations) {
        let idx: U64 = (i % 10000) as U64
        sum = sum + data[idx]
        i = i + 1
    }
    sum
}

// Pseudo-random access (cache unfriendly)
func bench_random_access(iterations: I64) -> I64 {
    var data: [I64; 10000] = [0; 10000]
    var indices: [I64; 10000] = [0; 10000]

    var i: I64 = 0
    loop (i < 10000) {
        data[i as U64] = i
        indices[i as U64] = (i * 7919 + 1) % 10000
        i = i + 1
    }

    var sum: I64 = 0
    i = 0
    loop (i < iterations) {
        let idx_pos: U64 = (i % 10000) as U64
        let idx: U64 = indices[idx_pos] as U64
        sum = sum + data[idx]
        i = i + 1
    }
    sum
}

// Struct field access
func bench_struct_field_access(iterations: I64) -> I64 {
    let s: MediumStruct = MediumStruct::create(1, 2, 3, 4)
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + s.a + s.b + s.c + s.d
        i = i + 1
    }
    sum
}

// Nested struct access
func bench_nested_struct_access(iterations: I64) -> F64 {
    let tri: Triangle = Triangle::create()
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + tri.ax + tri.by + tri.cx
        i = i + 1
    }
    sum
}

// Array copy benchmark
func bench_array_copy(iterations: I64) -> I64 {
    var src: [I64; 1000] = [0; 1000]
    var dst: [I64; 1000] = [0; 1000]

    var i: I64 = 0
    loop (i < 1000) {
        src[i as U64] = i
        i = i + 1
    }

    var round: I64 = 0
    loop (round < iterations / 1000) {
        i = 0
        loop (i < 1000) {
            dst[i as U64] = src[i as U64]
            i = i + 1
        }
        round = round + 1
    }
    dst[500]
}

// Array fill benchmark
func bench_array_fill(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var round: I64 = 0
    loop (round < iterations / 1000) {
        var i: I64 = 0
        loop (i < 1000) {
            arr[i as U64] = round
            i = i + 1
        }
        round = round + 1
    }
    arr[0]
}

// Point creation benchmark
func bench_point_creation(iterations: I64) -> F64 {
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        let p: Point = Point::create((i as F64), (i as F64) + 1.0)
        sum = sum + p.x + p.y
        i = i + 1
    }
    sum
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  Memory Benchmarks (TML)\n")
    print("================================================================\n\n")

    let ACCESS_ITER: I64 = 10000000  // 10M access ops
    let STRUCT_ITER: I64 = 10000000  // 10M struct ops
    let COPY_ITER: I64 = 1000000     // 1M copy ops

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 100) {
        let s: SmallStruct = SmallStruct::create(1, 2)
        let _: I64 = s.a + s.b
        warmup = warmup + 1
    }

    // Stack Struct Small
    var start: Instant = Instant::now()
    let _sss: I64 = bench_stack_struct_small(STRUCT_ITER)
    run_and_print("Stack Struct Small (16 bytes)", STRUCT_ITER, start.elapsed().as_nanos())

    // Stack Struct Medium
    start = Instant::now()
    let _ssm: I64 = bench_stack_struct_medium(STRUCT_ITER)
    run_and_print("Stack Struct Medium (64 bytes)", STRUCT_ITER, start.elapsed().as_nanos())

    // Sequential Access
    start = Instant::now()
    let _sa: I64 = bench_sequential_access(ACCESS_ITER)
    run_and_print("Sequential Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Random Access
    start = Instant::now()
    let _ra: I64 = bench_random_access(ACCESS_ITER)
    run_and_print("Random Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Struct Field Access
    start = Instant::now()
    let _sfa: I64 = bench_struct_field_access(ACCESS_ITER)
    run_and_print("Struct Field Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Nested Struct Access
    start = Instant::now()
    let _nsa: F64 = bench_nested_struct_access(ACCESS_ITER)
    run_and_print("Nested Struct Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Point Creation
    start = Instant::now()
    let _pc: F64 = bench_point_creation(STRUCT_ITER)
    run_and_print("Point Creation", STRUCT_ITER, start.elapsed().as_nanos())

    // Array Copy
    start = Instant::now()
    let _ac: I64 = bench_array_copy(COPY_ITER)
    run_and_print("Array Copy (1000 elements)", COPY_ITER, start.elapsed().as_nanos())

    // Array Fill
    start = Instant::now()
    let _af: I64 = bench_array_fill(COPY_ITER)
    run_and_print("Array Fill (1000 elements)", COPY_ITER, start.elapsed().as_nanos())

    0
}
