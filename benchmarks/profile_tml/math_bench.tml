// Math Benchmarks (TML)
//
// Tests basic arithmetic operations and loop performance.
// Must produce identical results to C++ for fair comparison.

use std::time::Instant

// Integer addition benchmark
func bench_int_add(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + i
        i = i + 1
    }
    sum
}

// Integer multiplication benchmark
func bench_int_mul(iterations: I64) -> I64 {
    var prod: I64 = 1
    var i: I64 = 1
    loop (i <= iterations) {
        prod = (prod * i) % 1000000007
        i = i + 1
    }
    prod
}

// Float addition benchmark
func bench_float_add(iterations: I64) -> F64 {
    var sum: F64 = 0.0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + (i as F64) * 0.001
        i = i + 1
    }
    sum
}

// Float multiplication benchmark
func bench_float_mul(iterations: I64) -> F64 {
    var prod: F64 = 1.0
    var i: I64 = 1
    loop (i <= iterations) {
        prod = prod * 1.0000001
        i = i + 1
    }
    prod
}

// Fibonacci (recursive) - tests function call overhead
func fib(n: I32) -> I64 {
    if n <= 1 { return n as I64 }
    fib(n - 1) + fib(n - 2)
}

func bench_fib_recursive(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + fib(20)
        i = i + 1
    }
    sum
}

// Fibonacci (iterative) - tests loop performance
func fib_iter(n: I32) -> I64 {
    if n <= 1 { return n as I64 }
    var a: I64 = 0
    var b: I64 = 1
    var i: I32 = 2
    loop (i <= n) {
        let temp: I64 = a + b
        a = b
        b = temp
        i = i + 1
    }
    b
}

func bench_fib_iterative(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + fib_iter(50)
        i = i + 1
    }
    sum
}

// Empty loop - measures loop overhead
func bench_empty_loop(iterations: I64) -> I64 {
    var counter: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        counter = i
        i = i + 1
    }
    counter
}

// Division benchmark (integer)
func bench_int_div(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 1
    loop (i <= iterations) {
        sum = sum + (i * 1000000) / (i + 1)
        i = i + 1
    }
    sum
}

// Modulo benchmark
func bench_int_mod(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 1
    loop (i <= iterations) {
        sum = sum + (i % 17)
        i = i + 1
    }
    sum
}

// Bitwise operations
func bench_bitwise(iterations: I64) -> I64 {
    var result: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        result = (result ^ i) | (i & 255) | ((i << 3) >> 1)
        i = i + 1
    }
    result
}

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

pub func main() -> I32 {
    print("\n================================================================\n")
    print("  Math Benchmarks (TML)\n")
    print("================================================================\n\n")

    let ITERATIONS: I64 = 10000000
    let FIB_ITERATIONS: I64 = 1000

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 10) {
        let _: I64 = bench_int_add(1000)
        warmup = warmup + 1
    }

    // Integer Addition
    var start: Instant = Instant::now()
    let _add: I64 = bench_int_add(ITERATIONS)
    run_and_print("Integer Addition", ITERATIONS, start.elapsed().as_nanos())

    // Integer Multiplication
    start = Instant::now()
    let _mul: I64 = bench_int_mul(ITERATIONS)
    run_and_print("Integer Multiplication", ITERATIONS, start.elapsed().as_nanos())

    // Integer Division
    start = Instant::now()
    let _div: I64 = bench_int_div(ITERATIONS)
    run_and_print("Integer Division", ITERATIONS, start.elapsed().as_nanos())

    // Integer Modulo
    start = Instant::now()
    let _mod: I64 = bench_int_mod(ITERATIONS)
    run_and_print("Integer Modulo", ITERATIONS, start.elapsed().as_nanos())

    // Bitwise Operations
    start = Instant::now()
    let _bit: I64 = bench_bitwise(ITERATIONS)
    run_and_print("Bitwise Operations", ITERATIONS, start.elapsed().as_nanos())

    // Float Addition
    start = Instant::now()
    let _fadd: F64 = bench_float_add(ITERATIONS)
    run_and_print("Float Addition", ITERATIONS, start.elapsed().as_nanos())

    // Float Multiplication
    start = Instant::now()
    let _fmul: F64 = bench_float_mul(ITERATIONS)
    run_and_print("Float Multiplication", ITERATIONS, start.elapsed().as_nanos())

    // Fibonacci Recursive
    start = Instant::now()
    let _fibr: I64 = bench_fib_recursive(FIB_ITERATIONS)
    run_and_print("Fibonacci Recursive (n=20)", FIB_ITERATIONS, start.elapsed().as_nanos())

    // Fibonacci Iterative
    start = Instant::now()
    let _fibi: I64 = bench_fib_iterative(ITERATIONS)
    run_and_print("Fibonacci Iterative (n=50)", ITERATIONS, start.elapsed().as_nanos())

    // Empty Loop
    start = Instant::now()
    let _empty: I64 = bench_empty_loop(ITERATIONS)
    run_and_print("Empty Loop", ITERATIONS, start.elapsed().as_nanos())

    0
}
