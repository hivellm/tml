// Collections Benchmarks (TML)
//
// Tests basic collection-like operations.
// Uses fixed-size arrays to test access patterns.

use std::time::Instant

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// Array sequential read
func bench_array_sequential(iterations: I64) -> I64 {
    var arr: [I64; 100] = [0; 100]
    var i: I64 = 0
    loop (i < 100) {
        arr[i as U64] = i
        i = i + 1
    }

    var sum: I64 = 0
    var round: I64 = 0
    loop (round < iterations / 100) {
        i = 0
        loop (i < 100) {
            sum = sum + arr[i as U64]
            i = i + 1
        }
        round = round + 1
    }
    sum
}

// Array random access
func bench_array_random(iterations: I64) -> I64 {
    var arr: [I64; 100] = [0; 100]
    var i: I64 = 0
    loop (i < 100) {
        arr[i as U64] = i
        i = i + 1
    }

    var sum: I64 = 0
    i = 0
    loop (i < iterations) {
        let idx: I64 = (i * 7919 + 1) % 100
        sum = sum + arr[idx as U64]
        i = i + 1
    }
    sum
}

// Array write
func bench_array_write(iterations: I64) -> I64 {
    var arr: [I64; 100] = [0; 100]
    var i: I64 = 0
    loop (i < iterations) {
        let idx: U64 = (i % 100) as U64
        arr[idx] = i
        i = i + 1
    }
    arr[0]
}

// Array initialization
func bench_array_init(iterations: I64) -> I64 {
    var total: I64 = 0
    var round: I64 = 0
    loop (round < iterations / 100) {
        var arr: [I64; 100] = [0; 100]
        total = total + arr[0]
        round = round + 1
    }
    total
}

// Linear search
func bench_linear_search(iterations: I64) -> I64 {
    var arr: [I64; 100] = [0; 100]
    var i: I64 = 0
    loop (i < 100) {
        arr[i as U64] = i * 2
        i = i + 1
    }

    var found: I64 = 0
    var round: I64 = 0
    loop (round < iterations / 100) {
        let target: I64 = round % 2000
        i = 0
        loop (i < 100) {
            if arr[i as U64] == target {
                found = found + 1
                break
            }
            i = i + 1
        }
        round = round + 1
    }
    found
}

// Accumulate sum
func bench_accumulate(iterations: I64) -> I64 {
    var arr: [I64; 100] = [0; 100]
    var i: I64 = 0
    loop (i < 100) {
        arr[i as U64] = i
        i = i + 1
    }

    var total_sum: I64 = 0
    var round: I64 = 0
    loop (round < iterations / 100) {
        var sum: I64 = 0
        i = 0
        loop (i < 100) {
            sum = sum + arr[i as U64]
            i = i + 1
        }
        total_sum = total_sum + sum
        round = round + 1
    }
    total_sum
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  Collections Benchmarks (TML)\n")
    print("================================================================\n\n")
    print("Note: Using fixed-size arrays for benchmarking.\n\n")

    let ITERATIONS: I64 = 10000000    // 10M operations

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 10) {
        let _: I64 = bench_array_sequential(1000)
        warmup = warmup + 1
    }

    // Array Sequential Read
    var start: Instant = Instant::now()
    let _seq: I64 = bench_array_sequential(ITERATIONS)
    run_and_print("Array Sequential Read", ITERATIONS, start.elapsed().as_nanos())

    // Array Random Access
    start = Instant::now()
    let _rand: I64 = bench_array_random(ITERATIONS)
    run_and_print("Array Random Access", ITERATIONS, start.elapsed().as_nanos())

    // Array Write
    start = Instant::now()
    let _write: I64 = bench_array_write(ITERATIONS)
    run_and_print("Array Write", ITERATIONS, start.elapsed().as_nanos())

    // Array Initialization
    start = Instant::now()
    let _init: I64 = bench_array_init(ITERATIONS)
    run_and_print("Array Initialization", ITERATIONS, start.elapsed().as_nanos())

    // Linear Search
    start = Instant::now()
    let _search: I64 = bench_linear_search(ITERATIONS)
    run_and_print("Linear Search", ITERATIONS, start.elapsed().as_nanos())

    // Accumulate
    start = Instant::now()
    let _acc: I64 = bench_accumulate(ITERATIONS)
    run_and_print("Accumulate Sum", ITERATIONS, start.elapsed().as_nanos())

    0
}
