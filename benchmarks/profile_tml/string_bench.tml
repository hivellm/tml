// String Benchmarks (TML)
//
// Tests string operations performance.
// Compares with C++ baseline for optimization opportunities.

use std::text::Text
use std::time::Instant

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// String concatenation (small strings)
func bench_concat_small(iterations: I64) -> I64 {
    var count: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let result: Str = "Hello" + " " + "World" + "!"
        count = count + 1
        i = i + 1
    }
    count
}

// String concatenation in loop (using Str - O(n^2) pattern)
func bench_concat_naive(iterations: I64) -> I64 {
    var result: Str = ""
    var i: I64 = 0
    loop (i < iterations) {
        result = result + "ab"
        i = i + 1
    }
    result.len() as I64
}

// String concatenation with Text (O(n) amortized)
func bench_concat_text(iterations: I64) -> I64 {
    let result: Text = Text::with_capacity(iterations * 2)
    var i: I64 = 0
    loop (i < iterations) {
        result.push_str("ab")
        i = i + 1
    }
    let len: I64 = result.len()
    result.drop()
    len
}

// String length
func bench_strlen(iterations: I64) -> I64 {
    let str: Str = "The quick brown fox jumps over the lazy dog"
    var total: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        total = total + (str.len() as I64)
        i = i + 1
    }
    total
}

// String comparison (equal)
func bench_strcmp_equal(iterations: I64) -> I64 {
    let s1: Str = "Hello, World!"
    let s2: Str = "Hello, World!"
    var matches: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        if s1 == s2 {
            matches = matches + 1
        }
        i = i + 1
    }
    matches
}

// String comparison (different)
func bench_strcmp_different(iterations: I64) -> I64 {
    let s1: Str = "Hello, World!"
    let s2: Str = "Hello, World?"
    var matches: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        if s1 == s2 {
            matches = matches + 1
        }
        i = i + 1
    }
    matches
}

// Integer to string conversion
func bench_int_to_str(iterations: I64) -> I64 {
    var total: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let s: Str = i.to_string()
        total = total + (s.len() as I64)
        i = i + 1
    }
    total
}

// Log building with Str (O(n^2))
func bench_log_naive(iterations: I64) -> I64 {
    var log: Str = ""
    var i: I64 = 0
    loop (i < iterations) {
        log = log + "[INFO] Message number " + i.to_string() + "\n"
        i = i + 1
    }
    log.len() as I64
}

// Log building with Text (O(n))
func bench_log_text(iterations: I64) -> I64 {
    let log: Text = Text::with_capacity(iterations * 32)
    var i: I64 = 0
    loop (i < iterations) {
        log.push_str("[INFO] Message number ")
        log.push_str(i.to_string())
        log.push_str("\n")
        i = i + 1
    }
    let len: I64 = log.len()
    log.drop()
    len
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  String Benchmarks (TML)\n")
    print("================================================================\n\n")

    let ITERATIONS: I64 = 1000000     // 1M for fast ops
    let CONCAT_ITER: I64 = 10000      // 10K for naive concat (slow!)
    let TEXT_ITER: I64 = 100000       // 100K for Text concat
    let LOG_ITER: I64 = 1000          // 1K for log building (naive is very slow)
    let TEXT_LOG_ITER: I64 = 10000    // 10K for Text log building

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 10) {
        let _: I64 = bench_concat_small(100)
        warmup = warmup + 1
    }

    // Concat Small
    var start: Instant = Instant::now()
    let _cs: I64 = bench_concat_small(ITERATIONS)
    run_and_print("Concat Small (3 strings)", ITERATIONS, start.elapsed().as_nanos())

    // Concat Loop with Text (O(n))
    start = Instant::now()
    let _ct: I64 = bench_concat_text(TEXT_ITER)
    run_and_print("Concat Loop (Text - O(n))", TEXT_ITER, start.elapsed().as_nanos())

    // Concat Loop naive (O(n^2)) - use fewer iterations!
    start = Instant::now()
    let _cn: I64 = bench_concat_naive(CONCAT_ITER)
    run_and_print("Concat Loop (Str - O(n^2))", CONCAT_ITER, start.elapsed().as_nanos())

    // String Length
    start = Instant::now()
    let _sl: I64 = bench_strlen(ITERATIONS)
    run_and_print("String Length", ITERATIONS, start.elapsed().as_nanos())

    // String Compare (equal)
    start = Instant::now()
    let _sce: I64 = bench_strcmp_equal(ITERATIONS)
    run_and_print("String Compare (equal)", ITERATIONS, start.elapsed().as_nanos())

    // String Compare (different)
    start = Instant::now()
    let _scd: I64 = bench_strcmp_different(ITERATIONS)
    run_and_print("String Compare (different)", ITERATIONS, start.elapsed().as_nanos())

    // Int to String
    start = Instant::now()
    let _its: I64 = bench_int_to_str(ITERATIONS)
    run_and_print("Int to String", ITERATIONS, start.elapsed().as_nanos())

    // Log Building with Text (O(n))
    start = Instant::now()
    let _lt: I64 = bench_log_text(TEXT_LOG_ITER)
    run_and_print("Log Building (Text - O(n))", TEXT_LOG_ITER, start.elapsed().as_nanos())

    // Log Building naive (O(n^2)) - use fewer iterations!
    start = Instant::now()
    let _ln: I64 = bench_log_naive(LOG_ITER)
    run_and_print("Log Building (Str - O(n^2))", LOG_ITER, start.elapsed().as_nanos())

    print("Note: Str uses O(n^2) concatenation, Text uses O(n) amortized.\n")
    print("For fair comparison with C++, compare Text times with reserve.\n")

    0
}
