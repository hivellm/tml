// List/Vec Benchmarks (TML)
//
// Tests dynamic list operations: push, pop, get, set, iteration.
// All benchmarks use 1M operations for accurate ns/op measurement.
// Results are printed to prevent LLVM dead-code elimination.

use std::collections::List
use std::time::Instant

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  List Benchmarks (TML)\n")
    print("================================================================\n\n")

    let N: I64 = 10000000
    var i: I64 = 0

    // Warmup
    let wl: List[I64] = List[I64].new(8)
    var w: I64 = 0
    loop (w < 1000) { wl.push(w); w = w + 1 }
    wl.destroy()

    // === List Push (1M elements, grow from 8) ===
    let t1: Instant = Instant::now()
    let l1: List[I64] = List[I64].new(8)
    i = 0
    loop (i < N) { l1.push(i); i = i + 1 }
    let ns1: I64 = t1.elapsed().as_nanos()
    print("  List Push (grow):\n")
    print("    Iterations: {N}\n")
    let ms1: I64 = ns1 / 1000000
    print("    Total time: {ms1} ms\n")
    let pop1: I64 = if ns1 > 0 { ns1 / N } else { 0 }
    print("    Per op:     {pop1} ns\n")
    let ops1: I64 = if ns1 > 0 { (N * 1000000000) / ns1 } else { 0 }
    print("    Ops/sec:    {ops1}\n")
    print("    Notes:      len={l1.len()}\n\n")
    l1.destroy()

    // === List Push (reserved, 1M capacity pre-allocated) ===
    let t2: Instant = Instant::now()
    let l2: List[I64] = List[I64].new(N)
    i = 0
    loop (i < N) { l2.push(i); i = i + 1 }
    let ns2: I64 = t2.elapsed().as_nanos()
    print("  List Push (reserved):\n")
    print("    Iterations: {N}\n")
    let ms2: I64 = ns2 / 1000000
    print("    Total time: {ms2} ms\n")
    let pop2: I64 = if ns2 > 0 { ns2 / N } else { 0 }
    print("    Per op:     {pop2} ns\n")
    let ops2: I64 = if ns2 > 0 { (N * 1000000000) / ns2 } else { 0 }
    print("    Ops/sec:    {ops2}\n")
    print("    Notes:      len={l2.len()}\n\n")
    l2.destroy()

    // === List Random Access (1M gets in 10K-element list) ===
    let l3: List[I64] = List[I64].new(10000)
    i = 0
    loop (i < 10000) { l3.push(i * 2); i = i + 1 }
    let t3: Instant = Instant::now()
    var sum3: I64 = 0
    i = 0
    loop (i < N) { sum3 = sum3 + l3.get(i % 10000); i = i + 1 }
    let ns3: I64 = t3.elapsed().as_nanos()
    print("  List Random Access:\n")
    print("    Iterations: {N}\n")
    let ms3: I64 = ns3 / 1000000
    print("    Total time: {ms3} ms\n")
    let pop3: I64 = if ns3 > 0 { ns3 / N } else { 0 }
    print("    Per op:     {pop3} ns\n")
    let ops3: I64 = if ns3 > 0 { (N * 1000000000) / ns3 } else { 0 }
    print("    Ops/sec:    {ops3}\n")
    print("    Notes:      sum={sum3}\n\n")
    l3.destroy()

    // === List Iteration (sequential, 100 rounds of 10K) ===
    let l4: List[I64] = List[I64].new(10000)
    i = 0
    loop (i < 10000) { l4.push(i); i = i + 1 }
    let t4: Instant = Instant::now()
    var sum4: I64 = 0
    var round: I64 = 0
    loop (round < N / 10000) {
        i = 0
        loop (i < 10000) {
            sum4 = sum4 + l4.get(i)
            i = i + 1
        }
        round = round + 1
    }
    let ns4: I64 = t4.elapsed().as_nanos()
    print("  List Iteration:\n")
    print("    Iterations: {N}\n")
    let ms4: I64 = ns4 / 1000000
    print("    Total time: {ms4} ms\n")
    let pop4: I64 = if ns4 > 0 { ns4 / N } else { 0 }
    print("    Per op:     {pop4} ns\n")
    let ops4: I64 = if ns4 > 0 { (N * 1000000000) / ns4 } else { 0 }
    print("    Ops/sec:    {ops4}\n")
    print("    Notes:      sum={sum4}\n\n")
    l4.destroy()

    // === List Pop (push 1M then pop all) ===
    let l5: List[I64] = List[I64].new(N)
    i = 0
    loop (i < N) { l5.push(i); i = i + 1 }
    let t5: Instant = Instant::now()
    var sum5: I64 = 0
    loop (l5.len() > 0) {
        sum5 = sum5 + l5.pop()
    }
    let ns5: I64 = t5.elapsed().as_nanos()
    print("  List Pop:\n")
    print("    Iterations: {N}\n")
    let ms5: I64 = ns5 / 1000000
    print("    Total time: {ms5} ms\n")
    let pop5: I64 = if ns5 > 0 { ns5 / N } else { 0 }
    print("    Per op:     {pop5} ns\n")
    let ops5: I64 = if ns5 > 0 { (N * 1000000000) / ns5 } else { 0 }
    print("    Ops/sec:    {ops5}\n")
    print("    Notes:      sum={sum5}\n\n")
    l5.destroy()

    // === List Set (1M modifications in 10K-element list) ===
    let l6: List[I64] = List[I64].new(10000)
    i = 0
    loop (i < 10000) { l6.push(0); i = i + 1 }
    let t6: Instant = Instant::now()
    i = 0
    loop (i < N) { l6.set(i % 10000, i); i = i + 1 }
    let ns6: I64 = t6.elapsed().as_nanos()
    let sink6: I64 = l6.get(0) + l6.get(9999)
    print("  List Set:\n")
    print("    Iterations: {N}\n")
    let ms6: I64 = ns6 / 1000000
    print("    Total time: {ms6} ms\n")
    let pop6: I64 = if ns6 > 0 { ns6 / N } else { 0 }
    print("    Per op:     {pop6} ns\n")
    let ops6: I64 = if ns6 > 0 { (N * 1000000000) / ns6 } else { 0 }
    print("    Ops/sec:    {ops6}\n")
    print("    Notes:      sink={sink6}\n\n")
    l6.destroy()

    0
}
