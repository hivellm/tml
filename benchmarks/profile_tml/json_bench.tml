// JSON Benchmarks (TML)
//
// Tests JSON parsing and access performance through FFI.
// Compares with C++ raw parser to measure FFI overhead.

use std::json
use std::time::Instant

// Test JSON strings (same as C++)
func get_tiny_json() -> Str {
    "{\"name\":\"John\",\"age\":30}"
}

func get_small_json() -> Str {
    "{\"name\":\"John Doe\",\"age\":30,\"active\":true,\"email\":\"john@example.com\",\"scores\":[95,87,92,88,91],\"address\":{\"street\":\"123 Main St\",\"city\":\"New York\",\"zip\":\"10001\"}}"
}

func get_medium_json() -> Str {
    "{\"users\":[{\"id\":1,\"name\":\"Alice\",\"email\":\"alice@example.com\",\"active\":true},{\"id\":2,\"name\":\"Bob\",\"email\":\"bob@example.com\",\"active\":false},{\"id\":3,\"name\":\"Charlie\",\"email\":\"charlie@example.com\",\"active\":true},{\"id\":4,\"name\":\"Diana\",\"email\":\"diana@example.com\",\"active\":true},{\"id\":5,\"name\":\"Eve\",\"email\":\"eve@example.com\",\"active\":false}],\"metadata\":{\"total\":5,\"page\":1,\"per_page\":10,\"has_more\":false}}"
}

// Helper to run and print a benchmark
func run_and_print(name: Str, iterations: I64, total_ns: I64) {
    let per_op: I64 = if total_ns > 0 { total_ns / iterations } else { 0 }
    let ops_sec: I64 = if total_ns > 0 {
        (iterations * 1000000000) / total_ns
    } else {
        0
    }
    print("  {}:\n", name)
    print("    Iterations: {}\n", iterations)
    print("    Total time: {} ms\n", total_ns / 1000000)
    print("    Per op:     {} ns\n", per_op)
    print("    Ops/sec:    {}\n\n", ops_sec)
}

// Parse tiny JSON
func bench_parse_tiny(iterations: I64) -> I64 {
    let json_str: Str = get_tiny_json()
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        json::free(h)
        i = i + 1
    }
    iterations
}

// Parse small JSON
func bench_parse_small(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        json::free(h)
        i = i + 1
    }
    iterations
}

// Parse medium JSON
func bench_parse_medium(iterations: I64) -> I64 {
    let json_str: Str = get_medium_json()
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        json::free(h)
        i = i + 1
    }
    iterations
}

// Parse with standard parser (non-SIMD)
func bench_parse_standard(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_ffi(json_str)
        json::free(h)
        i = i + 1
    }
    iterations
}

// Field access
func bench_field_access(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var total_age: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        let age: I64 = json::object_get_i64(h, "age")
        total_age = total_age + age
        json::free(h)
        i = i + 1
    }
    total_age
}

// Array iteration
func bench_array_iterate(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var total: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        let scores: I64 = json::object_get(h, "scores")
        let len: I64 = json::array_len(scores)
        var j: I64 = 0
        loop (j < len) {
            let val: I64 = json::array_get_i64(scores, j)
            total = total + val
            j = j + 1
        }
        json::free(scores)
        json::free(h)
        i = i + 1
    }
    total
}

// Nested object access
func bench_nested_access(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var count: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        let addr: I64 = json::object_get(h, "address")
        let city: Str = json::object_get_string(addr, "city")
        if city.len() > 0 {
            count = count + 1
        }
        json::free(addr)
        json::free(h)
        i = i + 1
    }
    count
}

// Parse + validate
func bench_parse_validate(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var valid: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        let t: I32 = json::get_type(h)
        if t == 6 {  // Object type
            let name_h: I64 = json::object_get(h, "name")
            let age_h: I64 = json::object_get(h, "age")
            let active_h: I64 = json::object_get(h, "active")
            let scores_h: I64 = json::object_get(h, "scores")
            let addr_h: I64 = json::object_get(h, "address")

            let ok: Bool = (json::get_type(name_h) == 4) and  // String
                          (json::get_type(age_h) == 3) and    // Number
                          (json::get_type(active_h) == 1 or json::get_type(active_h) == 2) and  // Bool
                          (json::get_type(scores_h) == 5) and // Array
                          (json::get_type(addr_h) == 6)       // Object
            if ok {
                valid = valid + 1
            }
            json::free(name_h)
            json::free(age_h)
            json::free(active_h)
            json::free(scores_h)
            json::free(addr_h)
        }
        json::free(h)
        i = i + 1
    }
    valid
}

// Object traversal (count keys)
func bench_object_traverse(iterations: I64) -> I64 {
    let json_str: Str = get_small_json()
    var keys: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let h: I64 = json::parse_fast(json_str)
        let len: I64 = json::object_len(h)
        keys = keys + len
        json::free(h)
        i = i + 1
    }
    keys
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  JSON Benchmarks (TML)\n")
    print("================================================================\n\n")

    let PARSE_ITER: I64 = 100000   // 100K parses
    let ACCESS_ITER: I64 = 100000  // 100K access ops

    // Warmup
    var warmup: I64 = 0
    loop (warmup < 100) {
        let h: I64 = json::parse_fast(get_tiny_json())
        json::free(h)
        warmup = warmup + 1
    }

    // Parse Tiny
    var start: Instant = Instant::now()
    let _pt: I64 = bench_parse_tiny(PARSE_ITER)
    run_and_print("Parse Tiny (27 bytes)", PARSE_ITER, start.elapsed().as_nanos())

    // Parse Small
    start = Instant::now()
    let _ps: I64 = bench_parse_small(PARSE_ITER)
    run_and_print("Parse Small (200 bytes)", PARSE_ITER, start.elapsed().as_nanos())

    // Parse Medium
    start = Instant::now()
    let _pm: I64 = bench_parse_medium(PARSE_ITER)
    run_and_print("Parse Medium (500 bytes)", PARSE_ITER, start.elapsed().as_nanos())

    // Parse Standard (non-SIMD)
    start = Instant::now()
    let _pstd: I64 = bench_parse_standard(PARSE_ITER)
    run_and_print("Parse Standard (non-SIMD)", PARSE_ITER, start.elapsed().as_nanos())

    // Field Access
    start = Instant::now()
    let _fa: I64 = bench_field_access(ACCESS_ITER)
    run_and_print("Field Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Array Iteration
    start = Instant::now()
    let _ai: I64 = bench_array_iterate(ACCESS_ITER)
    run_and_print("Array Iteration", ACCESS_ITER, start.elapsed().as_nanos())

    // Nested Object Access
    start = Instant::now()
    let _na: I64 = bench_nested_access(ACCESS_ITER)
    run_and_print("Nested Object Access", ACCESS_ITER, start.elapsed().as_nanos())

    // Parse + Validate
    start = Instant::now()
    let _pv: I64 = bench_parse_validate(ACCESS_ITER)
    run_and_print("Parse + Validate", ACCESS_ITER, start.elapsed().as_nanos())

    // Object Traversal
    start = Instant::now()
    let _ot: I64 = bench_object_traverse(ACCESS_ITER)
    run_and_print("Object Traversal", ACCESS_ITER, start.elapsed().as_nanos())

    json::free_all()
    0
}
