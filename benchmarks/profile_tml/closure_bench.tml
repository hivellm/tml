// Closure and Iterator Benchmarks (TML)
//
// Tests closure overhead: function pointers, simple closures, iteration.

use std::time::Instant

// ============================================================================
// Function Pointer Benchmarks
// ============================================================================

func double_it(x: I64) -> I64 {
    x * 2
}

func triple_it(x: I64) -> I64 {
    x * 3
}

func add_ten(x: I64) -> I64 {
    x + 10
}

// Function pointer no capture
func bench_func_pointer(iterations: I64) -> I64 {
    let f: func(I64) -> I64 = double_it
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + f(i)
        i = i + 1
    }
    sum
}

// Function pointer switching
func bench_func_pointer_switch(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        let f: func(I64) -> I64 = if (i % 2) == 0 { double_it } else { triple_it }
        sum = sum + f(i)
        i = i + 1
    }
    sum
}

// Higher-order function
func apply_n_times(f: func(I64) -> I64, x: I64, n: I64) -> I64 {
    var result: I64 = x
    var i: I64 = 0
    loop (i < n) {
        result = f(result)
        i = i + 1
    }
    result
}

func bench_higher_order(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + apply_n_times(add_ten, i % 100, 5)
        i = i + 1
    }
    sum
}

// Function composition simulation
func compose_and_apply(f: func(I64) -> I64, g: func(I64) -> I64, x: I64) -> I64 {
    f(g(x))
}

func bench_composition(iterations: I64) -> I64 {
    var sum: I64 = 0
    var i: I64 = 0
    loop (i < iterations) {
        sum = sum + compose_and_apply(double_it, triple_it, i % 100)
        i = i + 1
    }
    sum
}

// ============================================================================
// Iterator Simulation Benchmarks
// ============================================================================

// Manual array iteration
func bench_manual_loop(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var k: I64 = 0
    loop (k < 1000) {
        arr[k] = k
        k = k + 1
    }

    var total: I64 = 0
    var iter: I64 = 0
    loop (iter < iterations / 1000) {
        var i: I64 = 0
        loop (i < 1000) {
            total = total + arr[i]
            i = i + 1
        }
        iter = iter + 1
    }
    total
}

// Map simulation (transform in place)
func bench_map_simulation(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var k: I64 = 0
    loop (k < 1000) {
        arr[k] = k
        k = k + 1
    }

    var iter: I64 = 0
    loop (iter < iterations / 1000) {
        var i: I64 = 0
        loop (i < 1000) {
            arr[i] = arr[i] * 2
            i = i + 1
        }
        // Reset for next iteration
        i = 0
        loop (i < 1000) {
            arr[i] = i
            i = i + 1
        }
        iter = iter + 1
    }
    arr[0]
}

// Filter simulation
func bench_filter_simulation(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var k: I64 = 0
    loop (k < 1000) {
        arr[k] = k
        k = k + 1
    }

    var total: I64 = 0
    var iter: I64 = 0
    loop (iter < iterations / 1000) {
        var i: I64 = 0
        loop (i < 1000) {
            if (arr[i] % 2) == 0 {
                total = total + arr[i]
            }
            i = i + 1
        }
        iter = iter + 1
    }
    total
}

// Fold/reduce simulation
func bench_fold_simulation(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var k: I64 = 0
    loop (k < 1000) {
        arr[k] = k
        k = k + 1
    }

    var total: I64 = 0
    var iter: I64 = 0
    loop (iter < iterations / 1000) {
        var acc: I64 = 0
        var i: I64 = 0
        loop (i < 1000) {
            acc = acc + arr[i]
            i = i + 1
        }
        total = total + acc
        iter = iter + 1
    }
    total
}

// Chain: filter -> map -> fold
func bench_chain_operations(iterations: I64) -> I64 {
    var arr: [I64; 1000] = [0; 1000]
    var k: I64 = 0
    loop (k < 1000) {
        arr[k] = k
        k = k + 1
    }

    var total: I64 = 0
    var iter: I64 = 0
    loop (iter < iterations / 1000) {
        var i: I64 = 0
        loop (i < 1000) {
            // Filter even, map to double, accumulate
            if (arr[i] % 2) == 0 {
                total = total + (arr[i] * 2)
            }
            i = i + 1
        }
        iter = iter + 1
    }
    total
}

// Helper to run and print a benchmark
func run_bench(name: Str, iterations: I64, runs: I32, bench_fn: func(I64) -> I64) {
    // Warmup
    let _w: I64 = bench_fn(iterations / 10)

    var best_ns: I64 = 9223372036854775807  // I64 max
    var run: I32 = 0
    loop (run < runs) {
        let start: Instant = Instant::now()
        let _r: I64 = bench_fn(iterations)
        let elapsed: I64 = start.elapsed().as_nanos()
        if elapsed < best_ns {
            best_ns = elapsed
        }
        run = run + 1
    }

    let per_op: I64 = best_ns / iterations
    let ops_sec: I64 = if best_ns > 0 {
        (iterations * 1000000000) / best_ns
    } else {
        0
    }

    print("  {}:\n", name)
    print("    {} ns/op\n", per_op)
    print("    {} ops/sec\n\n", ops_sec)
}

pub func main() -> I32 {
    print("\n")
    print("================================================================\n")
    print("  Closure and Iterator Benchmarks (TML)\n")
    print("================================================================\n\n")

    let ITERATIONS: I64 = 10000000  // 10M

    // Function pointer benchmarks
    run_bench("Function Pointer", ITERATIONS, 10, bench_func_pointer)
    run_bench("Function Pointer Switch", ITERATIONS, 10, bench_func_pointer_switch)
    run_bench("Higher Order Function", ITERATIONS, 10, bench_higher_order)
    run_bench("Function Composition", ITERATIONS, 10, bench_composition)

    // Iterator simulation benchmarks
    run_bench("Manual Loop (array)", ITERATIONS, 10, bench_manual_loop)
    run_bench("Map Simulation", ITERATIONS, 10, bench_map_simulation)
    run_bench("Filter Simulation", ITERATIONS, 10, bench_filter_simulation)
    run_bench("Fold/Reduce Simulation", ITERATIONS, 10, bench_fold_simulation)
    run_bench("Chain Operations", ITERATIONS, 10, bench_chain_operations)

    0
}
